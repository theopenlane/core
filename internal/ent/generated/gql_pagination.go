// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/assessment"
	"github.com/theopenlane/core/internal/ent/generated/assessmenthistory"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponse"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponsehistory"
	"github.com/theopenlane/core/internal/ent/generated/asset"
	"github.com/theopenlane/core/internal/ent/generated/assethistory"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementation"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/controlscheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/controlscheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/customdomain"
	"github.com/theopenlane/core/internal/ent/generated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/dnsverification"
	"github.com/theopenlane/core/internal/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/evidence"
	"github.com/theopenlane/core/internal/ent/generated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/jobresult"
	"github.com/theopenlane/core/internal/ent/generated/jobrunner"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnerregistrationtoken"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnertoken"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomain"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrol"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/onboarding"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscription"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/scan"
	"github.com/theopenlane/core/internal/ent/generated/scanhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobrun"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcenter"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// paginateLimit calculates the limit for pagination based on the first and last arguments.
// and returns the limit multiplied by 10.
// This is to ensure we overfetch the data to get the number of requested results.
func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first * 10
	} else if last != nil {
		limit = *last * 10
	}
	return limit
}

// APITokenEdge is the edge representation of APIToken.
type APITokenEdge struct {
	Node   *APIToken `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// APITokenConnection is the connection containing edges to APIToken.
type APITokenConnection struct {
	Edges      []*APITokenEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *APITokenConnection) build(nodes []*APIToken, pager *apitokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *APIToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *APIToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *APIToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*APITokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &APITokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// APITokenPaginateOption enables pagination customization.
type APITokenPaginateOption func(*apitokenPager) error

// WithAPITokenOrder configures pagination ordering.
func WithAPITokenOrder(order []*APITokenOrder) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAPITokenFilter configures pagination filter.
func WithAPITokenFilter(filter func(*APITokenQuery) (*APITokenQuery, error)) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		if filter == nil {
			return errors.New("APITokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apitokenPager struct {
	reverse bool
	order   []*APITokenOrder
	filter  func(*APITokenQuery) (*APITokenQuery, error)
}

func newAPITokenPager(opts []APITokenPaginateOption, reverse bool) (*apitokenPager, error) {
	pager := &apitokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *apitokenPager) applyFilter(query *APITokenQuery) (*APITokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apitokenPager) toCursor(at *APIToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(at).Value)
	}
	return Cursor{ID: at.ID, Value: cs_}
}

func (p *apitokenPager) applyCursors(query *APITokenQuery, after, before *Cursor) (*APITokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAPITokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *apitokenPager) applyOrder(query *APITokenQuery) *APITokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAPITokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAPITokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *apitokenPager) orderExpr(query *APITokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAPITokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to APIToken.
func (at *APITokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...APITokenPaginateOption,
) (*APITokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAPITokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &APITokenConnection{Edges: []*APITokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := at.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if at, err = pager.applyCursors(at, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	at = pager.applyOrder(at)
	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// APITokenOrderFieldCreatedAt orders APIToken by created_at.
	APITokenOrderFieldCreatedAt = &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.CreatedAt, nil
		},
		column: apitoken.FieldCreatedAt,
		toTerm: apitoken.ByCreatedAt,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.CreatedAt,
			}
		},
	}
	// APITokenOrderFieldUpdatedAt orders APIToken by updated_at.
	APITokenOrderFieldUpdatedAt = &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.UpdatedAt, nil
		},
		column: apitoken.FieldUpdatedAt,
		toTerm: apitoken.ByUpdatedAt,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.UpdatedAt,
			}
		},
	}
	// APITokenOrderFieldName orders APIToken by name.
	APITokenOrderFieldName = &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.Name, nil
		},
		column: apitoken.FieldName,
		toTerm: apitoken.ByName,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.Name,
			}
		},
	}
	// APITokenOrderFieldExpiresAt orders APIToken by expires_at.
	APITokenOrderFieldExpiresAt = &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			// allow for nil values for fields
			if at.ExpiresAt == nil {
				return nil, nil
			}
			return at.ExpiresAt, nil
		},
		column: apitoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) apitoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return apitoken.ByExpiresAt(opts...)
		},
		toCursor: func(at *APIToken) Cursor {
			if at.ExpiresAt == nil {
				return Cursor{
					ID:    at.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    at.ID,
				Value: at.ExpiresAt,
			}
		},
	}
	// APITokenOrderFieldLastUsedAt orders APIToken by last_used_at.
	APITokenOrderFieldLastUsedAt = &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			// allow for nil values for fields
			if at.LastUsedAt == nil {
				return nil, nil
			}
			return at.LastUsedAt, nil
		},
		column: apitoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) apitoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return apitoken.ByLastUsedAt(opts...)
		},
		toCursor: func(at *APIToken) Cursor {
			if at.LastUsedAt == nil {
				return Cursor{
					ID:    at.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    at.ID,
				Value: at.LastUsedAt,
			}
		},
	}
	// APITokenOrderFieldIsActive orders APIToken by is_active.
	APITokenOrderFieldIsActive = &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.IsActive, nil
		},
		column: apitoken.FieldIsActive,
		toTerm: apitoken.ByIsActive,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.IsActive,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f APITokenOrderField) String() string {
	var str string
	switch f.column {
	case APITokenOrderFieldCreatedAt.column:
		str = "created_at"
	case APITokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case APITokenOrderFieldName.column:
		str = "name"
	case APITokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case APITokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case APITokenOrderFieldIsActive.column:
		str = "is_active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f APITokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *APITokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("APITokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *APITokenOrderFieldCreatedAt
	case "updated_at":
		*f = *APITokenOrderFieldUpdatedAt
	case "name":
		*f = *APITokenOrderFieldName
	case "expires_at":
		*f = *APITokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *APITokenOrderFieldLastUsedAt
	case "is_active":
		*f = *APITokenOrderFieldIsActive
	default:
		return fmt.Errorf("%s is not a valid APITokenOrderField", str)
	}
	return nil
}

// APITokenOrderField defines the ordering field of APIToken.
type APITokenOrderField struct {
	// Value extracts the ordering value from the given APIToken.
	Value    func(*APIToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apitoken.OrderOption
	toCursor func(*APIToken) Cursor
}

// APITokenOrder defines the ordering of APIToken.
type APITokenOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *APITokenOrderField `json:"field"`
}

// DefaultAPITokenOrder is the default ordering of APIToken.
var DefaultAPITokenOrder = &APITokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.ID, nil
		},
		column: apitoken.FieldID,
		toTerm: apitoken.ByID,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts APIToken into APITokenEdge.
func (at *APIToken) ToEdge(order *APITokenOrder) *APITokenEdge {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	return &APITokenEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// ActionPlanEdge is the edge representation of ActionPlan.
type ActionPlanEdge struct {
	Node   *ActionPlan `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ActionPlanConnection is the connection containing edges to ActionPlan.
type ActionPlanConnection struct {
	Edges      []*ActionPlanEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ActionPlanConnection) build(nodes []*ActionPlan, pager *actionplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ActionPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanPaginateOption enables pagination customization.
type ActionPlanPaginateOption func(*actionplanPager) error

// WithActionPlanOrder configures pagination ordering.
func WithActionPlanOrder(order []*ActionPlanOrder) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithActionPlanFilter configures pagination filter.
func WithActionPlanFilter(filter func(*ActionPlanQuery) (*ActionPlanQuery, error)) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		if filter == nil {
			return errors.New("ActionPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanPager struct {
	reverse bool
	order   []*ActionPlanOrder
	filter  func(*ActionPlanQuery) (*ActionPlanQuery, error)
}

func newActionPlanPager(opts []ActionPlanPaginateOption, reverse bool) (*actionplanPager, error) {
	pager := &actionplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *actionplanPager) applyFilter(query *ActionPlanQuery) (*ActionPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanPager) toCursor(ap *ActionPlan) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(ap).Value)
	}
	return Cursor{ID: ap.ID, Value: cs_}
}

func (p *actionplanPager) applyCursors(query *ActionPlanQuery, after, before *Cursor) (*ActionPlanQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultActionPlanOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *actionplanPager) applyOrder(query *ActionPlanQuery) *ActionPlanQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultActionPlanOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultActionPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *actionplanPager) orderExpr(query *ActionPlanQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultActionPlanOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlan.
func (ap *ActionPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanPaginateOption,
) (*ActionPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ap, err = pager.applyFilter(ap); err != nil {
		return nil, err
	}
	conn := &ActionPlanConnection{Edges: []*ActionPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ap.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ap, err = pager.applyCursors(ap, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ap.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ap = pager.applyOrder(ap)
	nodes, err := ap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ActionPlanOrderFieldCreatedAt orders ActionPlan by created_at.
	ActionPlanOrderFieldCreatedAt = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.CreatedAt, nil
		},
		column: actionplan.FieldCreatedAt,
		toTerm: actionplan.ByCreatedAt,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.CreatedAt,
			}
		},
	}
	// ActionPlanOrderFieldUpdatedAt orders ActionPlan by updated_at.
	ActionPlanOrderFieldUpdatedAt = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.UpdatedAt, nil
		},
		column: actionplan.FieldUpdatedAt,
		toTerm: actionplan.ByUpdatedAt,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.UpdatedAt,
			}
		},
	}
	// ActionPlanOrderFieldRevision orders ActionPlan by revision.
	ActionPlanOrderFieldRevision = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.Revision, nil
		},
		column: actionplan.FieldRevision,
		toTerm: actionplan.ByRevision,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.Revision,
			}
		},
	}
	// ActionPlanOrderFieldName orders ActionPlan by name.
	ActionPlanOrderFieldName = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.Name, nil
		},
		column: actionplan.FieldName,
		toTerm: actionplan.ByName,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.Name,
			}
		},
	}
	// ActionPlanOrderFieldStatus orders ActionPlan by status.
	ActionPlanOrderFieldStatus = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.Status, nil
		},
		column: actionplan.FieldStatus,
		toTerm: actionplan.ByStatus,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.Status,
			}
		},
	}
	// ActionPlanOrderFieldReviewDue orders ActionPlan by review_due.
	ActionPlanOrderFieldReviewDue = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.ReviewDue, nil
		},
		column: actionplan.FieldReviewDue,
		toTerm: actionplan.ByReviewDue,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.ReviewDue,
			}
		},
	}
	// ActionPlanOrderFieldReviewFrequency orders ActionPlan by review_frequency.
	ActionPlanOrderFieldReviewFrequency = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.ReviewFrequency, nil
		},
		column: actionplan.FieldReviewFrequency,
		toTerm: actionplan.ByReviewFrequency,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.ReviewFrequency,
			}
		},
	}
	// ActionPlanOrderFieldDueDate orders ActionPlan by due_date.
	ActionPlanOrderFieldDueDate = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.DueDate, nil
		},
		column: actionplan.FieldDueDate,
		toTerm: actionplan.ByDueDate,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.DueDate,
			}
		},
	}
	// ActionPlanOrderFieldPriority orders ActionPlan by priority.
	ActionPlanOrderFieldPriority = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.Priority, nil
		},
		column: actionplan.FieldPriority,
		toTerm: actionplan.ByPriority,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.Priority,
			}
		},
	}
	// ActionPlanOrderFieldSource orders ActionPlan by source.
	ActionPlanOrderFieldSource = &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.Source, nil
		},
		column: actionplan.FieldSource,
		toTerm: actionplan.BySource,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{
				ID:    ap.ID,
				Value: ap.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActionPlanOrderField) String() string {
	var str string
	switch f.column {
	case ActionPlanOrderFieldCreatedAt.column:
		str = "created_at"
	case ActionPlanOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ActionPlanOrderFieldRevision.column:
		str = "revision"
	case ActionPlanOrderFieldName.column:
		str = "name"
	case ActionPlanOrderFieldStatus.column:
		str = "STATUS"
	case ActionPlanOrderFieldReviewDue.column:
		str = "review_due"
	case ActionPlanOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case ActionPlanOrderFieldDueDate.column:
		str = "due_date"
	case ActionPlanOrderFieldPriority.column:
		str = "PRIORITY"
	case ActionPlanOrderFieldSource.column:
		str = "source"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActionPlanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActionPlanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActionPlanOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ActionPlanOrderFieldCreatedAt
	case "updated_at":
		*f = *ActionPlanOrderFieldUpdatedAt
	case "revision":
		*f = *ActionPlanOrderFieldRevision
	case "name":
		*f = *ActionPlanOrderFieldName
	case "STATUS":
		*f = *ActionPlanOrderFieldStatus
	case "review_due":
		*f = *ActionPlanOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ActionPlanOrderFieldReviewFrequency
	case "due_date":
		*f = *ActionPlanOrderFieldDueDate
	case "PRIORITY":
		*f = *ActionPlanOrderFieldPriority
	case "source":
		*f = *ActionPlanOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid ActionPlanOrderField", str)
	}
	return nil
}

// ActionPlanOrderField defines the ordering field of ActionPlan.
type ActionPlanOrderField struct {
	// Value extracts the ordering value from the given ActionPlan.
	Value    func(*ActionPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplan.OrderOption
	toCursor func(*ActionPlan) Cursor
}

// ActionPlanOrder defines the ordering of ActionPlan.
type ActionPlanOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ActionPlanOrderField `json:"field"`
}

// DefaultActionPlanOrder is the default ordering of ActionPlan.
var DefaultActionPlanOrder = &ActionPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.ID, nil
		},
		column: actionplan.FieldID,
		toTerm: actionplan.ByID,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{ID: ap.ID}
		},
	},
}

// ToEdge converts ActionPlan into ActionPlanEdge.
func (ap *ActionPlan) ToEdge(order *ActionPlanOrder) *ActionPlanEdge {
	if order == nil {
		order = DefaultActionPlanOrder
	}
	return &ActionPlanEdge{
		Node:   ap,
		Cursor: order.Field.toCursor(ap),
	}
}

// ActionPlanHistoryEdge is the edge representation of ActionPlanHistory.
type ActionPlanHistoryEdge struct {
	Node   *ActionPlanHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ActionPlanHistoryConnection is the connection containing edges to ActionPlanHistory.
type ActionPlanHistoryConnection struct {
	Edges      []*ActionPlanHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ActionPlanHistoryConnection) build(nodes []*ActionPlanHistory, pager *actionplanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ActionPlanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanHistoryPaginateOption enables pagination customization.
type ActionPlanHistoryPaginateOption func(*actionplanhistoryPager) error

// WithActionPlanHistoryOrder configures pagination ordering.
func WithActionPlanHistoryOrder(order *ActionPlanHistoryOrder) ActionPlanHistoryPaginateOption {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	o := *order
	return func(pager *actionplanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActionPlanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActionPlanHistoryFilter configures pagination filter.
func WithActionPlanHistoryFilter(filter func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)) ActionPlanHistoryPaginateOption {
	return func(pager *actionplanhistoryPager) error {
		if filter == nil {
			return errors.New("ActionPlanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanhistoryPager struct {
	reverse bool
	order   *ActionPlanHistoryOrder
	filter  func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)
}

func newActionPlanHistoryPager(opts []ActionPlanHistoryPaginateOption, reverse bool) (*actionplanhistoryPager, error) {
	pager := &actionplanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActionPlanHistoryOrder
	}
	return pager, nil
}

func (p *actionplanhistoryPager) applyFilter(query *ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanhistoryPager) toCursor(aph *ActionPlanHistory) Cursor {
	return p.order.Field.toCursor(aph)
}

func (p *actionplanhistoryPager) applyCursors(query *ActionPlanHistoryQuery, after, before *Cursor) (*ActionPlanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultActionPlanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *actionplanhistoryPager) applyOrder(query *ActionPlanHistoryQuery) *ActionPlanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultActionPlanHistoryOrder.Field {
		query = query.Order(DefaultActionPlanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *actionplanhistoryPager) orderExpr(query *ActionPlanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultActionPlanHistoryOrder.Field {
			b.Comma().Ident(DefaultActionPlanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlanHistory.
func (aph *ActionPlanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanHistoryPaginateOption,
) (*ActionPlanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if aph, err = pager.applyFilter(aph); err != nil {
		return nil, err
	}
	conn := &ActionPlanHistoryConnection{Edges: []*ActionPlanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := aph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if aph, err = pager.applyCursors(aph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		aph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := aph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	aph = pager.applyOrder(aph)
	nodes, err := aph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ActionPlanHistoryOrderFieldHistoryTime orders ActionPlanHistory by history_time.
	ActionPlanHistoryOrderFieldHistoryTime = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.HistoryTime, nil
		},
		column: actionplanhistory.FieldHistoryTime,
		toTerm: actionplanhistory.ByHistoryTime,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.HistoryTime,
			}
		},
	}
	// ActionPlanHistoryOrderFieldCreatedAt orders ActionPlanHistory by created_at.
	ActionPlanHistoryOrderFieldCreatedAt = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.CreatedAt, nil
		},
		column: actionplanhistory.FieldCreatedAt,
		toTerm: actionplanhistory.ByCreatedAt,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.CreatedAt,
			}
		},
	}
	// ActionPlanHistoryOrderFieldUpdatedAt orders ActionPlanHistory by updated_at.
	ActionPlanHistoryOrderFieldUpdatedAt = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.UpdatedAt, nil
		},
		column: actionplanhistory.FieldUpdatedAt,
		toTerm: actionplanhistory.ByUpdatedAt,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.UpdatedAt,
			}
		},
	}
	// ActionPlanHistoryOrderFieldRevision orders ActionPlanHistory by revision.
	ActionPlanHistoryOrderFieldRevision = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.Revision, nil
		},
		column: actionplanhistory.FieldRevision,
		toTerm: actionplanhistory.ByRevision,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.Revision,
			}
		},
	}
	// ActionPlanHistoryOrderFieldName orders ActionPlanHistory by name.
	ActionPlanHistoryOrderFieldName = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.Name, nil
		},
		column: actionplanhistory.FieldName,
		toTerm: actionplanhistory.ByName,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.Name,
			}
		},
	}
	// ActionPlanHistoryOrderFieldStatus orders ActionPlanHistory by status.
	ActionPlanHistoryOrderFieldStatus = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.Status, nil
		},
		column: actionplanhistory.FieldStatus,
		toTerm: actionplanhistory.ByStatus,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.Status,
			}
		},
	}
	// ActionPlanHistoryOrderFieldReviewDue orders ActionPlanHistory by review_due.
	ActionPlanHistoryOrderFieldReviewDue = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.ReviewDue, nil
		},
		column: actionplanhistory.FieldReviewDue,
		toTerm: actionplanhistory.ByReviewDue,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.ReviewDue,
			}
		},
	}
	// ActionPlanHistoryOrderFieldReviewFrequency orders ActionPlanHistory by review_frequency.
	ActionPlanHistoryOrderFieldReviewFrequency = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.ReviewFrequency, nil
		},
		column: actionplanhistory.FieldReviewFrequency,
		toTerm: actionplanhistory.ByReviewFrequency,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.ReviewFrequency,
			}
		},
	}
	// ActionPlanHistoryOrderFieldDueDate orders ActionPlanHistory by due_date.
	ActionPlanHistoryOrderFieldDueDate = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.DueDate, nil
		},
		column: actionplanhistory.FieldDueDate,
		toTerm: actionplanhistory.ByDueDate,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.DueDate,
			}
		},
	}
	// ActionPlanHistoryOrderFieldPriority orders ActionPlanHistory by priority.
	ActionPlanHistoryOrderFieldPriority = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.Priority, nil
		},
		column: actionplanhistory.FieldPriority,
		toTerm: actionplanhistory.ByPriority,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.Priority,
			}
		},
	}
	// ActionPlanHistoryOrderFieldSource orders ActionPlanHistory by source.
	ActionPlanHistoryOrderFieldSource = &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.Source, nil
		},
		column: actionplanhistory.FieldSource,
		toTerm: actionplanhistory.BySource,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    aph.ID,
				Value: aph.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActionPlanHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ActionPlanHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ActionPlanHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ActionPlanHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ActionPlanHistoryOrderFieldRevision.column:
		str = "revision"
	case ActionPlanHistoryOrderFieldName.column:
		str = "name"
	case ActionPlanHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ActionPlanHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case ActionPlanHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case ActionPlanHistoryOrderFieldDueDate.column:
		str = "due_date"
	case ActionPlanHistoryOrderFieldPriority.column:
		str = "PRIORITY"
	case ActionPlanHistoryOrderFieldSource.column:
		str = "source"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActionPlanHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActionPlanHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActionPlanHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ActionPlanHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ActionPlanHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ActionPlanHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ActionPlanHistoryOrderFieldRevision
	case "name":
		*f = *ActionPlanHistoryOrderFieldName
	case "STATUS":
		*f = *ActionPlanHistoryOrderFieldStatus
	case "review_due":
		*f = *ActionPlanHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ActionPlanHistoryOrderFieldReviewFrequency
	case "due_date":
		*f = *ActionPlanHistoryOrderFieldDueDate
	case "PRIORITY":
		*f = *ActionPlanHistoryOrderFieldPriority
	case "source":
		*f = *ActionPlanHistoryOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid ActionPlanHistoryOrderField", str)
	}
	return nil
}

// ActionPlanHistoryOrderField defines the ordering field of ActionPlanHistory.
type ActionPlanHistoryOrderField struct {
	// Value extracts the ordering value from the given ActionPlanHistory.
	Value    func(*ActionPlanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplanhistory.OrderOption
	toCursor func(*ActionPlanHistory) Cursor
}

// ActionPlanHistoryOrder defines the ordering of ActionPlanHistory.
type ActionPlanHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ActionPlanHistoryOrderField `json:"field"`
}

// DefaultActionPlanHistoryOrder is the default ordering of ActionPlanHistory.
var DefaultActionPlanHistoryOrder = &ActionPlanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.ID, nil
		},
		column: actionplanhistory.FieldID,
		toTerm: actionplanhistory.ByID,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{ID: aph.ID}
		},
	},
}

// ToEdge converts ActionPlanHistory into ActionPlanHistoryEdge.
func (aph *ActionPlanHistory) ToEdge(order *ActionPlanHistoryOrder) *ActionPlanHistoryEdge {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	return &ActionPlanHistoryEdge{
		Node:   aph,
		Cursor: order.Field.toCursor(aph),
	}
}

// AssessmentEdge is the edge representation of Assessment.
type AssessmentEdge struct {
	Node   *Assessment `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AssessmentConnection is the connection containing edges to Assessment.
type AssessmentConnection struct {
	Edges      []*AssessmentEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AssessmentConnection) build(nodes []*Assessment, pager *assessmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Assessment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Assessment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Assessment {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentPaginateOption enables pagination customization.
type AssessmentPaginateOption func(*assessmentPager) error

// WithAssessmentOrder configures pagination ordering.
func WithAssessmentOrder(order []*AssessmentOrder) AssessmentPaginateOption {
	return func(pager *assessmentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssessmentFilter configures pagination filter.
func WithAssessmentFilter(filter func(*AssessmentQuery) (*AssessmentQuery, error)) AssessmentPaginateOption {
	return func(pager *assessmentPager) error {
		if filter == nil {
			return errors.New("AssessmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentPager struct {
	reverse bool
	order   []*AssessmentOrder
	filter  func(*AssessmentQuery) (*AssessmentQuery, error)
}

func newAssessmentPager(opts []AssessmentPaginateOption, reverse bool) (*assessmentPager, error) {
	pager := &assessmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assessmentPager) applyFilter(query *AssessmentQuery) (*AssessmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentPager) toCursor(a *Assessment) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs_}
}

func (p *assessmentPager) applyCursors(query *AssessmentQuery, after, before *Cursor) (*AssessmentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssessmentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assessmentPager) applyOrder(query *AssessmentQuery) *AssessmentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssessmentOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case AssessmentOrderFieldAssessmentOwnerName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssessmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assessmentPager) orderExpr(query *AssessmentQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case AssessmentOrderFieldAssessmentOwnerName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssessmentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Assessment.
func (a *AssessmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentPaginateOption,
) (*AssessmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AssessmentConnection{Edges: []*AssessmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentOrderFieldCreatedAt orders Assessment by created_at.
	AssessmentOrderFieldCreatedAt = &AssessmentOrderField{
		Value: func(a *Assessment) (ent.Value, error) {
			return a.CreatedAt, nil
		},
		column: assessment.FieldCreatedAt,
		toTerm: assessment.ByCreatedAt,
		toCursor: func(a *Assessment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// AssessmentOrderFieldUpdatedAt orders Assessment by updated_at.
	AssessmentOrderFieldUpdatedAt = &AssessmentOrderField{
		Value: func(a *Assessment) (ent.Value, error) {
			return a.UpdatedAt, nil
		},
		column: assessment.FieldUpdatedAt,
		toTerm: assessment.ByUpdatedAt,
		toCursor: func(a *Assessment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// AssessmentOrderFieldName orders Assessment by name.
	AssessmentOrderFieldName = &AssessmentOrderField{
		Value: func(a *Assessment) (ent.Value, error) {
			return a.Name, nil
		},
		column: assessment.FieldName,
		toTerm: assessment.ByName,
		toCursor: func(a *Assessment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Name,
			}
		},
	}
	// AssessmentOrderFieldAssessmentType orders Assessment by assessment_type.
	AssessmentOrderFieldAssessmentType = &AssessmentOrderField{
		Value: func(a *Assessment) (ent.Value, error) {
			return a.AssessmentType, nil
		},
		column: assessment.FieldAssessmentType,
		toTerm: assessment.ByAssessmentType,
		toCursor: func(a *Assessment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.AssessmentType,
			}
		},
	}
	// AssessmentOrderFieldAssessmentOwnerName orders by ASSESSMENT_OWNER_name.
	AssessmentOrderFieldAssessmentOwnerName = &AssessmentOrderField{
		Value: func(a *Assessment) (ent.Value, error) {
			return a.Value("assessment_owner_name")
		},
		column: "assessment_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) assessment.OrderOption {
			return assessment.ByAssessmentOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("assessment_owner_name"))...,
			)
		},
		toCursor: func(a *Assessment) Cursor {
			cv, _ := a.Value("assessment_owner_name")
			return Cursor{
				ID:    a.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentOrderFieldName.column:
		str = "name"
	case AssessmentOrderFieldAssessmentType.column:
		str = "assessment_type"
	case AssessmentOrderFieldAssessmentOwnerName.column:
		str = "ASSESSMENT_OWNER_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssessmentOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentOrderFieldUpdatedAt
	case "name":
		*f = *AssessmentOrderFieldName
	case "assessment_type":
		*f = *AssessmentOrderFieldAssessmentType
	case "ASSESSMENT_OWNER_name":
		*f = *AssessmentOrderFieldAssessmentOwnerName
	default:
		return fmt.Errorf("%s is not a valid AssessmentOrderField", str)
	}
	return nil
}

// AssessmentOrderField defines the ordering field of Assessment.
type AssessmentOrderField struct {
	// Value extracts the ordering value from the given Assessment.
	Value    func(*Assessment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessment.OrderOption
	toCursor func(*Assessment) Cursor
}

// AssessmentOrder defines the ordering of Assessment.
type AssessmentOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AssessmentOrderField `json:"field"`
}

// DefaultAssessmentOrder is the default ordering of Assessment.
var DefaultAssessmentOrder = &AssessmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentOrderField{
		Value: func(a *Assessment) (ent.Value, error) {
			return a.ID, nil
		},
		column: assessment.FieldID,
		toTerm: assessment.ByID,
		toCursor: func(a *Assessment) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Assessment into AssessmentEdge.
func (a *Assessment) ToEdge(order *AssessmentOrder) *AssessmentEdge {
	if order == nil {
		order = DefaultAssessmentOrder
	}
	return &AssessmentEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AssessmentHistoryEdge is the edge representation of AssessmentHistory.
type AssessmentHistoryEdge struct {
	Node   *AssessmentHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// AssessmentHistoryConnection is the connection containing edges to AssessmentHistory.
type AssessmentHistoryConnection struct {
	Edges      []*AssessmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *AssessmentHistoryConnection) build(nodes []*AssessmentHistory, pager *assessmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentHistoryPaginateOption enables pagination customization.
type AssessmentHistoryPaginateOption func(*assessmenthistoryPager) error

// WithAssessmentHistoryOrder configures pagination ordering.
func WithAssessmentHistoryOrder(order *AssessmentHistoryOrder) AssessmentHistoryPaginateOption {
	if order == nil {
		order = DefaultAssessmentHistoryOrder
	}
	o := *order
	return func(pager *assessmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssessmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssessmentHistoryFilter configures pagination filter.
func WithAssessmentHistoryFilter(filter func(*AssessmentHistoryQuery) (*AssessmentHistoryQuery, error)) AssessmentHistoryPaginateOption {
	return func(pager *assessmenthistoryPager) error {
		if filter == nil {
			return errors.New("AssessmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmenthistoryPager struct {
	reverse bool
	order   *AssessmentHistoryOrder
	filter  func(*AssessmentHistoryQuery) (*AssessmentHistoryQuery, error)
}

func newAssessmentHistoryPager(opts []AssessmentHistoryPaginateOption, reverse bool) (*assessmenthistoryPager, error) {
	pager := &assessmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssessmentHistoryOrder
	}
	return pager, nil
}

func (p *assessmenthistoryPager) applyFilter(query *AssessmentHistoryQuery) (*AssessmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmenthistoryPager) toCursor(ah *AssessmentHistory) Cursor {
	return p.order.Field.toCursor(ah)
}

func (p *assessmenthistoryPager) applyCursors(query *AssessmentHistoryQuery, after, before *Cursor) (*AssessmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssessmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assessmenthistoryPager) applyOrder(query *AssessmentHistoryQuery) *AssessmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssessmentHistoryOrder.Field {
		query = query.Order(DefaultAssessmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assessmenthistoryPager) orderExpr(query *AssessmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssessmentHistoryOrder.Field {
			b.Comma().Ident(DefaultAssessmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentHistory.
func (ah *AssessmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentHistoryPaginateOption,
) (*AssessmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ah, err = pager.applyFilter(ah); err != nil {
		return nil, err
	}
	conn := &AssessmentHistoryConnection{Edges: []*AssessmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ah.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ah, err = pager.applyCursors(ah, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ah.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ah.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ah = pager.applyOrder(ah)
	nodes, err := ah.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentHistoryOrderFieldHistoryTime orders AssessmentHistory by history_time.
	AssessmentHistoryOrderFieldHistoryTime = &AssessmentHistoryOrderField{
		Value: func(ah *AssessmentHistory) (ent.Value, error) {
			return ah.HistoryTime, nil
		},
		column: assessmenthistory.FieldHistoryTime,
		toTerm: assessmenthistory.ByHistoryTime,
		toCursor: func(ah *AssessmentHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.HistoryTime,
			}
		},
	}
	// AssessmentHistoryOrderFieldCreatedAt orders AssessmentHistory by created_at.
	AssessmentHistoryOrderFieldCreatedAt = &AssessmentHistoryOrderField{
		Value: func(ah *AssessmentHistory) (ent.Value, error) {
			return ah.CreatedAt, nil
		},
		column: assessmenthistory.FieldCreatedAt,
		toTerm: assessmenthistory.ByCreatedAt,
		toCursor: func(ah *AssessmentHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.CreatedAt,
			}
		},
	}
	// AssessmentHistoryOrderFieldUpdatedAt orders AssessmentHistory by updated_at.
	AssessmentHistoryOrderFieldUpdatedAt = &AssessmentHistoryOrderField{
		Value: func(ah *AssessmentHistory) (ent.Value, error) {
			return ah.UpdatedAt, nil
		},
		column: assessmenthistory.FieldUpdatedAt,
		toTerm: assessmenthistory.ByUpdatedAt,
		toCursor: func(ah *AssessmentHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.UpdatedAt,
			}
		},
	}
	// AssessmentHistoryOrderFieldName orders AssessmentHistory by name.
	AssessmentHistoryOrderFieldName = &AssessmentHistoryOrderField{
		Value: func(ah *AssessmentHistory) (ent.Value, error) {
			return ah.Name, nil
		},
		column: assessmenthistory.FieldName,
		toTerm: assessmenthistory.ByName,
		toCursor: func(ah *AssessmentHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.Name,
			}
		},
	}
	// AssessmentHistoryOrderFieldAssessmentType orders AssessmentHistory by assessment_type.
	AssessmentHistoryOrderFieldAssessmentType = &AssessmentHistoryOrderField{
		Value: func(ah *AssessmentHistory) (ent.Value, error) {
			return ah.AssessmentType, nil
		},
		column: assessmenthistory.FieldAssessmentType,
		toTerm: assessmenthistory.ByAssessmentType,
		toCursor: func(ah *AssessmentHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.AssessmentType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssessmentHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentHistoryOrderFieldName.column:
		str = "name"
	case AssessmentHistoryOrderFieldAssessmentType.column:
		str = "assessment_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssessmentHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssessmentHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentHistoryOrderFieldUpdatedAt
	case "name":
		*f = *AssessmentHistoryOrderFieldName
	case "assessment_type":
		*f = *AssessmentHistoryOrderFieldAssessmentType
	default:
		return fmt.Errorf("%s is not a valid AssessmentHistoryOrderField", str)
	}
	return nil
}

// AssessmentHistoryOrderField defines the ordering field of AssessmentHistory.
type AssessmentHistoryOrderField struct {
	// Value extracts the ordering value from the given AssessmentHistory.
	Value    func(*AssessmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmenthistory.OrderOption
	toCursor func(*AssessmentHistory) Cursor
}

// AssessmentHistoryOrder defines the ordering of AssessmentHistory.
type AssessmentHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *AssessmentHistoryOrderField `json:"field"`
}

// DefaultAssessmentHistoryOrder is the default ordering of AssessmentHistory.
var DefaultAssessmentHistoryOrder = &AssessmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentHistoryOrderField{
		Value: func(ah *AssessmentHistory) (ent.Value, error) {
			return ah.ID, nil
		},
		column: assessmenthistory.FieldID,
		toTerm: assessmenthistory.ByID,
		toCursor: func(ah *AssessmentHistory) Cursor {
			return Cursor{ID: ah.ID}
		},
	},
}

// ToEdge converts AssessmentHistory into AssessmentHistoryEdge.
func (ah *AssessmentHistory) ToEdge(order *AssessmentHistoryOrder) *AssessmentHistoryEdge {
	if order == nil {
		order = DefaultAssessmentHistoryOrder
	}
	return &AssessmentHistoryEdge{
		Node:   ah,
		Cursor: order.Field.toCursor(ah),
	}
}

// AssessmentResponseEdge is the edge representation of AssessmentResponse.
type AssessmentResponseEdge struct {
	Node   *AssessmentResponse `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// AssessmentResponseConnection is the connection containing edges to AssessmentResponse.
type AssessmentResponseConnection struct {
	Edges      []*AssessmentResponseEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *AssessmentResponseConnection) build(nodes []*AssessmentResponse, pager *assessmentresponsePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentResponse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentResponse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentResponse {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentResponseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentResponseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentResponsePaginateOption enables pagination customization.
type AssessmentResponsePaginateOption func(*assessmentresponsePager) error

// WithAssessmentResponseOrder configures pagination ordering.
func WithAssessmentResponseOrder(order []*AssessmentResponseOrder) AssessmentResponsePaginateOption {
	return func(pager *assessmentresponsePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssessmentResponseFilter configures pagination filter.
func WithAssessmentResponseFilter(filter func(*AssessmentResponseQuery) (*AssessmentResponseQuery, error)) AssessmentResponsePaginateOption {
	return func(pager *assessmentresponsePager) error {
		if filter == nil {
			return errors.New("AssessmentResponseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentresponsePager struct {
	reverse bool
	order   []*AssessmentResponseOrder
	filter  func(*AssessmentResponseQuery) (*AssessmentResponseQuery, error)
}

func newAssessmentResponsePager(opts []AssessmentResponsePaginateOption, reverse bool) (*assessmentresponsePager, error) {
	pager := &assessmentresponsePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assessmentresponsePager) applyFilter(query *AssessmentResponseQuery) (*AssessmentResponseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentresponsePager) toCursor(ar *AssessmentResponse) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(ar).Value)
	}
	return Cursor{ID: ar.ID, Value: cs_}
}

func (p *assessmentresponsePager) applyCursors(query *AssessmentResponseQuery, after, before *Cursor) (*AssessmentResponseQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssessmentResponseOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assessmentresponsePager) applyOrder(query *AssessmentResponseQuery) *AssessmentResponseQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssessmentResponseOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssessmentResponseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assessmentresponsePager) orderExpr(query *AssessmentResponseQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssessmentResponseOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentResponse.
func (ar *AssessmentResponseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentResponsePaginateOption,
) (*AssessmentResponseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentResponsePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ar, err = pager.applyFilter(ar); err != nil {
		return nil, err
	}
	conn := &AssessmentResponseConnection{Edges: []*AssessmentResponseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ar.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ar, err = pager.applyCursors(ar, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ar.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ar = pager.applyOrder(ar)
	nodes, err := ar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentResponseOrderFieldCreatedAt orders AssessmentResponse by created_at.
	AssessmentResponseOrderFieldCreatedAt = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.CreatedAt, nil
		},
		column: assessmentresponse.FieldCreatedAt,
		toTerm: assessmentresponse.ByCreatedAt,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.CreatedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldUpdatedAt orders AssessmentResponse by updated_at.
	AssessmentResponseOrderFieldUpdatedAt = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.UpdatedAt, nil
		},
		column: assessmentresponse.FieldUpdatedAt,
		toTerm: assessmentresponse.ByUpdatedAt,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.UpdatedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldStatus orders AssessmentResponse by status.
	AssessmentResponseOrderFieldStatus = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.Status, nil
		},
		column: assessmentresponse.FieldStatus,
		toTerm: assessmentresponse.ByStatus,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.Status,
			}
		},
	}
	// AssessmentResponseOrderFieldAssignedAt orders AssessmentResponse by assigned_at.
	AssessmentResponseOrderFieldAssignedAt = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.AssignedAt, nil
		},
		column: assessmentresponse.FieldAssignedAt,
		toTerm: assessmentresponse.ByAssignedAt,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.AssignedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldStartedAt orders AssessmentResponse by started_at.
	AssessmentResponseOrderFieldStartedAt = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.StartedAt, nil
		},
		column: assessmentresponse.FieldStartedAt,
		toTerm: assessmentresponse.ByStartedAt,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.StartedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldCompletedAt orders AssessmentResponse by completed_at.
	AssessmentResponseOrderFieldCompletedAt = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.CompletedAt, nil
		},
		column: assessmentresponse.FieldCompletedAt,
		toTerm: assessmentresponse.ByCompletedAt,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.CompletedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldDueDate orders AssessmentResponse by due_date.
	AssessmentResponseOrderFieldDueDate = &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.DueDate, nil
		},
		column: assessmentresponse.FieldDueDate,
		toTerm: assessmentresponse.ByDueDate,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.DueDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentResponseOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentResponseOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentResponseOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentResponseOrderFieldStatus.column:
		str = "status"
	case AssessmentResponseOrderFieldAssignedAt.column:
		str = "assigned_at"
	case AssessmentResponseOrderFieldStartedAt.column:
		str = "started_at"
	case AssessmentResponseOrderFieldCompletedAt.column:
		str = "completed_at"
	case AssessmentResponseOrderFieldDueDate.column:
		str = "due_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentResponseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentResponseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentResponseOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssessmentResponseOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentResponseOrderFieldUpdatedAt
	case "status":
		*f = *AssessmentResponseOrderFieldStatus
	case "assigned_at":
		*f = *AssessmentResponseOrderFieldAssignedAt
	case "started_at":
		*f = *AssessmentResponseOrderFieldStartedAt
	case "completed_at":
		*f = *AssessmentResponseOrderFieldCompletedAt
	case "due_date":
		*f = *AssessmentResponseOrderFieldDueDate
	default:
		return fmt.Errorf("%s is not a valid AssessmentResponseOrderField", str)
	}
	return nil
}

// AssessmentResponseOrderField defines the ordering field of AssessmentResponse.
type AssessmentResponseOrderField struct {
	// Value extracts the ordering value from the given AssessmentResponse.
	Value    func(*AssessmentResponse) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmentresponse.OrderOption
	toCursor func(*AssessmentResponse) Cursor
}

// AssessmentResponseOrder defines the ordering of AssessmentResponse.
type AssessmentResponseOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *AssessmentResponseOrderField `json:"field"`
}

// DefaultAssessmentResponseOrder is the default ordering of AssessmentResponse.
var DefaultAssessmentResponseOrder = &AssessmentResponseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentResponseOrderField{
		Value: func(ar *AssessmentResponse) (ent.Value, error) {
			return ar.ID, nil
		},
		column: assessmentresponse.FieldID,
		toTerm: assessmentresponse.ByID,
		toCursor: func(ar *AssessmentResponse) Cursor {
			return Cursor{ID: ar.ID}
		},
	},
}

// ToEdge converts AssessmentResponse into AssessmentResponseEdge.
func (ar *AssessmentResponse) ToEdge(order *AssessmentResponseOrder) *AssessmentResponseEdge {
	if order == nil {
		order = DefaultAssessmentResponseOrder
	}
	return &AssessmentResponseEdge{
		Node:   ar,
		Cursor: order.Field.toCursor(ar),
	}
}

// AssessmentResponseHistoryEdge is the edge representation of AssessmentResponseHistory.
type AssessmentResponseHistoryEdge struct {
	Node   *AssessmentResponseHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// AssessmentResponseHistoryConnection is the connection containing edges to AssessmentResponseHistory.
type AssessmentResponseHistoryConnection struct {
	Edges      []*AssessmentResponseHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *AssessmentResponseHistoryConnection) build(nodes []*AssessmentResponseHistory, pager *assessmentresponsehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentResponseHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentResponseHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentResponseHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentResponseHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentResponseHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentResponseHistoryPaginateOption enables pagination customization.
type AssessmentResponseHistoryPaginateOption func(*assessmentresponsehistoryPager) error

// WithAssessmentResponseHistoryOrder configures pagination ordering.
func WithAssessmentResponseHistoryOrder(order *AssessmentResponseHistoryOrder) AssessmentResponseHistoryPaginateOption {
	if order == nil {
		order = DefaultAssessmentResponseHistoryOrder
	}
	o := *order
	return func(pager *assessmentresponsehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssessmentResponseHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssessmentResponseHistoryFilter configures pagination filter.
func WithAssessmentResponseHistoryFilter(filter func(*AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error)) AssessmentResponseHistoryPaginateOption {
	return func(pager *assessmentresponsehistoryPager) error {
		if filter == nil {
			return errors.New("AssessmentResponseHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentresponsehistoryPager struct {
	reverse bool
	order   *AssessmentResponseHistoryOrder
	filter  func(*AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error)
}

func newAssessmentResponseHistoryPager(opts []AssessmentResponseHistoryPaginateOption, reverse bool) (*assessmentresponsehistoryPager, error) {
	pager := &assessmentresponsehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssessmentResponseHistoryOrder
	}
	return pager, nil
}

func (p *assessmentresponsehistoryPager) applyFilter(query *AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentresponsehistoryPager) toCursor(arh *AssessmentResponseHistory) Cursor {
	return p.order.Field.toCursor(arh)
}

func (p *assessmentresponsehistoryPager) applyCursors(query *AssessmentResponseHistoryQuery, after, before *Cursor) (*AssessmentResponseHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssessmentResponseHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assessmentresponsehistoryPager) applyOrder(query *AssessmentResponseHistoryQuery) *AssessmentResponseHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssessmentResponseHistoryOrder.Field {
		query = query.Order(DefaultAssessmentResponseHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assessmentresponsehistoryPager) orderExpr(query *AssessmentResponseHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssessmentResponseHistoryOrder.Field {
			b.Comma().Ident(DefaultAssessmentResponseHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentResponseHistory.
func (arh *AssessmentResponseHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentResponseHistoryPaginateOption,
) (*AssessmentResponseHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentResponseHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if arh, err = pager.applyFilter(arh); err != nil {
		return nil, err
	}
	conn := &AssessmentResponseHistoryConnection{Edges: []*AssessmentResponseHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := arh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if arh, err = pager.applyCursors(arh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		arh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := arh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	arh = pager.applyOrder(arh)
	nodes, err := arh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentResponseHistoryOrderFieldHistoryTime orders AssessmentResponseHistory by history_time.
	AssessmentResponseHistoryOrderFieldHistoryTime = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.HistoryTime, nil
		},
		column: assessmentresponsehistory.FieldHistoryTime,
		toTerm: assessmentresponsehistory.ByHistoryTime,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.HistoryTime,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldCreatedAt orders AssessmentResponseHistory by created_at.
	AssessmentResponseHistoryOrderFieldCreatedAt = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.CreatedAt, nil
		},
		column: assessmentresponsehistory.FieldCreatedAt,
		toTerm: assessmentresponsehistory.ByCreatedAt,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.CreatedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldUpdatedAt orders AssessmentResponseHistory by updated_at.
	AssessmentResponseHistoryOrderFieldUpdatedAt = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.UpdatedAt, nil
		},
		column: assessmentresponsehistory.FieldUpdatedAt,
		toTerm: assessmentresponsehistory.ByUpdatedAt,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.UpdatedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldStatus orders AssessmentResponseHistory by status.
	AssessmentResponseHistoryOrderFieldStatus = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.Status, nil
		},
		column: assessmentresponsehistory.FieldStatus,
		toTerm: assessmentresponsehistory.ByStatus,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.Status,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldAssignedAt orders AssessmentResponseHistory by assigned_at.
	AssessmentResponseHistoryOrderFieldAssignedAt = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.AssignedAt, nil
		},
		column: assessmentresponsehistory.FieldAssignedAt,
		toTerm: assessmentresponsehistory.ByAssignedAt,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.AssignedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldStartedAt orders AssessmentResponseHistory by started_at.
	AssessmentResponseHistoryOrderFieldStartedAt = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.StartedAt, nil
		},
		column: assessmentresponsehistory.FieldStartedAt,
		toTerm: assessmentresponsehistory.ByStartedAt,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.StartedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldCompletedAt orders AssessmentResponseHistory by completed_at.
	AssessmentResponseHistoryOrderFieldCompletedAt = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.CompletedAt, nil
		},
		column: assessmentresponsehistory.FieldCompletedAt,
		toTerm: assessmentresponsehistory.ByCompletedAt,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.CompletedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldDueDate orders AssessmentResponseHistory by due_date.
	AssessmentResponseHistoryOrderFieldDueDate = &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.DueDate, nil
		},
		column: assessmentresponsehistory.FieldDueDate,
		toTerm: assessmentresponsehistory.ByDueDate,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    arh.ID,
				Value: arh.DueDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentResponseHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentResponseHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssessmentResponseHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentResponseHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentResponseHistoryOrderFieldStatus.column:
		str = "status"
	case AssessmentResponseHistoryOrderFieldAssignedAt.column:
		str = "assigned_at"
	case AssessmentResponseHistoryOrderFieldStartedAt.column:
		str = "started_at"
	case AssessmentResponseHistoryOrderFieldCompletedAt.column:
		str = "completed_at"
	case AssessmentResponseHistoryOrderFieldDueDate.column:
		str = "due_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentResponseHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentResponseHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentResponseHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssessmentResponseHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssessmentResponseHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentResponseHistoryOrderFieldUpdatedAt
	case "status":
		*f = *AssessmentResponseHistoryOrderFieldStatus
	case "assigned_at":
		*f = *AssessmentResponseHistoryOrderFieldAssignedAt
	case "started_at":
		*f = *AssessmentResponseHistoryOrderFieldStartedAt
	case "completed_at":
		*f = *AssessmentResponseHistoryOrderFieldCompletedAt
	case "due_date":
		*f = *AssessmentResponseHistoryOrderFieldDueDate
	default:
		return fmt.Errorf("%s is not a valid AssessmentResponseHistoryOrderField", str)
	}
	return nil
}

// AssessmentResponseHistoryOrderField defines the ordering field of AssessmentResponseHistory.
type AssessmentResponseHistoryOrderField struct {
	// Value extracts the ordering value from the given AssessmentResponseHistory.
	Value    func(*AssessmentResponseHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmentresponsehistory.OrderOption
	toCursor func(*AssessmentResponseHistory) Cursor
}

// AssessmentResponseHistoryOrder defines the ordering of AssessmentResponseHistory.
type AssessmentResponseHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *AssessmentResponseHistoryOrderField `json:"field"`
}

// DefaultAssessmentResponseHistoryOrder is the default ordering of AssessmentResponseHistory.
var DefaultAssessmentResponseHistoryOrder = &AssessmentResponseHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentResponseHistoryOrderField{
		Value: func(arh *AssessmentResponseHistory) (ent.Value, error) {
			return arh.ID, nil
		},
		column: assessmentresponsehistory.FieldID,
		toTerm: assessmentresponsehistory.ByID,
		toCursor: func(arh *AssessmentResponseHistory) Cursor {
			return Cursor{ID: arh.ID}
		},
	},
}

// ToEdge converts AssessmentResponseHistory into AssessmentResponseHistoryEdge.
func (arh *AssessmentResponseHistory) ToEdge(order *AssessmentResponseHistoryOrder) *AssessmentResponseHistoryEdge {
	if order == nil {
		order = DefaultAssessmentResponseHistoryOrder
	}
	return &AssessmentResponseHistoryEdge{
		Node:   arh,
		Cursor: order.Field.toCursor(arh),
	}
}

// AssetEdge is the edge representation of Asset.
type AssetEdge struct {
	Node   *Asset `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AssetConnection is the connection containing edges to Asset.
type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AssetConnection) build(nodes []*Asset, pager *assetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Asset
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Asset {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Asset {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetPaginateOption enables pagination customization.
type AssetPaginateOption func(*assetPager) error

// WithAssetOrder configures pagination ordering.
func WithAssetOrder(order []*AssetOrder) AssetPaginateOption {
	return func(pager *assetPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssetFilter configures pagination filter.
func WithAssetFilter(filter func(*AssetQuery) (*AssetQuery, error)) AssetPaginateOption {
	return func(pager *assetPager) error {
		if filter == nil {
			return errors.New("AssetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetPager struct {
	reverse bool
	order   []*AssetOrder
	filter  func(*AssetQuery) (*AssetQuery, error)
}

func newAssetPager(opts []AssetPaginateOption, reverse bool) (*assetPager, error) {
	pager := &assetPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assetPager) applyFilter(query *AssetQuery) (*AssetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetPager) toCursor(a *Asset) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs_}
}

func (p *assetPager) applyCursors(query *AssetQuery, after, before *Cursor) (*AssetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assetPager) applyOrder(query *AssetQuery) *AssetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assetPager) orderExpr(query *AssetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Asset.
func (a *AssetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetPaginateOption,
) (*AssetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AssetConnection{Edges: []*AssetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetOrderFieldCreatedAt orders Asset by created_at.
	AssetOrderFieldCreatedAt = &AssetOrderField{
		Value: func(a *Asset) (ent.Value, error) {
			return a.CreatedAt, nil
		},
		column: asset.FieldCreatedAt,
		toTerm: asset.ByCreatedAt,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// AssetOrderFieldUpdatedAt orders Asset by updated_at.
	AssetOrderFieldUpdatedAt = &AssetOrderField{
		Value: func(a *Asset) (ent.Value, error) {
			return a.UpdatedAt, nil
		},
		column: asset.FieldUpdatedAt,
		toTerm: asset.ByUpdatedAt,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// AssetOrderFieldAssetType orders Asset by asset_type.
	AssetOrderFieldAssetType = &AssetOrderField{
		Value: func(a *Asset) (ent.Value, error) {
			return a.AssetType, nil
		},
		column: asset.FieldAssetType,
		toTerm: asset.ByAssetType,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.AssetType,
			}
		},
	}
	// AssetOrderFieldName orders Asset by name.
	AssetOrderFieldName = &AssetOrderField{
		Value: func(a *Asset) (ent.Value, error) {
			return a.Name, nil
		},
		column: asset.FieldName,
		toTerm: asset.ByName,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetOrderField) String() string {
	var str string
	switch f.column {
	case AssetOrderFieldCreatedAt.column:
		str = "created_at"
	case AssetOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssetOrderFieldAssetType.column:
		str = "ASSET_TYPE"
	case AssetOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssetOrderFieldCreatedAt
	case "updated_at":
		*f = *AssetOrderFieldUpdatedAt
	case "ASSET_TYPE":
		*f = *AssetOrderFieldAssetType
	case "name":
		*f = *AssetOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AssetOrderField", str)
	}
	return nil
}

// AssetOrderField defines the ordering field of Asset.
type AssetOrderField struct {
	// Value extracts the ordering value from the given Asset.
	Value    func(*Asset) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) asset.OrderOption
	toCursor func(*Asset) Cursor
}

// AssetOrder defines the ordering of Asset.
type AssetOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AssetOrderField `json:"field"`
}

// DefaultAssetOrder is the default ordering of Asset.
var DefaultAssetOrder = &AssetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssetOrderField{
		Value: func(a *Asset) (ent.Value, error) {
			return a.ID, nil
		},
		column: asset.FieldID,
		toTerm: asset.ByID,
		toCursor: func(a *Asset) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Asset into AssetEdge.
func (a *Asset) ToEdge(order *AssetOrder) *AssetEdge {
	if order == nil {
		order = DefaultAssetOrder
	}
	return &AssetEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AssetHistoryEdge is the edge representation of AssetHistory.
type AssetHistoryEdge struct {
	Node   *AssetHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// AssetHistoryConnection is the connection containing edges to AssetHistory.
type AssetHistoryConnection struct {
	Edges      []*AssetHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *AssetHistoryConnection) build(nodes []*AssetHistory, pager *assethistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssetHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssetHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssetHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetHistoryPaginateOption enables pagination customization.
type AssetHistoryPaginateOption func(*assethistoryPager) error

// WithAssetHistoryOrder configures pagination ordering.
func WithAssetHistoryOrder(order *AssetHistoryOrder) AssetHistoryPaginateOption {
	if order == nil {
		order = DefaultAssetHistoryOrder
	}
	o := *order
	return func(pager *assethistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetHistoryFilter configures pagination filter.
func WithAssetHistoryFilter(filter func(*AssetHistoryQuery) (*AssetHistoryQuery, error)) AssetHistoryPaginateOption {
	return func(pager *assethistoryPager) error {
		if filter == nil {
			return errors.New("AssetHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assethistoryPager struct {
	reverse bool
	order   *AssetHistoryOrder
	filter  func(*AssetHistoryQuery) (*AssetHistoryQuery, error)
}

func newAssetHistoryPager(opts []AssetHistoryPaginateOption, reverse bool) (*assethistoryPager, error) {
	pager := &assethistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetHistoryOrder
	}
	return pager, nil
}

func (p *assethistoryPager) applyFilter(query *AssetHistoryQuery) (*AssetHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assethistoryPager) toCursor(ah *AssetHistory) Cursor {
	return p.order.Field.toCursor(ah)
}

func (p *assethistoryPager) applyCursors(query *AssetHistoryQuery, after, before *Cursor) (*AssetHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssetHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assethistoryPager) applyOrder(query *AssetHistoryQuery) *AssetHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssetHistoryOrder.Field {
		query = query.Order(DefaultAssetHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assethistoryPager) orderExpr(query *AssetHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetHistoryOrder.Field {
			b.Comma().Ident(DefaultAssetHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssetHistory.
func (ah *AssetHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetHistoryPaginateOption,
) (*AssetHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ah, err = pager.applyFilter(ah); err != nil {
		return nil, err
	}
	conn := &AssetHistoryConnection{Edges: []*AssetHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ah.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ah, err = pager.applyCursors(ah, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ah.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ah.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ah = pager.applyOrder(ah)
	nodes, err := ah.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetHistoryOrderFieldHistoryTime orders AssetHistory by history_time.
	AssetHistoryOrderFieldHistoryTime = &AssetHistoryOrderField{
		Value: func(ah *AssetHistory) (ent.Value, error) {
			return ah.HistoryTime, nil
		},
		column: assethistory.FieldHistoryTime,
		toTerm: assethistory.ByHistoryTime,
		toCursor: func(ah *AssetHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.HistoryTime,
			}
		},
	}
	// AssetHistoryOrderFieldCreatedAt orders AssetHistory by created_at.
	AssetHistoryOrderFieldCreatedAt = &AssetHistoryOrderField{
		Value: func(ah *AssetHistory) (ent.Value, error) {
			return ah.CreatedAt, nil
		},
		column: assethistory.FieldCreatedAt,
		toTerm: assethistory.ByCreatedAt,
		toCursor: func(ah *AssetHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.CreatedAt,
			}
		},
	}
	// AssetHistoryOrderFieldUpdatedAt orders AssetHistory by updated_at.
	AssetHistoryOrderFieldUpdatedAt = &AssetHistoryOrderField{
		Value: func(ah *AssetHistory) (ent.Value, error) {
			return ah.UpdatedAt, nil
		},
		column: assethistory.FieldUpdatedAt,
		toTerm: assethistory.ByUpdatedAt,
		toCursor: func(ah *AssetHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.UpdatedAt,
			}
		},
	}
	// AssetHistoryOrderFieldAssetType orders AssetHistory by asset_type.
	AssetHistoryOrderFieldAssetType = &AssetHistoryOrderField{
		Value: func(ah *AssetHistory) (ent.Value, error) {
			return ah.AssetType, nil
		},
		column: assethistory.FieldAssetType,
		toTerm: assethistory.ByAssetType,
		toCursor: func(ah *AssetHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.AssetType,
			}
		},
	}
	// AssetHistoryOrderFieldName orders AssetHistory by name.
	AssetHistoryOrderFieldName = &AssetHistoryOrderField{
		Value: func(ah *AssetHistory) (ent.Value, error) {
			return ah.Name, nil
		},
		column: assethistory.FieldName,
		toTerm: assethistory.ByName,
		toCursor: func(ah *AssetHistory) Cursor {
			return Cursor{
				ID:    ah.ID,
				Value: ah.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssetHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssetHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssetHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssetHistoryOrderFieldAssetType.column:
		str = "ASSET_TYPE"
	case AssetHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssetHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssetHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssetHistoryOrderFieldUpdatedAt
	case "ASSET_TYPE":
		*f = *AssetHistoryOrderFieldAssetType
	case "name":
		*f = *AssetHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AssetHistoryOrderField", str)
	}
	return nil
}

// AssetHistoryOrderField defines the ordering field of AssetHistory.
type AssetHistoryOrderField struct {
	// Value extracts the ordering value from the given AssetHistory.
	Value    func(*AssetHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assethistory.OrderOption
	toCursor func(*AssetHistory) Cursor
}

// AssetHistoryOrder defines the ordering of AssetHistory.
type AssetHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *AssetHistoryOrderField `json:"field"`
}

// DefaultAssetHistoryOrder is the default ordering of AssetHistory.
var DefaultAssetHistoryOrder = &AssetHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssetHistoryOrderField{
		Value: func(ah *AssetHistory) (ent.Value, error) {
			return ah.ID, nil
		},
		column: assethistory.FieldID,
		toTerm: assethistory.ByID,
		toCursor: func(ah *AssetHistory) Cursor {
			return Cursor{ID: ah.ID}
		},
	},
}

// ToEdge converts AssetHistory into AssetHistoryEdge.
func (ah *AssetHistory) ToEdge(order *AssetHistoryOrder) *AssetHistoryEdge {
	if order == nil {
		order = DefaultAssetHistoryOrder
	}
	return &AssetHistoryEdge{
		Node:   ah,
		Cursor: order.Field.toCursor(ah),
	}
}

// ContactEdge is the edge representation of Contact.
type ContactEdge struct {
	Node   *Contact `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ContactConnection is the connection containing edges to Contact.
type ContactConnection struct {
	Edges      []*ContactEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ContactConnection) build(nodes []*Contact, pager *contactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Contact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Contact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Contact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactPaginateOption enables pagination customization.
type ContactPaginateOption func(*contactPager) error

// WithContactOrder configures pagination ordering.
func WithContactOrder(order []*ContactOrder) ContactPaginateOption {
	return func(pager *contactPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithContactFilter configures pagination filter.
func WithContactFilter(filter func(*ContactQuery) (*ContactQuery, error)) ContactPaginateOption {
	return func(pager *contactPager) error {
		if filter == nil {
			return errors.New("ContactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contactPager struct {
	reverse bool
	order   []*ContactOrder
	filter  func(*ContactQuery) (*ContactQuery, error)
}

func newContactPager(opts []ContactPaginateOption, reverse bool) (*contactPager, error) {
	pager := &contactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *contactPager) applyFilter(query *ContactQuery) (*ContactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contactPager) toCursor(c *Contact) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs_}
}

func (p *contactPager) applyCursors(query *ContactQuery, after, before *Cursor) (*ContactQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultContactOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *contactPager) applyOrder(query *ContactQuery) *ContactQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultContactOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultContactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *contactPager) orderExpr(query *ContactQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultContactOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Contact.
func (c *ContactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactPaginateOption,
) (*ContactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ContactConnection{Edges: []*ContactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactOrderFieldCreatedAt orders Contact by created_at.
	ContactOrderFieldCreatedAt = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: contact.FieldCreatedAt,
		toTerm: contact.ByCreatedAt,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// ContactOrderFieldUpdatedAt orders Contact by updated_at.
	ContactOrderFieldUpdatedAt = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: contact.FieldUpdatedAt,
		toTerm: contact.ByUpdatedAt,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// ContactOrderFieldFullName orders Contact by full_name.
	ContactOrderFieldFullName = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.FullName, nil
		},
		column: contact.FieldFullName,
		toTerm: contact.ByFullName,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.FullName,
			}
		},
	}
	// ContactOrderFieldTitle orders Contact by title.
	ContactOrderFieldTitle = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.Title, nil
		},
		column: contact.FieldTitle,
		toTerm: contact.ByTitle,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Title,
			}
		},
	}
	// ContactOrderFieldCompany orders Contact by company.
	ContactOrderFieldCompany = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.Company, nil
		},
		column: contact.FieldCompany,
		toTerm: contact.ByCompany,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Company,
			}
		},
	}
	// ContactOrderFieldEmail orders Contact by email.
	ContactOrderFieldEmail = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.Email, nil
		},
		column: contact.FieldEmail,
		toTerm: contact.ByEmail,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Email,
			}
		},
	}
	// ContactOrderFieldStatus orders Contact by status.
	ContactOrderFieldStatus = &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.Status, nil
		},
		column: contact.FieldStatus,
		toTerm: contact.ByStatus,
		toCursor: func(c *Contact) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactOrderField) String() string {
	var str string
	switch f.column {
	case ContactOrderFieldCreatedAt.column:
		str = "created_at"
	case ContactOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ContactOrderFieldFullName.column:
		str = "full_name"
	case ContactOrderFieldTitle.column:
		str = "title"
	case ContactOrderFieldCompany.column:
		str = "company"
	case ContactOrderFieldEmail.column:
		str = "email"
	case ContactOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ContactOrderFieldCreatedAt
	case "updated_at":
		*f = *ContactOrderFieldUpdatedAt
	case "full_name":
		*f = *ContactOrderFieldFullName
	case "title":
		*f = *ContactOrderFieldTitle
	case "company":
		*f = *ContactOrderFieldCompany
	case "email":
		*f = *ContactOrderFieldEmail
	case "STATUS":
		*f = *ContactOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ContactOrderField", str)
	}
	return nil
}

// ContactOrderField defines the ordering field of Contact.
type ContactOrderField struct {
	// Value extracts the ordering value from the given Contact.
	Value    func(*Contact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contact.OrderOption
	toCursor func(*Contact) Cursor
}

// ContactOrder defines the ordering of Contact.
type ContactOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ContactOrderField `json:"field"`
}

// DefaultContactOrder is the default ordering of Contact.
var DefaultContactOrder = &ContactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.ID, nil
		},
		column: contact.FieldID,
		toTerm: contact.ByID,
		toCursor: func(c *Contact) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Contact into ContactEdge.
func (c *Contact) ToEdge(order *ContactOrder) *ContactEdge {
	if order == nil {
		order = DefaultContactOrder
	}
	return &ContactEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ContactHistoryEdge is the edge representation of ContactHistory.
type ContactHistoryEdge struct {
	Node   *ContactHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ContactHistoryConnection is the connection containing edges to ContactHistory.
type ContactHistoryConnection struct {
	Edges      []*ContactHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ContactHistoryConnection) build(nodes []*ContactHistory, pager *contacthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ContactHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ContactHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ContactHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactHistoryPaginateOption enables pagination customization.
type ContactHistoryPaginateOption func(*contacthistoryPager) error

// WithContactHistoryOrder configures pagination ordering.
func WithContactHistoryOrder(order *ContactHistoryOrder) ContactHistoryPaginateOption {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	o := *order
	return func(pager *contacthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactHistoryFilter configures pagination filter.
func WithContactHistoryFilter(filter func(*ContactHistoryQuery) (*ContactHistoryQuery, error)) ContactHistoryPaginateOption {
	return func(pager *contacthistoryPager) error {
		if filter == nil {
			return errors.New("ContactHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contacthistoryPager struct {
	reverse bool
	order   *ContactHistoryOrder
	filter  func(*ContactHistoryQuery) (*ContactHistoryQuery, error)
}

func newContactHistoryPager(opts []ContactHistoryPaginateOption, reverse bool) (*contacthistoryPager, error) {
	pager := &contacthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactHistoryOrder
	}
	return pager, nil
}

func (p *contacthistoryPager) applyFilter(query *ContactHistoryQuery) (*ContactHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contacthistoryPager) toCursor(ch *ContactHistory) Cursor {
	return p.order.Field.toCursor(ch)
}

func (p *contacthistoryPager) applyCursors(query *ContactHistoryQuery, after, before *Cursor) (*ContactHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contacthistoryPager) applyOrder(query *ContactHistoryQuery) *ContactHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactHistoryOrder.Field {
		query = query.Order(DefaultContactHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contacthistoryPager) orderExpr(query *ContactHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactHistoryOrder.Field {
			b.Comma().Ident(DefaultContactHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ContactHistory.
func (ch *ContactHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactHistoryPaginateOption,
) (*ContactHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ch, err = pager.applyFilter(ch); err != nil {
		return nil, err
	}
	conn := &ContactHistoryConnection{Edges: []*ContactHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ch, err = pager.applyCursors(ch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ch = pager.applyOrder(ch)
	nodes, err := ch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactHistoryOrderFieldHistoryTime orders ContactHistory by history_time.
	ContactHistoryOrderFieldHistoryTime = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.HistoryTime, nil
		},
		column: contacthistory.FieldHistoryTime,
		toTerm: contacthistory.ByHistoryTime,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.HistoryTime,
			}
		},
	}
	// ContactHistoryOrderFieldCreatedAt orders ContactHistory by created_at.
	ContactHistoryOrderFieldCreatedAt = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.CreatedAt, nil
		},
		column: contacthistory.FieldCreatedAt,
		toTerm: contacthistory.ByCreatedAt,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.CreatedAt,
			}
		},
	}
	// ContactHistoryOrderFieldUpdatedAt orders ContactHistory by updated_at.
	ContactHistoryOrderFieldUpdatedAt = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.UpdatedAt, nil
		},
		column: contacthistory.FieldUpdatedAt,
		toTerm: contacthistory.ByUpdatedAt,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.UpdatedAt,
			}
		},
	}
	// ContactHistoryOrderFieldFullName orders ContactHistory by full_name.
	ContactHistoryOrderFieldFullName = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.FullName, nil
		},
		column: contacthistory.FieldFullName,
		toTerm: contacthistory.ByFullName,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.FullName,
			}
		},
	}
	// ContactHistoryOrderFieldTitle orders ContactHistory by title.
	ContactHistoryOrderFieldTitle = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.Title, nil
		},
		column: contacthistory.FieldTitle,
		toTerm: contacthistory.ByTitle,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Title,
			}
		},
	}
	// ContactHistoryOrderFieldCompany orders ContactHistory by company.
	ContactHistoryOrderFieldCompany = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.Company, nil
		},
		column: contacthistory.FieldCompany,
		toTerm: contacthistory.ByCompany,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Company,
			}
		},
	}
	// ContactHistoryOrderFieldEmail orders ContactHistory by email.
	ContactHistoryOrderFieldEmail = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.Email, nil
		},
		column: contacthistory.FieldEmail,
		toTerm: contacthistory.ByEmail,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Email,
			}
		},
	}
	// ContactHistoryOrderFieldStatus orders ContactHistory by status.
	ContactHistoryOrderFieldStatus = &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.Status, nil
		},
		column: contacthistory.FieldStatus,
		toTerm: contacthistory.ByStatus,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ContactHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ContactHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ContactHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ContactHistoryOrderFieldFullName.column:
		str = "full_name"
	case ContactHistoryOrderFieldTitle.column:
		str = "title"
	case ContactHistoryOrderFieldCompany.column:
		str = "company"
	case ContactHistoryOrderFieldEmail.column:
		str = "email"
	case ContactHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ContactHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ContactHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ContactHistoryOrderFieldUpdatedAt
	case "full_name":
		*f = *ContactHistoryOrderFieldFullName
	case "title":
		*f = *ContactHistoryOrderFieldTitle
	case "company":
		*f = *ContactHistoryOrderFieldCompany
	case "email":
		*f = *ContactHistoryOrderFieldEmail
	case "STATUS":
		*f = *ContactHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ContactHistoryOrderField", str)
	}
	return nil
}

// ContactHistoryOrderField defines the ordering field of ContactHistory.
type ContactHistoryOrderField struct {
	// Value extracts the ordering value from the given ContactHistory.
	Value    func(*ContactHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contacthistory.OrderOption
	toCursor func(*ContactHistory) Cursor
}

// ContactHistoryOrder defines the ordering of ContactHistory.
type ContactHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ContactHistoryOrderField `json:"field"`
}

// DefaultContactHistoryOrder is the default ordering of ContactHistory.
var DefaultContactHistoryOrder = &ContactHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.ID, nil
		},
		column: contacthistory.FieldID,
		toTerm: contacthistory.ByID,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{ID: ch.ID}
		},
	},
}

// ToEdge converts ContactHistory into ContactHistoryEdge.
func (ch *ContactHistory) ToEdge(order *ContactHistoryOrder) *ContactHistoryEdge {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	return &ContactHistoryEdge{
		Node:   ch,
		Cursor: order.Field.toCursor(ch),
	}
}

// ControlEdge is the edge representation of Control.
type ControlEdge struct {
	Node   *Control `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ControlConnection is the connection containing edges to Control.
type ControlConnection struct {
	Edges      []*ControlEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ControlConnection) build(nodes []*Control, pager *controlPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Control
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Control {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Control {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlPaginateOption enables pagination customization.
type ControlPaginateOption func(*controlPager) error

// WithControlOrder configures pagination ordering.
func WithControlOrder(order []*ControlOrder) ControlPaginateOption {
	return func(pager *controlPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlFilter configures pagination filter.
func WithControlFilter(filter func(*ControlQuery) (*ControlQuery, error)) ControlPaginateOption {
	return func(pager *controlPager) error {
		if filter == nil {
			return errors.New("ControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlPager struct {
	reverse bool
	order   []*ControlOrder
	filter  func(*ControlQuery) (*ControlQuery, error)
}

func newControlPager(opts []ControlPaginateOption, reverse bool) (*controlPager, error) {
	pager := &controlPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlPager) applyFilter(query *ControlQuery) (*ControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlPager) toCursor(c *Control) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(c).Value)
	}
	return Cursor{ID: c.ID, Value: cs_}
}

func (p *controlPager) applyCursors(query *ControlQuery, after, before *Cursor) (*ControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlPager) applyOrder(query *ControlQuery) *ControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case ControlOrderFieldControlOwnerName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlPager) orderExpr(query *ControlQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case ControlOrderFieldControlOwnerName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Control.
func (c *ControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlPaginateOption,
) (*ControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ControlConnection{Edges: []*ControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlOrderFieldCreatedAt orders Control by created_at.
	ControlOrderFieldCreatedAt = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: control.FieldCreatedAt,
		toTerm: control.ByCreatedAt,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// ControlOrderFieldUpdatedAt orders Control by updated_at.
	ControlOrderFieldUpdatedAt = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: control.FieldUpdatedAt,
		toTerm: control.ByUpdatedAt,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// ControlOrderFieldStatus orders Control by status.
	ControlOrderFieldStatus = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.Status, nil
		},
		column: control.FieldStatus,
		toTerm: control.ByStatus,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Status,
			}
		},
	}
	// ControlOrderFieldSource orders Control by source.
	ControlOrderFieldSource = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.Source, nil
		},
		column: control.FieldSource,
		toTerm: control.BySource,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Source,
			}
		},
	}
	// ControlOrderFieldReferenceFramework orders Control by reference_framework.
	ControlOrderFieldReferenceFramework = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			// allow for nil values for fields
			if c.ReferenceFramework == nil {
				return nil, nil
			}
			return c.ReferenceFramework, nil
		},
		column: control.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return control.ByReferenceFramework(opts...)
		},
		toCursor: func(c *Control) Cursor {
			if c.ReferenceFramework == nil {
				return Cursor{
					ID:    c.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    c.ID,
				Value: c.ReferenceFramework,
			}
		},
	}
	// ControlOrderFieldControlType orders Control by control_type.
	ControlOrderFieldControlType = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.ControlType, nil
		},
		column: control.FieldControlType,
		toTerm: control.ByControlType,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ControlType,
			}
		},
	}
	// ControlOrderFieldCategory orders Control by category.
	ControlOrderFieldCategory = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.Category, nil
		},
		column: control.FieldCategory,
		toTerm: control.ByCategory,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Category,
			}
		},
	}
	// ControlOrderFieldSubcategory orders Control by subcategory.
	ControlOrderFieldSubcategory = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.Subcategory, nil
		},
		column: control.FieldSubcategory,
		toTerm: control.BySubcategory,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Subcategory,
			}
		},
	}
	// ControlOrderFieldRefCode orders Control by ref_code.
	ControlOrderFieldRefCode = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.RefCode, nil
		},
		column: control.FieldRefCode,
		toTerm: control.ByRefCode,
		toCursor: func(c *Control) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.RefCode,
			}
		},
	}
	// ControlOrderFieldControlOwnerName orders by CONTROL_OWNER_name.
	ControlOrderFieldControlOwnerName = &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.Value("control_owner_name")
		},
		column: "control_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByControlOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("control_owner_name"))...,
			)
		},
		toCursor: func(c *Control) Cursor {
			cv, _ := c.Value("control_owner_name")
			return Cursor{
				ID:    c.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlOrderField) String() string {
	var str string
	switch f.column {
	case ControlOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlOrderFieldStatus.column:
		str = "STATUS"
	case ControlOrderFieldSource.column:
		str = "SOURCE"
	case ControlOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case ControlOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case ControlOrderFieldCategory.column:
		str = "category"
	case ControlOrderFieldSubcategory.column:
		str = "subcategory"
	case ControlOrderFieldRefCode.column:
		str = "ref_code"
	case ControlOrderFieldControlOwnerName.column:
		str = "CONTROL_OWNER_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlOrderFieldStatus
	case "SOURCE":
		*f = *ControlOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *ControlOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *ControlOrderFieldControlType
	case "category":
		*f = *ControlOrderFieldCategory
	case "subcategory":
		*f = *ControlOrderFieldSubcategory
	case "ref_code":
		*f = *ControlOrderFieldRefCode
	case "CONTROL_OWNER_name":
		*f = *ControlOrderFieldControlOwnerName
	default:
		return fmt.Errorf("%s is not a valid ControlOrderField", str)
	}
	return nil
}

// ControlOrderField defines the ordering field of Control.
type ControlOrderField struct {
	// Value extracts the ordering value from the given Control.
	Value    func(*Control) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) control.OrderOption
	toCursor func(*Control) Cursor
}

// ControlOrder defines the ordering of Control.
type ControlOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ControlOrderField `json:"field"`
}

// DefaultControlOrder is the default ordering of Control.
var DefaultControlOrder = &ControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.ID, nil
		},
		column: control.FieldID,
		toTerm: control.ByID,
		toCursor: func(c *Control) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Control into ControlEdge.
func (c *Control) ToEdge(order *ControlOrder) *ControlEdge {
	if order == nil {
		order = DefaultControlOrder
	}
	return &ControlEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ControlHistoryEdge is the edge representation of ControlHistory.
type ControlHistoryEdge struct {
	Node   *ControlHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ControlHistoryConnection is the connection containing edges to ControlHistory.
type ControlHistoryConnection struct {
	Edges      []*ControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ControlHistoryConnection) build(nodes []*ControlHistory, pager *controlhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlHistoryPaginateOption enables pagination customization.
type ControlHistoryPaginateOption func(*controlhistoryPager) error

// WithControlHistoryOrder configures pagination ordering.
func WithControlHistoryOrder(order *ControlHistoryOrder) ControlHistoryPaginateOption {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	o := *order
	return func(pager *controlhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlHistoryFilter configures pagination filter.
func WithControlHistoryFilter(filter func(*ControlHistoryQuery) (*ControlHistoryQuery, error)) ControlHistoryPaginateOption {
	return func(pager *controlhistoryPager) error {
		if filter == nil {
			return errors.New("ControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlhistoryPager struct {
	reverse bool
	order   *ControlHistoryOrder
	filter  func(*ControlHistoryQuery) (*ControlHistoryQuery, error)
}

func newControlHistoryPager(opts []ControlHistoryPaginateOption, reverse bool) (*controlhistoryPager, error) {
	pager := &controlhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlHistoryOrder
	}
	return pager, nil
}

func (p *controlhistoryPager) applyFilter(query *ControlHistoryQuery) (*ControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlhistoryPager) toCursor(ch *ControlHistory) Cursor {
	return p.order.Field.toCursor(ch)
}

func (p *controlhistoryPager) applyCursors(query *ControlHistoryQuery, after, before *Cursor) (*ControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlhistoryPager) applyOrder(query *ControlHistoryQuery) *ControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlHistoryOrder.Field {
		query = query.Order(DefaultControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlhistoryPager) orderExpr(query *ControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlHistoryOrder.Field {
			b.Comma().Ident(DefaultControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlHistory.
func (ch *ControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlHistoryPaginateOption,
) (*ControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ch, err = pager.applyFilter(ch); err != nil {
		return nil, err
	}
	conn := &ControlHistoryConnection{Edges: []*ControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ch, err = pager.applyCursors(ch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ch = pager.applyOrder(ch)
	nodes, err := ch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlHistoryOrderFieldHistoryTime orders ControlHistory by history_time.
	ControlHistoryOrderFieldHistoryTime = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.HistoryTime, nil
		},
		column: controlhistory.FieldHistoryTime,
		toTerm: controlhistory.ByHistoryTime,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.HistoryTime,
			}
		},
	}
	// ControlHistoryOrderFieldCreatedAt orders ControlHistory by created_at.
	ControlHistoryOrderFieldCreatedAt = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.CreatedAt, nil
		},
		column: controlhistory.FieldCreatedAt,
		toTerm: controlhistory.ByCreatedAt,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.CreatedAt,
			}
		},
	}
	// ControlHistoryOrderFieldUpdatedAt orders ControlHistory by updated_at.
	ControlHistoryOrderFieldUpdatedAt = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.UpdatedAt, nil
		},
		column: controlhistory.FieldUpdatedAt,
		toTerm: controlhistory.ByUpdatedAt,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.UpdatedAt,
			}
		},
	}
	// ControlHistoryOrderFieldStatus orders ControlHistory by status.
	ControlHistoryOrderFieldStatus = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.Status, nil
		},
		column: controlhistory.FieldStatus,
		toTerm: controlhistory.ByStatus,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Status,
			}
		},
	}
	// ControlHistoryOrderFieldSource orders ControlHistory by source.
	ControlHistoryOrderFieldSource = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.Source, nil
		},
		column: controlhistory.FieldSource,
		toTerm: controlhistory.BySource,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Source,
			}
		},
	}
	// ControlHistoryOrderFieldReferenceFramework orders ControlHistory by reference_framework.
	ControlHistoryOrderFieldReferenceFramework = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			// allow for nil values for fields
			if ch.ReferenceFramework == nil {
				return nil, nil
			}
			return ch.ReferenceFramework, nil
		},
		column: controlhistory.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) controlhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return controlhistory.ByReferenceFramework(opts...)
		},
		toCursor: func(ch *ControlHistory) Cursor {
			if ch.ReferenceFramework == nil {
				return Cursor{
					ID:    ch.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    ch.ID,
				Value: ch.ReferenceFramework,
			}
		},
	}
	// ControlHistoryOrderFieldControlType orders ControlHistory by control_type.
	ControlHistoryOrderFieldControlType = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.ControlType, nil
		},
		column: controlhistory.FieldControlType,
		toTerm: controlhistory.ByControlType,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.ControlType,
			}
		},
	}
	// ControlHistoryOrderFieldCategory orders ControlHistory by category.
	ControlHistoryOrderFieldCategory = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.Category, nil
		},
		column: controlhistory.FieldCategory,
		toTerm: controlhistory.ByCategory,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Category,
			}
		},
	}
	// ControlHistoryOrderFieldSubcategory orders ControlHistory by subcategory.
	ControlHistoryOrderFieldSubcategory = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.Subcategory, nil
		},
		column: controlhistory.FieldSubcategory,
		toTerm: controlhistory.BySubcategory,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.Subcategory,
			}
		},
	}
	// ControlHistoryOrderFieldRefCode orders ControlHistory by ref_code.
	ControlHistoryOrderFieldRefCode = &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.RefCode, nil
		},
		column: controlhistory.FieldRefCode,
		toTerm: controlhistory.ByRefCode,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.RefCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ControlHistoryOrderFieldSource.column:
		str = "SOURCE"
	case ControlHistoryOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case ControlHistoryOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case ControlHistoryOrderFieldCategory.column:
		str = "category"
	case ControlHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	case ControlHistoryOrderFieldRefCode.column:
		str = "ref_code"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlHistoryOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlHistoryOrderFieldStatus
	case "SOURCE":
		*f = *ControlHistoryOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *ControlHistoryOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *ControlHistoryOrderFieldControlType
	case "category":
		*f = *ControlHistoryOrderFieldCategory
	case "subcategory":
		*f = *ControlHistoryOrderFieldSubcategory
	case "ref_code":
		*f = *ControlHistoryOrderFieldRefCode
	default:
		return fmt.Errorf("%s is not a valid ControlHistoryOrderField", str)
	}
	return nil
}

// ControlHistoryOrderField defines the ordering field of ControlHistory.
type ControlHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlHistory.
	Value    func(*ControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlhistory.OrderOption
	toCursor func(*ControlHistory) Cursor
}

// ControlHistoryOrder defines the ordering of ControlHistory.
type ControlHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ControlHistoryOrderField `json:"field"`
}

// DefaultControlHistoryOrder is the default ordering of ControlHistory.
var DefaultControlHistoryOrder = &ControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.ID, nil
		},
		column: controlhistory.FieldID,
		toTerm: controlhistory.ByID,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{ID: ch.ID}
		},
	},
}

// ToEdge converts ControlHistory into ControlHistoryEdge.
func (ch *ControlHistory) ToEdge(order *ControlHistoryOrder) *ControlHistoryEdge {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	return &ControlHistoryEdge{
		Node:   ch,
		Cursor: order.Field.toCursor(ch),
	}
}

// ControlImplementationEdge is the edge representation of ControlImplementation.
type ControlImplementationEdge struct {
	Node   *ControlImplementation `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// ControlImplementationConnection is the connection containing edges to ControlImplementation.
type ControlImplementationConnection struct {
	Edges      []*ControlImplementationEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *ControlImplementationConnection) build(nodes []*ControlImplementation, pager *controlimplementationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlImplementation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlImplementation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlImplementation {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlImplementationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlImplementationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlImplementationPaginateOption enables pagination customization.
type ControlImplementationPaginateOption func(*controlimplementationPager) error

// WithControlImplementationOrder configures pagination ordering.
func WithControlImplementationOrder(order []*ControlImplementationOrder) ControlImplementationPaginateOption {
	return func(pager *controlimplementationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlImplementationFilter configures pagination filter.
func WithControlImplementationFilter(filter func(*ControlImplementationQuery) (*ControlImplementationQuery, error)) ControlImplementationPaginateOption {
	return func(pager *controlimplementationPager) error {
		if filter == nil {
			return errors.New("ControlImplementationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlimplementationPager struct {
	reverse bool
	order   []*ControlImplementationOrder
	filter  func(*ControlImplementationQuery) (*ControlImplementationQuery, error)
}

func newControlImplementationPager(opts []ControlImplementationPaginateOption, reverse bool) (*controlimplementationPager, error) {
	pager := &controlimplementationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlimplementationPager) applyFilter(query *ControlImplementationQuery) (*ControlImplementationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlimplementationPager) toCursor(ci *ControlImplementation) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(ci).Value)
	}
	return Cursor{ID: ci.ID, Value: cs_}
}

func (p *controlimplementationPager) applyCursors(query *ControlImplementationQuery, after, before *Cursor) (*ControlImplementationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlImplementationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlimplementationPager) applyOrder(query *ControlImplementationQuery) *ControlImplementationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlImplementationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlImplementationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlimplementationPager) orderExpr(query *ControlImplementationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlImplementationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlImplementation.
func (ci *ControlImplementationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlImplementationPaginateOption,
) (*ControlImplementationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlImplementationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ci, err = pager.applyFilter(ci); err != nil {
		return nil, err
	}
	conn := &ControlImplementationConnection{Edges: []*ControlImplementationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ci.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ci, err = pager.applyCursors(ci, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ci.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ci.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ci = pager.applyOrder(ci)
	nodes, err := ci.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlImplementationOrderFieldCreatedAt orders ControlImplementation by created_at.
	ControlImplementationOrderFieldCreatedAt = &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.CreatedAt, nil
		},
		column: controlimplementation.FieldCreatedAt,
		toTerm: controlimplementation.ByCreatedAt,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.CreatedAt,
			}
		},
	}
	// ControlImplementationOrderFieldUpdatedAt orders ControlImplementation by updated_at.
	ControlImplementationOrderFieldUpdatedAt = &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.UpdatedAt, nil
		},
		column: controlimplementation.FieldUpdatedAt,
		toTerm: controlimplementation.ByUpdatedAt,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.UpdatedAt,
			}
		},
	}
	// ControlImplementationOrderFieldStatus orders ControlImplementation by status.
	ControlImplementationOrderFieldStatus = &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.Status, nil
		},
		column: controlimplementation.FieldStatus,
		toTerm: controlimplementation.ByStatus,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Status,
			}
		},
	}
	// ControlImplementationOrderFieldImplementationDate orders ControlImplementation by implementation_date.
	ControlImplementationOrderFieldImplementationDate = &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.ImplementationDate, nil
		},
		column: controlimplementation.FieldImplementationDate,
		toTerm: controlimplementation.ByImplementationDate,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.ImplementationDate,
			}
		},
	}
	// ControlImplementationOrderFieldVerified orders ControlImplementation by verified.
	ControlImplementationOrderFieldVerified = &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.Verified, nil
		},
		column: controlimplementation.FieldVerified,
		toTerm: controlimplementation.ByVerified,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Verified,
			}
		},
	}
	// ControlImplementationOrderFieldVerificationDate orders ControlImplementation by verification_date.
	ControlImplementationOrderFieldVerificationDate = &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.VerificationDate, nil
		},
		column: controlimplementation.FieldVerificationDate,
		toTerm: controlimplementation.ByVerificationDate,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.VerificationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlImplementationOrderField) String() string {
	var str string
	switch f.column {
	case ControlImplementationOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlImplementationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlImplementationOrderFieldStatus.column:
		str = "STATUS"
	case ControlImplementationOrderFieldImplementationDate.column:
		str = "implementation_date"
	case ControlImplementationOrderFieldVerified.column:
		str = "verified"
	case ControlImplementationOrderFieldVerificationDate.column:
		str = "verification_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlImplementationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlImplementationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlImplementationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlImplementationOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlImplementationOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlImplementationOrderFieldStatus
	case "implementation_date":
		*f = *ControlImplementationOrderFieldImplementationDate
	case "verified":
		*f = *ControlImplementationOrderFieldVerified
	case "verification_date":
		*f = *ControlImplementationOrderFieldVerificationDate
	default:
		return fmt.Errorf("%s is not a valid ControlImplementationOrderField", str)
	}
	return nil
}

// ControlImplementationOrderField defines the ordering field of ControlImplementation.
type ControlImplementationOrderField struct {
	// Value extracts the ordering value from the given ControlImplementation.
	Value    func(*ControlImplementation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlimplementation.OrderOption
	toCursor func(*ControlImplementation) Cursor
}

// ControlImplementationOrder defines the ordering of ControlImplementation.
type ControlImplementationOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *ControlImplementationOrderField `json:"field"`
}

// DefaultControlImplementationOrder is the default ordering of ControlImplementation.
var DefaultControlImplementationOrder = &ControlImplementationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlImplementationOrderField{
		Value: func(ci *ControlImplementation) (ent.Value, error) {
			return ci.ID, nil
		},
		column: controlimplementation.FieldID,
		toTerm: controlimplementation.ByID,
		toCursor: func(ci *ControlImplementation) Cursor {
			return Cursor{ID: ci.ID}
		},
	},
}

// ToEdge converts ControlImplementation into ControlImplementationEdge.
func (ci *ControlImplementation) ToEdge(order *ControlImplementationOrder) *ControlImplementationEdge {
	if order == nil {
		order = DefaultControlImplementationOrder
	}
	return &ControlImplementationEdge{
		Node:   ci,
		Cursor: order.Field.toCursor(ci),
	}
}

// ControlImplementationHistoryEdge is the edge representation of ControlImplementationHistory.
type ControlImplementationHistoryEdge struct {
	Node   *ControlImplementationHistory `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// ControlImplementationHistoryConnection is the connection containing edges to ControlImplementationHistory.
type ControlImplementationHistoryConnection struct {
	Edges      []*ControlImplementationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *ControlImplementationHistoryConnection) build(nodes []*ControlImplementationHistory, pager *controlimplementationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlImplementationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlImplementationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlImplementationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlImplementationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlImplementationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlImplementationHistoryPaginateOption enables pagination customization.
type ControlImplementationHistoryPaginateOption func(*controlimplementationhistoryPager) error

// WithControlImplementationHistoryOrder configures pagination ordering.
func WithControlImplementationHistoryOrder(order *ControlImplementationHistoryOrder) ControlImplementationHistoryPaginateOption {
	if order == nil {
		order = DefaultControlImplementationHistoryOrder
	}
	o := *order
	return func(pager *controlimplementationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlImplementationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlImplementationHistoryFilter configures pagination filter.
func WithControlImplementationHistoryFilter(filter func(*ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error)) ControlImplementationHistoryPaginateOption {
	return func(pager *controlimplementationhistoryPager) error {
		if filter == nil {
			return errors.New("ControlImplementationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlimplementationhistoryPager struct {
	reverse bool
	order   *ControlImplementationHistoryOrder
	filter  func(*ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error)
}

func newControlImplementationHistoryPager(opts []ControlImplementationHistoryPaginateOption, reverse bool) (*controlimplementationhistoryPager, error) {
	pager := &controlimplementationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlImplementationHistoryOrder
	}
	return pager, nil
}

func (p *controlimplementationhistoryPager) applyFilter(query *ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlimplementationhistoryPager) toCursor(cih *ControlImplementationHistory) Cursor {
	return p.order.Field.toCursor(cih)
}

func (p *controlimplementationhistoryPager) applyCursors(query *ControlImplementationHistoryQuery, after, before *Cursor) (*ControlImplementationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlImplementationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlimplementationhistoryPager) applyOrder(query *ControlImplementationHistoryQuery) *ControlImplementationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlImplementationHistoryOrder.Field {
		query = query.Order(DefaultControlImplementationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlimplementationhistoryPager) orderExpr(query *ControlImplementationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlImplementationHistoryOrder.Field {
			b.Comma().Ident(DefaultControlImplementationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlImplementationHistory.
func (cih *ControlImplementationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlImplementationHistoryPaginateOption,
) (*ControlImplementationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlImplementationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cih, err = pager.applyFilter(cih); err != nil {
		return nil, err
	}
	conn := &ControlImplementationHistoryConnection{Edges: []*ControlImplementationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cih.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cih, err = pager.applyCursors(cih, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cih.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cih.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cih = pager.applyOrder(cih)
	nodes, err := cih.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlImplementationHistoryOrderFieldHistoryTime orders ControlImplementationHistory by history_time.
	ControlImplementationHistoryOrderFieldHistoryTime = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.HistoryTime, nil
		},
		column: controlimplementationhistory.FieldHistoryTime,
		toTerm: controlimplementationhistory.ByHistoryTime,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.HistoryTime,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldCreatedAt orders ControlImplementationHistory by created_at.
	ControlImplementationHistoryOrderFieldCreatedAt = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.CreatedAt, nil
		},
		column: controlimplementationhistory.FieldCreatedAt,
		toTerm: controlimplementationhistory.ByCreatedAt,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.CreatedAt,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldUpdatedAt orders ControlImplementationHistory by updated_at.
	ControlImplementationHistoryOrderFieldUpdatedAt = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.UpdatedAt, nil
		},
		column: controlimplementationhistory.FieldUpdatedAt,
		toTerm: controlimplementationhistory.ByUpdatedAt,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.UpdatedAt,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldStatus orders ControlImplementationHistory by status.
	ControlImplementationHistoryOrderFieldStatus = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.Status, nil
		},
		column: controlimplementationhistory.FieldStatus,
		toTerm: controlimplementationhistory.ByStatus,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.Status,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldImplementationDate orders ControlImplementationHistory by implementation_date.
	ControlImplementationHistoryOrderFieldImplementationDate = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.ImplementationDate, nil
		},
		column: controlimplementationhistory.FieldImplementationDate,
		toTerm: controlimplementationhistory.ByImplementationDate,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.ImplementationDate,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldVerified orders ControlImplementationHistory by verified.
	ControlImplementationHistoryOrderFieldVerified = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.Verified, nil
		},
		column: controlimplementationhistory.FieldVerified,
		toTerm: controlimplementationhistory.ByVerified,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.Verified,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldVerificationDate orders ControlImplementationHistory by verification_date.
	ControlImplementationHistoryOrderFieldVerificationDate = &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.VerificationDate, nil
		},
		column: controlimplementationhistory.FieldVerificationDate,
		toTerm: controlimplementationhistory.ByVerificationDate,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    cih.ID,
				Value: cih.VerificationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlImplementationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlImplementationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlImplementationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlImplementationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlImplementationHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ControlImplementationHistoryOrderFieldImplementationDate.column:
		str = "implementation_date"
	case ControlImplementationHistoryOrderFieldVerified.column:
		str = "verified"
	case ControlImplementationHistoryOrderFieldVerificationDate.column:
		str = "verification_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlImplementationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlImplementationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlImplementationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlImplementationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlImplementationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlImplementationHistoryOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlImplementationHistoryOrderFieldStatus
	case "implementation_date":
		*f = *ControlImplementationHistoryOrderFieldImplementationDate
	case "verified":
		*f = *ControlImplementationHistoryOrderFieldVerified
	case "verification_date":
		*f = *ControlImplementationHistoryOrderFieldVerificationDate
	default:
		return fmt.Errorf("%s is not a valid ControlImplementationHistoryOrderField", str)
	}
	return nil
}

// ControlImplementationHistoryOrderField defines the ordering field of ControlImplementationHistory.
type ControlImplementationHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlImplementationHistory.
	Value    func(*ControlImplementationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlimplementationhistory.OrderOption
	toCursor func(*ControlImplementationHistory) Cursor
}

// ControlImplementationHistoryOrder defines the ordering of ControlImplementationHistory.
type ControlImplementationHistoryOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *ControlImplementationHistoryOrderField `json:"field"`
}

// DefaultControlImplementationHistoryOrder is the default ordering of ControlImplementationHistory.
var DefaultControlImplementationHistoryOrder = &ControlImplementationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlImplementationHistoryOrderField{
		Value: func(cih *ControlImplementationHistory) (ent.Value, error) {
			return cih.ID, nil
		},
		column: controlimplementationhistory.FieldID,
		toTerm: controlimplementationhistory.ByID,
		toCursor: func(cih *ControlImplementationHistory) Cursor {
			return Cursor{ID: cih.ID}
		},
	},
}

// ToEdge converts ControlImplementationHistory into ControlImplementationHistoryEdge.
func (cih *ControlImplementationHistory) ToEdge(order *ControlImplementationHistoryOrder) *ControlImplementationHistoryEdge {
	if order == nil {
		order = DefaultControlImplementationHistoryOrder
	}
	return &ControlImplementationHistoryEdge{
		Node:   cih,
		Cursor: order.Field.toCursor(cih),
	}
}

// ControlObjectiveEdge is the edge representation of ControlObjective.
type ControlObjectiveEdge struct {
	Node   *ControlObjective `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ControlObjectiveConnection is the connection containing edges to ControlObjective.
type ControlObjectiveConnection struct {
	Edges      []*ControlObjectiveEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ControlObjectiveConnection) build(nodes []*ControlObjective, pager *controlobjectivePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlObjective
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjective {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjective {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectivePaginateOption enables pagination customization.
type ControlObjectivePaginateOption func(*controlobjectivePager) error

// WithControlObjectiveOrder configures pagination ordering.
func WithControlObjectiveOrder(order []*ControlObjectiveOrder) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlObjectiveFilter configures pagination filter.
func WithControlObjectiveFilter(filter func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		if filter == nil {
			return errors.New("ControlObjectiveQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivePager struct {
	reverse bool
	order   []*ControlObjectiveOrder
	filter  func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)
}

func newControlObjectivePager(opts []ControlObjectivePaginateOption, reverse bool) (*controlobjectivePager, error) {
	pager := &controlobjectivePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlobjectivePager) applyFilter(query *ControlObjectiveQuery) (*ControlObjectiveQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivePager) toCursor(co *ControlObjective) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(co).Value)
	}
	return Cursor{ID: co.ID, Value: cs_}
}

func (p *controlobjectivePager) applyCursors(query *ControlObjectiveQuery, after, before *Cursor) (*ControlObjectiveQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlObjectiveOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlobjectivePager) applyOrder(query *ControlObjectiveQuery) *ControlObjectiveQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlObjectiveOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlObjectiveOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlobjectivePager) orderExpr(query *ControlObjectiveQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlObjectiveOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjective.
func (co *ControlObjectiveQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectivePaginateOption,
) (*ControlObjectiveConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectivePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if co, err = pager.applyFilter(co); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveConnection{Edges: []*ControlObjectiveEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := co.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if co, err = pager.applyCursors(co, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		co.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := co.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	co = pager.applyOrder(co)
	nodes, err := co.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlObjectiveOrderFieldCreatedAt orders ControlObjective by created_at.
	ControlObjectiveOrderFieldCreatedAt = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.CreatedAt, nil
		},
		column: controlobjective.FieldCreatedAt,
		toTerm: controlobjective.ByCreatedAt,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.CreatedAt,
			}
		},
	}
	// ControlObjectiveOrderFieldUpdatedAt orders ControlObjective by updated_at.
	ControlObjectiveOrderFieldUpdatedAt = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.UpdatedAt, nil
		},
		column: controlobjective.FieldUpdatedAt,
		toTerm: controlobjective.ByUpdatedAt,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.UpdatedAt,
			}
		},
	}
	// ControlObjectiveOrderFieldRevision orders ControlObjective by revision.
	ControlObjectiveOrderFieldRevision = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.Revision, nil
		},
		column: controlobjective.FieldRevision,
		toTerm: controlobjective.ByRevision,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Revision,
			}
		},
	}
	// ControlObjectiveOrderFieldName orders ControlObjective by name.
	ControlObjectiveOrderFieldName = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.Name, nil
		},
		column: controlobjective.FieldName,
		toTerm: controlobjective.ByName,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Name,
			}
		},
	}
	// ControlObjectiveOrderFieldStatus orders ControlObjective by status.
	ControlObjectiveOrderFieldStatus = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.Status, nil
		},
		column: controlobjective.FieldStatus,
		toTerm: controlobjective.ByStatus,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Status,
			}
		},
	}
	// ControlObjectiveOrderFieldSource orders ControlObjective by source.
	ControlObjectiveOrderFieldSource = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.Source, nil
		},
		column: controlobjective.FieldSource,
		toTerm: controlobjective.BySource,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Source,
			}
		},
	}
	// ControlObjectiveOrderFieldControlObjectiveType orders ControlObjective by control_objective_type.
	ControlObjectiveOrderFieldControlObjectiveType = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.ControlObjectiveType, nil
		},
		column: controlobjective.FieldControlObjectiveType,
		toTerm: controlobjective.ByControlObjectiveType,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.ControlObjectiveType,
			}
		},
	}
	// ControlObjectiveOrderFieldCategory orders ControlObjective by category.
	ControlObjectiveOrderFieldCategory = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.Category, nil
		},
		column: controlobjective.FieldCategory,
		toTerm: controlobjective.ByCategory,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Category,
			}
		},
	}
	// ControlObjectiveOrderFieldSubcategory orders ControlObjective by subcategory.
	ControlObjectiveOrderFieldSubcategory = &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.Subcategory, nil
		},
		column: controlobjective.FieldSubcategory,
		toTerm: controlobjective.BySubcategory,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{
				ID:    co.ID,
				Value: co.Subcategory,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlObjectiveOrderField) String() string {
	var str string
	switch f.column {
	case ControlObjectiveOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlObjectiveOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlObjectiveOrderFieldRevision.column:
		str = "revision"
	case ControlObjectiveOrderFieldName.column:
		str = "name"
	case ControlObjectiveOrderFieldStatus.column:
		str = "status"
	case ControlObjectiveOrderFieldSource.column:
		str = "SOURCE"
	case ControlObjectiveOrderFieldControlObjectiveType.column:
		str = "control_objective_type"
	case ControlObjectiveOrderFieldCategory.column:
		str = "category"
	case ControlObjectiveOrderFieldSubcategory.column:
		str = "subcategory"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlObjectiveOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlObjectiveOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlObjectiveOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlObjectiveOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlObjectiveOrderFieldUpdatedAt
	case "revision":
		*f = *ControlObjectiveOrderFieldRevision
	case "name":
		*f = *ControlObjectiveOrderFieldName
	case "status":
		*f = *ControlObjectiveOrderFieldStatus
	case "SOURCE":
		*f = *ControlObjectiveOrderFieldSource
	case "control_objective_type":
		*f = *ControlObjectiveOrderFieldControlObjectiveType
	case "category":
		*f = *ControlObjectiveOrderFieldCategory
	case "subcategory":
		*f = *ControlObjectiveOrderFieldSubcategory
	default:
		return fmt.Errorf("%s is not a valid ControlObjectiveOrderField", str)
	}
	return nil
}

// ControlObjectiveOrderField defines the ordering field of ControlObjective.
type ControlObjectiveOrderField struct {
	// Value extracts the ordering value from the given ControlObjective.
	Value    func(*ControlObjective) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjective.OrderOption
	toCursor func(*ControlObjective) Cursor
}

// ControlObjectiveOrder defines the ordering of ControlObjective.
type ControlObjectiveOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ControlObjectiveOrderField `json:"field"`
}

// DefaultControlObjectiveOrder is the default ordering of ControlObjective.
var DefaultControlObjectiveOrder = &ControlObjectiveOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.ID, nil
		},
		column: controlobjective.FieldID,
		toTerm: controlobjective.ByID,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{ID: co.ID}
		},
	},
}

// ToEdge converts ControlObjective into ControlObjectiveEdge.
func (co *ControlObjective) ToEdge(order *ControlObjectiveOrder) *ControlObjectiveEdge {
	if order == nil {
		order = DefaultControlObjectiveOrder
	}
	return &ControlObjectiveEdge{
		Node:   co,
		Cursor: order.Field.toCursor(co),
	}
}

// ControlObjectiveHistoryEdge is the edge representation of ControlObjectiveHistory.
type ControlObjectiveHistoryEdge struct {
	Node   *ControlObjectiveHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// ControlObjectiveHistoryConnection is the connection containing edges to ControlObjectiveHistory.
type ControlObjectiveHistoryConnection struct {
	Edges      []*ControlObjectiveHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *ControlObjectiveHistoryConnection) build(nodes []*ControlObjectiveHistory, pager *controlobjectivehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlObjectiveHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectiveHistoryPaginateOption enables pagination customization.
type ControlObjectiveHistoryPaginateOption func(*controlobjectivehistoryPager) error

// WithControlObjectiveHistoryOrder configures pagination ordering.
func WithControlObjectiveHistoryOrder(order *ControlObjectiveHistoryOrder) ControlObjectiveHistoryPaginateOption {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	o := *order
	return func(pager *controlobjectivehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlObjectiveHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlObjectiveHistoryFilter configures pagination filter.
func WithControlObjectiveHistoryFilter(filter func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)) ControlObjectiveHistoryPaginateOption {
	return func(pager *controlobjectivehistoryPager) error {
		if filter == nil {
			return errors.New("ControlObjectiveHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivehistoryPager struct {
	reverse bool
	order   *ControlObjectiveHistoryOrder
	filter  func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)
}

func newControlObjectiveHistoryPager(opts []ControlObjectiveHistoryPaginateOption, reverse bool) (*controlobjectivehistoryPager, error) {
	pager := &controlobjectivehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlObjectiveHistoryOrder
	}
	return pager, nil
}

func (p *controlobjectivehistoryPager) applyFilter(query *ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) toCursor(coh *ControlObjectiveHistory) Cursor {
	return p.order.Field.toCursor(coh)
}

func (p *controlobjectivehistoryPager) applyCursors(query *ControlObjectiveHistoryQuery, after, before *Cursor) (*ControlObjectiveHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlObjectiveHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) applyOrder(query *ControlObjectiveHistoryQuery) *ControlObjectiveHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
		query = query.Order(DefaultControlObjectiveHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlobjectivehistoryPager) orderExpr(query *ControlObjectiveHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
			b.Comma().Ident(DefaultControlObjectiveHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjectiveHistory.
func (coh *ControlObjectiveHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectiveHistoryPaginateOption,
) (*ControlObjectiveHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectiveHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if coh, err = pager.applyFilter(coh); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveHistoryConnection{Edges: []*ControlObjectiveHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := coh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if coh, err = pager.applyCursors(coh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		coh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := coh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	coh = pager.applyOrder(coh)
	nodes, err := coh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlObjectiveHistoryOrderFieldHistoryTime orders ControlObjectiveHistory by history_time.
	ControlObjectiveHistoryOrderFieldHistoryTime = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.HistoryTime, nil
		},
		column: controlobjectivehistory.FieldHistoryTime,
		toTerm: controlobjectivehistory.ByHistoryTime,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.HistoryTime,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldCreatedAt orders ControlObjectiveHistory by created_at.
	ControlObjectiveHistoryOrderFieldCreatedAt = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.CreatedAt, nil
		},
		column: controlobjectivehistory.FieldCreatedAt,
		toTerm: controlobjectivehistory.ByCreatedAt,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.CreatedAt,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldUpdatedAt orders ControlObjectiveHistory by updated_at.
	ControlObjectiveHistoryOrderFieldUpdatedAt = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.UpdatedAt, nil
		},
		column: controlobjectivehistory.FieldUpdatedAt,
		toTerm: controlobjectivehistory.ByUpdatedAt,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.UpdatedAt,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldRevision orders ControlObjectiveHistory by revision.
	ControlObjectiveHistoryOrderFieldRevision = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.Revision, nil
		},
		column: controlobjectivehistory.FieldRevision,
		toTerm: controlobjectivehistory.ByRevision,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.Revision,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldName orders ControlObjectiveHistory by name.
	ControlObjectiveHistoryOrderFieldName = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.Name, nil
		},
		column: controlobjectivehistory.FieldName,
		toTerm: controlobjectivehistory.ByName,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.Name,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldStatus orders ControlObjectiveHistory by status.
	ControlObjectiveHistoryOrderFieldStatus = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.Status, nil
		},
		column: controlobjectivehistory.FieldStatus,
		toTerm: controlobjectivehistory.ByStatus,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.Status,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldSource orders ControlObjectiveHistory by source.
	ControlObjectiveHistoryOrderFieldSource = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.Source, nil
		},
		column: controlobjectivehistory.FieldSource,
		toTerm: controlobjectivehistory.BySource,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.Source,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldControlObjectiveType orders ControlObjectiveHistory by control_objective_type.
	ControlObjectiveHistoryOrderFieldControlObjectiveType = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.ControlObjectiveType, nil
		},
		column: controlobjectivehistory.FieldControlObjectiveType,
		toTerm: controlobjectivehistory.ByControlObjectiveType,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.ControlObjectiveType,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldCategory orders ControlObjectiveHistory by category.
	ControlObjectiveHistoryOrderFieldCategory = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.Category, nil
		},
		column: controlobjectivehistory.FieldCategory,
		toTerm: controlobjectivehistory.ByCategory,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.Category,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldSubcategory orders ControlObjectiveHistory by subcategory.
	ControlObjectiveHistoryOrderFieldSubcategory = &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.Subcategory, nil
		},
		column: controlobjectivehistory.FieldSubcategory,
		toTerm: controlobjectivehistory.BySubcategory,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    coh.ID,
				Value: coh.Subcategory,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlObjectiveHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlObjectiveHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlObjectiveHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlObjectiveHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlObjectiveHistoryOrderFieldRevision.column:
		str = "revision"
	case ControlObjectiveHistoryOrderFieldName.column:
		str = "name"
	case ControlObjectiveHistoryOrderFieldStatus.column:
		str = "status"
	case ControlObjectiveHistoryOrderFieldSource.column:
		str = "SOURCE"
	case ControlObjectiveHistoryOrderFieldControlObjectiveType.column:
		str = "control_objective_type"
	case ControlObjectiveHistoryOrderFieldCategory.column:
		str = "category"
	case ControlObjectiveHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlObjectiveHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlObjectiveHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlObjectiveHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlObjectiveHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlObjectiveHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlObjectiveHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ControlObjectiveHistoryOrderFieldRevision
	case "name":
		*f = *ControlObjectiveHistoryOrderFieldName
	case "status":
		*f = *ControlObjectiveHistoryOrderFieldStatus
	case "SOURCE":
		*f = *ControlObjectiveHistoryOrderFieldSource
	case "control_objective_type":
		*f = *ControlObjectiveHistoryOrderFieldControlObjectiveType
	case "category":
		*f = *ControlObjectiveHistoryOrderFieldCategory
	case "subcategory":
		*f = *ControlObjectiveHistoryOrderFieldSubcategory
	default:
		return fmt.Errorf("%s is not a valid ControlObjectiveHistoryOrderField", str)
	}
	return nil
}

// ControlObjectiveHistoryOrderField defines the ordering field of ControlObjectiveHistory.
type ControlObjectiveHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlObjectiveHistory.
	Value    func(*ControlObjectiveHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjectivehistory.OrderOption
	toCursor func(*ControlObjectiveHistory) Cursor
}

// ControlObjectiveHistoryOrder defines the ordering of ControlObjectiveHistory.
type ControlObjectiveHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *ControlObjectiveHistoryOrderField `json:"field"`
}

// DefaultControlObjectiveHistoryOrder is the default ordering of ControlObjectiveHistory.
var DefaultControlObjectiveHistoryOrder = &ControlObjectiveHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.ID, nil
		},
		column: controlobjectivehistory.FieldID,
		toTerm: controlobjectivehistory.ByID,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{ID: coh.ID}
		},
	},
}

// ToEdge converts ControlObjectiveHistory into ControlObjectiveHistoryEdge.
func (coh *ControlObjectiveHistory) ToEdge(order *ControlObjectiveHistoryOrder) *ControlObjectiveHistoryEdge {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	return &ControlObjectiveHistoryEdge{
		Node:   coh,
		Cursor: order.Field.toCursor(coh),
	}
}

// ControlScheduledJobEdge is the edge representation of ControlScheduledJob.
type ControlScheduledJobEdge struct {
	Node   *ControlScheduledJob `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// ControlScheduledJobConnection is the connection containing edges to ControlScheduledJob.
type ControlScheduledJobConnection struct {
	Edges      []*ControlScheduledJobEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *ControlScheduledJobConnection) build(nodes []*ControlScheduledJob, pager *controlscheduledjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlScheduledJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlScheduledJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlScheduledJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlScheduledJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlScheduledJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlScheduledJobPaginateOption enables pagination customization.
type ControlScheduledJobPaginateOption func(*controlscheduledjobPager) error

// WithControlScheduledJobOrder configures pagination ordering.
func WithControlScheduledJobOrder(order []*ControlScheduledJobOrder) ControlScheduledJobPaginateOption {
	return func(pager *controlscheduledjobPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlScheduledJobFilter configures pagination filter.
func WithControlScheduledJobFilter(filter func(*ControlScheduledJobQuery) (*ControlScheduledJobQuery, error)) ControlScheduledJobPaginateOption {
	return func(pager *controlscheduledjobPager) error {
		if filter == nil {
			return errors.New("ControlScheduledJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlscheduledjobPager struct {
	reverse bool
	order   []*ControlScheduledJobOrder
	filter  func(*ControlScheduledJobQuery) (*ControlScheduledJobQuery, error)
}

func newControlScheduledJobPager(opts []ControlScheduledJobPaginateOption, reverse bool) (*controlscheduledjobPager, error) {
	pager := &controlscheduledjobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlscheduledjobPager) applyFilter(query *ControlScheduledJobQuery) (*ControlScheduledJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlscheduledjobPager) toCursor(csj *ControlScheduledJob) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(csj).Value)
	}
	return Cursor{ID: csj.ID, Value: cs_}
}

func (p *controlscheduledjobPager) applyCursors(query *ControlScheduledJobQuery, after, before *Cursor) (*ControlScheduledJobQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlScheduledJobOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlscheduledjobPager) applyOrder(query *ControlScheduledJobQuery) *ControlScheduledJobQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlScheduledJobOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlScheduledJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlscheduledjobPager) orderExpr(query *ControlScheduledJobQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlScheduledJobOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlScheduledJob.
func (csj *ControlScheduledJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlScheduledJobPaginateOption,
) (*ControlScheduledJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlScheduledJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csj, err = pager.applyFilter(csj); err != nil {
		return nil, err
	}
	conn := &ControlScheduledJobConnection{Edges: []*ControlScheduledJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csj.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csj, err = pager.applyCursors(csj, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csj.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csj.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csj = pager.applyOrder(csj)
	nodes, err := csj.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlScheduledJobOrderFieldCreatedAt orders ControlScheduledJob by created_at.
	ControlScheduledJobOrderFieldCreatedAt = &ControlScheduledJobOrderField{
		Value: func(csj *ControlScheduledJob) (ent.Value, error) {
			return csj.CreatedAt, nil
		},
		column: controlscheduledjob.FieldCreatedAt,
		toTerm: controlscheduledjob.ByCreatedAt,
		toCursor: func(csj *ControlScheduledJob) Cursor {
			return Cursor{
				ID:    csj.ID,
				Value: csj.CreatedAt,
			}
		},
	}
	// ControlScheduledJobOrderFieldUpdatedAt orders ControlScheduledJob by updated_at.
	ControlScheduledJobOrderFieldUpdatedAt = &ControlScheduledJobOrderField{
		Value: func(csj *ControlScheduledJob) (ent.Value, error) {
			return csj.UpdatedAt, nil
		},
		column: controlscheduledjob.FieldUpdatedAt,
		toTerm: controlscheduledjob.ByUpdatedAt,
		toCursor: func(csj *ControlScheduledJob) Cursor {
			return Cursor{
				ID:    csj.ID,
				Value: csj.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlScheduledJobOrderField) String() string {
	var str string
	switch f.column {
	case ControlScheduledJobOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlScheduledJobOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlScheduledJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlScheduledJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlScheduledJobOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlScheduledJobOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlScheduledJobOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ControlScheduledJobOrderField", str)
	}
	return nil
}

// ControlScheduledJobOrderField defines the ordering field of ControlScheduledJob.
type ControlScheduledJobOrderField struct {
	// Value extracts the ordering value from the given ControlScheduledJob.
	Value    func(*ControlScheduledJob) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlscheduledjob.OrderOption
	toCursor func(*ControlScheduledJob) Cursor
}

// ControlScheduledJobOrder defines the ordering of ControlScheduledJob.
type ControlScheduledJobOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *ControlScheduledJobOrderField `json:"field"`
}

// DefaultControlScheduledJobOrder is the default ordering of ControlScheduledJob.
var DefaultControlScheduledJobOrder = &ControlScheduledJobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlScheduledJobOrderField{
		Value: func(csj *ControlScheduledJob) (ent.Value, error) {
			return csj.ID, nil
		},
		column: controlscheduledjob.FieldID,
		toTerm: controlscheduledjob.ByID,
		toCursor: func(csj *ControlScheduledJob) Cursor {
			return Cursor{ID: csj.ID}
		},
	},
}

// ToEdge converts ControlScheduledJob into ControlScheduledJobEdge.
func (csj *ControlScheduledJob) ToEdge(order *ControlScheduledJobOrder) *ControlScheduledJobEdge {
	if order == nil {
		order = DefaultControlScheduledJobOrder
	}
	return &ControlScheduledJobEdge{
		Node:   csj,
		Cursor: order.Field.toCursor(csj),
	}
}

// ControlScheduledJobHistoryEdge is the edge representation of ControlScheduledJobHistory.
type ControlScheduledJobHistoryEdge struct {
	Node   *ControlScheduledJobHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// ControlScheduledJobHistoryConnection is the connection containing edges to ControlScheduledJobHistory.
type ControlScheduledJobHistoryConnection struct {
	Edges      []*ControlScheduledJobHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *ControlScheduledJobHistoryConnection) build(nodes []*ControlScheduledJobHistory, pager *controlscheduledjobhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlScheduledJobHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlScheduledJobHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlScheduledJobHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlScheduledJobHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlScheduledJobHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlScheduledJobHistoryPaginateOption enables pagination customization.
type ControlScheduledJobHistoryPaginateOption func(*controlscheduledjobhistoryPager) error

// WithControlScheduledJobHistoryOrder configures pagination ordering.
func WithControlScheduledJobHistoryOrder(order *ControlScheduledJobHistoryOrder) ControlScheduledJobHistoryPaginateOption {
	if order == nil {
		order = DefaultControlScheduledJobHistoryOrder
	}
	o := *order
	return func(pager *controlscheduledjobhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlScheduledJobHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlScheduledJobHistoryFilter configures pagination filter.
func WithControlScheduledJobHistoryFilter(filter func(*ControlScheduledJobHistoryQuery) (*ControlScheduledJobHistoryQuery, error)) ControlScheduledJobHistoryPaginateOption {
	return func(pager *controlscheduledjobhistoryPager) error {
		if filter == nil {
			return errors.New("ControlScheduledJobHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlscheduledjobhistoryPager struct {
	reverse bool
	order   *ControlScheduledJobHistoryOrder
	filter  func(*ControlScheduledJobHistoryQuery) (*ControlScheduledJobHistoryQuery, error)
}

func newControlScheduledJobHistoryPager(opts []ControlScheduledJobHistoryPaginateOption, reverse bool) (*controlscheduledjobhistoryPager, error) {
	pager := &controlscheduledjobhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlScheduledJobHistoryOrder
	}
	return pager, nil
}

func (p *controlscheduledjobhistoryPager) applyFilter(query *ControlScheduledJobHistoryQuery) (*ControlScheduledJobHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlscheduledjobhistoryPager) toCursor(csjh *ControlScheduledJobHistory) Cursor {
	return p.order.Field.toCursor(csjh)
}

func (p *controlscheduledjobhistoryPager) applyCursors(query *ControlScheduledJobHistoryQuery, after, before *Cursor) (*ControlScheduledJobHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlScheduledJobHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlscheduledjobhistoryPager) applyOrder(query *ControlScheduledJobHistoryQuery) *ControlScheduledJobHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlScheduledJobHistoryOrder.Field {
		query = query.Order(DefaultControlScheduledJobHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlscheduledjobhistoryPager) orderExpr(query *ControlScheduledJobHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlScheduledJobHistoryOrder.Field {
			b.Comma().Ident(DefaultControlScheduledJobHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlScheduledJobHistory.
func (csjh *ControlScheduledJobHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlScheduledJobHistoryPaginateOption,
) (*ControlScheduledJobHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlScheduledJobHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csjh, err = pager.applyFilter(csjh); err != nil {
		return nil, err
	}
	conn := &ControlScheduledJobHistoryConnection{Edges: []*ControlScheduledJobHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csjh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csjh, err = pager.applyCursors(csjh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csjh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csjh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csjh = pager.applyOrder(csjh)
	nodes, err := csjh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlScheduledJobHistoryOrderFieldHistoryTime orders ControlScheduledJobHistory by history_time.
	ControlScheduledJobHistoryOrderFieldHistoryTime = &ControlScheduledJobHistoryOrderField{
		Value: func(csjh *ControlScheduledJobHistory) (ent.Value, error) {
			return csjh.HistoryTime, nil
		},
		column: controlscheduledjobhistory.FieldHistoryTime,
		toTerm: controlscheduledjobhistory.ByHistoryTime,
		toCursor: func(csjh *ControlScheduledJobHistory) Cursor {
			return Cursor{
				ID:    csjh.ID,
				Value: csjh.HistoryTime,
			}
		},
	}
	// ControlScheduledJobHistoryOrderFieldCreatedAt orders ControlScheduledJobHistory by created_at.
	ControlScheduledJobHistoryOrderFieldCreatedAt = &ControlScheduledJobHistoryOrderField{
		Value: func(csjh *ControlScheduledJobHistory) (ent.Value, error) {
			return csjh.CreatedAt, nil
		},
		column: controlscheduledjobhistory.FieldCreatedAt,
		toTerm: controlscheduledjobhistory.ByCreatedAt,
		toCursor: func(csjh *ControlScheduledJobHistory) Cursor {
			return Cursor{
				ID:    csjh.ID,
				Value: csjh.CreatedAt,
			}
		},
	}
	// ControlScheduledJobHistoryOrderFieldUpdatedAt orders ControlScheduledJobHistory by updated_at.
	ControlScheduledJobHistoryOrderFieldUpdatedAt = &ControlScheduledJobHistoryOrderField{
		Value: func(csjh *ControlScheduledJobHistory) (ent.Value, error) {
			return csjh.UpdatedAt, nil
		},
		column: controlscheduledjobhistory.FieldUpdatedAt,
		toTerm: controlscheduledjobhistory.ByUpdatedAt,
		toCursor: func(csjh *ControlScheduledJobHistory) Cursor {
			return Cursor{
				ID:    csjh.ID,
				Value: csjh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlScheduledJobHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlScheduledJobHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlScheduledJobHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlScheduledJobHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlScheduledJobHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlScheduledJobHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlScheduledJobHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlScheduledJobHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlScheduledJobHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlScheduledJobHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ControlScheduledJobHistoryOrderField", str)
	}
	return nil
}

// ControlScheduledJobHistoryOrderField defines the ordering field of ControlScheduledJobHistory.
type ControlScheduledJobHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlScheduledJobHistory.
	Value    func(*ControlScheduledJobHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlscheduledjobhistory.OrderOption
	toCursor func(*ControlScheduledJobHistory) Cursor
}

// ControlScheduledJobHistoryOrder defines the ordering of ControlScheduledJobHistory.
type ControlScheduledJobHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *ControlScheduledJobHistoryOrderField `json:"field"`
}

// DefaultControlScheduledJobHistoryOrder is the default ordering of ControlScheduledJobHistory.
var DefaultControlScheduledJobHistoryOrder = &ControlScheduledJobHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlScheduledJobHistoryOrderField{
		Value: func(csjh *ControlScheduledJobHistory) (ent.Value, error) {
			return csjh.ID, nil
		},
		column: controlscheduledjobhistory.FieldID,
		toTerm: controlscheduledjobhistory.ByID,
		toCursor: func(csjh *ControlScheduledJobHistory) Cursor {
			return Cursor{ID: csjh.ID}
		},
	},
}

// ToEdge converts ControlScheduledJobHistory into ControlScheduledJobHistoryEdge.
func (csjh *ControlScheduledJobHistory) ToEdge(order *ControlScheduledJobHistoryOrder) *ControlScheduledJobHistoryEdge {
	if order == nil {
		order = DefaultControlScheduledJobHistoryOrder
	}
	return &ControlScheduledJobHistoryEdge{
		Node:   csjh,
		Cursor: order.Field.toCursor(csjh),
	}
}

// CustomDomainEdge is the edge representation of CustomDomain.
type CustomDomainEdge struct {
	Node   *CustomDomain `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CustomDomainConnection is the connection containing edges to CustomDomain.
type CustomDomainConnection struct {
	Edges      []*CustomDomainEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CustomDomainConnection) build(nodes []*CustomDomain, pager *customdomainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomDomain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomDomain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomDomain {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomDomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomDomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomDomainPaginateOption enables pagination customization.
type CustomDomainPaginateOption func(*customdomainPager) error

// WithCustomDomainOrder configures pagination ordering.
func WithCustomDomainOrder(order []*CustomDomainOrder) CustomDomainPaginateOption {
	return func(pager *customdomainPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomDomainFilter configures pagination filter.
func WithCustomDomainFilter(filter func(*CustomDomainQuery) (*CustomDomainQuery, error)) CustomDomainPaginateOption {
	return func(pager *customdomainPager) error {
		if filter == nil {
			return errors.New("CustomDomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customdomainPager struct {
	reverse bool
	order   []*CustomDomainOrder
	filter  func(*CustomDomainQuery) (*CustomDomainQuery, error)
}

func newCustomDomainPager(opts []CustomDomainPaginateOption, reverse bool) (*customdomainPager, error) {
	pager := &customdomainPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customdomainPager) applyFilter(query *CustomDomainQuery) (*CustomDomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customdomainPager) toCursor(cd *CustomDomain) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(cd).Value)
	}
	return Cursor{ID: cd.ID, Value: cs_}
}

func (p *customdomainPager) applyCursors(query *CustomDomainQuery, after, before *Cursor) (*CustomDomainQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomDomainOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *customdomainPager) applyOrder(query *CustomDomainQuery) *CustomDomainQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomDomainOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomDomainOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customdomainPager) orderExpr(query *CustomDomainQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomDomainOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomDomain.
func (cd *CustomDomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomDomainPaginateOption,
) (*CustomDomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomDomainPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CustomDomainConnection{Edges: []*CustomDomainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomDomainOrderFieldCreatedAt orders CustomDomain by created_at.
	CustomDomainOrderFieldCreatedAt = &CustomDomainOrderField{
		Value: func(cd *CustomDomain) (ent.Value, error) {
			return cd.CreatedAt, nil
		},
		column: customdomain.FieldCreatedAt,
		toTerm: customdomain.ByCreatedAt,
		toCursor: func(cd *CustomDomain) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.CreatedAt,
			}
		},
	}
	// CustomDomainOrderFieldUpdatedAt orders CustomDomain by updated_at.
	CustomDomainOrderFieldUpdatedAt = &CustomDomainOrderField{
		Value: func(cd *CustomDomain) (ent.Value, error) {
			return cd.UpdatedAt, nil
		},
		column: customdomain.FieldUpdatedAt,
		toTerm: customdomain.ByUpdatedAt,
		toCursor: func(cd *CustomDomain) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.UpdatedAt,
			}
		},
	}
	// CustomDomainOrderFieldCnameRecord orders CustomDomain by cname_record.
	CustomDomainOrderFieldCnameRecord = &CustomDomainOrderField{
		Value: func(cd *CustomDomain) (ent.Value, error) {
			return cd.CnameRecord, nil
		},
		column: customdomain.FieldCnameRecord,
		toTerm: customdomain.ByCnameRecord,
		toCursor: func(cd *CustomDomain) Cursor {
			return Cursor{
				ID:    cd.ID,
				Value: cd.CnameRecord,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomDomainOrderField) String() string {
	var str string
	switch f.column {
	case CustomDomainOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomDomainOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomDomainOrderFieldCnameRecord.column:
		str = "cname_record"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomDomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomDomainOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CustomDomainOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomDomainOrderFieldUpdatedAt
	case "cname_record":
		*f = *CustomDomainOrderFieldCnameRecord
	default:
		return fmt.Errorf("%s is not a valid CustomDomainOrderField", str)
	}
	return nil
}

// CustomDomainOrderField defines the ordering field of CustomDomain.
type CustomDomainOrderField struct {
	// Value extracts the ordering value from the given CustomDomain.
	Value    func(*CustomDomain) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customdomain.OrderOption
	toCursor func(*CustomDomain) Cursor
}

// CustomDomainOrder defines the ordering of CustomDomain.
type CustomDomainOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CustomDomainOrderField `json:"field"`
}

// DefaultCustomDomainOrder is the default ordering of CustomDomain.
var DefaultCustomDomainOrder = &CustomDomainOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomDomainOrderField{
		Value: func(cd *CustomDomain) (ent.Value, error) {
			return cd.ID, nil
		},
		column: customdomain.FieldID,
		toTerm: customdomain.ByID,
		toCursor: func(cd *CustomDomain) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CustomDomain into CustomDomainEdge.
func (cd *CustomDomain) ToEdge(order *CustomDomainOrder) *CustomDomainEdge {
	if order == nil {
		order = DefaultCustomDomainOrder
	}
	return &CustomDomainEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CustomDomainHistoryEdge is the edge representation of CustomDomainHistory.
type CustomDomainHistoryEdge struct {
	Node   *CustomDomainHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// CustomDomainHistoryConnection is the connection containing edges to CustomDomainHistory.
type CustomDomainHistoryConnection struct {
	Edges      []*CustomDomainHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *CustomDomainHistoryConnection) build(nodes []*CustomDomainHistory, pager *customdomainhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomDomainHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomDomainHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomDomainHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomDomainHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomDomainHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomDomainHistoryPaginateOption enables pagination customization.
type CustomDomainHistoryPaginateOption func(*customdomainhistoryPager) error

// WithCustomDomainHistoryOrder configures pagination ordering.
func WithCustomDomainHistoryOrder(order *CustomDomainHistoryOrder) CustomDomainHistoryPaginateOption {
	if order == nil {
		order = DefaultCustomDomainHistoryOrder
	}
	o := *order
	return func(pager *customdomainhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomDomainHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomDomainHistoryFilter configures pagination filter.
func WithCustomDomainHistoryFilter(filter func(*CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error)) CustomDomainHistoryPaginateOption {
	return func(pager *customdomainhistoryPager) error {
		if filter == nil {
			return errors.New("CustomDomainHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customdomainhistoryPager struct {
	reverse bool
	order   *CustomDomainHistoryOrder
	filter  func(*CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error)
}

func newCustomDomainHistoryPager(opts []CustomDomainHistoryPaginateOption, reverse bool) (*customdomainhistoryPager, error) {
	pager := &customdomainhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomDomainHistoryOrder
	}
	return pager, nil
}

func (p *customdomainhistoryPager) applyFilter(query *CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customdomainhistoryPager) toCursor(cdh *CustomDomainHistory) Cursor {
	return p.order.Field.toCursor(cdh)
}

func (p *customdomainhistoryPager) applyCursors(query *CustomDomainHistoryQuery, after, before *Cursor) (*CustomDomainHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCustomDomainHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customdomainhistoryPager) applyOrder(query *CustomDomainHistoryQuery) *CustomDomainHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCustomDomainHistoryOrder.Field {
		query = query.Order(DefaultCustomDomainHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *customdomainhistoryPager) orderExpr(query *CustomDomainHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCustomDomainHistoryOrder.Field {
			b.Comma().Ident(DefaultCustomDomainHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomDomainHistory.
func (cdh *CustomDomainHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomDomainHistoryPaginateOption,
) (*CustomDomainHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomDomainHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cdh, err = pager.applyFilter(cdh); err != nil {
		return nil, err
	}
	conn := &CustomDomainHistoryConnection{Edges: []*CustomDomainHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cdh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cdh, err = pager.applyCursors(cdh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cdh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cdh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cdh = pager.applyOrder(cdh)
	nodes, err := cdh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomDomainHistoryOrderFieldHistoryTime orders CustomDomainHistory by history_time.
	CustomDomainHistoryOrderFieldHistoryTime = &CustomDomainHistoryOrderField{
		Value: func(cdh *CustomDomainHistory) (ent.Value, error) {
			return cdh.HistoryTime, nil
		},
		column: customdomainhistory.FieldHistoryTime,
		toTerm: customdomainhistory.ByHistoryTime,
		toCursor: func(cdh *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    cdh.ID,
				Value: cdh.HistoryTime,
			}
		},
	}
	// CustomDomainHistoryOrderFieldCreatedAt orders CustomDomainHistory by created_at.
	CustomDomainHistoryOrderFieldCreatedAt = &CustomDomainHistoryOrderField{
		Value: func(cdh *CustomDomainHistory) (ent.Value, error) {
			return cdh.CreatedAt, nil
		},
		column: customdomainhistory.FieldCreatedAt,
		toTerm: customdomainhistory.ByCreatedAt,
		toCursor: func(cdh *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    cdh.ID,
				Value: cdh.CreatedAt,
			}
		},
	}
	// CustomDomainHistoryOrderFieldUpdatedAt orders CustomDomainHistory by updated_at.
	CustomDomainHistoryOrderFieldUpdatedAt = &CustomDomainHistoryOrderField{
		Value: func(cdh *CustomDomainHistory) (ent.Value, error) {
			return cdh.UpdatedAt, nil
		},
		column: customdomainhistory.FieldUpdatedAt,
		toTerm: customdomainhistory.ByUpdatedAt,
		toCursor: func(cdh *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    cdh.ID,
				Value: cdh.UpdatedAt,
			}
		},
	}
	// CustomDomainHistoryOrderFieldCnameRecord orders CustomDomainHistory by cname_record.
	CustomDomainHistoryOrderFieldCnameRecord = &CustomDomainHistoryOrderField{
		Value: func(cdh *CustomDomainHistory) (ent.Value, error) {
			return cdh.CnameRecord, nil
		},
		column: customdomainhistory.FieldCnameRecord,
		toTerm: customdomainhistory.ByCnameRecord,
		toCursor: func(cdh *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    cdh.ID,
				Value: cdh.CnameRecord,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomDomainHistoryOrderField) String() string {
	var str string
	switch f.column {
	case CustomDomainHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case CustomDomainHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomDomainHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomDomainHistoryOrderFieldCnameRecord.column:
		str = "cname_record"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomDomainHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomDomainHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *CustomDomainHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *CustomDomainHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomDomainHistoryOrderFieldUpdatedAt
	case "cname_record":
		*f = *CustomDomainHistoryOrderFieldCnameRecord
	default:
		return fmt.Errorf("%s is not a valid CustomDomainHistoryOrderField", str)
	}
	return nil
}

// CustomDomainHistoryOrderField defines the ordering field of CustomDomainHistory.
type CustomDomainHistoryOrderField struct {
	// Value extracts the ordering value from the given CustomDomainHistory.
	Value    func(*CustomDomainHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customdomainhistory.OrderOption
	toCursor func(*CustomDomainHistory) Cursor
}

// CustomDomainHistoryOrder defines the ordering of CustomDomainHistory.
type CustomDomainHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *CustomDomainHistoryOrderField `json:"field"`
}

// DefaultCustomDomainHistoryOrder is the default ordering of CustomDomainHistory.
var DefaultCustomDomainHistoryOrder = &CustomDomainHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomDomainHistoryOrderField{
		Value: func(cdh *CustomDomainHistory) (ent.Value, error) {
			return cdh.ID, nil
		},
		column: customdomainhistory.FieldID,
		toTerm: customdomainhistory.ByID,
		toCursor: func(cdh *CustomDomainHistory) Cursor {
			return Cursor{ID: cdh.ID}
		},
	},
}

// ToEdge converts CustomDomainHistory into CustomDomainHistoryEdge.
func (cdh *CustomDomainHistory) ToEdge(order *CustomDomainHistoryOrder) *CustomDomainHistoryEdge {
	if order == nil {
		order = DefaultCustomDomainHistoryOrder
	}
	return &CustomDomainHistoryEdge{
		Node:   cdh,
		Cursor: order.Field.toCursor(cdh),
	}
}

// DNSVerificationEdge is the edge representation of DNSVerification.
type DNSVerificationEdge struct {
	Node   *DNSVerification `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// DNSVerificationConnection is the connection containing edges to DNSVerification.
type DNSVerificationConnection struct {
	Edges      []*DNSVerificationEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *DNSVerificationConnection) build(nodes []*DNSVerification, pager *dnsverificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DNSVerification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSVerification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSVerification {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSVerificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSVerificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSVerificationPaginateOption enables pagination customization.
type DNSVerificationPaginateOption func(*dnsverificationPager) error

// WithDNSVerificationOrder configures pagination ordering.
func WithDNSVerificationOrder(order []*DNSVerificationOrder) DNSVerificationPaginateOption {
	return func(pager *dnsverificationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDNSVerificationFilter configures pagination filter.
func WithDNSVerificationFilter(filter func(*DNSVerificationQuery) (*DNSVerificationQuery, error)) DNSVerificationPaginateOption {
	return func(pager *dnsverificationPager) error {
		if filter == nil {
			return errors.New("DNSVerificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsverificationPager struct {
	reverse bool
	order   []*DNSVerificationOrder
	filter  func(*DNSVerificationQuery) (*DNSVerificationQuery, error)
}

func newDNSVerificationPager(opts []DNSVerificationPaginateOption, reverse bool) (*dnsverificationPager, error) {
	pager := &dnsverificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *dnsverificationPager) applyFilter(query *DNSVerificationQuery) (*DNSVerificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsverificationPager) toCursor(dv *DNSVerification) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(dv).Value)
	}
	return Cursor{ID: dv.ID, Value: cs_}
}

func (p *dnsverificationPager) applyCursors(query *DNSVerificationQuery, after, before *Cursor) (*DNSVerificationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDNSVerificationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *dnsverificationPager) applyOrder(query *DNSVerificationQuery) *DNSVerificationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDNSVerificationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDNSVerificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *dnsverificationPager) orderExpr(query *DNSVerificationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDNSVerificationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSVerification.
func (dv *DNSVerificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSVerificationPaginateOption,
) (*DNSVerificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSVerificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dv, err = pager.applyFilter(dv); err != nil {
		return nil, err
	}
	conn := &DNSVerificationConnection{Edges: []*DNSVerificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dv.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dv, err = pager.applyCursors(dv, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dv.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dv = pager.applyOrder(dv)
	nodes, err := dv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DNSVerificationOrderFieldCreatedAt orders DNSVerification by created_at.
	DNSVerificationOrderFieldCreatedAt = &DNSVerificationOrderField{
		Value: func(dv *DNSVerification) (ent.Value, error) {
			return dv.CreatedAt, nil
		},
		column: dnsverification.FieldCreatedAt,
		toTerm: dnsverification.ByCreatedAt,
		toCursor: func(dv *DNSVerification) Cursor {
			return Cursor{
				ID:    dv.ID,
				Value: dv.CreatedAt,
			}
		},
	}
	// DNSVerificationOrderFieldUpdatedAt orders DNSVerification by updated_at.
	DNSVerificationOrderFieldUpdatedAt = &DNSVerificationOrderField{
		Value: func(dv *DNSVerification) (ent.Value, error) {
			return dv.UpdatedAt, nil
		},
		column: dnsverification.FieldUpdatedAt,
		toTerm: dnsverification.ByUpdatedAt,
		toCursor: func(dv *DNSVerification) Cursor {
			return Cursor{
				ID:    dv.ID,
				Value: dv.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DNSVerificationOrderField) String() string {
	var str string
	switch f.column {
	case DNSVerificationOrderFieldCreatedAt.column:
		str = "created_at"
	case DNSVerificationOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DNSVerificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DNSVerificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DNSVerificationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DNSVerificationOrderFieldCreatedAt
	case "updated_at":
		*f = *DNSVerificationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DNSVerificationOrderField", str)
	}
	return nil
}

// DNSVerificationOrderField defines the ordering field of DNSVerification.
type DNSVerificationOrderField struct {
	// Value extracts the ordering value from the given DNSVerification.
	Value    func(*DNSVerification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsverification.OrderOption
	toCursor func(*DNSVerification) Cursor
}

// DNSVerificationOrder defines the ordering of DNSVerification.
type DNSVerificationOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *DNSVerificationOrderField `json:"field"`
}

// DefaultDNSVerificationOrder is the default ordering of DNSVerification.
var DefaultDNSVerificationOrder = &DNSVerificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSVerificationOrderField{
		Value: func(dv *DNSVerification) (ent.Value, error) {
			return dv.ID, nil
		},
		column: dnsverification.FieldID,
		toTerm: dnsverification.ByID,
		toCursor: func(dv *DNSVerification) Cursor {
			return Cursor{ID: dv.ID}
		},
	},
}

// ToEdge converts DNSVerification into DNSVerificationEdge.
func (dv *DNSVerification) ToEdge(order *DNSVerificationOrder) *DNSVerificationEdge {
	if order == nil {
		order = DefaultDNSVerificationOrder
	}
	return &DNSVerificationEdge{
		Node:   dv,
		Cursor: order.Field.toCursor(dv),
	}
}

// DNSVerificationHistoryEdge is the edge representation of DNSVerificationHistory.
type DNSVerificationHistoryEdge struct {
	Node   *DNSVerificationHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// DNSVerificationHistoryConnection is the connection containing edges to DNSVerificationHistory.
type DNSVerificationHistoryConnection struct {
	Edges      []*DNSVerificationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *DNSVerificationHistoryConnection) build(nodes []*DNSVerificationHistory, pager *dnsverificationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DNSVerificationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSVerificationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSVerificationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSVerificationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSVerificationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSVerificationHistoryPaginateOption enables pagination customization.
type DNSVerificationHistoryPaginateOption func(*dnsverificationhistoryPager) error

// WithDNSVerificationHistoryOrder configures pagination ordering.
func WithDNSVerificationHistoryOrder(order *DNSVerificationHistoryOrder) DNSVerificationHistoryPaginateOption {
	if order == nil {
		order = DefaultDNSVerificationHistoryOrder
	}
	o := *order
	return func(pager *dnsverificationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSVerificationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSVerificationHistoryFilter configures pagination filter.
func WithDNSVerificationHistoryFilter(filter func(*DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error)) DNSVerificationHistoryPaginateOption {
	return func(pager *dnsverificationhistoryPager) error {
		if filter == nil {
			return errors.New("DNSVerificationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsverificationhistoryPager struct {
	reverse bool
	order   *DNSVerificationHistoryOrder
	filter  func(*DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error)
}

func newDNSVerificationHistoryPager(opts []DNSVerificationHistoryPaginateOption, reverse bool) (*dnsverificationhistoryPager, error) {
	pager := &dnsverificationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSVerificationHistoryOrder
	}
	return pager, nil
}

func (p *dnsverificationhistoryPager) applyFilter(query *DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsverificationhistoryPager) toCursor(dvh *DNSVerificationHistory) Cursor {
	return p.order.Field.toCursor(dvh)
}

func (p *dnsverificationhistoryPager) applyCursors(query *DNSVerificationHistoryQuery, after, before *Cursor) (*DNSVerificationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDNSVerificationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dnsverificationhistoryPager) applyOrder(query *DNSVerificationHistoryQuery) *DNSVerificationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDNSVerificationHistoryOrder.Field {
		query = query.Order(DefaultDNSVerificationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dnsverificationhistoryPager) orderExpr(query *DNSVerificationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDNSVerificationHistoryOrder.Field {
			b.Comma().Ident(DefaultDNSVerificationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSVerificationHistory.
func (dvh *DNSVerificationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSVerificationHistoryPaginateOption,
) (*DNSVerificationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSVerificationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dvh, err = pager.applyFilter(dvh); err != nil {
		return nil, err
	}
	conn := &DNSVerificationHistoryConnection{Edges: []*DNSVerificationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dvh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dvh, err = pager.applyCursors(dvh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dvh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dvh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dvh = pager.applyOrder(dvh)
	nodes, err := dvh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DNSVerificationHistoryOrderFieldHistoryTime orders DNSVerificationHistory by history_time.
	DNSVerificationHistoryOrderFieldHistoryTime = &DNSVerificationHistoryOrderField{
		Value: func(dvh *DNSVerificationHistory) (ent.Value, error) {
			return dvh.HistoryTime, nil
		},
		column: dnsverificationhistory.FieldHistoryTime,
		toTerm: dnsverificationhistory.ByHistoryTime,
		toCursor: func(dvh *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    dvh.ID,
				Value: dvh.HistoryTime,
			}
		},
	}
	// DNSVerificationHistoryOrderFieldCreatedAt orders DNSVerificationHistory by created_at.
	DNSVerificationHistoryOrderFieldCreatedAt = &DNSVerificationHistoryOrderField{
		Value: func(dvh *DNSVerificationHistory) (ent.Value, error) {
			return dvh.CreatedAt, nil
		},
		column: dnsverificationhistory.FieldCreatedAt,
		toTerm: dnsverificationhistory.ByCreatedAt,
		toCursor: func(dvh *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    dvh.ID,
				Value: dvh.CreatedAt,
			}
		},
	}
	// DNSVerificationHistoryOrderFieldUpdatedAt orders DNSVerificationHistory by updated_at.
	DNSVerificationHistoryOrderFieldUpdatedAt = &DNSVerificationHistoryOrderField{
		Value: func(dvh *DNSVerificationHistory) (ent.Value, error) {
			return dvh.UpdatedAt, nil
		},
		column: dnsverificationhistory.FieldUpdatedAt,
		toTerm: dnsverificationhistory.ByUpdatedAt,
		toCursor: func(dvh *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    dvh.ID,
				Value: dvh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DNSVerificationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DNSVerificationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DNSVerificationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DNSVerificationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DNSVerificationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DNSVerificationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DNSVerificationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DNSVerificationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DNSVerificationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DNSVerificationHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DNSVerificationHistoryOrderField", str)
	}
	return nil
}

// DNSVerificationHistoryOrderField defines the ordering field of DNSVerificationHistory.
type DNSVerificationHistoryOrderField struct {
	// Value extracts the ordering value from the given DNSVerificationHistory.
	Value    func(*DNSVerificationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsverificationhistory.OrderOption
	toCursor func(*DNSVerificationHistory) Cursor
}

// DNSVerificationHistoryOrder defines the ordering of DNSVerificationHistory.
type DNSVerificationHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *DNSVerificationHistoryOrderField `json:"field"`
}

// DefaultDNSVerificationHistoryOrder is the default ordering of DNSVerificationHistory.
var DefaultDNSVerificationHistoryOrder = &DNSVerificationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSVerificationHistoryOrderField{
		Value: func(dvh *DNSVerificationHistory) (ent.Value, error) {
			return dvh.ID, nil
		},
		column: dnsverificationhistory.FieldID,
		toTerm: dnsverificationhistory.ByID,
		toCursor: func(dvh *DNSVerificationHistory) Cursor {
			return Cursor{ID: dvh.ID}
		},
	},
}

// ToEdge converts DNSVerificationHistory into DNSVerificationHistoryEdge.
func (dvh *DNSVerificationHistory) ToEdge(order *DNSVerificationHistoryOrder) *DNSVerificationHistoryEdge {
	if order == nil {
		order = DefaultDNSVerificationHistoryOrder
	}
	return &DNSVerificationHistoryEdge{
		Node:   dvh,
		Cursor: order.Field.toCursor(dvh),
	}
}

// DocumentDataEdge is the edge representation of DocumentData.
type DocumentDataEdge struct {
	Node   *DocumentData `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// DocumentDataConnection is the connection containing edges to DocumentData.
type DocumentDataConnection struct {
	Edges      []*DocumentDataEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *DocumentDataConnection) build(nodes []*DocumentData, pager *documentdataPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DocumentData
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentData {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentData {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataPaginateOption enables pagination customization.
type DocumentDataPaginateOption func(*documentdataPager) error

// WithDocumentDataOrder configures pagination ordering.
func WithDocumentDataOrder(order []*DocumentDataOrder) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDocumentDataFilter configures pagination filter.
func WithDocumentDataFilter(filter func(*DocumentDataQuery) (*DocumentDataQuery, error)) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		if filter == nil {
			return errors.New("DocumentDataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdataPager struct {
	reverse bool
	order   []*DocumentDataOrder
	filter  func(*DocumentDataQuery) (*DocumentDataQuery, error)
}

func newDocumentDataPager(opts []DocumentDataPaginateOption, reverse bool) (*documentdataPager, error) {
	pager := &documentdataPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *documentdataPager) applyFilter(query *DocumentDataQuery) (*DocumentDataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdataPager) toCursor(dd *DocumentData) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(dd).Value)
	}
	return Cursor{ID: dd.ID, Value: cs_}
}

func (p *documentdataPager) applyCursors(query *DocumentDataQuery, after, before *Cursor) (*DocumentDataQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDocumentDataOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *documentdataPager) applyOrder(query *DocumentDataQuery) *DocumentDataQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDocumentDataOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDocumentDataOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *documentdataPager) orderExpr(query *DocumentDataQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDocumentDataOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentData.
func (dd *DocumentDataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataPaginateOption,
) (*DocumentDataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dd, err = pager.applyFilter(dd); err != nil {
		return nil, err
	}
	conn := &DocumentDataConnection{Edges: []*DocumentDataEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dd, err = pager.applyCursors(dd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dd = pager.applyOrder(dd)
	nodes, err := dd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentDataOrderFieldCreatedAt orders DocumentData by created_at.
	DocumentDataOrderFieldCreatedAt = &DocumentDataOrderField{
		Value: func(dd *DocumentData) (ent.Value, error) {
			return dd.CreatedAt, nil
		},
		column: documentdata.FieldCreatedAt,
		toTerm: documentdata.ByCreatedAt,
		toCursor: func(dd *DocumentData) Cursor {
			return Cursor{
				ID:    dd.ID,
				Value: dd.CreatedAt,
			}
		},
	}
	// DocumentDataOrderFieldUpdatedAt orders DocumentData by updated_at.
	DocumentDataOrderFieldUpdatedAt = &DocumentDataOrderField{
		Value: func(dd *DocumentData) (ent.Value, error) {
			return dd.UpdatedAt, nil
		},
		column: documentdata.FieldUpdatedAt,
		toTerm: documentdata.ByUpdatedAt,
		toCursor: func(dd *DocumentData) Cursor {
			return Cursor{
				ID:    dd.ID,
				Value: dd.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentDataOrderField) String() string {
	var str string
	switch f.column {
	case DocumentDataOrderFieldCreatedAt.column:
		str = "created_at"
	case DocumentDataOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentDataOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentDataOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentDataOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DocumentDataOrderFieldCreatedAt
	case "updated_at":
		*f = *DocumentDataOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentDataOrderField", str)
	}
	return nil
}

// DocumentDataOrderField defines the ordering field of DocumentData.
type DocumentDataOrderField struct {
	// Value extracts the ordering value from the given DocumentData.
	Value    func(*DocumentData) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdata.OrderOption
	toCursor func(*DocumentData) Cursor
}

// DocumentDataOrder defines the ordering of DocumentData.
type DocumentDataOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *DocumentDataOrderField `json:"field"`
}

// DefaultDocumentDataOrder is the default ordering of DocumentData.
var DefaultDocumentDataOrder = &DocumentDataOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataOrderField{
		Value: func(dd *DocumentData) (ent.Value, error) {
			return dd.ID, nil
		},
		column: documentdata.FieldID,
		toTerm: documentdata.ByID,
		toCursor: func(dd *DocumentData) Cursor {
			return Cursor{ID: dd.ID}
		},
	},
}

// ToEdge converts DocumentData into DocumentDataEdge.
func (dd *DocumentData) ToEdge(order *DocumentDataOrder) *DocumentDataEdge {
	if order == nil {
		order = DefaultDocumentDataOrder
	}
	return &DocumentDataEdge{
		Node:   dd,
		Cursor: order.Field.toCursor(dd),
	}
}

// DocumentDataHistoryEdge is the edge representation of DocumentDataHistory.
type DocumentDataHistoryEdge struct {
	Node   *DocumentDataHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DocumentDataHistoryConnection is the connection containing edges to DocumentDataHistory.
type DocumentDataHistoryConnection struct {
	Edges      []*DocumentDataHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DocumentDataHistoryConnection) build(nodes []*DocumentDataHistory, pager *documentdatahistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DocumentDataHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataHistoryPaginateOption enables pagination customization.
type DocumentDataHistoryPaginateOption func(*documentdatahistoryPager) error

// WithDocumentDataHistoryOrder configures pagination ordering.
func WithDocumentDataHistoryOrder(order *DocumentDataHistoryOrder) DocumentDataHistoryPaginateOption {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	o := *order
	return func(pager *documentdatahistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentDataHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentDataHistoryFilter configures pagination filter.
func WithDocumentDataHistoryFilter(filter func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)) DocumentDataHistoryPaginateOption {
	return func(pager *documentdatahistoryPager) error {
		if filter == nil {
			return errors.New("DocumentDataHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdatahistoryPager struct {
	reverse bool
	order   *DocumentDataHistoryOrder
	filter  func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)
}

func newDocumentDataHistoryPager(opts []DocumentDataHistoryPaginateOption, reverse bool) (*documentdatahistoryPager, error) {
	pager := &documentdatahistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentDataHistoryOrder
	}
	return pager, nil
}

func (p *documentdatahistoryPager) applyFilter(query *DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdatahistoryPager) toCursor(ddh *DocumentDataHistory) Cursor {
	return p.order.Field.toCursor(ddh)
}

func (p *documentdatahistoryPager) applyCursors(query *DocumentDataHistoryQuery, after, before *Cursor) (*DocumentDataHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentDataHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentdatahistoryPager) applyOrder(query *DocumentDataHistoryQuery) *DocumentDataHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
		query = query.Order(DefaultDocumentDataHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentdatahistoryPager) orderExpr(query *DocumentDataHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
			b.Comma().Ident(DefaultDocumentDataHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentDataHistory.
func (ddh *DocumentDataHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataHistoryPaginateOption,
) (*DocumentDataHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ddh, err = pager.applyFilter(ddh); err != nil {
		return nil, err
	}
	conn := &DocumentDataHistoryConnection{Edges: []*DocumentDataHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ddh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ddh, err = pager.applyCursors(ddh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ddh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ddh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ddh = pager.applyOrder(ddh)
	nodes, err := ddh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentDataHistoryOrderFieldHistoryTime orders DocumentDataHistory by history_time.
	DocumentDataHistoryOrderFieldHistoryTime = &DocumentDataHistoryOrderField{
		Value: func(ddh *DocumentDataHistory) (ent.Value, error) {
			return ddh.HistoryTime, nil
		},
		column: documentdatahistory.FieldHistoryTime,
		toTerm: documentdatahistory.ByHistoryTime,
		toCursor: func(ddh *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    ddh.ID,
				Value: ddh.HistoryTime,
			}
		},
	}
	// DocumentDataHistoryOrderFieldCreatedAt orders DocumentDataHistory by created_at.
	DocumentDataHistoryOrderFieldCreatedAt = &DocumentDataHistoryOrderField{
		Value: func(ddh *DocumentDataHistory) (ent.Value, error) {
			return ddh.CreatedAt, nil
		},
		column: documentdatahistory.FieldCreatedAt,
		toTerm: documentdatahistory.ByCreatedAt,
		toCursor: func(ddh *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    ddh.ID,
				Value: ddh.CreatedAt,
			}
		},
	}
	// DocumentDataHistoryOrderFieldUpdatedAt orders DocumentDataHistory by updated_at.
	DocumentDataHistoryOrderFieldUpdatedAt = &DocumentDataHistoryOrderField{
		Value: func(ddh *DocumentDataHistory) (ent.Value, error) {
			return ddh.UpdatedAt, nil
		},
		column: documentdatahistory.FieldUpdatedAt,
		toTerm: documentdatahistory.ByUpdatedAt,
		toCursor: func(ddh *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    ddh.ID,
				Value: ddh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentDataHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DocumentDataHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DocumentDataHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DocumentDataHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentDataHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentDataHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentDataHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DocumentDataHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DocumentDataHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DocumentDataHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentDataHistoryOrderField", str)
	}
	return nil
}

// DocumentDataHistoryOrderField defines the ordering field of DocumentDataHistory.
type DocumentDataHistoryOrderField struct {
	// Value extracts the ordering value from the given DocumentDataHistory.
	Value    func(*DocumentDataHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdatahistory.OrderOption
	toCursor func(*DocumentDataHistory) Cursor
}

// DocumentDataHistoryOrder defines the ordering of DocumentDataHistory.
type DocumentDataHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DocumentDataHistoryOrderField `json:"field"`
}

// DefaultDocumentDataHistoryOrder is the default ordering of DocumentDataHistory.
var DefaultDocumentDataHistoryOrder = &DocumentDataHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataHistoryOrderField{
		Value: func(ddh *DocumentDataHistory) (ent.Value, error) {
			return ddh.ID, nil
		},
		column: documentdatahistory.FieldID,
		toTerm: documentdatahistory.ByID,
		toCursor: func(ddh *DocumentDataHistory) Cursor {
			return Cursor{ID: ddh.ID}
		},
	},
}

// ToEdge converts DocumentDataHistory into DocumentDataHistoryEdge.
func (ddh *DocumentDataHistory) ToEdge(order *DocumentDataHistoryOrder) *DocumentDataHistoryEdge {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	return &DocumentDataHistoryEdge{
		Node:   ddh,
		Cursor: order.Field.toCursor(ddh),
	}
}

// EntityEdge is the edge representation of Entity.
type EntityEdge struct {
	Node   *Entity `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EntityConnection is the connection containing edges to Entity.
type EntityConnection struct {
	Edges      []*EntityEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *EntityConnection) build(nodes []*Entity, pager *entityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Entity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Entity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Entity {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityPaginateOption enables pagination customization.
type EntityPaginateOption func(*entityPager) error

// WithEntityOrder configures pagination ordering.
func WithEntityOrder(order []*EntityOrder) EntityPaginateOption {
	return func(pager *entityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEntityFilter configures pagination filter.
func WithEntityFilter(filter func(*EntityQuery) (*EntityQuery, error)) EntityPaginateOption {
	return func(pager *entityPager) error {
		if filter == nil {
			return errors.New("EntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityPager struct {
	reverse bool
	order   []*EntityOrder
	filter  func(*EntityQuery) (*EntityQuery, error)
}

func newEntityPager(opts []EntityPaginateOption, reverse bool) (*entityPager, error) {
	pager := &entityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *entityPager) applyFilter(query *EntityQuery) (*EntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityPager) toCursor(e *Entity) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(e).Value)
	}
	return Cursor{ID: e.ID, Value: cs_}
}

func (p *entityPager) applyCursors(query *EntityQuery, after, before *Cursor) (*EntityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEntityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *entityPager) applyOrder(query *EntityQuery) *EntityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEntityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *entityPager) orderExpr(query *EntityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEntityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Entity.
func (e *EntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityPaginateOption,
) (*EntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EntityConnection{Edges: []*EntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityOrderFieldCreatedAt orders Entity by created_at.
	EntityOrderFieldCreatedAt = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.CreatedAt, nil
		},
		column: entity.FieldCreatedAt,
		toTerm: entity.ByCreatedAt,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EntityOrderFieldUpdatedAt orders Entity by updated_at.
	EntityOrderFieldUpdatedAt = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.UpdatedAt, nil
		},
		column: entity.FieldUpdatedAt,
		toTerm: entity.ByUpdatedAt,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
	// EntityOrderFieldName orders Entity by name.
	EntityOrderFieldName = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.Name, nil
		},
		column: entity.FieldName,
		toTerm: entity.ByName,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Name,
			}
		},
	}
	// EntityOrderFieldDisplayName orders Entity by display_name.
	EntityOrderFieldDisplayName = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.DisplayName, nil
		},
		column: entity.FieldDisplayName,
		toTerm: entity.ByDisplayName,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.DisplayName,
			}
		},
	}
	// EntityOrderFieldStatus orders Entity by status.
	EntityOrderFieldStatus = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.Status, nil
		},
		column: entity.FieldStatus,
		toTerm: entity.ByStatus,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityOrderField) String() string {
	var str string
	switch f.column {
	case EntityOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityOrderFieldName.column:
		str = "name"
	case EntityOrderFieldDisplayName.column:
		str = "display_name"
	case EntityOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityOrderFieldUpdatedAt
	case "name":
		*f = *EntityOrderFieldName
	case "display_name":
		*f = *EntityOrderFieldDisplayName
	case "status":
		*f = *EntityOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

// EntityOrderField defines the ordering field of Entity.
type EntityOrderField struct {
	// Value extracts the ordering value from the given Entity.
	Value    func(*Entity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entity.OrderOption
	toCursor func(*Entity) Cursor
}

// EntityOrder defines the ordering of Entity.
type EntityOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EntityOrderField `json:"field"`
}

// DefaultEntityOrder is the default ordering of Entity.
var DefaultEntityOrder = &EntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.ID, nil
		},
		column: entity.FieldID,
		toTerm: entity.ByID,
		toCursor: func(e *Entity) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Entity into EntityEdge.
func (e *Entity) ToEdge(order *EntityOrder) *EntityEdge {
	if order == nil {
		order = DefaultEntityOrder
	}
	return &EntityEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EntityHistoryEdge is the edge representation of EntityHistory.
type EntityHistoryEdge struct {
	Node   *EntityHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EntityHistoryConnection is the connection containing edges to EntityHistory.
type EntityHistoryConnection struct {
	Edges      []*EntityHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EntityHistoryConnection) build(nodes []*EntityHistory, pager *entityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityHistoryPaginateOption enables pagination customization.
type EntityHistoryPaginateOption func(*entityhistoryPager) error

// WithEntityHistoryOrder configures pagination ordering.
func WithEntityHistoryOrder(order *EntityHistoryOrder) EntityHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	o := *order
	return func(pager *entityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityHistoryFilter configures pagination filter.
func WithEntityHistoryFilter(filter func(*EntityHistoryQuery) (*EntityHistoryQuery, error)) EntityHistoryPaginateOption {
	return func(pager *entityhistoryPager) error {
		if filter == nil {
			return errors.New("EntityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityhistoryPager struct {
	reverse bool
	order   *EntityHistoryOrder
	filter  func(*EntityHistoryQuery) (*EntityHistoryQuery, error)
}

func newEntityHistoryPager(opts []EntityHistoryPaginateOption, reverse bool) (*entityhistoryPager, error) {
	pager := &entityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityHistoryOrder
	}
	return pager, nil
}

func (p *entityhistoryPager) applyFilter(query *EntityHistoryQuery) (*EntityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityhistoryPager) toCursor(eh *EntityHistory) Cursor {
	return p.order.Field.toCursor(eh)
}

func (p *entityhistoryPager) applyCursors(query *EntityHistoryQuery, after, before *Cursor) (*EntityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entityhistoryPager) applyOrder(query *EntityHistoryQuery) *EntityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityHistoryOrder.Field {
		query = query.Order(DefaultEntityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entityhistoryPager) orderExpr(query *EntityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityHistory.
func (eh *EntityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityHistoryPaginateOption,
) (*EntityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eh, err = pager.applyFilter(eh); err != nil {
		return nil, err
	}
	conn := &EntityHistoryConnection{Edges: []*EntityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eh, err = pager.applyCursors(eh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eh = pager.applyOrder(eh)
	nodes, err := eh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityHistoryOrderFieldHistoryTime orders EntityHistory by history_time.
	EntityHistoryOrderFieldHistoryTime = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.HistoryTime, nil
		},
		column: entityhistory.FieldHistoryTime,
		toTerm: entityhistory.ByHistoryTime,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.HistoryTime,
			}
		},
	}
	// EntityHistoryOrderFieldCreatedAt orders EntityHistory by created_at.
	EntityHistoryOrderFieldCreatedAt = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.CreatedAt, nil
		},
		column: entityhistory.FieldCreatedAt,
		toTerm: entityhistory.ByCreatedAt,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.CreatedAt,
			}
		},
	}
	// EntityHistoryOrderFieldUpdatedAt orders EntityHistory by updated_at.
	EntityHistoryOrderFieldUpdatedAt = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.UpdatedAt, nil
		},
		column: entityhistory.FieldUpdatedAt,
		toTerm: entityhistory.ByUpdatedAt,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.UpdatedAt,
			}
		},
	}
	// EntityHistoryOrderFieldName orders EntityHistory by name.
	EntityHistoryOrderFieldName = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.Name, nil
		},
		column: entityhistory.FieldName,
		toTerm: entityhistory.ByName,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.Name,
			}
		},
	}
	// EntityHistoryOrderFieldDisplayName orders EntityHistory by display_name.
	EntityHistoryOrderFieldDisplayName = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.DisplayName, nil
		},
		column: entityhistory.FieldDisplayName,
		toTerm: entityhistory.ByDisplayName,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.DisplayName,
			}
		},
	}
	// EntityHistoryOrderFieldStatus orders EntityHistory by status.
	EntityHistoryOrderFieldStatus = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.Status, nil
		},
		column: entityhistory.FieldStatus,
		toTerm: entityhistory.ByStatus,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EntityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityHistoryOrderFieldName.column:
		str = "name"
	case EntityHistoryOrderFieldDisplayName.column:
		str = "display_name"
	case EntityHistoryOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EntityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EntityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EntityHistoryOrderFieldName
	case "display_name":
		*f = *EntityHistoryOrderFieldDisplayName
	case "status":
		*f = *EntityHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

// EntityHistoryOrderField defines the ordering field of EntityHistory.
type EntityHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityHistory.
	Value    func(*EntityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entityhistory.OrderOption
	toCursor func(*EntityHistory) Cursor
}

// EntityHistoryOrder defines the ordering of EntityHistory.
type EntityHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EntityHistoryOrderField `json:"field"`
}

// DefaultEntityHistoryOrder is the default ordering of EntityHistory.
var DefaultEntityHistoryOrder = &EntityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.ID, nil
		},
		column: entityhistory.FieldID,
		toTerm: entityhistory.ByID,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{ID: eh.ID}
		},
	},
}

// ToEdge converts EntityHistory into EntityHistoryEdge.
func (eh *EntityHistory) ToEdge(order *EntityHistoryOrder) *EntityHistoryEdge {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	return &EntityHistoryEdge{
		Node:   eh,
		Cursor: order.Field.toCursor(eh),
	}
}

// EntityTypeEdge is the edge representation of EntityType.
type EntityTypeEdge struct {
	Node   *EntityType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// EntityTypeConnection is the connection containing edges to EntityType.
type EntityTypeConnection struct {
	Edges      []*EntityTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *EntityTypeConnection) build(nodes []*EntityType, pager *entitytypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityType {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypePaginateOption enables pagination customization.
type EntityTypePaginateOption func(*entitytypePager) error

// WithEntityTypeOrder configures pagination ordering.
func WithEntityTypeOrder(order []*EntityTypeOrder) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEntityTypeFilter configures pagination filter.
func WithEntityTypeFilter(filter func(*EntityTypeQuery) (*EntityTypeQuery, error)) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		if filter == nil {
			return errors.New("EntityTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypePager struct {
	reverse bool
	order   []*EntityTypeOrder
	filter  func(*EntityTypeQuery) (*EntityTypeQuery, error)
}

func newEntityTypePager(opts []EntityTypePaginateOption, reverse bool) (*entitytypePager, error) {
	pager := &entitytypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *entitytypePager) applyFilter(query *EntityTypeQuery) (*EntityTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypePager) toCursor(et *EntityType) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(et).Value)
	}
	return Cursor{ID: et.ID, Value: cs_}
}

func (p *entitytypePager) applyCursors(query *EntityTypeQuery, after, before *Cursor) (*EntityTypeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEntityTypeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *entitytypePager) applyOrder(query *EntityTypeQuery) *EntityTypeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEntityTypeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEntityTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *entitytypePager) orderExpr(query *EntityTypeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEntityTypeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityType.
func (et *EntityTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypePaginateOption,
) (*EntityTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}
	conn := &EntityTypeConnection{Edges: []*EntityTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := et.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if et, err = pager.applyCursors(et, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		et.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := et.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	et = pager.applyOrder(et)
	nodes, err := et.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeOrderFieldCreatedAt orders EntityType by created_at.
	EntityTypeOrderFieldCreatedAt = &EntityTypeOrderField{
		Value: func(et *EntityType) (ent.Value, error) {
			return et.CreatedAt, nil
		},
		column: entitytype.FieldCreatedAt,
		toTerm: entitytype.ByCreatedAt,
		toCursor: func(et *EntityType) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.CreatedAt,
			}
		},
	}
	// EntityTypeOrderFieldUpdatedAt orders EntityType by updated_at.
	EntityTypeOrderFieldUpdatedAt = &EntityTypeOrderField{
		Value: func(et *EntityType) (ent.Value, error) {
			return et.UpdatedAt, nil
		},
		column: entitytype.FieldUpdatedAt,
		toTerm: entitytype.ByUpdatedAt,
		toCursor: func(et *EntityType) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.UpdatedAt,
			}
		},
	}
	// EntityTypeOrderFieldName orders EntityType by name.
	EntityTypeOrderFieldName = &EntityTypeOrderField{
		Value: func(et *EntityType) (ent.Value, error) {
			return et.Name, nil
		},
		column: entitytype.FieldName,
		toTerm: entitytype.ByName,
		toCursor: func(et *EntityType) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityTypeOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityTypeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityTypeOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityTypeOrderFieldUpdatedAt
	case "name":
		*f = *EntityTypeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

// EntityTypeOrderField defines the ordering field of EntityType.
type EntityTypeOrderField struct {
	// Value extracts the ordering value from the given EntityType.
	Value    func(*EntityType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytype.OrderOption
	toCursor func(*EntityType) Cursor
}

// EntityTypeOrder defines the ordering of EntityType.
type EntityTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *EntityTypeOrderField `json:"field"`
}

// DefaultEntityTypeOrder is the default ordering of EntityType.
var DefaultEntityTypeOrder = &EntityTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeOrderField{
		Value: func(et *EntityType) (ent.Value, error) {
			return et.ID, nil
		},
		column: entitytype.FieldID,
		toTerm: entitytype.ByID,
		toCursor: func(et *EntityType) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// ToEdge converts EntityType into EntityTypeEdge.
func (et *EntityType) ToEdge(order *EntityTypeOrder) *EntityTypeEdge {
	if order == nil {
		order = DefaultEntityTypeOrder
	}
	return &EntityTypeEdge{
		Node:   et,
		Cursor: order.Field.toCursor(et),
	}
}

// EntityTypeHistoryEdge is the edge representation of EntityTypeHistory.
type EntityTypeHistoryEdge struct {
	Node   *EntityTypeHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EntityTypeHistoryConnection is the connection containing edges to EntityTypeHistory.
type EntityTypeHistoryConnection struct {
	Edges      []*EntityTypeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *EntityTypeHistoryConnection) build(nodes []*EntityTypeHistory, pager *entitytypehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityTypeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypeHistoryPaginateOption enables pagination customization.
type EntityTypeHistoryPaginateOption func(*entitytypehistoryPager) error

// WithEntityTypeHistoryOrder configures pagination ordering.
func WithEntityTypeHistoryOrder(order *EntityTypeHistoryOrder) EntityTypeHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	o := *order
	return func(pager *entitytypehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityTypeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityTypeHistoryFilter configures pagination filter.
func WithEntityTypeHistoryFilter(filter func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)) EntityTypeHistoryPaginateOption {
	return func(pager *entitytypehistoryPager) error {
		if filter == nil {
			return errors.New("EntityTypeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypehistoryPager struct {
	reverse bool
	order   *EntityTypeHistoryOrder
	filter  func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)
}

func newEntityTypeHistoryPager(opts []EntityTypeHistoryPaginateOption, reverse bool) (*entitytypehistoryPager, error) {
	pager := &entitytypehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityTypeHistoryOrder
	}
	return pager, nil
}

func (p *entitytypehistoryPager) applyFilter(query *EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypehistoryPager) toCursor(eth *EntityTypeHistory) Cursor {
	return p.order.Field.toCursor(eth)
}

func (p *entitytypehistoryPager) applyCursors(query *EntityTypeHistoryQuery, after, before *Cursor) (*EntityTypeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityTypeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitytypehistoryPager) applyOrder(query *EntityTypeHistoryQuery) *EntityTypeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
		query = query.Order(DefaultEntityTypeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitytypehistoryPager) orderExpr(query *EntityTypeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityTypeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityTypeHistory.
func (eth *EntityTypeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypeHistoryPaginateOption,
) (*EntityTypeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eth, err = pager.applyFilter(eth); err != nil {
		return nil, err
	}
	conn := &EntityTypeHistoryConnection{Edges: []*EntityTypeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eth.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eth, err = pager.applyCursors(eth, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eth.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eth.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eth = pager.applyOrder(eth)
	nodes, err := eth.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeHistoryOrderFieldHistoryTime orders EntityTypeHistory by history_time.
	EntityTypeHistoryOrderFieldHistoryTime = &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.HistoryTime, nil
		},
		column: entitytypehistory.FieldHistoryTime,
		toTerm: entitytypehistory.ByHistoryTime,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    eth.ID,
				Value: eth.HistoryTime,
			}
		},
	}
	// EntityTypeHistoryOrderFieldCreatedAt orders EntityTypeHistory by created_at.
	EntityTypeHistoryOrderFieldCreatedAt = &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.CreatedAt, nil
		},
		column: entitytypehistory.FieldCreatedAt,
		toTerm: entitytypehistory.ByCreatedAt,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    eth.ID,
				Value: eth.CreatedAt,
			}
		},
	}
	// EntityTypeHistoryOrderFieldUpdatedAt orders EntityTypeHistory by updated_at.
	EntityTypeHistoryOrderFieldUpdatedAt = &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.UpdatedAt, nil
		},
		column: entitytypehistory.FieldUpdatedAt,
		toTerm: entitytypehistory.ByUpdatedAt,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    eth.ID,
				Value: eth.UpdatedAt,
			}
		},
	}
	// EntityTypeHistoryOrderFieldName orders EntityTypeHistory by name.
	EntityTypeHistoryOrderFieldName = &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.Name, nil
		},
		column: entitytypehistory.FieldName,
		toTerm: entitytypehistory.ByName,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    eth.ID,
				Value: eth.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EntityTypeHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityTypeHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityTypeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EntityTypeHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EntityTypeHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityTypeHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EntityTypeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

// EntityTypeHistoryOrderField defines the ordering field of EntityTypeHistory.
type EntityTypeHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityTypeHistory.
	Value    func(*EntityTypeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytypehistory.OrderOption
	toCursor func(*EntityTypeHistory) Cursor
}

// EntityTypeHistoryOrder defines the ordering of EntityTypeHistory.
type EntityTypeHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EntityTypeHistoryOrderField `json:"field"`
}

// DefaultEntityTypeHistoryOrder is the default ordering of EntityTypeHistory.
var DefaultEntityTypeHistoryOrder = &EntityTypeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.ID, nil
		},
		column: entitytypehistory.FieldID,
		toTerm: entitytypehistory.ByID,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{ID: eth.ID}
		},
	},
}

// ToEdge converts EntityTypeHistory into EntityTypeHistoryEdge.
func (eth *EntityTypeHistory) ToEdge(order *EntityTypeHistoryOrder) *EntityTypeHistoryEdge {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	return &EntityTypeHistoryEdge{
		Node:   eth,
		Cursor: order.Field.toCursor(eth),
	}
}

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EventConnection) build(nodes []*Event, pager *eventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order []*EventOrder) EventPaginateOption {
	return func(pager *eventPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	reverse bool
	order   []*EventOrder
	filter  func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption, reverse bool) (*eventPager, error) {
	pager := &eventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(e *Event) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(e).Value)
	}
	return Cursor{ID: e.ID, Value: cs_}
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) (*EventQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEventOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *eventPager) applyOrder(query *EventQuery) *EventQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEventOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *eventPager) orderExpr(query *EventQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEventOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (e *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EventConnection{Edges: []*EventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EventOrderFieldCreatedAt orders Event by created_at.
	EventOrderFieldCreatedAt = &EventOrderField{
		Value: func(e *Event) (ent.Value, error) {
			return e.CreatedAt, nil
		},
		column: event.FieldCreatedAt,
		toTerm: event.ByCreatedAt,
		toCursor: func(e *Event) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EventOrderFieldUpdatedAt orders Event by updated_at.
	EventOrderFieldUpdatedAt = &EventOrderField{
		Value: func(e *Event) (ent.Value, error) {
			return e.UpdatedAt, nil
		},
		column: event.FieldUpdatedAt,
		toTerm: event.ByUpdatedAt,
		toCursor: func(e *Event) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventOrderField) String() string {
	var str string
	switch f.column {
	case EventOrderFieldCreatedAt.column:
		str = "created_at"
	case EventOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EventOrderFieldCreatedAt
	case "updated_at":
		*f = *EventOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid EventOrderField", str)
	}
	return nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	// Value extracts the ordering value from the given Event.
	Value    func(*Event) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) event.OrderOption
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EventOrderField{
		Value: func(e *Event) (ent.Value, error) {
			return e.ID, nil
		},
		column: event.FieldID,
		toTerm: event.ByID,
		toCursor: func(e *Event) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (e *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EvidenceEdge is the edge representation of Evidence.
type EvidenceEdge struct {
	Node   *Evidence `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// EvidenceConnection is the connection containing edges to Evidence.
type EvidenceConnection struct {
	Edges      []*EvidenceEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *EvidenceConnection) build(nodes []*Evidence, pager *evidencePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Evidence
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Evidence {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Evidence {
			return nodes[i]
		}
	}
	c.Edges = make([]*EvidenceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EvidenceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EvidencePaginateOption enables pagination customization.
type EvidencePaginateOption func(*evidencePager) error

// WithEvidenceOrder configures pagination ordering.
func WithEvidenceOrder(order []*EvidenceOrder) EvidencePaginateOption {
	return func(pager *evidencePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEvidenceFilter configures pagination filter.
func WithEvidenceFilter(filter func(*EvidenceQuery) (*EvidenceQuery, error)) EvidencePaginateOption {
	return func(pager *evidencePager) error {
		if filter == nil {
			return errors.New("EvidenceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type evidencePager struct {
	reverse bool
	order   []*EvidenceOrder
	filter  func(*EvidenceQuery) (*EvidenceQuery, error)
}

func newEvidencePager(opts []EvidencePaginateOption, reverse bool) (*evidencePager, error) {
	pager := &evidencePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *evidencePager) applyFilter(query *EvidenceQuery) (*EvidenceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *evidencePager) toCursor(e *Evidence) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(e).Value)
	}
	return Cursor{ID: e.ID, Value: cs_}
}

func (p *evidencePager) applyCursors(query *EvidenceQuery, after, before *Cursor) (*EvidenceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEvidenceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *evidencePager) applyOrder(query *EvidenceQuery) *EvidenceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEvidenceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEvidenceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *evidencePager) orderExpr(query *EvidenceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEvidenceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Evidence.
func (e *EvidenceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EvidencePaginateOption,
) (*EvidenceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEvidencePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EvidenceConnection{Edges: []*EvidenceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EvidenceOrderFieldCreatedAt orders Evidence by created_at.
	EvidenceOrderFieldCreatedAt = &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.CreatedAt, nil
		},
		column: evidence.FieldCreatedAt,
		toTerm: evidence.ByCreatedAt,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EvidenceOrderFieldUpdatedAt orders Evidence by updated_at.
	EvidenceOrderFieldUpdatedAt = &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.UpdatedAt, nil
		},
		column: evidence.FieldUpdatedAt,
		toTerm: evidence.ByUpdatedAt,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
	// EvidenceOrderFieldName orders Evidence by name.
	EvidenceOrderFieldName = &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.Name, nil
		},
		column: evidence.FieldName,
		toTerm: evidence.ByName,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Name,
			}
		},
	}
	// EvidenceOrderFieldCreationDate orders Evidence by creation_date.
	EvidenceOrderFieldCreationDate = &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.CreationDate, nil
		},
		column: evidence.FieldCreationDate,
		toTerm: evidence.ByCreationDate,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreationDate,
			}
		},
	}
	// EvidenceOrderFieldRenewalDate orders Evidence by renewal_date.
	EvidenceOrderFieldRenewalDate = &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.RenewalDate, nil
		},
		column: evidence.FieldRenewalDate,
		toTerm: evidence.ByRenewalDate,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.RenewalDate,
			}
		},
	}
	// EvidenceOrderFieldStatus orders Evidence by status.
	EvidenceOrderFieldStatus = &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.Status, nil
		},
		column: evidence.FieldStatus,
		toTerm: evidence.ByStatus,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EvidenceOrderField) String() string {
	var str string
	switch f.column {
	case EvidenceOrderFieldCreatedAt.column:
		str = "created_at"
	case EvidenceOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EvidenceOrderFieldName.column:
		str = "name"
	case EvidenceOrderFieldCreationDate.column:
		str = "creation_date"
	case EvidenceOrderFieldRenewalDate.column:
		str = "renewal_date"
	case EvidenceOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EvidenceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EvidenceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EvidenceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EvidenceOrderFieldCreatedAt
	case "updated_at":
		*f = *EvidenceOrderFieldUpdatedAt
	case "name":
		*f = *EvidenceOrderFieldName
	case "creation_date":
		*f = *EvidenceOrderFieldCreationDate
	case "renewal_date":
		*f = *EvidenceOrderFieldRenewalDate
	case "STATUS":
		*f = *EvidenceOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EvidenceOrderField", str)
	}
	return nil
}

// EvidenceOrderField defines the ordering field of Evidence.
type EvidenceOrderField struct {
	// Value extracts the ordering value from the given Evidence.
	Value    func(*Evidence) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) evidence.OrderOption
	toCursor func(*Evidence) Cursor
}

// EvidenceOrder defines the ordering of Evidence.
type EvidenceOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *EvidenceOrderField `json:"field"`
}

// DefaultEvidenceOrder is the default ordering of Evidence.
var DefaultEvidenceOrder = &EvidenceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EvidenceOrderField{
		Value: func(e *Evidence) (ent.Value, error) {
			return e.ID, nil
		},
		column: evidence.FieldID,
		toTerm: evidence.ByID,
		toCursor: func(e *Evidence) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Evidence into EvidenceEdge.
func (e *Evidence) ToEdge(order *EvidenceOrder) *EvidenceEdge {
	if order == nil {
		order = DefaultEvidenceOrder
	}
	return &EvidenceEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EvidenceHistoryEdge is the edge representation of EvidenceHistory.
type EvidenceHistoryEdge struct {
	Node   *EvidenceHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// EvidenceHistoryConnection is the connection containing edges to EvidenceHistory.
type EvidenceHistoryConnection struct {
	Edges      []*EvidenceHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *EvidenceHistoryConnection) build(nodes []*EvidenceHistory, pager *evidencehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EvidenceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EvidenceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EvidenceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EvidenceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EvidenceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EvidenceHistoryPaginateOption enables pagination customization.
type EvidenceHistoryPaginateOption func(*evidencehistoryPager) error

// WithEvidenceHistoryOrder configures pagination ordering.
func WithEvidenceHistoryOrder(order *EvidenceHistoryOrder) EvidenceHistoryPaginateOption {
	if order == nil {
		order = DefaultEvidenceHistoryOrder
	}
	o := *order
	return func(pager *evidencehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEvidenceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEvidenceHistoryFilter configures pagination filter.
func WithEvidenceHistoryFilter(filter func(*EvidenceHistoryQuery) (*EvidenceHistoryQuery, error)) EvidenceHistoryPaginateOption {
	return func(pager *evidencehistoryPager) error {
		if filter == nil {
			return errors.New("EvidenceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type evidencehistoryPager struct {
	reverse bool
	order   *EvidenceHistoryOrder
	filter  func(*EvidenceHistoryQuery) (*EvidenceHistoryQuery, error)
}

func newEvidenceHistoryPager(opts []EvidenceHistoryPaginateOption, reverse bool) (*evidencehistoryPager, error) {
	pager := &evidencehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEvidenceHistoryOrder
	}
	return pager, nil
}

func (p *evidencehistoryPager) applyFilter(query *EvidenceHistoryQuery) (*EvidenceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *evidencehistoryPager) toCursor(eh *EvidenceHistory) Cursor {
	return p.order.Field.toCursor(eh)
}

func (p *evidencehistoryPager) applyCursors(query *EvidenceHistoryQuery, after, before *Cursor) (*EvidenceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEvidenceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *evidencehistoryPager) applyOrder(query *EvidenceHistoryQuery) *EvidenceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEvidenceHistoryOrder.Field {
		query = query.Order(DefaultEvidenceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *evidencehistoryPager) orderExpr(query *EvidenceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEvidenceHistoryOrder.Field {
			b.Comma().Ident(DefaultEvidenceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EvidenceHistory.
func (eh *EvidenceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EvidenceHistoryPaginateOption,
) (*EvidenceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEvidenceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eh, err = pager.applyFilter(eh); err != nil {
		return nil, err
	}
	conn := &EvidenceHistoryConnection{Edges: []*EvidenceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eh, err = pager.applyCursors(eh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eh = pager.applyOrder(eh)
	nodes, err := eh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EvidenceHistoryOrderFieldHistoryTime orders EvidenceHistory by history_time.
	EvidenceHistoryOrderFieldHistoryTime = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.HistoryTime, nil
		},
		column: evidencehistory.FieldHistoryTime,
		toTerm: evidencehistory.ByHistoryTime,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.HistoryTime,
			}
		},
	}
	// EvidenceHistoryOrderFieldCreatedAt orders EvidenceHistory by created_at.
	EvidenceHistoryOrderFieldCreatedAt = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.CreatedAt, nil
		},
		column: evidencehistory.FieldCreatedAt,
		toTerm: evidencehistory.ByCreatedAt,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.CreatedAt,
			}
		},
	}
	// EvidenceHistoryOrderFieldUpdatedAt orders EvidenceHistory by updated_at.
	EvidenceHistoryOrderFieldUpdatedAt = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.UpdatedAt, nil
		},
		column: evidencehistory.FieldUpdatedAt,
		toTerm: evidencehistory.ByUpdatedAt,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.UpdatedAt,
			}
		},
	}
	// EvidenceHistoryOrderFieldName orders EvidenceHistory by name.
	EvidenceHistoryOrderFieldName = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.Name, nil
		},
		column: evidencehistory.FieldName,
		toTerm: evidencehistory.ByName,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.Name,
			}
		},
	}
	// EvidenceHistoryOrderFieldCreationDate orders EvidenceHistory by creation_date.
	EvidenceHistoryOrderFieldCreationDate = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.CreationDate, nil
		},
		column: evidencehistory.FieldCreationDate,
		toTerm: evidencehistory.ByCreationDate,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.CreationDate,
			}
		},
	}
	// EvidenceHistoryOrderFieldRenewalDate orders EvidenceHistory by renewal_date.
	EvidenceHistoryOrderFieldRenewalDate = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.RenewalDate, nil
		},
		column: evidencehistory.FieldRenewalDate,
		toTerm: evidencehistory.ByRenewalDate,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.RenewalDate,
			}
		},
	}
	// EvidenceHistoryOrderFieldStatus orders EvidenceHistory by status.
	EvidenceHistoryOrderFieldStatus = &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.Status, nil
		},
		column: evidencehistory.FieldStatus,
		toTerm: evidencehistory.ByStatus,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EvidenceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EvidenceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EvidenceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EvidenceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EvidenceHistoryOrderFieldName.column:
		str = "name"
	case EvidenceHistoryOrderFieldCreationDate.column:
		str = "creation_date"
	case EvidenceHistoryOrderFieldRenewalDate.column:
		str = "renewal_date"
	case EvidenceHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EvidenceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EvidenceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EvidenceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EvidenceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EvidenceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EvidenceHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EvidenceHistoryOrderFieldName
	case "creation_date":
		*f = *EvidenceHistoryOrderFieldCreationDate
	case "renewal_date":
		*f = *EvidenceHistoryOrderFieldRenewalDate
	case "STATUS":
		*f = *EvidenceHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EvidenceHistoryOrderField", str)
	}
	return nil
}

// EvidenceHistoryOrderField defines the ordering field of EvidenceHistory.
type EvidenceHistoryOrderField struct {
	// Value extracts the ordering value from the given EvidenceHistory.
	Value    func(*EvidenceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) evidencehistory.OrderOption
	toCursor func(*EvidenceHistory) Cursor
}

// EvidenceHistoryOrder defines the ordering of EvidenceHistory.
type EvidenceHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *EvidenceHistoryOrderField `json:"field"`
}

// DefaultEvidenceHistoryOrder is the default ordering of EvidenceHistory.
var DefaultEvidenceHistoryOrder = &EvidenceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EvidenceHistoryOrderField{
		Value: func(eh *EvidenceHistory) (ent.Value, error) {
			return eh.ID, nil
		},
		column: evidencehistory.FieldID,
		toTerm: evidencehistory.ByID,
		toCursor: func(eh *EvidenceHistory) Cursor {
			return Cursor{ID: eh.ID}
		},
	},
}

// ToEdge converts EvidenceHistory into EvidenceHistoryEdge.
func (eh *EvidenceHistory) ToEdge(order *EvidenceHistoryOrder) *EvidenceHistoryEdge {
	if order == nil {
		order = DefaultEvidenceHistoryOrder
	}
	return &EvidenceHistoryEdge{
		Node:   eh,
		Cursor: order.Field.toCursor(eh),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order []*FileOrder) FilePaginateOption {
	return func(pager *filePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   []*FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(f).Value)
	}
	return Cursor{ID: f.ID, Value: cs_}
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFileOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFileOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := f.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileOrderFieldCreatedAt orders File by created_at.
	FileOrderFieldCreatedAt = &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.CreatedAt, nil
		},
		column: file.FieldCreatedAt,
		toTerm: file.ByCreatedAt,
		toCursor: func(f *File) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.CreatedAt,
			}
		},
	}
	// FileOrderFieldUpdatedAt orders File by updated_at.
	FileOrderFieldUpdatedAt = &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.UpdatedAt, nil
		},
		column: file.FieldUpdatedAt,
		toTerm: file.ByUpdatedAt,
		toCursor: func(f *File) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileOrderField) String() string {
	var str string
	switch f.column {
	case FileOrderFieldCreatedAt.column:
		str = "created_at"
	case FileOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FileOrderFieldCreatedAt
	case "updated_at":
		*f = *FileOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// FileHistoryEdge is the edge representation of FileHistory.
type FileHistoryEdge struct {
	Node   *FileHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileHistoryConnection is the connection containing edges to FileHistory.
type FileHistoryConnection struct {
	Edges      []*FileHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *FileHistoryConnection) build(nodes []*FileHistory, pager *filehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FileHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileHistoryPaginateOption enables pagination customization.
type FileHistoryPaginateOption func(*filehistoryPager) error

// WithFileHistoryOrder configures pagination ordering.
func WithFileHistoryOrder(order *FileHistoryOrder) FileHistoryPaginateOption {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	o := *order
	return func(pager *filehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileHistoryFilter configures pagination filter.
func WithFileHistoryFilter(filter func(*FileHistoryQuery) (*FileHistoryQuery, error)) FileHistoryPaginateOption {
	return func(pager *filehistoryPager) error {
		if filter == nil {
			return errors.New("FileHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filehistoryPager struct {
	reverse bool
	order   *FileHistoryOrder
	filter  func(*FileHistoryQuery) (*FileHistoryQuery, error)
}

func newFileHistoryPager(opts []FileHistoryPaginateOption, reverse bool) (*filehistoryPager, error) {
	pager := &filehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileHistoryOrder
	}
	return pager, nil
}

func (p *filehistoryPager) applyFilter(query *FileHistoryQuery) (*FileHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filehistoryPager) toCursor(fh *FileHistory) Cursor {
	return p.order.Field.toCursor(fh)
}

func (p *filehistoryPager) applyCursors(query *FileHistoryQuery, after, before *Cursor) (*FileHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filehistoryPager) applyOrder(query *FileHistoryQuery) *FileHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileHistoryOrder.Field {
		query = query.Order(DefaultFileHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filehistoryPager) orderExpr(query *FileHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileHistoryOrder.Field {
			b.Comma().Ident(DefaultFileHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileHistory.
func (fh *FileHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileHistoryPaginateOption,
) (*FileHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fh, err = pager.applyFilter(fh); err != nil {
		return nil, err
	}
	conn := &FileHistoryConnection{Edges: []*FileHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := fh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fh, err = pager.applyCursors(fh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		fh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fh = pager.applyOrder(fh)
	nodes, err := fh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileHistoryOrderFieldHistoryTime orders FileHistory by history_time.
	FileHistoryOrderFieldHistoryTime = &FileHistoryOrderField{
		Value: func(fh *FileHistory) (ent.Value, error) {
			return fh.HistoryTime, nil
		},
		column: filehistory.FieldHistoryTime,
		toTerm: filehistory.ByHistoryTime,
		toCursor: func(fh *FileHistory) Cursor {
			return Cursor{
				ID:    fh.ID,
				Value: fh.HistoryTime,
			}
		},
	}
	// FileHistoryOrderFieldCreatedAt orders FileHistory by created_at.
	FileHistoryOrderFieldCreatedAt = &FileHistoryOrderField{
		Value: func(fh *FileHistory) (ent.Value, error) {
			return fh.CreatedAt, nil
		},
		column: filehistory.FieldCreatedAt,
		toTerm: filehistory.ByCreatedAt,
		toCursor: func(fh *FileHistory) Cursor {
			return Cursor{
				ID:    fh.ID,
				Value: fh.CreatedAt,
			}
		},
	}
	// FileHistoryOrderFieldUpdatedAt orders FileHistory by updated_at.
	FileHistoryOrderFieldUpdatedAt = &FileHistoryOrderField{
		Value: func(fh *FileHistory) (ent.Value, error) {
			return fh.UpdatedAt, nil
		},
		column: filehistory.FieldUpdatedAt,
		toTerm: filehistory.ByUpdatedAt,
		toCursor: func(fh *FileHistory) Cursor {
			return Cursor{
				ID:    fh.ID,
				Value: fh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FileHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FileHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FileHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FileHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FileHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FileHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FileHistoryOrderField", str)
	}
	return nil
}

// FileHistoryOrderField defines the ordering field of FileHistory.
type FileHistoryOrderField struct {
	// Value extracts the ordering value from the given FileHistory.
	Value    func(*FileHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filehistory.OrderOption
	toCursor func(*FileHistory) Cursor
}

// FileHistoryOrder defines the ordering of FileHistory.
type FileHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileHistoryOrderField `json:"field"`
}

// DefaultFileHistoryOrder is the default ordering of FileHistory.
var DefaultFileHistoryOrder = &FileHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileHistoryOrderField{
		Value: func(fh *FileHistory) (ent.Value, error) {
			return fh.ID, nil
		},
		column: filehistory.FieldID,
		toTerm: filehistory.ByID,
		toCursor: func(fh *FileHistory) Cursor {
			return Cursor{ID: fh.ID}
		},
	},
}

// ToEdge converts FileHistory into FileHistoryEdge.
func (fh *FileHistory) ToEdge(order *FileHistoryOrder) *FileHistoryEdge {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	return &FileHistoryEdge{
		Node:   fh,
		Cursor: order.Field.toCursor(fh),
	}
}

// GroupEdge is the edge representation of Group.
type GroupEdge struct {
	Node   *Group `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GroupConnection is the connection containing edges to Group.
type GroupConnection struct {
	Edges      []*GroupEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *GroupConnection) build(nodes []*Group, pager *groupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Group
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Group {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Group {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupPaginateOption enables pagination customization.
type GroupPaginateOption func(*groupPager) error

// WithGroupOrder configures pagination ordering.
func WithGroupOrder(order []*GroupOrder) GroupPaginateOption {
	return func(pager *groupPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupFilter configures pagination filter.
func WithGroupFilter(filter func(*GroupQuery) (*GroupQuery, error)) GroupPaginateOption {
	return func(pager *groupPager) error {
		if filter == nil {
			return errors.New("GroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupPager struct {
	reverse bool
	order   []*GroupOrder
	filter  func(*GroupQuery) (*GroupQuery, error)
}

func newGroupPager(opts []GroupPaginateOption, reverse bool) (*groupPager, error) {
	pager := &groupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupPager) applyFilter(query *GroupQuery) (*GroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupPager) toCursor(gr *Group) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(gr).Value)
	}
	return Cursor{ID: gr.ID, Value: cs_}
}

func (p *groupPager) applyCursors(query *GroupQuery, after, before *Cursor) (*GroupQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupPager) applyOrder(query *GroupQuery) *GroupQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupPager) orderExpr(query *GroupQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Group.
func (gr *GroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupPaginateOption,
) (*GroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gr, err = pager.applyFilter(gr); err != nil {
		return nil, err
	}
	conn := &GroupConnection{Edges: []*GroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gr, err = pager.applyCursors(gr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gr = pager.applyOrder(gr)
	nodes, err := gr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupOrderFieldCreatedAt orders Group by created_at.
	GroupOrderFieldCreatedAt = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.CreatedAt, nil
		},
		column: group.FieldCreatedAt,
		toTerm: group.ByCreatedAt,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.CreatedAt,
			}
		},
	}
	// GroupOrderFieldUpdatedAt orders Group by updated_at.
	GroupOrderFieldUpdatedAt = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.UpdatedAt, nil
		},
		column: group.FieldUpdatedAt,
		toTerm: group.ByUpdatedAt,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.UpdatedAt,
			}
		},
	}
	// GroupOrderFieldName orders Group by name.
	GroupOrderFieldName = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.Name, nil
		},
		column: group.FieldName,
		toTerm: group.ByName,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.Name,
			}
		},
	}
	// GroupOrderFieldDisplayName orders Group by display_name.
	GroupOrderFieldDisplayName = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.DisplayName, nil
		},
		column: group.FieldDisplayName,
		toTerm: group.ByDisplayName,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupOrderField) String() string {
	var str string
	switch f.column {
	case GroupOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupOrderFieldName.column:
		str = "name"
	case GroupOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupOrderFieldUpdatedAt
	case "name":
		*f = *GroupOrderFieldName
	case "display_name":
		*f = *GroupOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

// GroupOrderField defines the ordering field of Group.
type GroupOrderField struct {
	// Value extracts the ordering value from the given Group.
	Value    func(*Group) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) group.OrderOption
	toCursor func(*Group) Cursor
}

// GroupOrder defines the ordering of Group.
type GroupOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *GroupOrderField `json:"field"`
}

// DefaultGroupOrder is the default ordering of Group.
var DefaultGroupOrder = &GroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.ID, nil
		},
		column: group.FieldID,
		toTerm: group.ByID,
		toCursor: func(gr *Group) Cursor {
			return Cursor{ID: gr.ID}
		},
	},
}

// ToEdge converts Group into GroupEdge.
func (gr *Group) ToEdge(order *GroupOrder) *GroupEdge {
	if order == nil {
		order = DefaultGroupOrder
	}
	return &GroupEdge{
		Node:   gr,
		Cursor: order.Field.toCursor(gr),
	}
}

// GroupHistoryEdge is the edge representation of GroupHistory.
type GroupHistoryEdge struct {
	Node   *GroupHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupHistoryConnection is the connection containing edges to GroupHistory.
type GroupHistoryConnection struct {
	Edges      []*GroupHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupHistoryConnection) build(nodes []*GroupHistory, pager *grouphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupHistoryPaginateOption enables pagination customization.
type GroupHistoryPaginateOption func(*grouphistoryPager) error

// WithGroupHistoryOrder configures pagination ordering.
func WithGroupHistoryOrder(order *GroupHistoryOrder) GroupHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	o := *order
	return func(pager *grouphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupHistoryFilter configures pagination filter.
func WithGroupHistoryFilter(filter func(*GroupHistoryQuery) (*GroupHistoryQuery, error)) GroupHistoryPaginateOption {
	return func(pager *grouphistoryPager) error {
		if filter == nil {
			return errors.New("GroupHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type grouphistoryPager struct {
	reverse bool
	order   *GroupHistoryOrder
	filter  func(*GroupHistoryQuery) (*GroupHistoryQuery, error)
}

func newGroupHistoryPager(opts []GroupHistoryPaginateOption, reverse bool) (*grouphistoryPager, error) {
	pager := &grouphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupHistoryOrder
	}
	return pager, nil
}

func (p *grouphistoryPager) applyFilter(query *GroupHistoryQuery) (*GroupHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *grouphistoryPager) toCursor(gh *GroupHistory) Cursor {
	return p.order.Field.toCursor(gh)
}

func (p *grouphistoryPager) applyCursors(query *GroupHistoryQuery, after, before *Cursor) (*GroupHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *grouphistoryPager) applyOrder(query *GroupHistoryQuery) *GroupHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupHistoryOrder.Field {
		query = query.Order(DefaultGroupHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *grouphistoryPager) orderExpr(query *GroupHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupHistory.
func (gh *GroupHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupHistoryPaginateOption,
) (*GroupHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gh, err = pager.applyFilter(gh); err != nil {
		return nil, err
	}
	conn := &GroupHistoryConnection{Edges: []*GroupHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gh, err = pager.applyCursors(gh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gh = pager.applyOrder(gh)
	nodes, err := gh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupHistoryOrderFieldHistoryTime orders GroupHistory by history_time.
	GroupHistoryOrderFieldHistoryTime = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.HistoryTime, nil
		},
		column: grouphistory.FieldHistoryTime,
		toTerm: grouphistory.ByHistoryTime,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.HistoryTime,
			}
		},
	}
	// GroupHistoryOrderFieldCreatedAt orders GroupHistory by created_at.
	GroupHistoryOrderFieldCreatedAt = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.CreatedAt, nil
		},
		column: grouphistory.FieldCreatedAt,
		toTerm: grouphistory.ByCreatedAt,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.CreatedAt,
			}
		},
	}
	// GroupHistoryOrderFieldUpdatedAt orders GroupHistory by updated_at.
	GroupHistoryOrderFieldUpdatedAt = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.UpdatedAt, nil
		},
		column: grouphistory.FieldUpdatedAt,
		toTerm: grouphistory.ByUpdatedAt,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.UpdatedAt,
			}
		},
	}
	// GroupHistoryOrderFieldName orders GroupHistory by name.
	GroupHistoryOrderFieldName = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.Name, nil
		},
		column: grouphistory.FieldName,
		toTerm: grouphistory.ByName,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.Name,
			}
		},
	}
	// GroupHistoryOrderFieldDisplayName orders GroupHistory by display_name.
	GroupHistoryOrderFieldDisplayName = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.DisplayName, nil
		},
		column: grouphistory.FieldDisplayName,
		toTerm: grouphistory.ByDisplayName,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupHistoryOrderFieldName.column:
		str = "name"
	case GroupHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupHistoryOrderFieldUpdatedAt
	case "name":
		*f = *GroupHistoryOrderFieldName
	case "display_name":
		*f = *GroupHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

// GroupHistoryOrderField defines the ordering field of GroupHistory.
type GroupHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupHistory.
	Value    func(*GroupHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) grouphistory.OrderOption
	toCursor func(*GroupHistory) Cursor
}

// GroupHistoryOrder defines the ordering of GroupHistory.
type GroupHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupHistoryOrderField `json:"field"`
}

// DefaultGroupHistoryOrder is the default ordering of GroupHistory.
var DefaultGroupHistoryOrder = &GroupHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.ID, nil
		},
		column: grouphistory.FieldID,
		toTerm: grouphistory.ByID,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{ID: gh.ID}
		},
	},
}

// ToEdge converts GroupHistory into GroupHistoryEdge.
func (gh *GroupHistory) ToEdge(order *GroupHistoryOrder) *GroupHistoryEdge {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	return &GroupHistoryEdge{
		Node:   gh,
		Cursor: order.Field.toCursor(gh),
	}
}

// GroupMembershipEdge is the edge representation of GroupMembership.
type GroupMembershipEdge struct {
	Node   *GroupMembership `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// GroupMembershipConnection is the connection containing edges to GroupMembership.
type GroupMembershipConnection struct {
	Edges      []*GroupMembershipEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *GroupMembershipConnection) build(nodes []*GroupMembership, pager *groupmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipPaginateOption enables pagination customization.
type GroupMembershipPaginateOption func(*groupmembershipPager) error

// WithGroupMembershipOrder configures pagination ordering.
func WithGroupMembershipOrder(order []*GroupMembershipOrder) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupMembershipFilter configures pagination filter.
func WithGroupMembershipFilter(filter func(*GroupMembershipQuery) (*GroupMembershipQuery, error)) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		if filter == nil {
			return errors.New("GroupMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershipPager struct {
	reverse bool
	order   []*GroupMembershipOrder
	filter  func(*GroupMembershipQuery) (*GroupMembershipQuery, error)
}

func newGroupMembershipPager(opts []GroupMembershipPaginateOption, reverse bool) (*groupmembershipPager, error) {
	pager := &groupmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupmembershipPager) applyFilter(query *GroupMembershipQuery) (*GroupMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershipPager) toCursor(gm *GroupMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(gm).Value)
	}
	return Cursor{ID: gm.ID, Value: cs_}
}

func (p *groupmembershipPager) applyCursors(query *GroupMembershipQuery, after, before *Cursor) (*GroupMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupmembershipPager) applyOrder(query *GroupMembershipQuery) *GroupMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupmembershipPager) orderExpr(query *GroupMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembership.
func (gm *GroupMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipPaginateOption,
) (*GroupMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gm, err = pager.applyFilter(gm); err != nil {
		return nil, err
	}
	conn := &GroupMembershipConnection{Edges: []*GroupMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gm.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gm, err = pager.applyCursors(gm, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gm.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gm = pager.applyOrder(gm)
	nodes, err := gm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupMembershipOrderFieldCreatedAt orders GroupMembership by created_at.
	GroupMembershipOrderFieldCreatedAt = &GroupMembershipOrderField{
		Value: func(gm *GroupMembership) (ent.Value, error) {
			return gm.CreatedAt, nil
		},
		column: groupmembership.FieldCreatedAt,
		toTerm: groupmembership.ByCreatedAt,
		toCursor: func(gm *GroupMembership) Cursor {
			return Cursor{
				ID:    gm.ID,
				Value: gm.CreatedAt,
			}
		},
	}
	// GroupMembershipOrderFieldUpdatedAt orders GroupMembership by updated_at.
	GroupMembershipOrderFieldUpdatedAt = &GroupMembershipOrderField{
		Value: func(gm *GroupMembership) (ent.Value, error) {
			return gm.UpdatedAt, nil
		},
		column: groupmembership.FieldUpdatedAt,
		toTerm: groupmembership.ByUpdatedAt,
		toCursor: func(gm *GroupMembership) Cursor {
			return Cursor{
				ID:    gm.ID,
				Value: gm.UpdatedAt,
			}
		},
	}
	// GroupMembershipOrderFieldRole orders GroupMembership by role.
	GroupMembershipOrderFieldRole = &GroupMembershipOrderField{
		Value: func(gm *GroupMembership) (ent.Value, error) {
			return gm.Role, nil
		},
		column: groupmembership.FieldRole,
		toTerm: groupmembership.ByRole,
		toCursor: func(gm *GroupMembership) Cursor {
			return Cursor{
				ID:    gm.ID,
				Value: gm.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupMembershipOrderField) String() string {
	var str string
	switch f.column {
	case GroupMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *GroupMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid GroupMembershipOrderField", str)
	}
	return nil
}

// GroupMembershipOrderField defines the ordering field of GroupMembership.
type GroupMembershipOrderField struct {
	// Value extracts the ordering value from the given GroupMembership.
	Value    func(*GroupMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembership.OrderOption
	toCursor func(*GroupMembership) Cursor
}

// GroupMembershipOrder defines the ordering of GroupMembership.
type GroupMembershipOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *GroupMembershipOrderField `json:"field"`
}

// DefaultGroupMembershipOrder is the default ordering of GroupMembership.
var DefaultGroupMembershipOrder = &GroupMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipOrderField{
		Value: func(gm *GroupMembership) (ent.Value, error) {
			return gm.ID, nil
		},
		column: groupmembership.FieldID,
		toTerm: groupmembership.ByID,
		toCursor: func(gm *GroupMembership) Cursor {
			return Cursor{ID: gm.ID}
		},
	},
}

// ToEdge converts GroupMembership into GroupMembershipEdge.
func (gm *GroupMembership) ToEdge(order *GroupMembershipOrder) *GroupMembershipEdge {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	return &GroupMembershipEdge{
		Node:   gm,
		Cursor: order.Field.toCursor(gm),
	}
}

// GroupMembershipHistoryEdge is the edge representation of GroupMembershipHistory.
type GroupMembershipHistoryEdge struct {
	Node   *GroupMembershipHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// GroupMembershipHistoryConnection is the connection containing edges to GroupMembershipHistory.
type GroupMembershipHistoryConnection struct {
	Edges      []*GroupMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *GroupMembershipHistoryConnection) build(nodes []*GroupMembershipHistory, pager *groupmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipHistoryPaginateOption enables pagination customization.
type GroupMembershipHistoryPaginateOption func(*groupmembershiphistoryPager) error

// WithGroupMembershipHistoryOrder configures pagination ordering.
func WithGroupMembershipHistoryOrder(order *GroupMembershipHistoryOrder) GroupMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	o := *order
	return func(pager *groupmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipHistoryFilter configures pagination filter.
func WithGroupMembershipHistoryFilter(filter func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)) GroupMembershipHistoryPaginateOption {
	return func(pager *groupmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("GroupMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershiphistoryPager struct {
	reverse bool
	order   *GroupMembershipHistoryOrder
	filter  func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)
}

func newGroupMembershipHistoryPager(opts []GroupMembershipHistoryPaginateOption, reverse bool) (*groupmembershiphistoryPager, error) {
	pager := &groupmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipHistoryOrder
	}
	return pager, nil
}

func (p *groupmembershiphistoryPager) applyFilter(query *GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) toCursor(gmh *GroupMembershipHistory) Cursor {
	return p.order.Field.toCursor(gmh)
}

func (p *groupmembershiphistoryPager) applyCursors(query *GroupMembershipHistoryQuery, after, before *Cursor) (*GroupMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) applyOrder(query *GroupMembershipHistoryQuery) *GroupMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
		query = query.Order(DefaultGroupMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershiphistoryPager) orderExpr(query *GroupMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembershipHistory.
func (gmh *GroupMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipHistoryPaginateOption,
) (*GroupMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gmh, err = pager.applyFilter(gmh); err != nil {
		return nil, err
	}
	conn := &GroupMembershipHistoryConnection{Edges: []*GroupMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gmh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gmh, err = pager.applyCursors(gmh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gmh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gmh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gmh = pager.applyOrder(gmh)
	nodes, err := gmh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupMembershipHistoryOrderFieldHistoryTime orders GroupMembershipHistory by history_time.
	GroupMembershipHistoryOrderFieldHistoryTime = &GroupMembershipHistoryOrderField{
		Value: func(gmh *GroupMembershipHistory) (ent.Value, error) {
			return gmh.HistoryTime, nil
		},
		column: groupmembershiphistory.FieldHistoryTime,
		toTerm: groupmembershiphistory.ByHistoryTime,
		toCursor: func(gmh *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    gmh.ID,
				Value: gmh.HistoryTime,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldCreatedAt orders GroupMembershipHistory by created_at.
	GroupMembershipHistoryOrderFieldCreatedAt = &GroupMembershipHistoryOrderField{
		Value: func(gmh *GroupMembershipHistory) (ent.Value, error) {
			return gmh.CreatedAt, nil
		},
		column: groupmembershiphistory.FieldCreatedAt,
		toTerm: groupmembershiphistory.ByCreatedAt,
		toCursor: func(gmh *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    gmh.ID,
				Value: gmh.CreatedAt,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldUpdatedAt orders GroupMembershipHistory by updated_at.
	GroupMembershipHistoryOrderFieldUpdatedAt = &GroupMembershipHistoryOrderField{
		Value: func(gmh *GroupMembershipHistory) (ent.Value, error) {
			return gmh.UpdatedAt, nil
		},
		column: groupmembershiphistory.FieldUpdatedAt,
		toTerm: groupmembershiphistory.ByUpdatedAt,
		toCursor: func(gmh *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    gmh.ID,
				Value: gmh.UpdatedAt,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldRole orders GroupMembershipHistory by role.
	GroupMembershipHistoryOrderFieldRole = &GroupMembershipHistoryOrderField{
		Value: func(gmh *GroupMembershipHistory) (ent.Value, error) {
			return gmh.Role, nil
		},
		column: groupmembershiphistory.FieldRole,
		toTerm: groupmembershiphistory.ByRole,
		toCursor: func(gmh *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    gmh.ID,
				Value: gmh.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *GroupMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid GroupMembershipHistoryOrderField", str)
	}
	return nil
}

// GroupMembershipHistoryOrderField defines the ordering field of GroupMembershipHistory.
type GroupMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupMembershipHistory.
	Value    func(*GroupMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembershiphistory.OrderOption
	toCursor func(*GroupMembershipHistory) Cursor
}

// GroupMembershipHistoryOrder defines the ordering of GroupMembershipHistory.
type GroupMembershipHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *GroupMembershipHistoryOrderField `json:"field"`
}

// DefaultGroupMembershipHistoryOrder is the default ordering of GroupMembershipHistory.
var DefaultGroupMembershipHistoryOrder = &GroupMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipHistoryOrderField{
		Value: func(gmh *GroupMembershipHistory) (ent.Value, error) {
			return gmh.ID, nil
		},
		column: groupmembershiphistory.FieldID,
		toTerm: groupmembershiphistory.ByID,
		toCursor: func(gmh *GroupMembershipHistory) Cursor {
			return Cursor{ID: gmh.ID}
		},
	},
}

// ToEdge converts GroupMembershipHistory into GroupMembershipHistoryEdge.
func (gmh *GroupMembershipHistory) ToEdge(order *GroupMembershipHistoryOrder) *GroupMembershipHistoryEdge {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	return &GroupMembershipHistoryEdge{
		Node:   gmh,
		Cursor: order.Field.toCursor(gmh),
	}
}

// GroupSettingEdge is the edge representation of GroupSetting.
type GroupSettingEdge struct {
	Node   *GroupSetting `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupSettingConnection is the connection containing edges to GroupSetting.
type GroupSettingConnection struct {
	Edges      []*GroupSettingEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupSettingConnection) build(nodes []*GroupSetting, pager *groupsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingPaginateOption enables pagination customization.
type GroupSettingPaginateOption func(*groupsettingPager) error

// WithGroupSettingOrder configures pagination ordering.
func WithGroupSettingOrder(order []*GroupSettingOrder) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupSettingFilter configures pagination filter.
func WithGroupSettingFilter(filter func(*GroupSettingQuery) (*GroupSettingQuery, error)) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		if filter == nil {
			return errors.New("GroupSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettingPager struct {
	reverse bool
	order   []*GroupSettingOrder
	filter  func(*GroupSettingQuery) (*GroupSettingQuery, error)
}

func newGroupSettingPager(opts []GroupSettingPaginateOption, reverse bool) (*groupsettingPager, error) {
	pager := &groupsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupsettingPager) applyFilter(query *GroupSettingQuery) (*GroupSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettingPager) toCursor(gs *GroupSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(gs).Value)
	}
	return Cursor{ID: gs.ID, Value: cs_}
}

func (p *groupsettingPager) applyCursors(query *GroupSettingQuery, after, before *Cursor) (*GroupSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupsettingPager) applyOrder(query *GroupSettingQuery) *GroupSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupsettingPager) orderExpr(query *GroupSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSetting.
func (gs *GroupSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingPaginateOption,
) (*GroupSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gs, err = pager.applyFilter(gs); err != nil {
		return nil, err
	}
	conn := &GroupSettingConnection{Edges: []*GroupSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gs, err = pager.applyCursors(gs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gs = pager.applyOrder(gs)
	nodes, err := gs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupSettingOrderFieldCreatedAt orders GroupSetting by created_at.
	GroupSettingOrderFieldCreatedAt = &GroupSettingOrderField{
		Value: func(gs *GroupSetting) (ent.Value, error) {
			return gs.CreatedAt, nil
		},
		column: groupsetting.FieldCreatedAt,
		toTerm: groupsetting.ByCreatedAt,
		toCursor: func(gs *GroupSetting) Cursor {
			return Cursor{
				ID:    gs.ID,
				Value: gs.CreatedAt,
			}
		},
	}
	// GroupSettingOrderFieldUpdatedAt orders GroupSetting by updated_at.
	GroupSettingOrderFieldUpdatedAt = &GroupSettingOrderField{
		Value: func(gs *GroupSetting) (ent.Value, error) {
			return gs.UpdatedAt, nil
		},
		column: groupsetting.FieldUpdatedAt,
		toTerm: groupsetting.ByUpdatedAt,
		toCursor: func(gs *GroupSetting) Cursor {
			return Cursor{
				ID:    gs.ID,
				Value: gs.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupSettingOrderField) String() string {
	var str string
	switch f.column {
	case GroupSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GroupSettingOrderField", str)
	}
	return nil
}

// GroupSettingOrderField defines the ordering field of GroupSetting.
type GroupSettingOrderField struct {
	// Value extracts the ordering value from the given GroupSetting.
	Value    func(*GroupSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsetting.OrderOption
	toCursor func(*GroupSetting) Cursor
}

// GroupSettingOrder defines the ordering of GroupSetting.
type GroupSettingOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupSettingOrderField `json:"field"`
}

// DefaultGroupSettingOrder is the default ordering of GroupSetting.
var DefaultGroupSettingOrder = &GroupSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingOrderField{
		Value: func(gs *GroupSetting) (ent.Value, error) {
			return gs.ID, nil
		},
		column: groupsetting.FieldID,
		toTerm: groupsetting.ByID,
		toCursor: func(gs *GroupSetting) Cursor {
			return Cursor{ID: gs.ID}
		},
	},
}

// ToEdge converts GroupSetting into GroupSettingEdge.
func (gs *GroupSetting) ToEdge(order *GroupSettingOrder) *GroupSettingEdge {
	if order == nil {
		order = DefaultGroupSettingOrder
	}
	return &GroupSettingEdge{
		Node:   gs,
		Cursor: order.Field.toCursor(gs),
	}
}

// GroupSettingHistoryEdge is the edge representation of GroupSettingHistory.
type GroupSettingHistoryEdge struct {
	Node   *GroupSettingHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// GroupSettingHistoryConnection is the connection containing edges to GroupSettingHistory.
type GroupSettingHistoryConnection struct {
	Edges      []*GroupSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *GroupSettingHistoryConnection) build(nodes []*GroupSettingHistory, pager *groupsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingHistoryPaginateOption enables pagination customization.
type GroupSettingHistoryPaginateOption func(*groupsettinghistoryPager) error

// WithGroupSettingHistoryOrder configures pagination ordering.
func WithGroupSettingHistoryOrder(order *GroupSettingHistoryOrder) GroupSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	o := *order
	return func(pager *groupsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupSettingHistoryFilter configures pagination filter.
func WithGroupSettingHistoryFilter(filter func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)) GroupSettingHistoryPaginateOption {
	return func(pager *groupsettinghistoryPager) error {
		if filter == nil {
			return errors.New("GroupSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettinghistoryPager struct {
	reverse bool
	order   *GroupSettingHistoryOrder
	filter  func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)
}

func newGroupSettingHistoryPager(opts []GroupSettingHistoryPaginateOption, reverse bool) (*groupsettinghistoryPager, error) {
	pager := &groupsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupSettingHistoryOrder
	}
	return pager, nil
}

func (p *groupsettinghistoryPager) applyFilter(query *GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) toCursor(gsh *GroupSettingHistory) Cursor {
	return p.order.Field.toCursor(gsh)
}

func (p *groupsettinghistoryPager) applyCursors(query *GroupSettingHistoryQuery, after, before *Cursor) (*GroupSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) applyOrder(query *GroupSettingHistoryQuery) *GroupSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
		query = query.Order(DefaultGroupSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupsettinghistoryPager) orderExpr(query *GroupSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSettingHistory.
func (gsh *GroupSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingHistoryPaginateOption,
) (*GroupSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gsh, err = pager.applyFilter(gsh); err != nil {
		return nil, err
	}
	conn := &GroupSettingHistoryConnection{Edges: []*GroupSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gsh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gsh, err = pager.applyCursors(gsh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gsh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gsh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gsh = pager.applyOrder(gsh)
	nodes, err := gsh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupSettingHistoryOrderFieldHistoryTime orders GroupSettingHistory by history_time.
	GroupSettingHistoryOrderFieldHistoryTime = &GroupSettingHistoryOrderField{
		Value: func(gsh *GroupSettingHistory) (ent.Value, error) {
			return gsh.HistoryTime, nil
		},
		column: groupsettinghistory.FieldHistoryTime,
		toTerm: groupsettinghistory.ByHistoryTime,
		toCursor: func(gsh *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    gsh.ID,
				Value: gsh.HistoryTime,
			}
		},
	}
	// GroupSettingHistoryOrderFieldCreatedAt orders GroupSettingHistory by created_at.
	GroupSettingHistoryOrderFieldCreatedAt = &GroupSettingHistoryOrderField{
		Value: func(gsh *GroupSettingHistory) (ent.Value, error) {
			return gsh.CreatedAt, nil
		},
		column: groupsettinghistory.FieldCreatedAt,
		toTerm: groupsettinghistory.ByCreatedAt,
		toCursor: func(gsh *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    gsh.ID,
				Value: gsh.CreatedAt,
			}
		},
	}
	// GroupSettingHistoryOrderFieldUpdatedAt orders GroupSettingHistory by updated_at.
	GroupSettingHistoryOrderFieldUpdatedAt = &GroupSettingHistoryOrderField{
		Value: func(gsh *GroupSettingHistory) (ent.Value, error) {
			return gsh.UpdatedAt, nil
		},
		column: groupsettinghistory.FieldUpdatedAt,
		toTerm: groupsettinghistory.ByUpdatedAt,
		toCursor: func(gsh *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    gsh.ID,
				Value: gsh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GroupSettingHistoryOrderField", str)
	}
	return nil
}

// GroupSettingHistoryOrderField defines the ordering field of GroupSettingHistory.
type GroupSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupSettingHistory.
	Value    func(*GroupSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsettinghistory.OrderOption
	toCursor func(*GroupSettingHistory) Cursor
}

// GroupSettingHistoryOrder defines the ordering of GroupSettingHistory.
type GroupSettingHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *GroupSettingHistoryOrderField `json:"field"`
}

// DefaultGroupSettingHistoryOrder is the default ordering of GroupSettingHistory.
var DefaultGroupSettingHistoryOrder = &GroupSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingHistoryOrderField{
		Value: func(gsh *GroupSettingHistory) (ent.Value, error) {
			return gsh.ID, nil
		},
		column: groupsettinghistory.FieldID,
		toTerm: groupsettinghistory.ByID,
		toCursor: func(gsh *GroupSettingHistory) Cursor {
			return Cursor{ID: gsh.ID}
		},
	},
}

// ToEdge converts GroupSettingHistory into GroupSettingHistoryEdge.
func (gsh *GroupSettingHistory) ToEdge(order *GroupSettingHistoryOrder) *GroupSettingHistoryEdge {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	return &GroupSettingHistoryEdge{
		Node:   gsh,
		Cursor: order.Field.toCursor(gsh),
	}
}

// HushEdge is the edge representation of Hush.
type HushEdge struct {
	Node   *Hush  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HushConnection is the connection containing edges to Hush.
type HushConnection struct {
	Edges      []*HushEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *HushConnection) build(nodes []*Hush, pager *hushPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Hush
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Hush {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Hush {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushPaginateOption enables pagination customization.
type HushPaginateOption func(*hushPager) error

// WithHushOrder configures pagination ordering.
func WithHushOrder(order []*HushOrder) HushPaginateOption {
	return func(pager *hushPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithHushFilter configures pagination filter.
func WithHushFilter(filter func(*HushQuery) (*HushQuery, error)) HushPaginateOption {
	return func(pager *hushPager) error {
		if filter == nil {
			return errors.New("HushQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushPager struct {
	reverse bool
	order   []*HushOrder
	filter  func(*HushQuery) (*HushQuery, error)
}

func newHushPager(opts []HushPaginateOption, reverse bool) (*hushPager, error) {
	pager := &hushPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *hushPager) applyFilter(query *HushQuery) (*HushQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushPager) toCursor(h *Hush) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(h).Value)
	}
	return Cursor{ID: h.ID, Value: cs_}
}

func (p *hushPager) applyCursors(query *HushQuery, after, before *Cursor) (*HushQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultHushOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *hushPager) applyOrder(query *HushQuery) *HushQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultHushOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultHushOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *hushPager) orderExpr(query *HushQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultHushOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Hush.
func (h *HushQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushPaginateOption,
) (*HushConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}
	conn := &HushConnection{Edges: []*HushEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := h.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if h, err = pager.applyCursors(h, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		h.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := h.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	h = pager.applyOrder(h)
	nodes, err := h.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushOrderFieldCreatedAt orders Hush by created_at.
	HushOrderFieldCreatedAt = &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.CreatedAt, nil
		},
		column: hush.FieldCreatedAt,
		toTerm: hush.ByCreatedAt,
		toCursor: func(h *Hush) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.CreatedAt,
			}
		},
	}
	// HushOrderFieldUpdatedAt orders Hush by updated_at.
	HushOrderFieldUpdatedAt = &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.UpdatedAt, nil
		},
		column: hush.FieldUpdatedAt,
		toTerm: hush.ByUpdatedAt,
		toCursor: func(h *Hush) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.UpdatedAt,
			}
		},
	}
	// HushOrderFieldName orders Hush by name.
	HushOrderFieldName = &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.Name, nil
		},
		column: hush.FieldName,
		toTerm: hush.ByName,
		toCursor: func(h *Hush) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.Name,
			}
		},
	}
	// HushOrderFieldKind orders Hush by kind.
	HushOrderFieldKind = &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.Kind, nil
		},
		column: hush.FieldKind,
		toTerm: hush.ByKind,
		toCursor: func(h *Hush) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushOrderField) String() string {
	var str string
	switch f.column {
	case HushOrderFieldCreatedAt.column:
		str = "created_at"
	case HushOrderFieldUpdatedAt.column:
		str = "updated_at"
	case HushOrderFieldName.column:
		str = "name"
	case HushOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HushOrderFieldCreatedAt
	case "updated_at":
		*f = *HushOrderFieldUpdatedAt
	case "name":
		*f = *HushOrderFieldName
	case "kind":
		*f = *HushOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

// HushOrderField defines the ordering field of Hush.
type HushOrderField struct {
	// Value extracts the ordering value from the given Hush.
	Value    func(*Hush) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hush.OrderOption
	toCursor func(*Hush) Cursor
}

// HushOrder defines the ordering of Hush.
type HushOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HushOrderField `json:"field"`
}

// DefaultHushOrder is the default ordering of Hush.
var DefaultHushOrder = &HushOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.ID, nil
		},
		column: hush.FieldID,
		toTerm: hush.ByID,
		toCursor: func(h *Hush) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Hush into HushEdge.
func (h *Hush) ToEdge(order *HushOrder) *HushEdge {
	if order == nil {
		order = DefaultHushOrder
	}
	return &HushEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// HushHistoryEdge is the edge representation of HushHistory.
type HushHistoryEdge struct {
	Node   *HushHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// HushHistoryConnection is the connection containing edges to HushHistory.
type HushHistoryConnection struct {
	Edges      []*HushHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *HushHistoryConnection) build(nodes []*HushHistory, pager *hushhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *HushHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HushHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HushHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushHistoryPaginateOption enables pagination customization.
type HushHistoryPaginateOption func(*hushhistoryPager) error

// WithHushHistoryOrder configures pagination ordering.
func WithHushHistoryOrder(order *HushHistoryOrder) HushHistoryPaginateOption {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	o := *order
	return func(pager *hushhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHushHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHushHistoryFilter configures pagination filter.
func WithHushHistoryFilter(filter func(*HushHistoryQuery) (*HushHistoryQuery, error)) HushHistoryPaginateOption {
	return func(pager *hushhistoryPager) error {
		if filter == nil {
			return errors.New("HushHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushhistoryPager struct {
	reverse bool
	order   *HushHistoryOrder
	filter  func(*HushHistoryQuery) (*HushHistoryQuery, error)
}

func newHushHistoryPager(opts []HushHistoryPaginateOption, reverse bool) (*hushhistoryPager, error) {
	pager := &hushhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHushHistoryOrder
	}
	return pager, nil
}

func (p *hushhistoryPager) applyFilter(query *HushHistoryQuery) (*HushHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushhistoryPager) toCursor(hh *HushHistory) Cursor {
	return p.order.Field.toCursor(hh)
}

func (p *hushhistoryPager) applyCursors(query *HushHistoryQuery, after, before *Cursor) (*HushHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHushHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hushhistoryPager) applyOrder(query *HushHistoryQuery) *HushHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHushHistoryOrder.Field {
		query = query.Order(DefaultHushHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hushhistoryPager) orderExpr(query *HushHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHushHistoryOrder.Field {
			b.Comma().Ident(DefaultHushHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HushHistory.
func (hh *HushHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushHistoryPaginateOption,
) (*HushHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hh, err = pager.applyFilter(hh); err != nil {
		return nil, err
	}
	conn := &HushHistoryConnection{Edges: []*HushHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := hh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if hh, err = pager.applyCursors(hh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		hh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	hh = pager.applyOrder(hh)
	nodes, err := hh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushHistoryOrderFieldHistoryTime orders HushHistory by history_time.
	HushHistoryOrderFieldHistoryTime = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.HistoryTime, nil
		},
		column: hushhistory.FieldHistoryTime,
		toTerm: hushhistory.ByHistoryTime,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.HistoryTime,
			}
		},
	}
	// HushHistoryOrderFieldCreatedAt orders HushHistory by created_at.
	HushHistoryOrderFieldCreatedAt = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.CreatedAt, nil
		},
		column: hushhistory.FieldCreatedAt,
		toTerm: hushhistory.ByCreatedAt,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.CreatedAt,
			}
		},
	}
	// HushHistoryOrderFieldUpdatedAt orders HushHistory by updated_at.
	HushHistoryOrderFieldUpdatedAt = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.UpdatedAt, nil
		},
		column: hushhistory.FieldUpdatedAt,
		toTerm: hushhistory.ByUpdatedAt,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.UpdatedAt,
			}
		},
	}
	// HushHistoryOrderFieldName orders HushHistory by name.
	HushHistoryOrderFieldName = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.Name, nil
		},
		column: hushhistory.FieldName,
		toTerm: hushhistory.ByName,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.Name,
			}
		},
	}
	// HushHistoryOrderFieldKind orders HushHistory by kind.
	HushHistoryOrderFieldKind = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.Kind, nil
		},
		column: hushhistory.FieldKind,
		toTerm: hushhistory.ByKind,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushHistoryOrderField) String() string {
	var str string
	switch f.column {
	case HushHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case HushHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case HushHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case HushHistoryOrderFieldName.column:
		str = "name"
	case HushHistoryOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *HushHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *HushHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *HushHistoryOrderFieldUpdatedAt
	case "name":
		*f = *HushHistoryOrderFieldName
	case "kind":
		*f = *HushHistoryOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

// HushHistoryOrderField defines the ordering field of HushHistory.
type HushHistoryOrderField struct {
	// Value extracts the ordering value from the given HushHistory.
	Value    func(*HushHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hushhistory.OrderOption
	toCursor func(*HushHistory) Cursor
}

// HushHistoryOrder defines the ordering of HushHistory.
type HushHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *HushHistoryOrderField `json:"field"`
}

// DefaultHushHistoryOrder is the default ordering of HushHistory.
var DefaultHushHistoryOrder = &HushHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.ID, nil
		},
		column: hushhistory.FieldID,
		toTerm: hushhistory.ByID,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{ID: hh.ID}
		},
	},
}

// ToEdge converts HushHistory into HushHistoryEdge.
func (hh *HushHistory) ToEdge(order *HushHistoryOrder) *HushHistoryEdge {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	return &HushHistoryEdge{
		Node:   hh,
		Cursor: order.Field.toCursor(hh),
	}
}

// IntegrationEdge is the edge representation of Integration.
type IntegrationEdge struct {
	Node   *Integration `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// IntegrationConnection is the connection containing edges to Integration.
type IntegrationConnection struct {
	Edges      []*IntegrationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *IntegrationConnection) build(nodes []*Integration, pager *integrationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Integration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Integration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Integration {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationPaginateOption enables pagination customization.
type IntegrationPaginateOption func(*integrationPager) error

// WithIntegrationOrder configures pagination ordering.
func WithIntegrationOrder(order []*IntegrationOrder) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithIntegrationFilter configures pagination filter.
func WithIntegrationFilter(filter func(*IntegrationQuery) (*IntegrationQuery, error)) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		if filter == nil {
			return errors.New("IntegrationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationPager struct {
	reverse bool
	order   []*IntegrationOrder
	filter  func(*IntegrationQuery) (*IntegrationQuery, error)
}

func newIntegrationPager(opts []IntegrationPaginateOption, reverse bool) (*integrationPager, error) {
	pager := &integrationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *integrationPager) applyFilter(query *IntegrationQuery) (*IntegrationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationPager) toCursor(i *Integration) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs_}
}

func (p *integrationPager) applyCursors(query *IntegrationQuery, after, before *Cursor) (*IntegrationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultIntegrationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *integrationPager) applyOrder(query *IntegrationQuery) *IntegrationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultIntegrationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultIntegrationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *integrationPager) orderExpr(query *IntegrationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultIntegrationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Integration.
func (i *IntegrationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationPaginateOption,
) (*IntegrationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IntegrationConnection{Edges: []*IntegrationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := i.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationOrderFieldCreatedAt orders Integration by created_at.
	IntegrationOrderFieldCreatedAt = &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.CreatedAt, nil
		},
		column: integration.FieldCreatedAt,
		toTerm: integration.ByCreatedAt,
		toCursor: func(i *Integration) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// IntegrationOrderFieldUpdatedAt orders Integration by updated_at.
	IntegrationOrderFieldUpdatedAt = &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.UpdatedAt, nil
		},
		column: integration.FieldUpdatedAt,
		toTerm: integration.ByUpdatedAt,
		toCursor: func(i *Integration) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.UpdatedAt,
			}
		},
	}
	// IntegrationOrderFieldName orders Integration by name.
	IntegrationOrderFieldName = &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.Name, nil
		},
		column: integration.FieldName,
		toTerm: integration.ByName,
		toCursor: func(i *Integration) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Name,
			}
		},
	}
	// IntegrationOrderFieldKind orders Integration by kind.
	IntegrationOrderFieldKind = &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.Kind, nil
		},
		column: integration.FieldKind,
		toTerm: integration.ByKind,
		toCursor: func(i *Integration) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationOrderFieldCreatedAt.column:
		str = "created_at"
	case IntegrationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IntegrationOrderFieldName.column:
		str = "name"
	case IntegrationOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *IntegrationOrderFieldCreatedAt
	case "updated_at":
		*f = *IntegrationOrderFieldUpdatedAt
	case "name":
		*f = *IntegrationOrderFieldName
	case "kind":
		*f = *IntegrationOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

// IntegrationOrderField defines the ordering field of Integration.
type IntegrationOrderField struct {
	// Value extracts the ordering value from the given Integration.
	Value    func(*Integration) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integration.OrderOption
	toCursor func(*Integration) Cursor
}

// IntegrationOrder defines the ordering of Integration.
type IntegrationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *IntegrationOrderField `json:"field"`
}

// DefaultIntegrationOrder is the default ordering of Integration.
var DefaultIntegrationOrder = &IntegrationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.ID, nil
		},
		column: integration.FieldID,
		toTerm: integration.ByID,
		toCursor: func(i *Integration) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Integration into IntegrationEdge.
func (i *Integration) ToEdge(order *IntegrationOrder) *IntegrationEdge {
	if order == nil {
		order = DefaultIntegrationOrder
	}
	return &IntegrationEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// IntegrationHistoryEdge is the edge representation of IntegrationHistory.
type IntegrationHistoryEdge struct {
	Node   *IntegrationHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// IntegrationHistoryConnection is the connection containing edges to IntegrationHistory.
type IntegrationHistoryConnection struct {
	Edges      []*IntegrationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *IntegrationHistoryConnection) build(nodes []*IntegrationHistory, pager *integrationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *IntegrationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationHistoryPaginateOption enables pagination customization.
type IntegrationHistoryPaginateOption func(*integrationhistoryPager) error

// WithIntegrationHistoryOrder configures pagination ordering.
func WithIntegrationHistoryOrder(order *IntegrationHistoryOrder) IntegrationHistoryPaginateOption {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	o := *order
	return func(pager *integrationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIntegrationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIntegrationHistoryFilter configures pagination filter.
func WithIntegrationHistoryFilter(filter func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)) IntegrationHistoryPaginateOption {
	return func(pager *integrationhistoryPager) error {
		if filter == nil {
			return errors.New("IntegrationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationhistoryPager struct {
	reverse bool
	order   *IntegrationHistoryOrder
	filter  func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)
}

func newIntegrationHistoryPager(opts []IntegrationHistoryPaginateOption, reverse bool) (*integrationhistoryPager, error) {
	pager := &integrationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIntegrationHistoryOrder
	}
	return pager, nil
}

func (p *integrationhistoryPager) applyFilter(query *IntegrationHistoryQuery) (*IntegrationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationhistoryPager) toCursor(ih *IntegrationHistory) Cursor {
	return p.order.Field.toCursor(ih)
}

func (p *integrationhistoryPager) applyCursors(query *IntegrationHistoryQuery, after, before *Cursor) (*IntegrationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIntegrationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *integrationhistoryPager) applyOrder(query *IntegrationHistoryQuery) *IntegrationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIntegrationHistoryOrder.Field {
		query = query.Order(DefaultIntegrationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *integrationhistoryPager) orderExpr(query *IntegrationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIntegrationHistoryOrder.Field {
			b.Comma().Ident(DefaultIntegrationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IntegrationHistory.
func (ih *IntegrationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationHistoryPaginateOption,
) (*IntegrationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ih, err = pager.applyFilter(ih); err != nil {
		return nil, err
	}
	conn := &IntegrationHistoryConnection{Edges: []*IntegrationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ih.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ih, err = pager.applyCursors(ih, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ih.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ih.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ih = pager.applyOrder(ih)
	nodes, err := ih.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationHistoryOrderFieldHistoryTime orders IntegrationHistory by history_time.
	IntegrationHistoryOrderFieldHistoryTime = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.HistoryTime, nil
		},
		column: integrationhistory.FieldHistoryTime,
		toTerm: integrationhistory.ByHistoryTime,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.HistoryTime,
			}
		},
	}
	// IntegrationHistoryOrderFieldCreatedAt orders IntegrationHistory by created_at.
	IntegrationHistoryOrderFieldCreatedAt = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.CreatedAt, nil
		},
		column: integrationhistory.FieldCreatedAt,
		toTerm: integrationhistory.ByCreatedAt,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.CreatedAt,
			}
		},
	}
	// IntegrationHistoryOrderFieldUpdatedAt orders IntegrationHistory by updated_at.
	IntegrationHistoryOrderFieldUpdatedAt = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.UpdatedAt, nil
		},
		column: integrationhistory.FieldUpdatedAt,
		toTerm: integrationhistory.ByUpdatedAt,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.UpdatedAt,
			}
		},
	}
	// IntegrationHistoryOrderFieldName orders IntegrationHistory by name.
	IntegrationHistoryOrderFieldName = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.Name, nil
		},
		column: integrationhistory.FieldName,
		toTerm: integrationhistory.ByName,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.Name,
			}
		},
	}
	// IntegrationHistoryOrderFieldKind orders IntegrationHistory by kind.
	IntegrationHistoryOrderFieldKind = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.Kind, nil
		},
		column: integrationhistory.FieldKind,
		toTerm: integrationhistory.ByKind,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case IntegrationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case IntegrationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IntegrationHistoryOrderFieldName.column:
		str = "name"
	case IntegrationHistoryOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *IntegrationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *IntegrationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *IntegrationHistoryOrderFieldUpdatedAt
	case "name":
		*f = *IntegrationHistoryOrderFieldName
	case "kind":
		*f = *IntegrationHistoryOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

// IntegrationHistoryOrderField defines the ordering field of IntegrationHistory.
type IntegrationHistoryOrderField struct {
	// Value extracts the ordering value from the given IntegrationHistory.
	Value    func(*IntegrationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integrationhistory.OrderOption
	toCursor func(*IntegrationHistory) Cursor
}

// IntegrationHistoryOrder defines the ordering of IntegrationHistory.
type IntegrationHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *IntegrationHistoryOrderField `json:"field"`
}

// DefaultIntegrationHistoryOrder is the default ordering of IntegrationHistory.
var DefaultIntegrationHistoryOrder = &IntegrationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.ID, nil
		},
		column: integrationhistory.FieldID,
		toTerm: integrationhistory.ByID,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{ID: ih.ID}
		},
	},
}

// ToEdge converts IntegrationHistory into IntegrationHistoryEdge.
func (ih *IntegrationHistory) ToEdge(order *IntegrationHistoryOrder) *IntegrationHistoryEdge {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	return &IntegrationHistoryEdge{
		Node:   ih,
		Cursor: order.Field.toCursor(ih),
	}
}

// InternalPolicyEdge is the edge representation of InternalPolicy.
type InternalPolicyEdge struct {
	Node   *InternalPolicy `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// InternalPolicyConnection is the connection containing edges to InternalPolicy.
type InternalPolicyConnection struct {
	Edges      []*InternalPolicyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *InternalPolicyConnection) build(nodes []*InternalPolicy, pager *internalpolicyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *InternalPolicy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicy {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyPaginateOption enables pagination customization.
type InternalPolicyPaginateOption func(*internalpolicyPager) error

// WithInternalPolicyOrder configures pagination ordering.
func WithInternalPolicyOrder(order []*InternalPolicyOrder) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInternalPolicyFilter configures pagination filter.
func WithInternalPolicyFilter(filter func(*InternalPolicyQuery) (*InternalPolicyQuery, error)) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		if filter == nil {
			return errors.New("InternalPolicyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyPager struct {
	reverse bool
	order   []*InternalPolicyOrder
	filter  func(*InternalPolicyQuery) (*InternalPolicyQuery, error)
}

func newInternalPolicyPager(opts []InternalPolicyPaginateOption, reverse bool) (*internalpolicyPager, error) {
	pager := &internalpolicyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *internalpolicyPager) applyFilter(query *InternalPolicyQuery) (*InternalPolicyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyPager) toCursor(ip *InternalPolicy) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(ip).Value)
	}
	return Cursor{ID: ip.ID, Value: cs_}
}

func (p *internalpolicyPager) applyCursors(query *InternalPolicyQuery, after, before *Cursor) (*InternalPolicyQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInternalPolicyOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *internalpolicyPager) applyOrder(query *InternalPolicyQuery) *InternalPolicyQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInternalPolicyOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInternalPolicyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *internalpolicyPager) orderExpr(query *InternalPolicyQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInternalPolicyOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicy.
func (ip *InternalPolicyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyPaginateOption,
) (*InternalPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ip, err = pager.applyFilter(ip); err != nil {
		return nil, err
	}
	conn := &InternalPolicyConnection{Edges: []*InternalPolicyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ip.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ip, err = pager.applyCursors(ip, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ip.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ip.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ip = pager.applyOrder(ip)
	nodes, err := ip.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InternalPolicyOrderFieldCreatedAt orders InternalPolicy by created_at.
	InternalPolicyOrderFieldCreatedAt = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.CreatedAt, nil
		},
		column: internalpolicy.FieldCreatedAt,
		toTerm: internalpolicy.ByCreatedAt,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.CreatedAt,
			}
		},
	}
	// InternalPolicyOrderFieldUpdatedAt orders InternalPolicy by updated_at.
	InternalPolicyOrderFieldUpdatedAt = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.UpdatedAt, nil
		},
		column: internalpolicy.FieldUpdatedAt,
		toTerm: internalpolicy.ByUpdatedAt,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.UpdatedAt,
			}
		},
	}
	// InternalPolicyOrderFieldRevision orders InternalPolicy by revision.
	InternalPolicyOrderFieldRevision = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.Revision, nil
		},
		column: internalpolicy.FieldRevision,
		toTerm: internalpolicy.ByRevision,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.Revision,
			}
		},
	}
	// InternalPolicyOrderFieldName orders InternalPolicy by name.
	InternalPolicyOrderFieldName = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.Name, nil
		},
		column: internalpolicy.FieldName,
		toTerm: internalpolicy.ByName,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.Name,
			}
		},
	}
	// InternalPolicyOrderFieldStatus orders InternalPolicy by status.
	InternalPolicyOrderFieldStatus = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.Status, nil
		},
		column: internalpolicy.FieldStatus,
		toTerm: internalpolicy.ByStatus,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.Status,
			}
		},
	}
	// InternalPolicyOrderFieldReviewDue orders InternalPolicy by review_due.
	InternalPolicyOrderFieldReviewDue = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.ReviewDue, nil
		},
		column: internalpolicy.FieldReviewDue,
		toTerm: internalpolicy.ByReviewDue,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.ReviewDue,
			}
		},
	}
	// InternalPolicyOrderFieldReviewFrequency orders InternalPolicy by review_frequency.
	InternalPolicyOrderFieldReviewFrequency = &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.ReviewFrequency, nil
		},
		column: internalpolicy.FieldReviewFrequency,
		toTerm: internalpolicy.ByReviewFrequency,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{
				ID:    ip.ID,
				Value: ip.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InternalPolicyOrderField) String() string {
	var str string
	switch f.column {
	case InternalPolicyOrderFieldCreatedAt.column:
		str = "created_at"
	case InternalPolicyOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InternalPolicyOrderFieldRevision.column:
		str = "revision"
	case InternalPolicyOrderFieldName.column:
		str = "name"
	case InternalPolicyOrderFieldStatus.column:
		str = "STATUS"
	case InternalPolicyOrderFieldReviewDue.column:
		str = "review_due"
	case InternalPolicyOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InternalPolicyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InternalPolicyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InternalPolicyOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *InternalPolicyOrderFieldCreatedAt
	case "updated_at":
		*f = *InternalPolicyOrderFieldUpdatedAt
	case "revision":
		*f = *InternalPolicyOrderFieldRevision
	case "name":
		*f = *InternalPolicyOrderFieldName
	case "STATUS":
		*f = *InternalPolicyOrderFieldStatus
	case "review_due":
		*f = *InternalPolicyOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *InternalPolicyOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid InternalPolicyOrderField", str)
	}
	return nil
}

// InternalPolicyOrderField defines the ordering field of InternalPolicy.
type InternalPolicyOrderField struct {
	// Value extracts the ordering value from the given InternalPolicy.
	Value    func(*InternalPolicy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicy.OrderOption
	toCursor func(*InternalPolicy) Cursor
}

// InternalPolicyOrder defines the ordering of InternalPolicy.
type InternalPolicyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *InternalPolicyOrderField `json:"field"`
}

// DefaultInternalPolicyOrder is the default ordering of InternalPolicy.
var DefaultInternalPolicyOrder = &InternalPolicyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.ID, nil
		},
		column: internalpolicy.FieldID,
		toTerm: internalpolicy.ByID,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{ID: ip.ID}
		},
	},
}

// ToEdge converts InternalPolicy into InternalPolicyEdge.
func (ip *InternalPolicy) ToEdge(order *InternalPolicyOrder) *InternalPolicyEdge {
	if order == nil {
		order = DefaultInternalPolicyOrder
	}
	return &InternalPolicyEdge{
		Node:   ip,
		Cursor: order.Field.toCursor(ip),
	}
}

// InternalPolicyHistoryEdge is the edge representation of InternalPolicyHistory.
type InternalPolicyHistoryEdge struct {
	Node   *InternalPolicyHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// InternalPolicyHistoryConnection is the connection containing edges to InternalPolicyHistory.
type InternalPolicyHistoryConnection struct {
	Edges      []*InternalPolicyHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *InternalPolicyHistoryConnection) build(nodes []*InternalPolicyHistory, pager *internalpolicyhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *InternalPolicyHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyHistoryPaginateOption enables pagination customization.
type InternalPolicyHistoryPaginateOption func(*internalpolicyhistoryPager) error

// WithInternalPolicyHistoryOrder configures pagination ordering.
func WithInternalPolicyHistoryOrder(order *InternalPolicyHistoryOrder) InternalPolicyHistoryPaginateOption {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	o := *order
	return func(pager *internalpolicyhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInternalPolicyHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInternalPolicyHistoryFilter configures pagination filter.
func WithInternalPolicyHistoryFilter(filter func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)) InternalPolicyHistoryPaginateOption {
	return func(pager *internalpolicyhistoryPager) error {
		if filter == nil {
			return errors.New("InternalPolicyHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyhistoryPager struct {
	reverse bool
	order   *InternalPolicyHistoryOrder
	filter  func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)
}

func newInternalPolicyHistoryPager(opts []InternalPolicyHistoryPaginateOption, reverse bool) (*internalpolicyhistoryPager, error) {
	pager := &internalpolicyhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInternalPolicyHistoryOrder
	}
	return pager, nil
}

func (p *internalpolicyhistoryPager) applyFilter(query *InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) toCursor(iph *InternalPolicyHistory) Cursor {
	return p.order.Field.toCursor(iph)
}

func (p *internalpolicyhistoryPager) applyCursors(query *InternalPolicyHistoryQuery, after, before *Cursor) (*InternalPolicyHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInternalPolicyHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) applyOrder(query *InternalPolicyHistoryQuery) *InternalPolicyHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
		query = query.Order(DefaultInternalPolicyHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *internalpolicyhistoryPager) orderExpr(query *InternalPolicyHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
			b.Comma().Ident(DefaultInternalPolicyHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicyHistory.
func (iph *InternalPolicyHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyHistoryPaginateOption,
) (*InternalPolicyHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if iph, err = pager.applyFilter(iph); err != nil {
		return nil, err
	}
	conn := &InternalPolicyHistoryConnection{Edges: []*InternalPolicyHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := iph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if iph, err = pager.applyCursors(iph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		iph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := iph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	iph = pager.applyOrder(iph)
	nodes, err := iph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InternalPolicyHistoryOrderFieldHistoryTime orders InternalPolicyHistory by history_time.
	InternalPolicyHistoryOrderFieldHistoryTime = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.HistoryTime, nil
		},
		column: internalpolicyhistory.FieldHistoryTime,
		toTerm: internalpolicyhistory.ByHistoryTime,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.HistoryTime,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldCreatedAt orders InternalPolicyHistory by created_at.
	InternalPolicyHistoryOrderFieldCreatedAt = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.CreatedAt, nil
		},
		column: internalpolicyhistory.FieldCreatedAt,
		toTerm: internalpolicyhistory.ByCreatedAt,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.CreatedAt,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldUpdatedAt orders InternalPolicyHistory by updated_at.
	InternalPolicyHistoryOrderFieldUpdatedAt = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.UpdatedAt, nil
		},
		column: internalpolicyhistory.FieldUpdatedAt,
		toTerm: internalpolicyhistory.ByUpdatedAt,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.UpdatedAt,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldRevision orders InternalPolicyHistory by revision.
	InternalPolicyHistoryOrderFieldRevision = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.Revision, nil
		},
		column: internalpolicyhistory.FieldRevision,
		toTerm: internalpolicyhistory.ByRevision,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.Revision,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldName orders InternalPolicyHistory by name.
	InternalPolicyHistoryOrderFieldName = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.Name, nil
		},
		column: internalpolicyhistory.FieldName,
		toTerm: internalpolicyhistory.ByName,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.Name,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldStatus orders InternalPolicyHistory by status.
	InternalPolicyHistoryOrderFieldStatus = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.Status, nil
		},
		column: internalpolicyhistory.FieldStatus,
		toTerm: internalpolicyhistory.ByStatus,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.Status,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldReviewDue orders InternalPolicyHistory by review_due.
	InternalPolicyHistoryOrderFieldReviewDue = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.ReviewDue, nil
		},
		column: internalpolicyhistory.FieldReviewDue,
		toTerm: internalpolicyhistory.ByReviewDue,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.ReviewDue,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldReviewFrequency orders InternalPolicyHistory by review_frequency.
	InternalPolicyHistoryOrderFieldReviewFrequency = &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.ReviewFrequency, nil
		},
		column: internalpolicyhistory.FieldReviewFrequency,
		toTerm: internalpolicyhistory.ByReviewFrequency,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    iph.ID,
				Value: iph.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InternalPolicyHistoryOrderField) String() string {
	var str string
	switch f.column {
	case InternalPolicyHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case InternalPolicyHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case InternalPolicyHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InternalPolicyHistoryOrderFieldRevision.column:
		str = "revision"
	case InternalPolicyHistoryOrderFieldName.column:
		str = "name"
	case InternalPolicyHistoryOrderFieldStatus.column:
		str = "STATUS"
	case InternalPolicyHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case InternalPolicyHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InternalPolicyHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InternalPolicyHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InternalPolicyHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *InternalPolicyHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *InternalPolicyHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *InternalPolicyHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *InternalPolicyHistoryOrderFieldRevision
	case "name":
		*f = *InternalPolicyHistoryOrderFieldName
	case "STATUS":
		*f = *InternalPolicyHistoryOrderFieldStatus
	case "review_due":
		*f = *InternalPolicyHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *InternalPolicyHistoryOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid InternalPolicyHistoryOrderField", str)
	}
	return nil
}

// InternalPolicyHistoryOrderField defines the ordering field of InternalPolicyHistory.
type InternalPolicyHistoryOrderField struct {
	// Value extracts the ordering value from the given InternalPolicyHistory.
	Value    func(*InternalPolicyHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicyhistory.OrderOption
	toCursor func(*InternalPolicyHistory) Cursor
}

// InternalPolicyHistoryOrder defines the ordering of InternalPolicyHistory.
type InternalPolicyHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *InternalPolicyHistoryOrderField `json:"field"`
}

// DefaultInternalPolicyHistoryOrder is the default ordering of InternalPolicyHistory.
var DefaultInternalPolicyHistoryOrder = &InternalPolicyHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.ID, nil
		},
		column: internalpolicyhistory.FieldID,
		toTerm: internalpolicyhistory.ByID,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{ID: iph.ID}
		},
	},
}

// ToEdge converts InternalPolicyHistory into InternalPolicyHistoryEdge.
func (iph *InternalPolicyHistory) ToEdge(order *InternalPolicyHistoryOrder) *InternalPolicyHistoryEdge {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	return &InternalPolicyHistoryEdge{
		Node:   iph,
		Cursor: order.Field.toCursor(iph),
	}
}

// InviteEdge is the edge representation of Invite.
type InviteEdge struct {
	Node   *Invite `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// InviteConnection is the connection containing edges to Invite.
type InviteConnection struct {
	Edges      []*InviteEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *InviteConnection) build(nodes []*Invite, pager *invitePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Invite
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Invite {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Invite {
			return nodes[i]
		}
	}
	c.Edges = make([]*InviteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InviteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InvitePaginateOption enables pagination customization.
type InvitePaginateOption func(*invitePager) error

// WithInviteOrder configures pagination ordering.
func WithInviteOrder(order []*InviteOrder) InvitePaginateOption {
	return func(pager *invitePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInviteFilter configures pagination filter.
func WithInviteFilter(filter func(*InviteQuery) (*InviteQuery, error)) InvitePaginateOption {
	return func(pager *invitePager) error {
		if filter == nil {
			return errors.New("InviteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type invitePager struct {
	reverse bool
	order   []*InviteOrder
	filter  func(*InviteQuery) (*InviteQuery, error)
}

func newInvitePager(opts []InvitePaginateOption, reverse bool) (*invitePager, error) {
	pager := &invitePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *invitePager) applyFilter(query *InviteQuery) (*InviteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *invitePager) toCursor(i *Invite) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs_}
}

func (p *invitePager) applyCursors(query *InviteQuery, after, before *Cursor) (*InviteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInviteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *invitePager) applyOrder(query *InviteQuery) *InviteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInviteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInviteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *invitePager) orderExpr(query *InviteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInviteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Invite.
func (i *InviteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InvitePaginateOption,
) (*InviteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInvitePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &InviteConnection{Edges: []*InviteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := i.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InviteOrderFieldCreatedAt orders Invite by created_at.
	InviteOrderFieldCreatedAt = &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.CreatedAt, nil
		},
		column: invite.FieldCreatedAt,
		toTerm: invite.ByCreatedAt,
		toCursor: func(i *Invite) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// InviteOrderFieldUpdatedAt orders Invite by updated_at.
	InviteOrderFieldUpdatedAt = &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.UpdatedAt, nil
		},
		column: invite.FieldUpdatedAt,
		toTerm: invite.ByUpdatedAt,
		toCursor: func(i *Invite) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.UpdatedAt,
			}
		},
	}
	// InviteOrderFieldExpires orders Invite by expires.
	InviteOrderFieldExpires = &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.Expires, nil
		},
		column: invite.FieldExpires,
		toTerm: invite.ByExpires,
		toCursor: func(i *Invite) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Expires,
			}
		},
	}
	// InviteOrderFieldStatus orders Invite by status.
	InviteOrderFieldStatus = &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.Status, nil
		},
		column: invite.FieldStatus,
		toTerm: invite.ByStatus,
		toCursor: func(i *Invite) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Status,
			}
		},
	}
	// InviteOrderFieldSendAttempts orders Invite by send_attempts.
	InviteOrderFieldSendAttempts = &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.SendAttempts, nil
		},
		column: invite.FieldSendAttempts,
		toTerm: invite.BySendAttempts,
		toCursor: func(i *Invite) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.SendAttempts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InviteOrderField) String() string {
	var str string
	switch f.column {
	case InviteOrderFieldCreatedAt.column:
		str = "created_at"
	case InviteOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InviteOrderFieldExpires.column:
		str = "expires"
	case InviteOrderFieldStatus.column:
		str = "STATUS"
	case InviteOrderFieldSendAttempts.column:
		str = "send_attempts"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InviteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InviteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InviteOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *InviteOrderFieldCreatedAt
	case "updated_at":
		*f = *InviteOrderFieldUpdatedAt
	case "expires":
		*f = *InviteOrderFieldExpires
	case "STATUS":
		*f = *InviteOrderFieldStatus
	case "send_attempts":
		*f = *InviteOrderFieldSendAttempts
	default:
		return fmt.Errorf("%s is not a valid InviteOrderField", str)
	}
	return nil
}

// InviteOrderField defines the ordering field of Invite.
type InviteOrderField struct {
	// Value extracts the ordering value from the given Invite.
	Value    func(*Invite) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) invite.OrderOption
	toCursor func(*Invite) Cursor
}

// InviteOrder defines the ordering of Invite.
type InviteOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *InviteOrderField `json:"field"`
}

// DefaultInviteOrder is the default ordering of Invite.
var DefaultInviteOrder = &InviteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.ID, nil
		},
		column: invite.FieldID,
		toTerm: invite.ByID,
		toCursor: func(i *Invite) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Invite into InviteEdge.
func (i *Invite) ToEdge(order *InviteOrder) *InviteEdge {
	if order == nil {
		order = DefaultInviteOrder
	}
	return &InviteEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// JobResultEdge is the edge representation of JobResult.
type JobResultEdge struct {
	Node   *JobResult `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobResultConnection is the connection containing edges to JobResult.
type JobResultConnection struct {
	Edges      []*JobResultEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobResultConnection) build(nodes []*JobResult, pager *jobresultPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobResult
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobResult {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobResult {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobResultEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobResultEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobResultPaginateOption enables pagination customization.
type JobResultPaginateOption func(*jobresultPager) error

// WithJobResultOrder configures pagination ordering.
func WithJobResultOrder(order []*JobResultOrder) JobResultPaginateOption {
	return func(pager *jobresultPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobResultFilter configures pagination filter.
func WithJobResultFilter(filter func(*JobResultQuery) (*JobResultQuery, error)) JobResultPaginateOption {
	return func(pager *jobresultPager) error {
		if filter == nil {
			return errors.New("JobResultQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobresultPager struct {
	reverse bool
	order   []*JobResultOrder
	filter  func(*JobResultQuery) (*JobResultQuery, error)
}

func newJobResultPager(opts []JobResultPaginateOption, reverse bool) (*jobresultPager, error) {
	pager := &jobresultPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobresultPager) applyFilter(query *JobResultQuery) (*JobResultQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobresultPager) toCursor(jr *JobResult) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(jr).Value)
	}
	return Cursor{ID: jr.ID, Value: cs_}
}

func (p *jobresultPager) applyCursors(query *JobResultQuery, after, before *Cursor) (*JobResultQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobResultOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobresultPager) applyOrder(query *JobResultQuery) *JobResultQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobResultOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobResultOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobresultPager) orderExpr(query *JobResultQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobResultOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobResult.
func (jr *JobResultQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobResultPaginateOption,
) (*JobResultConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobResultPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jr, err = pager.applyFilter(jr); err != nil {
		return nil, err
	}
	conn := &JobResultConnection{Edges: []*JobResultEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jr, err = pager.applyCursors(jr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jr = pager.applyOrder(jr)
	nodes, err := jr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobResultOrderFieldCreatedAt orders JobResult by created_at.
	JobResultOrderFieldCreatedAt = &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			return jr.CreatedAt, nil
		},
		column: jobresult.FieldCreatedAt,
		toTerm: jobresult.ByCreatedAt,
		toCursor: func(jr *JobResult) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.CreatedAt,
			}
		},
	}
	// JobResultOrderFieldUpdatedAt orders JobResult by updated_at.
	JobResultOrderFieldUpdatedAt = &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			return jr.UpdatedAt, nil
		},
		column: jobresult.FieldUpdatedAt,
		toTerm: jobresult.ByUpdatedAt,
		toCursor: func(jr *JobResult) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.UpdatedAt,
			}
		},
	}
	// JobResultOrderFieldStatus orders JobResult by status.
	JobResultOrderFieldStatus = &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			return jr.Status, nil
		},
		column: jobresult.FieldStatus,
		toTerm: jobresult.ByStatus,
		toCursor: func(jr *JobResult) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.Status,
			}
		},
	}
	// JobResultOrderFieldExitCode orders JobResult by exit_code.
	JobResultOrderFieldExitCode = &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			// allow for nil values for fields
			if jr.ExitCode == nil {
				return nil, nil
			}
			return jr.ExitCode, nil
		},
		column: jobresult.FieldExitCode,
		toTerm: func(opts ...sql.OrderTermOption) jobresult.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobresult.ByExitCode(opts...)
		},
		toCursor: func(jr *JobResult) Cursor {
			if jr.ExitCode == nil {
				return Cursor{
					ID:    jr.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    jr.ID,
				Value: jr.ExitCode,
			}
		},
	}
	// JobResultOrderFieldFinishedAt orders JobResult by finished_at.
	JobResultOrderFieldFinishedAt = &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			return jr.FinishedAt, nil
		},
		column: jobresult.FieldFinishedAt,
		toTerm: jobresult.ByFinishedAt,
		toCursor: func(jr *JobResult) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.FinishedAt,
			}
		},
	}
	// JobResultOrderFieldStartedAt orders JobResult by started_at.
	JobResultOrderFieldStartedAt = &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			return jr.StartedAt, nil
		},
		column: jobresult.FieldStartedAt,
		toTerm: jobresult.ByStartedAt,
		toCursor: func(jr *JobResult) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.StartedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobResultOrderField) String() string {
	var str string
	switch f.column {
	case JobResultOrderFieldCreatedAt.column:
		str = "created_at"
	case JobResultOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobResultOrderFieldStatus.column:
		str = "STATUS"
	case JobResultOrderFieldExitCode.column:
		str = "exit_code"
	case JobResultOrderFieldFinishedAt.column:
		str = "finished_at"
	case JobResultOrderFieldStartedAt.column:
		str = "started_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobResultOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobResultOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobResultOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobResultOrderFieldCreatedAt
	case "updated_at":
		*f = *JobResultOrderFieldUpdatedAt
	case "STATUS":
		*f = *JobResultOrderFieldStatus
	case "exit_code":
		*f = *JobResultOrderFieldExitCode
	case "finished_at":
		*f = *JobResultOrderFieldFinishedAt
	case "started_at":
		*f = *JobResultOrderFieldStartedAt
	default:
		return fmt.Errorf("%s is not a valid JobResultOrderField", str)
	}
	return nil
}

// JobResultOrderField defines the ordering field of JobResult.
type JobResultOrderField struct {
	// Value extracts the ordering value from the given JobResult.
	Value    func(*JobResult) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobresult.OrderOption
	toCursor func(*JobResult) Cursor
}

// JobResultOrder defines the ordering of JobResult.
type JobResultOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobResultOrderField `json:"field"`
}

// DefaultJobResultOrder is the default ordering of JobResult.
var DefaultJobResultOrder = &JobResultOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobResultOrderField{
		Value: func(jr *JobResult) (ent.Value, error) {
			return jr.ID, nil
		},
		column: jobresult.FieldID,
		toTerm: jobresult.ByID,
		toCursor: func(jr *JobResult) Cursor {
			return Cursor{ID: jr.ID}
		},
	},
}

// ToEdge converts JobResult into JobResultEdge.
func (jr *JobResult) ToEdge(order *JobResultOrder) *JobResultEdge {
	if order == nil {
		order = DefaultJobResultOrder
	}
	return &JobResultEdge{
		Node:   jr,
		Cursor: order.Field.toCursor(jr),
	}
}

// JobRunnerEdge is the edge representation of JobRunner.
type JobRunnerEdge struct {
	Node   *JobRunner `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobRunnerConnection is the connection containing edges to JobRunner.
type JobRunnerConnection struct {
	Edges      []*JobRunnerEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobRunnerConnection) build(nodes []*JobRunner, pager *jobrunnerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunner {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerPaginateOption enables pagination customization.
type JobRunnerPaginateOption func(*jobrunnerPager) error

// WithJobRunnerOrder configures pagination ordering.
func WithJobRunnerOrder(order []*JobRunnerOrder) JobRunnerPaginateOption {
	return func(pager *jobrunnerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerFilter configures pagination filter.
func WithJobRunnerFilter(filter func(*JobRunnerQuery) (*JobRunnerQuery, error)) JobRunnerPaginateOption {
	return func(pager *jobrunnerPager) error {
		if filter == nil {
			return errors.New("JobRunnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnerPager struct {
	reverse bool
	order   []*JobRunnerOrder
	filter  func(*JobRunnerQuery) (*JobRunnerQuery, error)
}

func newJobRunnerPager(opts []JobRunnerPaginateOption, reverse bool) (*jobrunnerPager, error) {
	pager := &jobrunnerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnerPager) applyFilter(query *JobRunnerQuery) (*JobRunnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnerPager) toCursor(jr *JobRunner) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(jr).Value)
	}
	return Cursor{ID: jr.ID, Value: cs_}
}

func (p *jobrunnerPager) applyCursors(query *JobRunnerQuery, after, before *Cursor) (*JobRunnerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnerPager) applyOrder(query *JobRunnerQuery) *JobRunnerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnerPager) orderExpr(query *JobRunnerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunner.
func (jr *JobRunnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerPaginateOption,
) (*JobRunnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jr, err = pager.applyFilter(jr); err != nil {
		return nil, err
	}
	conn := &JobRunnerConnection{Edges: []*JobRunnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jr, err = pager.applyCursors(jr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jr = pager.applyOrder(jr)
	nodes, err := jr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerOrderFieldCreatedAt orders JobRunner by created_at.
	JobRunnerOrderFieldCreatedAt = &JobRunnerOrderField{
		Value: func(jr *JobRunner) (ent.Value, error) {
			return jr.CreatedAt, nil
		},
		column: jobrunner.FieldCreatedAt,
		toTerm: jobrunner.ByCreatedAt,
		toCursor: func(jr *JobRunner) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.CreatedAt,
			}
		},
	}
	// JobRunnerOrderFieldUpdatedAt orders JobRunner by updated_at.
	JobRunnerOrderFieldUpdatedAt = &JobRunnerOrderField{
		Value: func(jr *JobRunner) (ent.Value, error) {
			return jr.UpdatedAt, nil
		},
		column: jobrunner.FieldUpdatedAt,
		toTerm: jobrunner.ByUpdatedAt,
		toCursor: func(jr *JobRunner) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.UpdatedAt,
			}
		},
	}
	// JobRunnerOrderFieldName orders JobRunner by name.
	JobRunnerOrderFieldName = &JobRunnerOrderField{
		Value: func(jr *JobRunner) (ent.Value, error) {
			return jr.Name, nil
		},
		column: jobrunner.FieldName,
		toTerm: jobrunner.ByName,
		toCursor: func(jr *JobRunner) Cursor {
			return Cursor{
				ID:    jr.ID,
				Value: jr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerOrderFieldUpdatedAt
	case "name":
		*f = *JobRunnerOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid JobRunnerOrderField", str)
	}
	return nil
}

// JobRunnerOrderField defines the ordering field of JobRunner.
type JobRunnerOrderField struct {
	// Value extracts the ordering value from the given JobRunner.
	Value    func(*JobRunner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunner.OrderOption
	toCursor func(*JobRunner) Cursor
}

// JobRunnerOrder defines the ordering of JobRunner.
type JobRunnerOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobRunnerOrderField `json:"field"`
}

// DefaultJobRunnerOrder is the default ordering of JobRunner.
var DefaultJobRunnerOrder = &JobRunnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerOrderField{
		Value: func(jr *JobRunner) (ent.Value, error) {
			return jr.ID, nil
		},
		column: jobrunner.FieldID,
		toTerm: jobrunner.ByID,
		toCursor: func(jr *JobRunner) Cursor {
			return Cursor{ID: jr.ID}
		},
	},
}

// ToEdge converts JobRunner into JobRunnerEdge.
func (jr *JobRunner) ToEdge(order *JobRunnerOrder) *JobRunnerEdge {
	if order == nil {
		order = DefaultJobRunnerOrder
	}
	return &JobRunnerEdge{
		Node:   jr,
		Cursor: order.Field.toCursor(jr),
	}
}

// JobRunnerRegistrationTokenEdge is the edge representation of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenEdge struct {
	Node   *JobRunnerRegistrationToken `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// JobRunnerRegistrationTokenConnection is the connection containing edges to JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenConnection struct {
	Edges      []*JobRunnerRegistrationTokenEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *JobRunnerRegistrationTokenConnection) build(nodes []*JobRunnerRegistrationToken, pager *jobrunnerregistrationtokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunnerRegistrationToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunnerRegistrationToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunnerRegistrationToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerRegistrationTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerRegistrationTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerRegistrationTokenPaginateOption enables pagination customization.
type JobRunnerRegistrationTokenPaginateOption func(*jobrunnerregistrationtokenPager) error

// WithJobRunnerRegistrationTokenOrder configures pagination ordering.
func WithJobRunnerRegistrationTokenOrder(order []*JobRunnerRegistrationTokenOrder) JobRunnerRegistrationTokenPaginateOption {
	return func(pager *jobrunnerregistrationtokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerRegistrationTokenFilter configures pagination filter.
func WithJobRunnerRegistrationTokenFilter(filter func(*JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error)) JobRunnerRegistrationTokenPaginateOption {
	return func(pager *jobrunnerregistrationtokenPager) error {
		if filter == nil {
			return errors.New("JobRunnerRegistrationTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnerregistrationtokenPager struct {
	reverse bool
	order   []*JobRunnerRegistrationTokenOrder
	filter  func(*JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error)
}

func newJobRunnerRegistrationTokenPager(opts []JobRunnerRegistrationTokenPaginateOption, reverse bool) (*jobrunnerregistrationtokenPager, error) {
	pager := &jobrunnerregistrationtokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnerregistrationtokenPager) applyFilter(query *JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnerregistrationtokenPager) toCursor(jrrt *JobRunnerRegistrationToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(jrrt).Value)
	}
	return Cursor{ID: jrrt.ID, Value: cs_}
}

func (p *jobrunnerregistrationtokenPager) applyCursors(query *JobRunnerRegistrationTokenQuery, after, before *Cursor) (*JobRunnerRegistrationTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerRegistrationTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnerregistrationtokenPager) applyOrder(query *JobRunnerRegistrationTokenQuery) *JobRunnerRegistrationTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerRegistrationTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerRegistrationTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnerregistrationtokenPager) orderExpr(query *JobRunnerRegistrationTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerRegistrationTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunnerRegistrationToken.
func (jrrt *JobRunnerRegistrationTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerRegistrationTokenPaginateOption,
) (*JobRunnerRegistrationTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerRegistrationTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jrrt, err = pager.applyFilter(jrrt); err != nil {
		return nil, err
	}
	conn := &JobRunnerRegistrationTokenConnection{Edges: []*JobRunnerRegistrationTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jrrt.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jrrt, err = pager.applyCursors(jrrt, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jrrt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jrrt.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jrrt = pager.applyOrder(jrrt)
	nodes, err := jrrt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerRegistrationTokenOrderFieldCreatedAt orders JobRunnerRegistrationToken by created_at.
	JobRunnerRegistrationTokenOrderFieldCreatedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(jrrt *JobRunnerRegistrationToken) (ent.Value, error) {
			return jrrt.CreatedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldCreatedAt,
		toTerm: jobrunnerregistrationtoken.ByCreatedAt,
		toCursor: func(jrrt *JobRunnerRegistrationToken) Cursor {
			return Cursor{
				ID:    jrrt.ID,
				Value: jrrt.CreatedAt,
			}
		},
	}
	// JobRunnerRegistrationTokenOrderFieldUpdatedAt orders JobRunnerRegistrationToken by updated_at.
	JobRunnerRegistrationTokenOrderFieldUpdatedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(jrrt *JobRunnerRegistrationToken) (ent.Value, error) {
			return jrrt.UpdatedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldUpdatedAt,
		toTerm: jobrunnerregistrationtoken.ByUpdatedAt,
		toCursor: func(jrrt *JobRunnerRegistrationToken) Cursor {
			return Cursor{
				ID:    jrrt.ID,
				Value: jrrt.UpdatedAt,
			}
		},
	}
	// JobRunnerRegistrationTokenOrderFieldLastUsedAt orders JobRunnerRegistrationToken by last_used_at.
	JobRunnerRegistrationTokenOrderFieldLastUsedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(jrrt *JobRunnerRegistrationToken) (ent.Value, error) {
			// allow for nil values for fields
			if jrrt.LastUsedAt == nil {
				return nil, nil
			}
			return jrrt.LastUsedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnerregistrationtoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnerregistrationtoken.ByLastUsedAt(opts...)
		},
		toCursor: func(jrrt *JobRunnerRegistrationToken) Cursor {
			if jrrt.LastUsedAt == nil {
				return Cursor{
					ID:    jrrt.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    jrrt.ID,
				Value: jrrt.LastUsedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerRegistrationTokenOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerRegistrationTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerRegistrationTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerRegistrationTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerRegistrationTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerRegistrationTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerRegistrationTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerRegistrationTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerRegistrationTokenOrderFieldUpdatedAt
	case "last_used_at":
		*f = *JobRunnerRegistrationTokenOrderFieldLastUsedAt
	default:
		return fmt.Errorf("%s is not a valid JobRunnerRegistrationTokenOrderField", str)
	}
	return nil
}

// JobRunnerRegistrationTokenOrderField defines the ordering field of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenOrderField struct {
	// Value extracts the ordering value from the given JobRunnerRegistrationToken.
	Value    func(*JobRunnerRegistrationToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunnerregistrationtoken.OrderOption
	toCursor func(*JobRunnerRegistrationToken) Cursor
}

// JobRunnerRegistrationTokenOrder defines the ordering of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *JobRunnerRegistrationTokenOrderField `json:"field"`
}

// DefaultJobRunnerRegistrationTokenOrder is the default ordering of JobRunnerRegistrationToken.
var DefaultJobRunnerRegistrationTokenOrder = &JobRunnerRegistrationTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerRegistrationTokenOrderField{
		Value: func(jrrt *JobRunnerRegistrationToken) (ent.Value, error) {
			return jrrt.ID, nil
		},
		column: jobrunnerregistrationtoken.FieldID,
		toTerm: jobrunnerregistrationtoken.ByID,
		toCursor: func(jrrt *JobRunnerRegistrationToken) Cursor {
			return Cursor{ID: jrrt.ID}
		},
	},
}

// ToEdge converts JobRunnerRegistrationToken into JobRunnerRegistrationTokenEdge.
func (jrrt *JobRunnerRegistrationToken) ToEdge(order *JobRunnerRegistrationTokenOrder) *JobRunnerRegistrationTokenEdge {
	if order == nil {
		order = DefaultJobRunnerRegistrationTokenOrder
	}
	return &JobRunnerRegistrationTokenEdge{
		Node:   jrrt,
		Cursor: order.Field.toCursor(jrrt),
	}
}

// JobRunnerTokenEdge is the edge representation of JobRunnerToken.
type JobRunnerTokenEdge struct {
	Node   *JobRunnerToken `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// JobRunnerTokenConnection is the connection containing edges to JobRunnerToken.
type JobRunnerTokenConnection struct {
	Edges      []*JobRunnerTokenEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *JobRunnerTokenConnection) build(nodes []*JobRunnerToken, pager *jobrunnertokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunnerToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunnerToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunnerToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerTokenPaginateOption enables pagination customization.
type JobRunnerTokenPaginateOption func(*jobrunnertokenPager) error

// WithJobRunnerTokenOrder configures pagination ordering.
func WithJobRunnerTokenOrder(order []*JobRunnerTokenOrder) JobRunnerTokenPaginateOption {
	return func(pager *jobrunnertokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerTokenFilter configures pagination filter.
func WithJobRunnerTokenFilter(filter func(*JobRunnerTokenQuery) (*JobRunnerTokenQuery, error)) JobRunnerTokenPaginateOption {
	return func(pager *jobrunnertokenPager) error {
		if filter == nil {
			return errors.New("JobRunnerTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnertokenPager struct {
	reverse bool
	order   []*JobRunnerTokenOrder
	filter  func(*JobRunnerTokenQuery) (*JobRunnerTokenQuery, error)
}

func newJobRunnerTokenPager(opts []JobRunnerTokenPaginateOption, reverse bool) (*jobrunnertokenPager, error) {
	pager := &jobrunnertokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnertokenPager) applyFilter(query *JobRunnerTokenQuery) (*JobRunnerTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnertokenPager) toCursor(jrt *JobRunnerToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(jrt).Value)
	}
	return Cursor{ID: jrt.ID, Value: cs_}
}

func (p *jobrunnertokenPager) applyCursors(query *JobRunnerTokenQuery, after, before *Cursor) (*JobRunnerTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnertokenPager) applyOrder(query *JobRunnerTokenQuery) *JobRunnerTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnertokenPager) orderExpr(query *JobRunnerTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunnerToken.
func (jrt *JobRunnerTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerTokenPaginateOption,
) (*JobRunnerTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jrt, err = pager.applyFilter(jrt); err != nil {
		return nil, err
	}
	conn := &JobRunnerTokenConnection{Edges: []*JobRunnerTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jrt.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jrt, err = pager.applyCursors(jrt, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jrt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jrt.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jrt = pager.applyOrder(jrt)
	nodes, err := jrt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerTokenOrderFieldCreatedAt orders JobRunnerToken by created_at.
	JobRunnerTokenOrderFieldCreatedAt = &JobRunnerTokenOrderField{
		Value: func(jrt *JobRunnerToken) (ent.Value, error) {
			return jrt.CreatedAt, nil
		},
		column: jobrunnertoken.FieldCreatedAt,
		toTerm: jobrunnertoken.ByCreatedAt,
		toCursor: func(jrt *JobRunnerToken) Cursor {
			return Cursor{
				ID:    jrt.ID,
				Value: jrt.CreatedAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldUpdatedAt orders JobRunnerToken by updated_at.
	JobRunnerTokenOrderFieldUpdatedAt = &JobRunnerTokenOrderField{
		Value: func(jrt *JobRunnerToken) (ent.Value, error) {
			return jrt.UpdatedAt, nil
		},
		column: jobrunnertoken.FieldUpdatedAt,
		toTerm: jobrunnertoken.ByUpdatedAt,
		toCursor: func(jrt *JobRunnerToken) Cursor {
			return Cursor{
				ID:    jrt.ID,
				Value: jrt.UpdatedAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldExpiresAt orders JobRunnerToken by expires_at.
	JobRunnerTokenOrderFieldExpiresAt = &JobRunnerTokenOrderField{
		Value: func(jrt *JobRunnerToken) (ent.Value, error) {
			// allow for nil values for fields
			if jrt.ExpiresAt == nil {
				return nil, nil
			}
			return jrt.ExpiresAt, nil
		},
		column: jobrunnertoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnertoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnertoken.ByExpiresAt(opts...)
		},
		toCursor: func(jrt *JobRunnerToken) Cursor {
			if jrt.ExpiresAt == nil {
				return Cursor{
					ID:    jrt.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    jrt.ID,
				Value: jrt.ExpiresAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldLastUsedAt orders JobRunnerToken by last_used_at.
	JobRunnerTokenOrderFieldLastUsedAt = &JobRunnerTokenOrderField{
		Value: func(jrt *JobRunnerToken) (ent.Value, error) {
			// allow for nil values for fields
			if jrt.LastUsedAt == nil {
				return nil, nil
			}
			return jrt.LastUsedAt, nil
		},
		column: jobrunnertoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnertoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnertoken.ByLastUsedAt(opts...)
		},
		toCursor: func(jrt *JobRunnerToken) Cursor {
			if jrt.LastUsedAt == nil {
				return Cursor{
					ID:    jrt.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    jrt.ID,
				Value: jrt.LastUsedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerTokenOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerTokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case JobRunnerTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerTokenOrderFieldUpdatedAt
	case "expires_at":
		*f = *JobRunnerTokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *JobRunnerTokenOrderFieldLastUsedAt
	default:
		return fmt.Errorf("%s is not a valid JobRunnerTokenOrderField", str)
	}
	return nil
}

// JobRunnerTokenOrderField defines the ordering field of JobRunnerToken.
type JobRunnerTokenOrderField struct {
	// Value extracts the ordering value from the given JobRunnerToken.
	Value    func(*JobRunnerToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunnertoken.OrderOption
	toCursor func(*JobRunnerToken) Cursor
}

// JobRunnerTokenOrder defines the ordering of JobRunnerToken.
type JobRunnerTokenOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *JobRunnerTokenOrderField `json:"field"`
}

// DefaultJobRunnerTokenOrder is the default ordering of JobRunnerToken.
var DefaultJobRunnerTokenOrder = &JobRunnerTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerTokenOrderField{
		Value: func(jrt *JobRunnerToken) (ent.Value, error) {
			return jrt.ID, nil
		},
		column: jobrunnertoken.FieldID,
		toTerm: jobrunnertoken.ByID,
		toCursor: func(jrt *JobRunnerToken) Cursor {
			return Cursor{ID: jrt.ID}
		},
	},
}

// ToEdge converts JobRunnerToken into JobRunnerTokenEdge.
func (jrt *JobRunnerToken) ToEdge(order *JobRunnerTokenOrder) *JobRunnerTokenEdge {
	if order == nil {
		order = DefaultJobRunnerTokenOrder
	}
	return &JobRunnerTokenEdge{
		Node:   jrt,
		Cursor: order.Field.toCursor(jrt),
	}
}

// MappableDomainEdge is the edge representation of MappableDomain.
type MappableDomainEdge struct {
	Node   *MappableDomain `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// MappableDomainConnection is the connection containing edges to MappableDomain.
type MappableDomainConnection struct {
	Edges      []*MappableDomainEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *MappableDomainConnection) build(nodes []*MappableDomain, pager *mappabledomainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappableDomain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappableDomain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappableDomain {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappableDomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappableDomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappableDomainPaginateOption enables pagination customization.
type MappableDomainPaginateOption func(*mappabledomainPager) error

// WithMappableDomainOrder configures pagination ordering.
func WithMappableDomainOrder(order []*MappableDomainOrder) MappableDomainPaginateOption {
	return func(pager *mappabledomainPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMappableDomainFilter configures pagination filter.
func WithMappableDomainFilter(filter func(*MappableDomainQuery) (*MappableDomainQuery, error)) MappableDomainPaginateOption {
	return func(pager *mappabledomainPager) error {
		if filter == nil {
			return errors.New("MappableDomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappabledomainPager struct {
	reverse bool
	order   []*MappableDomainOrder
	filter  func(*MappableDomainQuery) (*MappableDomainQuery, error)
}

func newMappableDomainPager(opts []MappableDomainPaginateOption, reverse bool) (*mappabledomainPager, error) {
	pager := &mappabledomainPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mappabledomainPager) applyFilter(query *MappableDomainQuery) (*MappableDomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappabledomainPager) toCursor(md *MappableDomain) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(md).Value)
	}
	return Cursor{ID: md.ID, Value: cs_}
}

func (p *mappabledomainPager) applyCursors(query *MappableDomainQuery, after, before *Cursor) (*MappableDomainQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMappableDomainOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *mappabledomainPager) applyOrder(query *MappableDomainQuery) *MappableDomainQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMappableDomainOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMappableDomainOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mappabledomainPager) orderExpr(query *MappableDomainQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMappableDomainOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappableDomain.
func (md *MappableDomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappableDomainPaginateOption,
) (*MappableDomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappableDomainPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if md, err = pager.applyFilter(md); err != nil {
		return nil, err
	}
	conn := &MappableDomainConnection{Edges: []*MappableDomainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := md.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if md, err = pager.applyCursors(md, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		md.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := md.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	md = pager.applyOrder(md)
	nodes, err := md.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappableDomainOrderFieldCreatedAt orders MappableDomain by created_at.
	MappableDomainOrderFieldCreatedAt = &MappableDomainOrderField{
		Value: func(md *MappableDomain) (ent.Value, error) {
			return md.CreatedAt, nil
		},
		column: mappabledomain.FieldCreatedAt,
		toTerm: mappabledomain.ByCreatedAt,
		toCursor: func(md *MappableDomain) Cursor {
			return Cursor{
				ID:    md.ID,
				Value: md.CreatedAt,
			}
		},
	}
	// MappableDomainOrderFieldUpdatedAt orders MappableDomain by updated_at.
	MappableDomainOrderFieldUpdatedAt = &MappableDomainOrderField{
		Value: func(md *MappableDomain) (ent.Value, error) {
			return md.UpdatedAt, nil
		},
		column: mappabledomain.FieldUpdatedAt,
		toTerm: mappabledomain.ByUpdatedAt,
		toCursor: func(md *MappableDomain) Cursor {
			return Cursor{
				ID:    md.ID,
				Value: md.UpdatedAt,
			}
		},
	}
	// MappableDomainOrderFieldName orders MappableDomain by name.
	MappableDomainOrderFieldName = &MappableDomainOrderField{
		Value: func(md *MappableDomain) (ent.Value, error) {
			return md.Name, nil
		},
		column: mappabledomain.FieldName,
		toTerm: mappabledomain.ByName,
		toCursor: func(md *MappableDomain) Cursor {
			return Cursor{
				ID:    md.ID,
				Value: md.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappableDomainOrderField) String() string {
	var str string
	switch f.column {
	case MappableDomainOrderFieldCreatedAt.column:
		str = "created_at"
	case MappableDomainOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappableDomainOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappableDomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappableDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappableDomainOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *MappableDomainOrderFieldCreatedAt
	case "updated_at":
		*f = *MappableDomainOrderFieldUpdatedAt
	case "name":
		*f = *MappableDomainOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid MappableDomainOrderField", str)
	}
	return nil
}

// MappableDomainOrderField defines the ordering field of MappableDomain.
type MappableDomainOrderField struct {
	// Value extracts the ordering value from the given MappableDomain.
	Value    func(*MappableDomain) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappabledomain.OrderOption
	toCursor func(*MappableDomain) Cursor
}

// MappableDomainOrder defines the ordering of MappableDomain.
type MappableDomainOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *MappableDomainOrderField `json:"field"`
}

// DefaultMappableDomainOrder is the default ordering of MappableDomain.
var DefaultMappableDomainOrder = &MappableDomainOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappableDomainOrderField{
		Value: func(md *MappableDomain) (ent.Value, error) {
			return md.ID, nil
		},
		column: mappabledomain.FieldID,
		toTerm: mappabledomain.ByID,
		toCursor: func(md *MappableDomain) Cursor {
			return Cursor{ID: md.ID}
		},
	},
}

// ToEdge converts MappableDomain into MappableDomainEdge.
func (md *MappableDomain) ToEdge(order *MappableDomainOrder) *MappableDomainEdge {
	if order == nil {
		order = DefaultMappableDomainOrder
	}
	return &MappableDomainEdge{
		Node:   md,
		Cursor: order.Field.toCursor(md),
	}
}

// MappableDomainHistoryEdge is the edge representation of MappableDomainHistory.
type MappableDomainHistoryEdge struct {
	Node   *MappableDomainHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// MappableDomainHistoryConnection is the connection containing edges to MappableDomainHistory.
type MappableDomainHistoryConnection struct {
	Edges      []*MappableDomainHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *MappableDomainHistoryConnection) build(nodes []*MappableDomainHistory, pager *mappabledomainhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappableDomainHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappableDomainHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappableDomainHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappableDomainHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappableDomainHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappableDomainHistoryPaginateOption enables pagination customization.
type MappableDomainHistoryPaginateOption func(*mappabledomainhistoryPager) error

// WithMappableDomainHistoryOrder configures pagination ordering.
func WithMappableDomainHistoryOrder(order *MappableDomainHistoryOrder) MappableDomainHistoryPaginateOption {
	if order == nil {
		order = DefaultMappableDomainHistoryOrder
	}
	o := *order
	return func(pager *mappabledomainhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMappableDomainHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMappableDomainHistoryFilter configures pagination filter.
func WithMappableDomainHistoryFilter(filter func(*MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error)) MappableDomainHistoryPaginateOption {
	return func(pager *mappabledomainhistoryPager) error {
		if filter == nil {
			return errors.New("MappableDomainHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappabledomainhistoryPager struct {
	reverse bool
	order   *MappableDomainHistoryOrder
	filter  func(*MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error)
}

func newMappableDomainHistoryPager(opts []MappableDomainHistoryPaginateOption, reverse bool) (*mappabledomainhistoryPager, error) {
	pager := &mappabledomainhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMappableDomainHistoryOrder
	}
	return pager, nil
}

func (p *mappabledomainhistoryPager) applyFilter(query *MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappabledomainhistoryPager) toCursor(mdh *MappableDomainHistory) Cursor {
	return p.order.Field.toCursor(mdh)
}

func (p *mappabledomainhistoryPager) applyCursors(query *MappableDomainHistoryQuery, after, before *Cursor) (*MappableDomainHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMappableDomainHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mappabledomainhistoryPager) applyOrder(query *MappableDomainHistoryQuery) *MappableDomainHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMappableDomainHistoryOrder.Field {
		query = query.Order(DefaultMappableDomainHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mappabledomainhistoryPager) orderExpr(query *MappableDomainHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMappableDomainHistoryOrder.Field {
			b.Comma().Ident(DefaultMappableDomainHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappableDomainHistory.
func (mdh *MappableDomainHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappableDomainHistoryPaginateOption,
) (*MappableDomainHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappableDomainHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mdh, err = pager.applyFilter(mdh); err != nil {
		return nil, err
	}
	conn := &MappableDomainHistoryConnection{Edges: []*MappableDomainHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := mdh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mdh, err = pager.applyCursors(mdh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		mdh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mdh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mdh = pager.applyOrder(mdh)
	nodes, err := mdh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappableDomainHistoryOrderFieldHistoryTime orders MappableDomainHistory by history_time.
	MappableDomainHistoryOrderFieldHistoryTime = &MappableDomainHistoryOrderField{
		Value: func(mdh *MappableDomainHistory) (ent.Value, error) {
			return mdh.HistoryTime, nil
		},
		column: mappabledomainhistory.FieldHistoryTime,
		toTerm: mappabledomainhistory.ByHistoryTime,
		toCursor: func(mdh *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    mdh.ID,
				Value: mdh.HistoryTime,
			}
		},
	}
	// MappableDomainHistoryOrderFieldCreatedAt orders MappableDomainHistory by created_at.
	MappableDomainHistoryOrderFieldCreatedAt = &MappableDomainHistoryOrderField{
		Value: func(mdh *MappableDomainHistory) (ent.Value, error) {
			return mdh.CreatedAt, nil
		},
		column: mappabledomainhistory.FieldCreatedAt,
		toTerm: mappabledomainhistory.ByCreatedAt,
		toCursor: func(mdh *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    mdh.ID,
				Value: mdh.CreatedAt,
			}
		},
	}
	// MappableDomainHistoryOrderFieldUpdatedAt orders MappableDomainHistory by updated_at.
	MappableDomainHistoryOrderFieldUpdatedAt = &MappableDomainHistoryOrderField{
		Value: func(mdh *MappableDomainHistory) (ent.Value, error) {
			return mdh.UpdatedAt, nil
		},
		column: mappabledomainhistory.FieldUpdatedAt,
		toTerm: mappabledomainhistory.ByUpdatedAt,
		toCursor: func(mdh *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    mdh.ID,
				Value: mdh.UpdatedAt,
			}
		},
	}
	// MappableDomainHistoryOrderFieldName orders MappableDomainHistory by name.
	MappableDomainHistoryOrderFieldName = &MappableDomainHistoryOrderField{
		Value: func(mdh *MappableDomainHistory) (ent.Value, error) {
			return mdh.Name, nil
		},
		column: mappabledomainhistory.FieldName,
		toTerm: mappabledomainhistory.ByName,
		toCursor: func(mdh *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    mdh.ID,
				Value: mdh.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappableDomainHistoryOrderField) String() string {
	var str string
	switch f.column {
	case MappableDomainHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case MappableDomainHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case MappableDomainHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappableDomainHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappableDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappableDomainHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappableDomainHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *MappableDomainHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *MappableDomainHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *MappableDomainHistoryOrderFieldUpdatedAt
	case "name":
		*f = *MappableDomainHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid MappableDomainHistoryOrderField", str)
	}
	return nil
}

// MappableDomainHistoryOrderField defines the ordering field of MappableDomainHistory.
type MappableDomainHistoryOrderField struct {
	// Value extracts the ordering value from the given MappableDomainHistory.
	Value    func(*MappableDomainHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappabledomainhistory.OrderOption
	toCursor func(*MappableDomainHistory) Cursor
}

// MappableDomainHistoryOrder defines the ordering of MappableDomainHistory.
type MappableDomainHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *MappableDomainHistoryOrderField `json:"field"`
}

// DefaultMappableDomainHistoryOrder is the default ordering of MappableDomainHistory.
var DefaultMappableDomainHistoryOrder = &MappableDomainHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappableDomainHistoryOrderField{
		Value: func(mdh *MappableDomainHistory) (ent.Value, error) {
			return mdh.ID, nil
		},
		column: mappabledomainhistory.FieldID,
		toTerm: mappabledomainhistory.ByID,
		toCursor: func(mdh *MappableDomainHistory) Cursor {
			return Cursor{ID: mdh.ID}
		},
	},
}

// ToEdge converts MappableDomainHistory into MappableDomainHistoryEdge.
func (mdh *MappableDomainHistory) ToEdge(order *MappableDomainHistoryOrder) *MappableDomainHistoryEdge {
	if order == nil {
		order = DefaultMappableDomainHistoryOrder
	}
	return &MappableDomainHistoryEdge{
		Node:   mdh,
		Cursor: order.Field.toCursor(mdh),
	}
}

// MappedControlEdge is the edge representation of MappedControl.
type MappedControlEdge struct {
	Node   *MappedControl `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// MappedControlConnection is the connection containing edges to MappedControl.
type MappedControlConnection struct {
	Edges      []*MappedControlEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *MappedControlConnection) build(nodes []*MappedControl, pager *mappedcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappedControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappedControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappedControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappedControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappedControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappedControlPaginateOption enables pagination customization.
type MappedControlPaginateOption func(*mappedcontrolPager) error

// WithMappedControlOrder configures pagination ordering.
func WithMappedControlOrder(order []*MappedControlOrder) MappedControlPaginateOption {
	return func(pager *mappedcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMappedControlFilter configures pagination filter.
func WithMappedControlFilter(filter func(*MappedControlQuery) (*MappedControlQuery, error)) MappedControlPaginateOption {
	return func(pager *mappedcontrolPager) error {
		if filter == nil {
			return errors.New("MappedControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappedcontrolPager struct {
	reverse bool
	order   []*MappedControlOrder
	filter  func(*MappedControlQuery) (*MappedControlQuery, error)
}

func newMappedControlPager(opts []MappedControlPaginateOption, reverse bool) (*mappedcontrolPager, error) {
	pager := &mappedcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mappedcontrolPager) applyFilter(query *MappedControlQuery) (*MappedControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappedcontrolPager) toCursor(mc *MappedControl) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(mc).Value)
	}
	return Cursor{ID: mc.ID, Value: cs_}
}

func (p *mappedcontrolPager) applyCursors(query *MappedControlQuery, after, before *Cursor) (*MappedControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMappedControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *mappedcontrolPager) applyOrder(query *MappedControlQuery) *MappedControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMappedControlOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMappedControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mappedcontrolPager) orderExpr(query *MappedControlQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMappedControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappedControl.
func (mc *MappedControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappedControlPaginateOption,
) (*MappedControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappedControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mc, err = pager.applyFilter(mc); err != nil {
		return nil, err
	}
	conn := &MappedControlConnection{Edges: []*MappedControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := mc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mc, err = pager.applyCursors(mc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		mc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mc = pager.applyOrder(mc)
	nodes, err := mc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappedControlOrderFieldCreatedAt orders MappedControl by created_at.
	MappedControlOrderFieldCreatedAt = &MappedControlOrderField{
		Value: func(mc *MappedControl) (ent.Value, error) {
			return mc.CreatedAt, nil
		},
		column: mappedcontrol.FieldCreatedAt,
		toTerm: mappedcontrol.ByCreatedAt,
		toCursor: func(mc *MappedControl) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.CreatedAt,
			}
		},
	}
	// MappedControlOrderFieldUpdatedAt orders MappedControl by updated_at.
	MappedControlOrderFieldUpdatedAt = &MappedControlOrderField{
		Value: func(mc *MappedControl) (ent.Value, error) {
			return mc.UpdatedAt, nil
		},
		column: mappedcontrol.FieldUpdatedAt,
		toTerm: mappedcontrol.ByUpdatedAt,
		toCursor: func(mc *MappedControl) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.UpdatedAt,
			}
		},
	}
	// MappedControlOrderFieldMappingType orders MappedControl by mapping_type.
	MappedControlOrderFieldMappingType = &MappedControlOrderField{
		Value: func(mc *MappedControl) (ent.Value, error) {
			return mc.MappingType, nil
		},
		column: mappedcontrol.FieldMappingType,
		toTerm: mappedcontrol.ByMappingType,
		toCursor: func(mc *MappedControl) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.MappingType,
			}
		},
	}
	// MappedControlOrderFieldSource orders MappedControl by source.
	MappedControlOrderFieldSource = &MappedControlOrderField{
		Value: func(mc *MappedControl) (ent.Value, error) {
			return mc.Source, nil
		},
		column: mappedcontrol.FieldSource,
		toTerm: mappedcontrol.BySource,
		toCursor: func(mc *MappedControl) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappedControlOrderField) String() string {
	var str string
	switch f.column {
	case MappedControlOrderFieldCreatedAt.column:
		str = "created_at"
	case MappedControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappedControlOrderFieldMappingType.column:
		str = "MAPPING_TYPE"
	case MappedControlOrderFieldSource.column:
		str = "SOURCE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappedControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappedControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappedControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *MappedControlOrderFieldCreatedAt
	case "updated_at":
		*f = *MappedControlOrderFieldUpdatedAt
	case "MAPPING_TYPE":
		*f = *MappedControlOrderFieldMappingType
	case "SOURCE":
		*f = *MappedControlOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid MappedControlOrderField", str)
	}
	return nil
}

// MappedControlOrderField defines the ordering field of MappedControl.
type MappedControlOrderField struct {
	// Value extracts the ordering value from the given MappedControl.
	Value    func(*MappedControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappedcontrol.OrderOption
	toCursor func(*MappedControl) Cursor
}

// MappedControlOrder defines the ordering of MappedControl.
type MappedControlOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *MappedControlOrderField `json:"field"`
}

// DefaultMappedControlOrder is the default ordering of MappedControl.
var DefaultMappedControlOrder = &MappedControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappedControlOrderField{
		Value: func(mc *MappedControl) (ent.Value, error) {
			return mc.ID, nil
		},
		column: mappedcontrol.FieldID,
		toTerm: mappedcontrol.ByID,
		toCursor: func(mc *MappedControl) Cursor {
			return Cursor{ID: mc.ID}
		},
	},
}

// ToEdge converts MappedControl into MappedControlEdge.
func (mc *MappedControl) ToEdge(order *MappedControlOrder) *MappedControlEdge {
	if order == nil {
		order = DefaultMappedControlOrder
	}
	return &MappedControlEdge{
		Node:   mc,
		Cursor: order.Field.toCursor(mc),
	}
}

// MappedControlHistoryEdge is the edge representation of MappedControlHistory.
type MappedControlHistoryEdge struct {
	Node   *MappedControlHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// MappedControlHistoryConnection is the connection containing edges to MappedControlHistory.
type MappedControlHistoryConnection struct {
	Edges      []*MappedControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *MappedControlHistoryConnection) build(nodes []*MappedControlHistory, pager *mappedcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappedControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappedControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappedControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappedControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappedControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappedControlHistoryPaginateOption enables pagination customization.
type MappedControlHistoryPaginateOption func(*mappedcontrolhistoryPager) error

// WithMappedControlHistoryOrder configures pagination ordering.
func WithMappedControlHistoryOrder(order *MappedControlHistoryOrder) MappedControlHistoryPaginateOption {
	if order == nil {
		order = DefaultMappedControlHistoryOrder
	}
	o := *order
	return func(pager *mappedcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMappedControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMappedControlHistoryFilter configures pagination filter.
func WithMappedControlHistoryFilter(filter func(*MappedControlHistoryQuery) (*MappedControlHistoryQuery, error)) MappedControlHistoryPaginateOption {
	return func(pager *mappedcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("MappedControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappedcontrolhistoryPager struct {
	reverse bool
	order   *MappedControlHistoryOrder
	filter  func(*MappedControlHistoryQuery) (*MappedControlHistoryQuery, error)
}

func newMappedControlHistoryPager(opts []MappedControlHistoryPaginateOption, reverse bool) (*mappedcontrolhistoryPager, error) {
	pager := &mappedcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMappedControlHistoryOrder
	}
	return pager, nil
}

func (p *mappedcontrolhistoryPager) applyFilter(query *MappedControlHistoryQuery) (*MappedControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappedcontrolhistoryPager) toCursor(mch *MappedControlHistory) Cursor {
	return p.order.Field.toCursor(mch)
}

func (p *mappedcontrolhistoryPager) applyCursors(query *MappedControlHistoryQuery, after, before *Cursor) (*MappedControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMappedControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mappedcontrolhistoryPager) applyOrder(query *MappedControlHistoryQuery) *MappedControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMappedControlHistoryOrder.Field {
		query = query.Order(DefaultMappedControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mappedcontrolhistoryPager) orderExpr(query *MappedControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMappedControlHistoryOrder.Field {
			b.Comma().Ident(DefaultMappedControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappedControlHistory.
func (mch *MappedControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappedControlHistoryPaginateOption,
) (*MappedControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappedControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mch, err = pager.applyFilter(mch); err != nil {
		return nil, err
	}
	conn := &MappedControlHistoryConnection{Edges: []*MappedControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := mch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mch, err = pager.applyCursors(mch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		mch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mch = pager.applyOrder(mch)
	nodes, err := mch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappedControlHistoryOrderFieldHistoryTime orders MappedControlHistory by history_time.
	MappedControlHistoryOrderFieldHistoryTime = &MappedControlHistoryOrderField{
		Value: func(mch *MappedControlHistory) (ent.Value, error) {
			return mch.HistoryTime, nil
		},
		column: mappedcontrolhistory.FieldHistoryTime,
		toTerm: mappedcontrolhistory.ByHistoryTime,
		toCursor: func(mch *MappedControlHistory) Cursor {
			return Cursor{
				ID:    mch.ID,
				Value: mch.HistoryTime,
			}
		},
	}
	// MappedControlHistoryOrderFieldCreatedAt orders MappedControlHistory by created_at.
	MappedControlHistoryOrderFieldCreatedAt = &MappedControlHistoryOrderField{
		Value: func(mch *MappedControlHistory) (ent.Value, error) {
			return mch.CreatedAt, nil
		},
		column: mappedcontrolhistory.FieldCreatedAt,
		toTerm: mappedcontrolhistory.ByCreatedAt,
		toCursor: func(mch *MappedControlHistory) Cursor {
			return Cursor{
				ID:    mch.ID,
				Value: mch.CreatedAt,
			}
		},
	}
	// MappedControlHistoryOrderFieldUpdatedAt orders MappedControlHistory by updated_at.
	MappedControlHistoryOrderFieldUpdatedAt = &MappedControlHistoryOrderField{
		Value: func(mch *MappedControlHistory) (ent.Value, error) {
			return mch.UpdatedAt, nil
		},
		column: mappedcontrolhistory.FieldUpdatedAt,
		toTerm: mappedcontrolhistory.ByUpdatedAt,
		toCursor: func(mch *MappedControlHistory) Cursor {
			return Cursor{
				ID:    mch.ID,
				Value: mch.UpdatedAt,
			}
		},
	}
	// MappedControlHistoryOrderFieldMappingType orders MappedControlHistory by mapping_type.
	MappedControlHistoryOrderFieldMappingType = &MappedControlHistoryOrderField{
		Value: func(mch *MappedControlHistory) (ent.Value, error) {
			return mch.MappingType, nil
		},
		column: mappedcontrolhistory.FieldMappingType,
		toTerm: mappedcontrolhistory.ByMappingType,
		toCursor: func(mch *MappedControlHistory) Cursor {
			return Cursor{
				ID:    mch.ID,
				Value: mch.MappingType,
			}
		},
	}
	// MappedControlHistoryOrderFieldSource orders MappedControlHistory by source.
	MappedControlHistoryOrderFieldSource = &MappedControlHistoryOrderField{
		Value: func(mch *MappedControlHistory) (ent.Value, error) {
			return mch.Source, nil
		},
		column: mappedcontrolhistory.FieldSource,
		toTerm: mappedcontrolhistory.BySource,
		toCursor: func(mch *MappedControlHistory) Cursor {
			return Cursor{
				ID:    mch.ID,
				Value: mch.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappedControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case MappedControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case MappedControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case MappedControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappedControlHistoryOrderFieldMappingType.column:
		str = "MAPPING_TYPE"
	case MappedControlHistoryOrderFieldSource.column:
		str = "SOURCE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappedControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappedControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappedControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *MappedControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *MappedControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *MappedControlHistoryOrderFieldUpdatedAt
	case "MAPPING_TYPE":
		*f = *MappedControlHistoryOrderFieldMappingType
	case "SOURCE":
		*f = *MappedControlHistoryOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid MappedControlHistoryOrderField", str)
	}
	return nil
}

// MappedControlHistoryOrderField defines the ordering field of MappedControlHistory.
type MappedControlHistoryOrderField struct {
	// Value extracts the ordering value from the given MappedControlHistory.
	Value    func(*MappedControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappedcontrolhistory.OrderOption
	toCursor func(*MappedControlHistory) Cursor
}

// MappedControlHistoryOrder defines the ordering of MappedControlHistory.
type MappedControlHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *MappedControlHistoryOrderField `json:"field"`
}

// DefaultMappedControlHistoryOrder is the default ordering of MappedControlHistory.
var DefaultMappedControlHistoryOrder = &MappedControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappedControlHistoryOrderField{
		Value: func(mch *MappedControlHistory) (ent.Value, error) {
			return mch.ID, nil
		},
		column: mappedcontrolhistory.FieldID,
		toTerm: mappedcontrolhistory.ByID,
		toCursor: func(mch *MappedControlHistory) Cursor {
			return Cursor{ID: mch.ID}
		},
	},
}

// ToEdge converts MappedControlHistory into MappedControlHistoryEdge.
func (mch *MappedControlHistory) ToEdge(order *MappedControlHistoryOrder) *MappedControlHistoryEdge {
	if order == nil {
		order = DefaultMappedControlHistoryOrder
	}
	return &MappedControlHistoryEdge{
		Node:   mch,
		Cursor: order.Field.toCursor(mch),
	}
}

// NarrativeEdge is the edge representation of Narrative.
type NarrativeEdge struct {
	Node   *Narrative `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// NarrativeConnection is the connection containing edges to Narrative.
type NarrativeConnection struct {
	Edges      []*NarrativeEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *NarrativeConnection) build(nodes []*Narrative, pager *narrativePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Narrative
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Narrative {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Narrative {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativePaginateOption enables pagination customization.
type NarrativePaginateOption func(*narrativePager) error

// WithNarrativeOrder configures pagination ordering.
func WithNarrativeOrder(order []*NarrativeOrder) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNarrativeFilter configures pagination filter.
func WithNarrativeFilter(filter func(*NarrativeQuery) (*NarrativeQuery, error)) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		if filter == nil {
			return errors.New("NarrativeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativePager struct {
	reverse bool
	order   []*NarrativeOrder
	filter  func(*NarrativeQuery) (*NarrativeQuery, error)
}

func newNarrativePager(opts []NarrativePaginateOption, reverse bool) (*narrativePager, error) {
	pager := &narrativePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *narrativePager) applyFilter(query *NarrativeQuery) (*NarrativeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativePager) toCursor(n *Narrative) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(n).Value)
	}
	return Cursor{ID: n.ID, Value: cs_}
}

func (p *narrativePager) applyCursors(query *NarrativeQuery, after, before *Cursor) (*NarrativeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNarrativeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *narrativePager) applyOrder(query *NarrativeQuery) *NarrativeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNarrativeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNarrativeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *narrativePager) orderExpr(query *NarrativeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNarrativeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Narrative.
func (n *NarrativeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativePaginateOption,
) (*NarrativeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NarrativeConnection{Edges: []*NarrativeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := n.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NarrativeOrderFieldCreatedAt orders Narrative by created_at.
	NarrativeOrderFieldCreatedAt = &NarrativeOrderField{
		Value: func(n *Narrative) (ent.Value, error) {
			return n.CreatedAt, nil
		},
		column: narrative.FieldCreatedAt,
		toTerm: narrative.ByCreatedAt,
		toCursor: func(n *Narrative) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.CreatedAt,
			}
		},
	}
	// NarrativeOrderFieldUpdatedAt orders Narrative by updated_at.
	NarrativeOrderFieldUpdatedAt = &NarrativeOrderField{
		Value: func(n *Narrative) (ent.Value, error) {
			return n.UpdatedAt, nil
		},
		column: narrative.FieldUpdatedAt,
		toTerm: narrative.ByUpdatedAt,
		toCursor: func(n *Narrative) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.UpdatedAt,
			}
		},
	}
	// NarrativeOrderFieldName orders Narrative by name.
	NarrativeOrderFieldName = &NarrativeOrderField{
		Value: func(n *Narrative) (ent.Value, error) {
			return n.Name, nil
		},
		column: narrative.FieldName,
		toTerm: narrative.ByName,
		toCursor: func(n *Narrative) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NarrativeOrderField) String() string {
	var str string
	switch f.column {
	case NarrativeOrderFieldCreatedAt.column:
		str = "created_at"
	case NarrativeOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NarrativeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NarrativeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NarrativeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NarrativeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NarrativeOrderFieldCreatedAt
	case "updated_at":
		*f = *NarrativeOrderFieldUpdatedAt
	case "name":
		*f = *NarrativeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NarrativeOrderField", str)
	}
	return nil
}

// NarrativeOrderField defines the ordering field of Narrative.
type NarrativeOrderField struct {
	// Value extracts the ordering value from the given Narrative.
	Value    func(*Narrative) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrative.OrderOption
	toCursor func(*Narrative) Cursor
}

// NarrativeOrder defines the ordering of Narrative.
type NarrativeOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *NarrativeOrderField `json:"field"`
}

// DefaultNarrativeOrder is the default ordering of Narrative.
var DefaultNarrativeOrder = &NarrativeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeOrderField{
		Value: func(n *Narrative) (ent.Value, error) {
			return n.ID, nil
		},
		column: narrative.FieldID,
		toTerm: narrative.ByID,
		toCursor: func(n *Narrative) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Narrative into NarrativeEdge.
func (n *Narrative) ToEdge(order *NarrativeOrder) *NarrativeEdge {
	if order == nil {
		order = DefaultNarrativeOrder
	}
	return &NarrativeEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// NarrativeHistoryEdge is the edge representation of NarrativeHistory.
type NarrativeHistoryEdge struct {
	Node   *NarrativeHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// NarrativeHistoryConnection is the connection containing edges to NarrativeHistory.
type NarrativeHistoryConnection struct {
	Edges      []*NarrativeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *NarrativeHistoryConnection) build(nodes []*NarrativeHistory, pager *narrativehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NarrativeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativeHistoryPaginateOption enables pagination customization.
type NarrativeHistoryPaginateOption func(*narrativehistoryPager) error

// WithNarrativeHistoryOrder configures pagination ordering.
func WithNarrativeHistoryOrder(order *NarrativeHistoryOrder) NarrativeHistoryPaginateOption {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	o := *order
	return func(pager *narrativehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNarrativeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNarrativeHistoryFilter configures pagination filter.
func WithNarrativeHistoryFilter(filter func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)) NarrativeHistoryPaginateOption {
	return func(pager *narrativehistoryPager) error {
		if filter == nil {
			return errors.New("NarrativeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativehistoryPager struct {
	reverse bool
	order   *NarrativeHistoryOrder
	filter  func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)
}

func newNarrativeHistoryPager(opts []NarrativeHistoryPaginateOption, reverse bool) (*narrativehistoryPager, error) {
	pager := &narrativehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNarrativeHistoryOrder
	}
	return pager, nil
}

func (p *narrativehistoryPager) applyFilter(query *NarrativeHistoryQuery) (*NarrativeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativehistoryPager) toCursor(nh *NarrativeHistory) Cursor {
	return p.order.Field.toCursor(nh)
}

func (p *narrativehistoryPager) applyCursors(query *NarrativeHistoryQuery, after, before *Cursor) (*NarrativeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNarrativeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *narrativehistoryPager) applyOrder(query *NarrativeHistoryQuery) *NarrativeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNarrativeHistoryOrder.Field {
		query = query.Order(DefaultNarrativeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *narrativehistoryPager) orderExpr(query *NarrativeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNarrativeHistoryOrder.Field {
			b.Comma().Ident(DefaultNarrativeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NarrativeHistory.
func (nh *NarrativeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativeHistoryPaginateOption,
) (*NarrativeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if nh, err = pager.applyFilter(nh); err != nil {
		return nil, err
	}
	conn := &NarrativeHistoryConnection{Edges: []*NarrativeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := nh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if nh, err = pager.applyCursors(nh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		nh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := nh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	nh = pager.applyOrder(nh)
	nodes, err := nh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NarrativeHistoryOrderFieldHistoryTime orders NarrativeHistory by history_time.
	NarrativeHistoryOrderFieldHistoryTime = &NarrativeHistoryOrderField{
		Value: func(nh *NarrativeHistory) (ent.Value, error) {
			return nh.HistoryTime, nil
		},
		column: narrativehistory.FieldHistoryTime,
		toTerm: narrativehistory.ByHistoryTime,
		toCursor: func(nh *NarrativeHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.HistoryTime,
			}
		},
	}
	// NarrativeHistoryOrderFieldCreatedAt orders NarrativeHistory by created_at.
	NarrativeHistoryOrderFieldCreatedAt = &NarrativeHistoryOrderField{
		Value: func(nh *NarrativeHistory) (ent.Value, error) {
			return nh.CreatedAt, nil
		},
		column: narrativehistory.FieldCreatedAt,
		toTerm: narrativehistory.ByCreatedAt,
		toCursor: func(nh *NarrativeHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.CreatedAt,
			}
		},
	}
	// NarrativeHistoryOrderFieldUpdatedAt orders NarrativeHistory by updated_at.
	NarrativeHistoryOrderFieldUpdatedAt = &NarrativeHistoryOrderField{
		Value: func(nh *NarrativeHistory) (ent.Value, error) {
			return nh.UpdatedAt, nil
		},
		column: narrativehistory.FieldUpdatedAt,
		toTerm: narrativehistory.ByUpdatedAt,
		toCursor: func(nh *NarrativeHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.UpdatedAt,
			}
		},
	}
	// NarrativeHistoryOrderFieldName orders NarrativeHistory by name.
	NarrativeHistoryOrderFieldName = &NarrativeHistoryOrderField{
		Value: func(nh *NarrativeHistory) (ent.Value, error) {
			return nh.Name, nil
		},
		column: narrativehistory.FieldName,
		toTerm: narrativehistory.ByName,
		toCursor: func(nh *NarrativeHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NarrativeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NarrativeHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NarrativeHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NarrativeHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NarrativeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NarrativeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NarrativeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NarrativeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NarrativeHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NarrativeHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NarrativeHistoryOrderFieldUpdatedAt
	case "name":
		*f = *NarrativeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NarrativeHistoryOrderField", str)
	}
	return nil
}

// NarrativeHistoryOrderField defines the ordering field of NarrativeHistory.
type NarrativeHistoryOrderField struct {
	// Value extracts the ordering value from the given NarrativeHistory.
	Value    func(*NarrativeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrativehistory.OrderOption
	toCursor func(*NarrativeHistory) Cursor
}

// NarrativeHistoryOrder defines the ordering of NarrativeHistory.
type NarrativeHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *NarrativeHistoryOrderField `json:"field"`
}

// DefaultNarrativeHistoryOrder is the default ordering of NarrativeHistory.
var DefaultNarrativeHistoryOrder = &NarrativeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeHistoryOrderField{
		Value: func(nh *NarrativeHistory) (ent.Value, error) {
			return nh.ID, nil
		},
		column: narrativehistory.FieldID,
		toTerm: narrativehistory.ByID,
		toCursor: func(nh *NarrativeHistory) Cursor {
			return Cursor{ID: nh.ID}
		},
	},
}

// ToEdge converts NarrativeHistory into NarrativeHistoryEdge.
func (nh *NarrativeHistory) ToEdge(order *NarrativeHistoryOrder) *NarrativeHistoryEdge {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	return &NarrativeHistoryEdge{
		Node:   nh,
		Cursor: order.Field.toCursor(nh),
	}
}

// NoteEdge is the edge representation of Note.
type NoteEdge struct {
	Node   *Note  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// NoteConnection is the connection containing edges to Note.
type NoteConnection struct {
	Edges      []*NoteEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *NoteConnection) build(nodes []*Note, pager *notePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Note
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Note {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Note {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotePaginateOption enables pagination customization.
type NotePaginateOption func(*notePager) error

// WithNoteOrder configures pagination ordering.
func WithNoteOrder(order []*NoteOrder) NotePaginateOption {
	return func(pager *notePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNoteFilter configures pagination filter.
func WithNoteFilter(filter func(*NoteQuery) (*NoteQuery, error)) NotePaginateOption {
	return func(pager *notePager) error {
		if filter == nil {
			return errors.New("NoteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notePager struct {
	reverse bool
	order   []*NoteOrder
	filter  func(*NoteQuery) (*NoteQuery, error)
}

func newNotePager(opts []NotePaginateOption, reverse bool) (*notePager, error) {
	pager := &notePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *notePager) applyFilter(query *NoteQuery) (*NoteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notePager) toCursor(n *Note) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(n).Value)
	}
	return Cursor{ID: n.ID, Value: cs_}
}

func (p *notePager) applyCursors(query *NoteQuery, after, before *Cursor) (*NoteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNoteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *notePager) applyOrder(query *NoteQuery) *NoteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNoteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNoteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *notePager) orderExpr(query *NoteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNoteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Note.
func (n *NoteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotePaginateOption,
) (*NoteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NoteConnection{Edges: []*NoteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := n.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NoteOrderFieldCreatedAt orders Note by created_at.
	NoteOrderFieldCreatedAt = &NoteOrderField{
		Value: func(n *Note) (ent.Value, error) {
			return n.CreatedAt, nil
		},
		column: note.FieldCreatedAt,
		toTerm: note.ByCreatedAt,
		toCursor: func(n *Note) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.CreatedAt,
			}
		},
	}
	// NoteOrderFieldUpdatedAt orders Note by updated_at.
	NoteOrderFieldUpdatedAt = &NoteOrderField{
		Value: func(n *Note) (ent.Value, error) {
			return n.UpdatedAt, nil
		},
		column: note.FieldUpdatedAt,
		toTerm: note.ByUpdatedAt,
		toCursor: func(n *Note) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NoteOrderField) String() string {
	var str string
	switch f.column {
	case NoteOrderFieldCreatedAt.column:
		str = "created_at"
	case NoteOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NoteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NoteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NoteOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NoteOrderFieldCreatedAt
	case "updated_at":
		*f = *NoteOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NoteOrderField", str)
	}
	return nil
}

// NoteOrderField defines the ordering field of Note.
type NoteOrderField struct {
	// Value extracts the ordering value from the given Note.
	Value    func(*Note) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) note.OrderOption
	toCursor func(*Note) Cursor
}

// NoteOrder defines the ordering of Note.
type NoteOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *NoteOrderField `json:"field"`
}

// DefaultNoteOrder is the default ordering of Note.
var DefaultNoteOrder = &NoteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteOrderField{
		Value: func(n *Note) (ent.Value, error) {
			return n.ID, nil
		},
		column: note.FieldID,
		toTerm: note.ByID,
		toCursor: func(n *Note) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Note into NoteEdge.
func (n *Note) ToEdge(order *NoteOrder) *NoteEdge {
	if order == nil {
		order = DefaultNoteOrder
	}
	return &NoteEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// NoteHistoryEdge is the edge representation of NoteHistory.
type NoteHistoryEdge struct {
	Node   *NoteHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// NoteHistoryConnection is the connection containing edges to NoteHistory.
type NoteHistoryConnection struct {
	Edges      []*NoteHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *NoteHistoryConnection) build(nodes []*NoteHistory, pager *notehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NoteHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NoteHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NoteHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NoteHistoryPaginateOption enables pagination customization.
type NoteHistoryPaginateOption func(*notehistoryPager) error

// WithNoteHistoryOrder configures pagination ordering.
func WithNoteHistoryOrder(order *NoteHistoryOrder) NoteHistoryPaginateOption {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	o := *order
	return func(pager *notehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNoteHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNoteHistoryFilter configures pagination filter.
func WithNoteHistoryFilter(filter func(*NoteHistoryQuery) (*NoteHistoryQuery, error)) NoteHistoryPaginateOption {
	return func(pager *notehistoryPager) error {
		if filter == nil {
			return errors.New("NoteHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notehistoryPager struct {
	reverse bool
	order   *NoteHistoryOrder
	filter  func(*NoteHistoryQuery) (*NoteHistoryQuery, error)
}

func newNoteHistoryPager(opts []NoteHistoryPaginateOption, reverse bool) (*notehistoryPager, error) {
	pager := &notehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNoteHistoryOrder
	}
	return pager, nil
}

func (p *notehistoryPager) applyFilter(query *NoteHistoryQuery) (*NoteHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notehistoryPager) toCursor(nh *NoteHistory) Cursor {
	return p.order.Field.toCursor(nh)
}

func (p *notehistoryPager) applyCursors(query *NoteHistoryQuery, after, before *Cursor) (*NoteHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNoteHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notehistoryPager) applyOrder(query *NoteHistoryQuery) *NoteHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNoteHistoryOrder.Field {
		query = query.Order(DefaultNoteHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notehistoryPager) orderExpr(query *NoteHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNoteHistoryOrder.Field {
			b.Comma().Ident(DefaultNoteHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NoteHistory.
func (nh *NoteHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NoteHistoryPaginateOption,
) (*NoteHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNoteHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if nh, err = pager.applyFilter(nh); err != nil {
		return nil, err
	}
	conn := &NoteHistoryConnection{Edges: []*NoteHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := nh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if nh, err = pager.applyCursors(nh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		nh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := nh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	nh = pager.applyOrder(nh)
	nodes, err := nh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NoteHistoryOrderFieldHistoryTime orders NoteHistory by history_time.
	NoteHistoryOrderFieldHistoryTime = &NoteHistoryOrderField{
		Value: func(nh *NoteHistory) (ent.Value, error) {
			return nh.HistoryTime, nil
		},
		column: notehistory.FieldHistoryTime,
		toTerm: notehistory.ByHistoryTime,
		toCursor: func(nh *NoteHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.HistoryTime,
			}
		},
	}
	// NoteHistoryOrderFieldCreatedAt orders NoteHistory by created_at.
	NoteHistoryOrderFieldCreatedAt = &NoteHistoryOrderField{
		Value: func(nh *NoteHistory) (ent.Value, error) {
			return nh.CreatedAt, nil
		},
		column: notehistory.FieldCreatedAt,
		toTerm: notehistory.ByCreatedAt,
		toCursor: func(nh *NoteHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.CreatedAt,
			}
		},
	}
	// NoteHistoryOrderFieldUpdatedAt orders NoteHistory by updated_at.
	NoteHistoryOrderFieldUpdatedAt = &NoteHistoryOrderField{
		Value: func(nh *NoteHistory) (ent.Value, error) {
			return nh.UpdatedAt, nil
		},
		column: notehistory.FieldUpdatedAt,
		toTerm: notehistory.ByUpdatedAt,
		toCursor: func(nh *NoteHistory) Cursor {
			return Cursor{
				ID:    nh.ID,
				Value: nh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NoteHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NoteHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NoteHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NoteHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NoteHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NoteHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NoteHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NoteHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NoteHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NoteHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NoteHistoryOrderField", str)
	}
	return nil
}

// NoteHistoryOrderField defines the ordering field of NoteHistory.
type NoteHistoryOrderField struct {
	// Value extracts the ordering value from the given NoteHistory.
	Value    func(*NoteHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notehistory.OrderOption
	toCursor func(*NoteHistory) Cursor
}

// NoteHistoryOrder defines the ordering of NoteHistory.
type NoteHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *NoteHistoryOrderField `json:"field"`
}

// DefaultNoteHistoryOrder is the default ordering of NoteHistory.
var DefaultNoteHistoryOrder = &NoteHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteHistoryOrderField{
		Value: func(nh *NoteHistory) (ent.Value, error) {
			return nh.ID, nil
		},
		column: notehistory.FieldID,
		toTerm: notehistory.ByID,
		toCursor: func(nh *NoteHistory) Cursor {
			return Cursor{ID: nh.ID}
		},
	},
}

// ToEdge converts NoteHistory into NoteHistoryEdge.
func (nh *NoteHistory) ToEdge(order *NoteHistoryOrder) *NoteHistoryEdge {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	return &NoteHistoryEdge{
		Node:   nh,
		Cursor: order.Field.toCursor(nh),
	}
}

// OnboardingEdge is the edge representation of Onboarding.
type OnboardingEdge struct {
	Node   *Onboarding `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// OnboardingConnection is the connection containing edges to Onboarding.
type OnboardingConnection struct {
	Edges      []*OnboardingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *OnboardingConnection) build(nodes []*Onboarding, pager *onboardingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Onboarding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Onboarding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Onboarding {
			return nodes[i]
		}
	}
	c.Edges = make([]*OnboardingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OnboardingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OnboardingPaginateOption enables pagination customization.
type OnboardingPaginateOption func(*onboardingPager) error

// WithOnboardingOrder configures pagination ordering.
func WithOnboardingOrder(order *OnboardingOrder) OnboardingPaginateOption {
	if order == nil {
		order = DefaultOnboardingOrder
	}
	o := *order
	return func(pager *onboardingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOnboardingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOnboardingFilter configures pagination filter.
func WithOnboardingFilter(filter func(*OnboardingQuery) (*OnboardingQuery, error)) OnboardingPaginateOption {
	return func(pager *onboardingPager) error {
		if filter == nil {
			return errors.New("OnboardingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type onboardingPager struct {
	reverse bool
	order   *OnboardingOrder
	filter  func(*OnboardingQuery) (*OnboardingQuery, error)
}

func newOnboardingPager(opts []OnboardingPaginateOption, reverse bool) (*onboardingPager, error) {
	pager := &onboardingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOnboardingOrder
	}
	return pager, nil
}

func (p *onboardingPager) applyFilter(query *OnboardingQuery) (*OnboardingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *onboardingPager) toCursor(o *Onboarding) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *onboardingPager) applyCursors(query *OnboardingQuery, after, before *Cursor) (*OnboardingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOnboardingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *onboardingPager) applyOrder(query *OnboardingQuery) *OnboardingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOnboardingOrder.Field {
		query = query.Order(DefaultOnboardingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *onboardingPager) orderExpr(query *OnboardingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOnboardingOrder.Field {
			b.Comma().Ident(DefaultOnboardingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Onboarding.
func (o *OnboardingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OnboardingPaginateOption,
) (*OnboardingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOnboardingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OnboardingConnection{Edges: []*OnboardingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OnboardingOrderField defines the ordering field of Onboarding.
type OnboardingOrderField struct {
	// Value extracts the ordering value from the given Onboarding.
	Value    func(*Onboarding) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) onboarding.OrderOption
	toCursor func(*Onboarding) Cursor
}

// OnboardingOrder defines the ordering of Onboarding.
type OnboardingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *OnboardingOrderField `json:"field"`
}

// DefaultOnboardingOrder is the default ordering of Onboarding.
var DefaultOnboardingOrder = &OnboardingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OnboardingOrderField{
		Value: func(o *Onboarding) (ent.Value, error) {
			return o.ID, nil
		},
		column: onboarding.FieldID,
		toTerm: onboarding.ByID,
		toCursor: func(o *Onboarding) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Onboarding into OnboardingEdge.
func (o *Onboarding) ToEdge(order *OnboardingOrder) *OnboardingEdge {
	if order == nil {
		order = DefaultOnboardingOrder
	}
	return &OnboardingEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// OrgMembershipEdge is the edge representation of OrgMembership.
type OrgMembershipEdge struct {
	Node   *OrgMembership `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// OrgMembershipConnection is the connection containing edges to OrgMembership.
type OrgMembershipConnection struct {
	Edges      []*OrgMembershipEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *OrgMembershipConnection) build(nodes []*OrgMembership, pager *orgmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipPaginateOption enables pagination customization.
type OrgMembershipPaginateOption func(*orgmembershipPager) error

// WithOrgMembershipOrder configures pagination ordering.
func WithOrgMembershipOrder(order []*OrgMembershipOrder) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrgMembershipFilter configures pagination filter.
func WithOrgMembershipFilter(filter func(*OrgMembershipQuery) (*OrgMembershipQuery, error)) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		if filter == nil {
			return errors.New("OrgMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershipPager struct {
	reverse bool
	order   []*OrgMembershipOrder
	filter  func(*OrgMembershipQuery) (*OrgMembershipQuery, error)
}

func newOrgMembershipPager(opts []OrgMembershipPaginateOption, reverse bool) (*orgmembershipPager, error) {
	pager := &orgmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *orgmembershipPager) applyFilter(query *OrgMembershipQuery) (*OrgMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershipPager) toCursor(om *OrgMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(om).Value)
	}
	return Cursor{ID: om.ID, Value: cs_}
}

func (p *orgmembershipPager) applyCursors(query *OrgMembershipQuery, after, before *Cursor) (*OrgMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrgMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *orgmembershipPager) applyOrder(query *OrgMembershipQuery) *OrgMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrgMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrgMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *orgmembershipPager) orderExpr(query *OrgMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrgMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembership.
func (om *OrgMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipPaginateOption,
) (*OrgMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if om, err = pager.applyFilter(om); err != nil {
		return nil, err
	}
	conn := &OrgMembershipConnection{Edges: []*OrgMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := om.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if om, err = pager.applyCursors(om, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		om.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := om.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	om = pager.applyOrder(om)
	nodes, err := om.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgMembershipOrderFieldCreatedAt orders OrgMembership by created_at.
	OrgMembershipOrderFieldCreatedAt = &OrgMembershipOrderField{
		Value: func(om *OrgMembership) (ent.Value, error) {
			return om.CreatedAt, nil
		},
		column: orgmembership.FieldCreatedAt,
		toTerm: orgmembership.ByCreatedAt,
		toCursor: func(om *OrgMembership) Cursor {
			return Cursor{
				ID:    om.ID,
				Value: om.CreatedAt,
			}
		},
	}
	// OrgMembershipOrderFieldUpdatedAt orders OrgMembership by updated_at.
	OrgMembershipOrderFieldUpdatedAt = &OrgMembershipOrderField{
		Value: func(om *OrgMembership) (ent.Value, error) {
			return om.UpdatedAt, nil
		},
		column: orgmembership.FieldUpdatedAt,
		toTerm: orgmembership.ByUpdatedAt,
		toCursor: func(om *OrgMembership) Cursor {
			return Cursor{
				ID:    om.ID,
				Value: om.UpdatedAt,
			}
		},
	}
	// OrgMembershipOrderFieldRole orders OrgMembership by role.
	OrgMembershipOrderFieldRole = &OrgMembershipOrderField{
		Value: func(om *OrgMembership) (ent.Value, error) {
			return om.Role, nil
		},
		column: orgmembership.FieldRole,
		toTerm: orgmembership.ByRole,
		toCursor: func(om *OrgMembership) Cursor {
			return Cursor{
				ID:    om.ID,
				Value: om.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgMembershipOrderField) String() string {
	var str string
	switch f.column {
	case OrgMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrgMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *OrgMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid OrgMembershipOrderField", str)
	}
	return nil
}

// OrgMembershipOrderField defines the ordering field of OrgMembership.
type OrgMembershipOrderField struct {
	// Value extracts the ordering value from the given OrgMembership.
	Value    func(*OrgMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembership.OrderOption
	toCursor func(*OrgMembership) Cursor
}

// OrgMembershipOrder defines the ordering of OrgMembership.
type OrgMembershipOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *OrgMembershipOrderField `json:"field"`
}

// DefaultOrgMembershipOrder is the default ordering of OrgMembership.
var DefaultOrgMembershipOrder = &OrgMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipOrderField{
		Value: func(om *OrgMembership) (ent.Value, error) {
			return om.ID, nil
		},
		column: orgmembership.FieldID,
		toTerm: orgmembership.ByID,
		toCursor: func(om *OrgMembership) Cursor {
			return Cursor{ID: om.ID}
		},
	},
}

// ToEdge converts OrgMembership into OrgMembershipEdge.
func (om *OrgMembership) ToEdge(order *OrgMembershipOrder) *OrgMembershipEdge {
	if order == nil {
		order = DefaultOrgMembershipOrder
	}
	return &OrgMembershipEdge{
		Node:   om,
		Cursor: order.Field.toCursor(om),
	}
}

// OrgMembershipHistoryEdge is the edge representation of OrgMembershipHistory.
type OrgMembershipHistoryEdge struct {
	Node   *OrgMembershipHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// OrgMembershipHistoryConnection is the connection containing edges to OrgMembershipHistory.
type OrgMembershipHistoryConnection struct {
	Edges      []*OrgMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *OrgMembershipHistoryConnection) build(nodes []*OrgMembershipHistory, pager *orgmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipHistoryPaginateOption enables pagination customization.
type OrgMembershipHistoryPaginateOption func(*orgmembershiphistoryPager) error

// WithOrgMembershipHistoryOrder configures pagination ordering.
func WithOrgMembershipHistoryOrder(order *OrgMembershipHistoryOrder) OrgMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	o := *order
	return func(pager *orgmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgMembershipHistoryFilter configures pagination filter.
func WithOrgMembershipHistoryFilter(filter func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)) OrgMembershipHistoryPaginateOption {
	return func(pager *orgmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("OrgMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershiphistoryPager struct {
	reverse bool
	order   *OrgMembershipHistoryOrder
	filter  func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)
}

func newOrgMembershipHistoryPager(opts []OrgMembershipHistoryPaginateOption, reverse bool) (*orgmembershiphistoryPager, error) {
	pager := &orgmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgMembershipHistoryOrder
	}
	return pager, nil
}

func (p *orgmembershiphistoryPager) applyFilter(query *OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) toCursor(omh *OrgMembershipHistory) Cursor {
	return p.order.Field.toCursor(omh)
}

func (p *orgmembershiphistoryPager) applyCursors(query *OrgMembershipHistoryQuery, after, before *Cursor) (*OrgMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) applyOrder(query *OrgMembershipHistoryQuery) *OrgMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
		query = query.Order(DefaultOrgMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgmembershiphistoryPager) orderExpr(query *OrgMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembershipHistory.
func (omh *OrgMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipHistoryPaginateOption,
) (*OrgMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if omh, err = pager.applyFilter(omh); err != nil {
		return nil, err
	}
	conn := &OrgMembershipHistoryConnection{Edges: []*OrgMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := omh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if omh, err = pager.applyCursors(omh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		omh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := omh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	omh = pager.applyOrder(omh)
	nodes, err := omh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgMembershipHistoryOrderFieldHistoryTime orders OrgMembershipHistory by history_time.
	OrgMembershipHistoryOrderFieldHistoryTime = &OrgMembershipHistoryOrderField{
		Value: func(omh *OrgMembershipHistory) (ent.Value, error) {
			return omh.HistoryTime, nil
		},
		column: orgmembershiphistory.FieldHistoryTime,
		toTerm: orgmembershiphistory.ByHistoryTime,
		toCursor: func(omh *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    omh.ID,
				Value: omh.HistoryTime,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldCreatedAt orders OrgMembershipHistory by created_at.
	OrgMembershipHistoryOrderFieldCreatedAt = &OrgMembershipHistoryOrderField{
		Value: func(omh *OrgMembershipHistory) (ent.Value, error) {
			return omh.CreatedAt, nil
		},
		column: orgmembershiphistory.FieldCreatedAt,
		toTerm: orgmembershiphistory.ByCreatedAt,
		toCursor: func(omh *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    omh.ID,
				Value: omh.CreatedAt,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldUpdatedAt orders OrgMembershipHistory by updated_at.
	OrgMembershipHistoryOrderFieldUpdatedAt = &OrgMembershipHistoryOrderField{
		Value: func(omh *OrgMembershipHistory) (ent.Value, error) {
			return omh.UpdatedAt, nil
		},
		column: orgmembershiphistory.FieldUpdatedAt,
		toTerm: orgmembershiphistory.ByUpdatedAt,
		toCursor: func(omh *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    omh.ID,
				Value: omh.UpdatedAt,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldRole orders OrgMembershipHistory by role.
	OrgMembershipHistoryOrderFieldRole = &OrgMembershipHistoryOrderField{
		Value: func(omh *OrgMembershipHistory) (ent.Value, error) {
			return omh.Role, nil
		},
		column: orgmembershiphistory.FieldRole,
		toTerm: orgmembershiphistory.ByRole,
		toCursor: func(omh *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    omh.ID,
				Value: omh.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrgMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrgMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrgMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrgMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *OrgMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid OrgMembershipHistoryOrderField", str)
	}
	return nil
}

// OrgMembershipHistoryOrderField defines the ordering field of OrgMembershipHistory.
type OrgMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgMembershipHistory.
	Value    func(*OrgMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembershiphistory.OrderOption
	toCursor func(*OrgMembershipHistory) Cursor
}

// OrgMembershipHistoryOrder defines the ordering of OrgMembershipHistory.
type OrgMembershipHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *OrgMembershipHistoryOrderField `json:"field"`
}

// DefaultOrgMembershipHistoryOrder is the default ordering of OrgMembershipHistory.
var DefaultOrgMembershipHistoryOrder = &OrgMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipHistoryOrderField{
		Value: func(omh *OrgMembershipHistory) (ent.Value, error) {
			return omh.ID, nil
		},
		column: orgmembershiphistory.FieldID,
		toTerm: orgmembershiphistory.ByID,
		toCursor: func(omh *OrgMembershipHistory) Cursor {
			return Cursor{ID: omh.ID}
		},
	},
}

// ToEdge converts OrgMembershipHistory into OrgMembershipHistoryEdge.
func (omh *OrgMembershipHistory) ToEdge(order *OrgMembershipHistoryOrder) *OrgMembershipHistoryEdge {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	return &OrgMembershipHistoryEdge{
		Node:   omh,
		Cursor: order.Field.toCursor(omh),
	}
}

// OrgSubscriptionEdge is the edge representation of OrgSubscription.
type OrgSubscriptionEdge struct {
	Node   *OrgSubscription `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// OrgSubscriptionConnection is the connection containing edges to OrgSubscription.
type OrgSubscriptionConnection struct {
	Edges      []*OrgSubscriptionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *OrgSubscriptionConnection) build(nodes []*OrgSubscription, pager *orgsubscriptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgSubscription
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgSubscription {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgSubscription {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgSubscriptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgSubscriptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgSubscriptionPaginateOption enables pagination customization.
type OrgSubscriptionPaginateOption func(*orgsubscriptionPager) error

// WithOrgSubscriptionOrder configures pagination ordering.
func WithOrgSubscriptionOrder(order *OrgSubscriptionOrder) OrgSubscriptionPaginateOption {
	if order == nil {
		order = DefaultOrgSubscriptionOrder
	}
	o := *order
	return func(pager *orgsubscriptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgSubscriptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgSubscriptionFilter configures pagination filter.
func WithOrgSubscriptionFilter(filter func(*OrgSubscriptionQuery) (*OrgSubscriptionQuery, error)) OrgSubscriptionPaginateOption {
	return func(pager *orgsubscriptionPager) error {
		if filter == nil {
			return errors.New("OrgSubscriptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgsubscriptionPager struct {
	reverse bool
	order   *OrgSubscriptionOrder
	filter  func(*OrgSubscriptionQuery) (*OrgSubscriptionQuery, error)
}

func newOrgSubscriptionPager(opts []OrgSubscriptionPaginateOption, reverse bool) (*orgsubscriptionPager, error) {
	pager := &orgsubscriptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgSubscriptionOrder
	}
	return pager, nil
}

func (p *orgsubscriptionPager) applyFilter(query *OrgSubscriptionQuery) (*OrgSubscriptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgsubscriptionPager) toCursor(os *OrgSubscription) Cursor {
	return p.order.Field.toCursor(os)
}

func (p *orgsubscriptionPager) applyCursors(query *OrgSubscriptionQuery, after, before *Cursor) (*OrgSubscriptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgSubscriptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgsubscriptionPager) applyOrder(query *OrgSubscriptionQuery) *OrgSubscriptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgSubscriptionOrder.Field {
		query = query.Order(DefaultOrgSubscriptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgsubscriptionPager) orderExpr(query *OrgSubscriptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgSubscriptionOrder.Field {
			b.Comma().Ident(DefaultOrgSubscriptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgSubscription.
func (os *OrgSubscriptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgSubscriptionPaginateOption,
) (*OrgSubscriptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgSubscriptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if os, err = pager.applyFilter(os); err != nil {
		return nil, err
	}
	conn := &OrgSubscriptionConnection{Edges: []*OrgSubscriptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := os.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if os, err = pager.applyCursors(os, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		os.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := os.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	os = pager.applyOrder(os)
	nodes, err := os.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgSubscriptionOrderFieldCreatedAt orders OrgSubscription by created_at.
	OrgSubscriptionOrderFieldCreatedAt = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			return os.CreatedAt, nil
		},
		column: orgsubscription.FieldCreatedAt,
		toTerm: orgsubscription.ByCreatedAt,
		toCursor: func(os *OrgSubscription) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.CreatedAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldUpdatedAt orders OrgSubscription by updated_at.
	OrgSubscriptionOrderFieldUpdatedAt = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			return os.UpdatedAt, nil
		},
		column: orgsubscription.FieldUpdatedAt,
		toTerm: orgsubscription.ByUpdatedAt,
		toCursor: func(os *OrgSubscription) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.UpdatedAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldProductTier orders OrgSubscription by product_tier.
	OrgSubscriptionOrderFieldProductTier = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			return os.ProductTier, nil
		},
		column: orgsubscription.FieldProductTier,
		toTerm: orgsubscription.ByProductTier,
		toCursor: func(os *OrgSubscription) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.ProductTier,
			}
		},
	}
	// OrgSubscriptionOrderFieldStripeSubscriptionStatus orders OrgSubscription by stripe_subscription_status.
	OrgSubscriptionOrderFieldStripeSubscriptionStatus = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			return os.StripeSubscriptionStatus, nil
		},
		column: orgsubscription.FieldStripeSubscriptionStatus,
		toTerm: orgsubscription.ByStripeSubscriptionStatus,
		toCursor: func(os *OrgSubscription) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.StripeSubscriptionStatus,
			}
		},
	}
	// OrgSubscriptionOrderFieldActive orders OrgSubscription by active.
	OrgSubscriptionOrderFieldActive = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			return os.Active, nil
		},
		column: orgsubscription.FieldActive,
		toTerm: orgsubscription.ByActive,
		toCursor: func(os *OrgSubscription) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.Active,
			}
		},
	}
	// OrgSubscriptionOrderFieldExpiresAt orders OrgSubscription by expires_at.
	OrgSubscriptionOrderFieldExpiresAt = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if os.ExpiresAt == nil {
				return nil, nil
			}
			return os.ExpiresAt, nil
		},
		column: orgsubscription.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByExpiresAt(opts...)
		},
		toCursor: func(os *OrgSubscription) Cursor {
			if os.ExpiresAt == nil {
				return Cursor{
					ID:    os.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    os.ID,
				Value: os.ExpiresAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldTrialExpiresAt orders OrgSubscription by trial_expires_at.
	OrgSubscriptionOrderFieldTrialExpiresAt = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if os.TrialExpiresAt == nil {
				return nil, nil
			}
			return os.TrialExpiresAt, nil
		},
		column: orgsubscription.FieldTrialExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByTrialExpiresAt(opts...)
		},
		toCursor: func(os *OrgSubscription) Cursor {
			if os.TrialExpiresAt == nil {
				return Cursor{
					ID:    os.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    os.ID,
				Value: os.TrialExpiresAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldDaysUntilDue orders OrgSubscription by days_until_due.
	OrgSubscriptionOrderFieldDaysUntilDue = &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if os.DaysUntilDue == nil {
				return nil, nil
			}
			return os.DaysUntilDue, nil
		},
		column: orgsubscription.FieldDaysUntilDue,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByDaysUntilDue(opts...)
		},
		toCursor: func(os *OrgSubscription) Cursor {
			if os.DaysUntilDue == nil {
				return Cursor{
					ID:    os.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    os.ID,
				Value: os.DaysUntilDue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgSubscriptionOrderField) String() string {
	var str string
	switch f.column {
	case OrgSubscriptionOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgSubscriptionOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgSubscriptionOrderFieldProductTier.column:
		str = "product_tier"
	case OrgSubscriptionOrderFieldStripeSubscriptionStatus.column:
		str = "stripe_subscription_status"
	case OrgSubscriptionOrderFieldActive.column:
		str = "active"
	case OrgSubscriptionOrderFieldExpiresAt.column:
		str = "expires_at"
	case OrgSubscriptionOrderFieldTrialExpiresAt.column:
		str = "trial_expires_at"
	case OrgSubscriptionOrderFieldDaysUntilDue.column:
		str = "days_until_due"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgSubscriptionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgSubscriptionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgSubscriptionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrgSubscriptionOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgSubscriptionOrderFieldUpdatedAt
	case "product_tier":
		*f = *OrgSubscriptionOrderFieldProductTier
	case "stripe_subscription_status":
		*f = *OrgSubscriptionOrderFieldStripeSubscriptionStatus
	case "active":
		*f = *OrgSubscriptionOrderFieldActive
	case "expires_at":
		*f = *OrgSubscriptionOrderFieldExpiresAt
	case "trial_expires_at":
		*f = *OrgSubscriptionOrderFieldTrialExpiresAt
	case "days_until_due":
		*f = *OrgSubscriptionOrderFieldDaysUntilDue
	default:
		return fmt.Errorf("%s is not a valid OrgSubscriptionOrderField", str)
	}
	return nil
}

// OrgSubscriptionOrderField defines the ordering field of OrgSubscription.
type OrgSubscriptionOrderField struct {
	// Value extracts the ordering value from the given OrgSubscription.
	Value    func(*OrgSubscription) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgsubscription.OrderOption
	toCursor func(*OrgSubscription) Cursor
}

// OrgSubscriptionOrder defines the ordering of OrgSubscription.
type OrgSubscriptionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *OrgSubscriptionOrderField `json:"field"`
}

// DefaultOrgSubscriptionOrder is the default ordering of OrgSubscription.
var DefaultOrgSubscriptionOrder = &OrgSubscriptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgSubscriptionOrderField{
		Value: func(os *OrgSubscription) (ent.Value, error) {
			return os.ID, nil
		},
		column: orgsubscription.FieldID,
		toTerm: orgsubscription.ByID,
		toCursor: func(os *OrgSubscription) Cursor {
			return Cursor{ID: os.ID}
		},
	},
}

// ToEdge converts OrgSubscription into OrgSubscriptionEdge.
func (os *OrgSubscription) ToEdge(order *OrgSubscriptionOrder) *OrgSubscriptionEdge {
	if order == nil {
		order = DefaultOrgSubscriptionOrder
	}
	return &OrgSubscriptionEdge{
		Node:   os,
		Cursor: order.Field.toCursor(os),
	}
}

// OrgSubscriptionHistoryEdge is the edge representation of OrgSubscriptionHistory.
type OrgSubscriptionHistoryEdge struct {
	Node   *OrgSubscriptionHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// OrgSubscriptionHistoryConnection is the connection containing edges to OrgSubscriptionHistory.
type OrgSubscriptionHistoryConnection struct {
	Edges      []*OrgSubscriptionHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *OrgSubscriptionHistoryConnection) build(nodes []*OrgSubscriptionHistory, pager *orgsubscriptionhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgSubscriptionHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgSubscriptionHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgSubscriptionHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgSubscriptionHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgSubscriptionHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgSubscriptionHistoryPaginateOption enables pagination customization.
type OrgSubscriptionHistoryPaginateOption func(*orgsubscriptionhistoryPager) error

// WithOrgSubscriptionHistoryOrder configures pagination ordering.
func WithOrgSubscriptionHistoryOrder(order *OrgSubscriptionHistoryOrder) OrgSubscriptionHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgSubscriptionHistoryOrder
	}
	o := *order
	return func(pager *orgsubscriptionhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgSubscriptionHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgSubscriptionHistoryFilter configures pagination filter.
func WithOrgSubscriptionHistoryFilter(filter func(*OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error)) OrgSubscriptionHistoryPaginateOption {
	return func(pager *orgsubscriptionhistoryPager) error {
		if filter == nil {
			return errors.New("OrgSubscriptionHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgsubscriptionhistoryPager struct {
	reverse bool
	order   *OrgSubscriptionHistoryOrder
	filter  func(*OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error)
}

func newOrgSubscriptionHistoryPager(opts []OrgSubscriptionHistoryPaginateOption, reverse bool) (*orgsubscriptionhistoryPager, error) {
	pager := &orgsubscriptionhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgSubscriptionHistoryOrder
	}
	return pager, nil
}

func (p *orgsubscriptionhistoryPager) applyFilter(query *OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgsubscriptionhistoryPager) toCursor(osh *OrgSubscriptionHistory) Cursor {
	return p.order.Field.toCursor(osh)
}

func (p *orgsubscriptionhistoryPager) applyCursors(query *OrgSubscriptionHistoryQuery, after, before *Cursor) (*OrgSubscriptionHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgSubscriptionHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgsubscriptionhistoryPager) applyOrder(query *OrgSubscriptionHistoryQuery) *OrgSubscriptionHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgSubscriptionHistoryOrder.Field {
		query = query.Order(DefaultOrgSubscriptionHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgsubscriptionhistoryPager) orderExpr(query *OrgSubscriptionHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgSubscriptionHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgSubscriptionHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgSubscriptionHistory.
func (osh *OrgSubscriptionHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgSubscriptionHistoryPaginateOption,
) (*OrgSubscriptionHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgSubscriptionHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if osh, err = pager.applyFilter(osh); err != nil {
		return nil, err
	}
	conn := &OrgSubscriptionHistoryConnection{Edges: []*OrgSubscriptionHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := osh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if osh, err = pager.applyCursors(osh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		osh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := osh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	osh = pager.applyOrder(osh)
	nodes, err := osh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgSubscriptionHistoryOrderFieldHistoryTime orders OrgSubscriptionHistory by history_time.
	OrgSubscriptionHistoryOrderFieldHistoryTime = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.HistoryTime, nil
		},
		column: orgsubscriptionhistory.FieldHistoryTime,
		toTerm: orgsubscriptionhistory.ByHistoryTime,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.HistoryTime,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldCreatedAt orders OrgSubscriptionHistory by created_at.
	OrgSubscriptionHistoryOrderFieldCreatedAt = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.CreatedAt, nil
		},
		column: orgsubscriptionhistory.FieldCreatedAt,
		toTerm: orgsubscriptionhistory.ByCreatedAt,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.CreatedAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldUpdatedAt orders OrgSubscriptionHistory by updated_at.
	OrgSubscriptionHistoryOrderFieldUpdatedAt = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.UpdatedAt, nil
		},
		column: orgsubscriptionhistory.FieldUpdatedAt,
		toTerm: orgsubscriptionhistory.ByUpdatedAt,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.UpdatedAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldProductTier orders OrgSubscriptionHistory by product_tier.
	OrgSubscriptionHistoryOrderFieldProductTier = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.ProductTier, nil
		},
		column: orgsubscriptionhistory.FieldProductTier,
		toTerm: orgsubscriptionhistory.ByProductTier,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.ProductTier,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus orders OrgSubscriptionHistory by stripe_subscription_status.
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.StripeSubscriptionStatus, nil
		},
		column: orgsubscriptionhistory.FieldStripeSubscriptionStatus,
		toTerm: orgsubscriptionhistory.ByStripeSubscriptionStatus,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.StripeSubscriptionStatus,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldActive orders OrgSubscriptionHistory by active.
	OrgSubscriptionHistoryOrderFieldActive = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.Active, nil
		},
		column: orgsubscriptionhistory.FieldActive,
		toTerm: orgsubscriptionhistory.ByActive,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.Active,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldExpiresAt orders OrgSubscriptionHistory by expires_at.
	OrgSubscriptionHistoryOrderFieldExpiresAt = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if osh.ExpiresAt == nil {
				return nil, nil
			}
			return osh.ExpiresAt, nil
		},
		column: orgsubscriptionhistory.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByExpiresAt(opts...)
		},
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			if osh.ExpiresAt == nil {
				return Cursor{
					ID:    osh.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    osh.ID,
				Value: osh.ExpiresAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldTrialExpiresAt orders OrgSubscriptionHistory by trial_expires_at.
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if osh.TrialExpiresAt == nil {
				return nil, nil
			}
			return osh.TrialExpiresAt, nil
		},
		column: orgsubscriptionhistory.FieldTrialExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByTrialExpiresAt(opts...)
		},
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			if osh.TrialExpiresAt == nil {
				return Cursor{
					ID:    osh.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    osh.ID,
				Value: osh.TrialExpiresAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldDaysUntilDue orders OrgSubscriptionHistory by days_until_due.
	OrgSubscriptionHistoryOrderFieldDaysUntilDue = &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if osh.DaysUntilDue == nil {
				return nil, nil
			}
			return osh.DaysUntilDue, nil
		},
		column: orgsubscriptionhistory.FieldDaysUntilDue,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByDaysUntilDue(opts...)
		},
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			if osh.DaysUntilDue == nil {
				return Cursor{
					ID:    osh.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    osh.ID,
				Value: osh.DaysUntilDue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgSubscriptionHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrgSubscriptionHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrgSubscriptionHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgSubscriptionHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgSubscriptionHistoryOrderFieldProductTier.column:
		str = "product_tier"
	case OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus.column:
		str = "stripe_subscription_status"
	case OrgSubscriptionHistoryOrderFieldActive.column:
		str = "active"
	case OrgSubscriptionHistoryOrderFieldExpiresAt.column:
		str = "expires_at"
	case OrgSubscriptionHistoryOrderFieldTrialExpiresAt.column:
		str = "trial_expires_at"
	case OrgSubscriptionHistoryOrderFieldDaysUntilDue.column:
		str = "days_until_due"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgSubscriptionHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgSubscriptionHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgSubscriptionHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrgSubscriptionHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrgSubscriptionHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgSubscriptionHistoryOrderFieldUpdatedAt
	case "product_tier":
		*f = *OrgSubscriptionHistoryOrderFieldProductTier
	case "stripe_subscription_status":
		*f = *OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus
	case "active":
		*f = *OrgSubscriptionHistoryOrderFieldActive
	case "expires_at":
		*f = *OrgSubscriptionHistoryOrderFieldExpiresAt
	case "trial_expires_at":
		*f = *OrgSubscriptionHistoryOrderFieldTrialExpiresAt
	case "days_until_due":
		*f = *OrgSubscriptionHistoryOrderFieldDaysUntilDue
	default:
		return fmt.Errorf("%s is not a valid OrgSubscriptionHistoryOrderField", str)
	}
	return nil
}

// OrgSubscriptionHistoryOrderField defines the ordering field of OrgSubscriptionHistory.
type OrgSubscriptionHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgSubscriptionHistory.
	Value    func(*OrgSubscriptionHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgsubscriptionhistory.OrderOption
	toCursor func(*OrgSubscriptionHistory) Cursor
}

// OrgSubscriptionHistoryOrder defines the ordering of OrgSubscriptionHistory.
type OrgSubscriptionHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *OrgSubscriptionHistoryOrderField `json:"field"`
}

// DefaultOrgSubscriptionHistoryOrder is the default ordering of OrgSubscriptionHistory.
var DefaultOrgSubscriptionHistoryOrder = &OrgSubscriptionHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgSubscriptionHistoryOrderField{
		Value: func(osh *OrgSubscriptionHistory) (ent.Value, error) {
			return osh.ID, nil
		},
		column: orgsubscriptionhistory.FieldID,
		toTerm: orgsubscriptionhistory.ByID,
		toCursor: func(osh *OrgSubscriptionHistory) Cursor {
			return Cursor{ID: osh.ID}
		},
	},
}

// ToEdge converts OrgSubscriptionHistory into OrgSubscriptionHistoryEdge.
func (osh *OrgSubscriptionHistory) ToEdge(order *OrgSubscriptionHistoryOrder) *OrgSubscriptionHistoryEdge {
	if order == nil {
		order = DefaultOrgSubscriptionHistoryOrder
	}
	return &OrgSubscriptionHistoryEdge{
		Node:   osh,
		Cursor: order.Field.toCursor(osh),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order []*OrganizationOrder) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   []*OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(o).Value)
	}
	return Cursor{ID: o.ID, Value: cs_}
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationOrderFieldCreatedAt orders Organization by created_at.
	OrganizationOrderFieldCreatedAt = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.CreatedAt, nil
		},
		column: organization.FieldCreatedAt,
		toTerm: organization.ByCreatedAt,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.CreatedAt,
			}
		},
	}
	// OrganizationOrderFieldUpdatedAt orders Organization by updated_at.
	OrganizationOrderFieldUpdatedAt = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.UpdatedAt, nil
		},
		column: organization.FieldUpdatedAt,
		toTerm: organization.ByUpdatedAt,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.UpdatedAt,
			}
		},
	}
	// OrganizationOrderFieldName orders Organization by name.
	OrganizationOrderFieldName = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.Name, nil
		},
		column: organization.FieldName,
		toTerm: organization.ByName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Name,
			}
		},
	}
	// OrganizationOrderFieldDisplayName orders Organization by display_name.
	OrganizationOrderFieldDisplayName = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.DisplayName, nil
		},
		column: organization.FieldDisplayName,
		toTerm: organization.ByDisplayName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrganizationOrderFieldName.column:
		str = "name"
	case OrganizationOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrganizationOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationOrderFieldUpdatedAt
	case "name":
		*f = *OrganizationOrderFieldName
	case "display_name":
		*f = *OrganizationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// OrganizationHistoryEdge is the edge representation of OrganizationHistory.
type OrganizationHistoryEdge struct {
	Node   *OrganizationHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationHistoryConnection is the connection containing edges to OrganizationHistory.
type OrganizationHistoryConnection struct {
	Edges      []*OrganizationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationHistoryConnection) build(nodes []*OrganizationHistory, pager *organizationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationHistoryPaginateOption enables pagination customization.
type OrganizationHistoryPaginateOption func(*organizationhistoryPager) error

// WithOrganizationHistoryOrder configures pagination ordering.
func WithOrganizationHistoryOrder(order *OrganizationHistoryOrder) OrganizationHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	o := *order
	return func(pager *organizationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationHistoryFilter configures pagination filter.
func WithOrganizationHistoryFilter(filter func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)) OrganizationHistoryPaginateOption {
	return func(pager *organizationhistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationhistoryPager struct {
	reverse bool
	order   *OrganizationHistoryOrder
	filter  func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)
}

func newOrganizationHistoryPager(opts []OrganizationHistoryPaginateOption, reverse bool) (*organizationhistoryPager, error) {
	pager := &organizationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationHistoryOrder
	}
	return pager, nil
}

func (p *organizationhistoryPager) applyFilter(query *OrganizationHistoryQuery) (*OrganizationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationhistoryPager) toCursor(oh *OrganizationHistory) Cursor {
	return p.order.Field.toCursor(oh)
}

func (p *organizationhistoryPager) applyCursors(query *OrganizationHistoryQuery, after, before *Cursor) (*OrganizationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationhistoryPager) applyOrder(query *OrganizationHistoryQuery) *OrganizationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationHistoryOrder.Field {
		query = query.Order(DefaultOrganizationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationhistoryPager) orderExpr(query *OrganizationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationHistory.
func (oh *OrganizationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationHistoryPaginateOption,
) (*OrganizationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if oh, err = pager.applyFilter(oh); err != nil {
		return nil, err
	}
	conn := &OrganizationHistoryConnection{Edges: []*OrganizationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := oh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if oh, err = pager.applyCursors(oh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		oh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := oh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	oh = pager.applyOrder(oh)
	nodes, err := oh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationHistoryOrderFieldHistoryTime orders OrganizationHistory by history_time.
	OrganizationHistoryOrderFieldHistoryTime = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.HistoryTime, nil
		},
		column: organizationhistory.FieldHistoryTime,
		toTerm: organizationhistory.ByHistoryTime,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.HistoryTime,
			}
		},
	}
	// OrganizationHistoryOrderFieldCreatedAt orders OrganizationHistory by created_at.
	OrganizationHistoryOrderFieldCreatedAt = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.CreatedAt, nil
		},
		column: organizationhistory.FieldCreatedAt,
		toTerm: organizationhistory.ByCreatedAt,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.CreatedAt,
			}
		},
	}
	// OrganizationHistoryOrderFieldUpdatedAt orders OrganizationHistory by updated_at.
	OrganizationHistoryOrderFieldUpdatedAt = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.UpdatedAt, nil
		},
		column: organizationhistory.FieldUpdatedAt,
		toTerm: organizationhistory.ByUpdatedAt,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.UpdatedAt,
			}
		},
	}
	// OrganizationHistoryOrderFieldName orders OrganizationHistory by name.
	OrganizationHistoryOrderFieldName = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.Name, nil
		},
		column: organizationhistory.FieldName,
		toTerm: organizationhistory.ByName,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.Name,
			}
		},
	}
	// OrganizationHistoryOrderFieldDisplayName orders OrganizationHistory by display_name.
	OrganizationHistoryOrderFieldDisplayName = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.DisplayName, nil
		},
		column: organizationhistory.FieldDisplayName,
		toTerm: organizationhistory.ByDisplayName,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrganizationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrganizationHistoryOrderFieldName.column:
		str = "name"
	case OrganizationHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrganizationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrganizationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationHistoryOrderFieldUpdatedAt
	case "name":
		*f = *OrganizationHistoryOrderFieldName
	case "display_name":
		*f = *OrganizationHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

// OrganizationHistoryOrderField defines the ordering field of OrganizationHistory.
type OrganizationHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationHistory.
	Value    func(*OrganizationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationhistory.OrderOption
	toCursor func(*OrganizationHistory) Cursor
}

// OrganizationHistoryOrder defines the ordering of OrganizationHistory.
type OrganizationHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationHistoryOrderField `json:"field"`
}

// DefaultOrganizationHistoryOrder is the default ordering of OrganizationHistory.
var DefaultOrganizationHistoryOrder = &OrganizationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.ID, nil
		},
		column: organizationhistory.FieldID,
		toTerm: organizationhistory.ByID,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{ID: oh.ID}
		},
	},
}

// ToEdge converts OrganizationHistory into OrganizationHistoryEdge.
func (oh *OrganizationHistory) ToEdge(order *OrganizationHistoryOrder) *OrganizationHistoryEdge {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	return &OrganizationHistoryEdge{
		Node:   oh,
		Cursor: order.Field.toCursor(oh),
	}
}

// OrganizationSettingEdge is the edge representation of OrganizationSetting.
type OrganizationSettingEdge struct {
	Node   *OrganizationSetting `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationSettingConnection is the connection containing edges to OrganizationSetting.
type OrganizationSettingConnection struct {
	Edges      []*OrganizationSettingEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationSettingConnection) build(nodes []*OrganizationSetting, pager *organizationsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingPaginateOption enables pagination customization.
type OrganizationSettingPaginateOption func(*organizationsettingPager) error

// WithOrganizationSettingOrder configures pagination ordering.
func WithOrganizationSettingOrder(order []*OrganizationSettingOrder) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationSettingFilter configures pagination filter.
func WithOrganizationSettingFilter(filter func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettingPager struct {
	reverse bool
	order   []*OrganizationSettingOrder
	filter  func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)
}

func newOrganizationSettingPager(opts []OrganizationSettingPaginateOption, reverse bool) (*organizationsettingPager, error) {
	pager := &organizationsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationsettingPager) applyFilter(query *OrganizationSettingQuery) (*OrganizationSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettingPager) toCursor(os *OrganizationSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(os).Value)
	}
	return Cursor{ID: os.ID, Value: cs_}
}

func (p *organizationsettingPager) applyCursors(query *OrganizationSettingQuery, after, before *Cursor) (*OrganizationSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *organizationsettingPager) applyOrder(query *OrganizationSettingQuery) *OrganizationSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationsettingPager) orderExpr(query *OrganizationSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSetting.
func (os *OrganizationSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingPaginateOption,
) (*OrganizationSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if os, err = pager.applyFilter(os); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingConnection{Edges: []*OrganizationSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := os.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if os, err = pager.applyCursors(os, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		os.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := os.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	os = pager.applyOrder(os)
	nodes, err := os.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationSettingOrderFieldCreatedAt orders OrganizationSetting by created_at.
	OrganizationSettingOrderFieldCreatedAt = &OrganizationSettingOrderField{
		Value: func(os *OrganizationSetting) (ent.Value, error) {
			return os.CreatedAt, nil
		},
		column: organizationsetting.FieldCreatedAt,
		toTerm: organizationsetting.ByCreatedAt,
		toCursor: func(os *OrganizationSetting) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.CreatedAt,
			}
		},
	}
	// OrganizationSettingOrderFieldUpdatedAt orders OrganizationSetting by updated_at.
	OrganizationSettingOrderFieldUpdatedAt = &OrganizationSettingOrderField{
		Value: func(os *OrganizationSetting) (ent.Value, error) {
			return os.UpdatedAt, nil
		},
		column: organizationsetting.FieldUpdatedAt,
		toTerm: organizationsetting.ByUpdatedAt,
		toCursor: func(os *OrganizationSetting) Cursor {
			return Cursor{
				ID:    os.ID,
				Value: os.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationSettingOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrganizationSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OrganizationSettingOrderField", str)
	}
	return nil
}

// OrganizationSettingOrderField defines the ordering field of OrganizationSetting.
type OrganizationSettingOrderField struct {
	// Value extracts the ordering value from the given OrganizationSetting.
	Value    func(*OrganizationSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsetting.OrderOption
	toCursor func(*OrganizationSetting) Cursor
}

// OrganizationSettingOrder defines the ordering of OrganizationSetting.
type OrganizationSettingOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationSettingOrderField `json:"field"`
}

// DefaultOrganizationSettingOrder is the default ordering of OrganizationSetting.
var DefaultOrganizationSettingOrder = &OrganizationSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingOrderField{
		Value: func(os *OrganizationSetting) (ent.Value, error) {
			return os.ID, nil
		},
		column: organizationsetting.FieldID,
		toTerm: organizationsetting.ByID,
		toCursor: func(os *OrganizationSetting) Cursor {
			return Cursor{ID: os.ID}
		},
	},
}

// ToEdge converts OrganizationSetting into OrganizationSettingEdge.
func (os *OrganizationSetting) ToEdge(order *OrganizationSettingOrder) *OrganizationSettingEdge {
	if order == nil {
		order = DefaultOrganizationSettingOrder
	}
	return &OrganizationSettingEdge{
		Node:   os,
		Cursor: order.Field.toCursor(os),
	}
}

// OrganizationSettingHistoryEdge is the edge representation of OrganizationSettingHistory.
type OrganizationSettingHistoryEdge struct {
	Node   *OrganizationSettingHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// OrganizationSettingHistoryConnection is the connection containing edges to OrganizationSettingHistory.
type OrganizationSettingHistoryConnection struct {
	Edges      []*OrganizationSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *OrganizationSettingHistoryConnection) build(nodes []*OrganizationSettingHistory, pager *organizationsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingHistoryPaginateOption enables pagination customization.
type OrganizationSettingHistoryPaginateOption func(*organizationsettinghistoryPager) error

// WithOrganizationSettingHistoryOrder configures pagination ordering.
func WithOrganizationSettingHistoryOrder(order *OrganizationSettingHistoryOrder) OrganizationSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	o := *order
	return func(pager *organizationsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationSettingHistoryFilter configures pagination filter.
func WithOrganizationSettingHistoryFilter(filter func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)) OrganizationSettingHistoryPaginateOption {
	return func(pager *organizationsettinghistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettinghistoryPager struct {
	reverse bool
	order   *OrganizationSettingHistoryOrder
	filter  func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)
}

func newOrganizationSettingHistoryPager(opts []OrganizationSettingHistoryPaginateOption, reverse bool) (*organizationsettinghistoryPager, error) {
	pager := &organizationsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationSettingHistoryOrder
	}
	return pager, nil
}

func (p *organizationsettinghistoryPager) applyFilter(query *OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) toCursor(osh *OrganizationSettingHistory) Cursor {
	return p.order.Field.toCursor(osh)
}

func (p *organizationsettinghistoryPager) applyCursors(query *OrganizationSettingHistoryQuery, after, before *Cursor) (*OrganizationSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) applyOrder(query *OrganizationSettingHistoryQuery) *OrganizationSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
		query = query.Order(DefaultOrganizationSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationsettinghistoryPager) orderExpr(query *OrganizationSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSettingHistory.
func (osh *OrganizationSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingHistoryPaginateOption,
) (*OrganizationSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if osh, err = pager.applyFilter(osh); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingHistoryConnection{Edges: []*OrganizationSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := osh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if osh, err = pager.applyCursors(osh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		osh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := osh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	osh = pager.applyOrder(osh)
	nodes, err := osh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationSettingHistoryOrderFieldHistoryTime orders OrganizationSettingHistory by history_time.
	OrganizationSettingHistoryOrderFieldHistoryTime = &OrganizationSettingHistoryOrderField{
		Value: func(osh *OrganizationSettingHistory) (ent.Value, error) {
			return osh.HistoryTime, nil
		},
		column: organizationsettinghistory.FieldHistoryTime,
		toTerm: organizationsettinghistory.ByHistoryTime,
		toCursor: func(osh *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.HistoryTime,
			}
		},
	}
	// OrganizationSettingHistoryOrderFieldCreatedAt orders OrganizationSettingHistory by created_at.
	OrganizationSettingHistoryOrderFieldCreatedAt = &OrganizationSettingHistoryOrderField{
		Value: func(osh *OrganizationSettingHistory) (ent.Value, error) {
			return osh.CreatedAt, nil
		},
		column: organizationsettinghistory.FieldCreatedAt,
		toTerm: organizationsettinghistory.ByCreatedAt,
		toCursor: func(osh *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.CreatedAt,
			}
		},
	}
	// OrganizationSettingHistoryOrderFieldUpdatedAt orders OrganizationSettingHistory by updated_at.
	OrganizationSettingHistoryOrderFieldUpdatedAt = &OrganizationSettingHistoryOrderField{
		Value: func(osh *OrganizationSettingHistory) (ent.Value, error) {
			return osh.UpdatedAt, nil
		},
		column: organizationsettinghistory.FieldUpdatedAt,
		toTerm: organizationsettinghistory.ByUpdatedAt,
		toCursor: func(osh *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    osh.ID,
				Value: osh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrganizationSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrganizationSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrganizationSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OrganizationSettingHistoryOrderField", str)
	}
	return nil
}

// OrganizationSettingHistoryOrderField defines the ordering field of OrganizationSettingHistory.
type OrganizationSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationSettingHistory.
	Value    func(*OrganizationSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsettinghistory.OrderOption
	toCursor func(*OrganizationSettingHistory) Cursor
}

// OrganizationSettingHistoryOrder defines the ordering of OrganizationSettingHistory.
type OrganizationSettingHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *OrganizationSettingHistoryOrderField `json:"field"`
}

// DefaultOrganizationSettingHistoryOrder is the default ordering of OrganizationSettingHistory.
var DefaultOrganizationSettingHistoryOrder = &OrganizationSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingHistoryOrderField{
		Value: func(osh *OrganizationSettingHistory) (ent.Value, error) {
			return osh.ID, nil
		},
		column: organizationsettinghistory.FieldID,
		toTerm: organizationsettinghistory.ByID,
		toCursor: func(osh *OrganizationSettingHistory) Cursor {
			return Cursor{ID: osh.ID}
		},
	},
}

// ToEdge converts OrganizationSettingHistory into OrganizationSettingHistoryEdge.
func (osh *OrganizationSettingHistory) ToEdge(order *OrganizationSettingHistoryOrder) *OrganizationSettingHistoryEdge {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	return &OrganizationSettingHistoryEdge{
		Node:   osh,
		Cursor: order.Field.toCursor(osh),
	}
}

// PersonalAccessTokenEdge is the edge representation of PersonalAccessToken.
type PersonalAccessTokenEdge struct {
	Node   *PersonalAccessToken `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// PersonalAccessTokenConnection is the connection containing edges to PersonalAccessToken.
type PersonalAccessTokenConnection struct {
	Edges      []*PersonalAccessTokenEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *PersonalAccessTokenConnection) build(nodes []*PersonalAccessToken, pager *personalaccesstokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *PersonalAccessToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonalAccessTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonalAccessTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonalAccessTokenPaginateOption enables pagination customization.
type PersonalAccessTokenPaginateOption func(*personalaccesstokenPager) error

// WithPersonalAccessTokenOrder configures pagination ordering.
func WithPersonalAccessTokenOrder(order []*PersonalAccessTokenOrder) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonalAccessTokenFilter configures pagination filter.
func WithPersonalAccessTokenFilter(filter func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		if filter == nil {
			return errors.New("PersonalAccessTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personalaccesstokenPager struct {
	reverse bool
	order   []*PersonalAccessTokenOrder
	filter  func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)
}

func newPersonalAccessTokenPager(opts []PersonalAccessTokenPaginateOption, reverse bool) (*personalaccesstokenPager, error) {
	pager := &personalaccesstokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personalaccesstokenPager) applyFilter(query *PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personalaccesstokenPager) toCursor(pat *PersonalAccessToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(pat).Value)
	}
	return Cursor{ID: pat.ID, Value: cs_}
}

func (p *personalaccesstokenPager) applyCursors(query *PersonalAccessTokenQuery, after, before *Cursor) (*PersonalAccessTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonalAccessTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *personalaccesstokenPager) applyOrder(query *PersonalAccessTokenQuery) *PersonalAccessTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonalAccessTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonalAccessTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personalaccesstokenPager) orderExpr(query *PersonalAccessTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonalAccessTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PersonalAccessToken.
func (pat *PersonalAccessTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PersonalAccessTokenPaginateOption,
) (*PersonalAccessTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonalAccessTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pat, err = pager.applyFilter(pat); err != nil {
		return nil, err
	}
	conn := &PersonalAccessTokenConnection{Edges: []*PersonalAccessTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pat.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pat, err = pager.applyCursors(pat, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pat.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pat.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pat = pager.applyOrder(pat)
	nodes, err := pat.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonalAccessTokenOrderFieldCreatedAt orders PersonalAccessToken by created_at.
	PersonalAccessTokenOrderFieldCreatedAt = &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			return pat.CreatedAt, nil
		},
		column: personalaccesstoken.FieldCreatedAt,
		toTerm: personalaccesstoken.ByCreatedAt,
		toCursor: func(pat *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    pat.ID,
				Value: pat.CreatedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldUpdatedAt orders PersonalAccessToken by updated_at.
	PersonalAccessTokenOrderFieldUpdatedAt = &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			return pat.UpdatedAt, nil
		},
		column: personalaccesstoken.FieldUpdatedAt,
		toTerm: personalaccesstoken.ByUpdatedAt,
		toCursor: func(pat *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    pat.ID,
				Value: pat.UpdatedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldName orders PersonalAccessToken by name.
	PersonalAccessTokenOrderFieldName = &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			return pat.Name, nil
		},
		column: personalaccesstoken.FieldName,
		toTerm: personalaccesstoken.ByName,
		toCursor: func(pat *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    pat.ID,
				Value: pat.Name,
			}
		},
	}
	// PersonalAccessTokenOrderFieldExpiresAt orders PersonalAccessToken by expires_at.
	PersonalAccessTokenOrderFieldExpiresAt = &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			// allow for nil values for fields
			if pat.ExpiresAt == nil {
				return nil, nil
			}
			return pat.ExpiresAt, nil
		},
		column: personalaccesstoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) personalaccesstoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return personalaccesstoken.ByExpiresAt(opts...)
		},
		toCursor: func(pat *PersonalAccessToken) Cursor {
			if pat.ExpiresAt == nil {
				return Cursor{
					ID:    pat.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    pat.ID,
				Value: pat.ExpiresAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldLastUsedAt orders PersonalAccessToken by last_used_at.
	PersonalAccessTokenOrderFieldLastUsedAt = &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			// allow for nil values for fields
			if pat.LastUsedAt == nil {
				return nil, nil
			}
			return pat.LastUsedAt, nil
		},
		column: personalaccesstoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) personalaccesstoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return personalaccesstoken.ByLastUsedAt(opts...)
		},
		toCursor: func(pat *PersonalAccessToken) Cursor {
			if pat.LastUsedAt == nil {
				return Cursor{
					ID:    pat.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    pat.ID,
				Value: pat.LastUsedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldIsActive orders PersonalAccessToken by is_active.
	PersonalAccessTokenOrderFieldIsActive = &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			return pat.IsActive, nil
		},
		column: personalaccesstoken.FieldIsActive,
		toTerm: personalaccesstoken.ByIsActive,
		toCursor: func(pat *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    pat.ID,
				Value: pat.IsActive,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonalAccessTokenOrderField) String() string {
	var str string
	switch f.column {
	case PersonalAccessTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case PersonalAccessTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case PersonalAccessTokenOrderFieldName.column:
		str = "name"
	case PersonalAccessTokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case PersonalAccessTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case PersonalAccessTokenOrderFieldIsActive.column:
		str = "is_active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonalAccessTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonalAccessTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonalAccessTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *PersonalAccessTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *PersonalAccessTokenOrderFieldUpdatedAt
	case "name":
		*f = *PersonalAccessTokenOrderFieldName
	case "expires_at":
		*f = *PersonalAccessTokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *PersonalAccessTokenOrderFieldLastUsedAt
	case "is_active":
		*f = *PersonalAccessTokenOrderFieldIsActive
	default:
		return fmt.Errorf("%s is not a valid PersonalAccessTokenOrderField", str)
	}
	return nil
}

// PersonalAccessTokenOrderField defines the ordering field of PersonalAccessToken.
type PersonalAccessTokenOrderField struct {
	// Value extracts the ordering value from the given PersonalAccessToken.
	Value    func(*PersonalAccessToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) personalaccesstoken.OrderOption
	toCursor func(*PersonalAccessToken) Cursor
}

// PersonalAccessTokenOrder defines the ordering of PersonalAccessToken.
type PersonalAccessTokenOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *PersonalAccessTokenOrderField `json:"field"`
}

// DefaultPersonalAccessTokenOrder is the default ordering of PersonalAccessToken.
var DefaultPersonalAccessTokenOrder = &PersonalAccessTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			return pat.ID, nil
		},
		column: personalaccesstoken.FieldID,
		toTerm: personalaccesstoken.ByID,
		toCursor: func(pat *PersonalAccessToken) Cursor {
			return Cursor{ID: pat.ID}
		},
	},
}

// ToEdge converts PersonalAccessToken into PersonalAccessTokenEdge.
func (pat *PersonalAccessToken) ToEdge(order *PersonalAccessTokenOrder) *PersonalAccessTokenEdge {
	if order == nil {
		order = DefaultPersonalAccessTokenOrder
	}
	return &PersonalAccessTokenEdge{
		Node:   pat,
		Cursor: order.Field.toCursor(pat),
	}
}

// ProcedureEdge is the edge representation of Procedure.
type ProcedureEdge struct {
	Node   *Procedure `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ProcedureConnection is the connection containing edges to Procedure.
type ProcedureConnection struct {
	Edges      []*ProcedureEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ProcedureConnection) build(nodes []*Procedure, pager *procedurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Procedure
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Procedure {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Procedure {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedurePaginateOption enables pagination customization.
type ProcedurePaginateOption func(*procedurePager) error

// WithProcedureOrder configures pagination ordering.
func WithProcedureOrder(order []*ProcedureOrder) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProcedureFilter configures pagination filter.
func WithProcedureFilter(filter func(*ProcedureQuery) (*ProcedureQuery, error)) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		if filter == nil {
			return errors.New("ProcedureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurePager struct {
	reverse bool
	order   []*ProcedureOrder
	filter  func(*ProcedureQuery) (*ProcedureQuery, error)
}

func newProcedurePager(opts []ProcedurePaginateOption, reverse bool) (*procedurePager, error) {
	pager := &procedurePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *procedurePager) applyFilter(query *ProcedureQuery) (*ProcedureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurePager) toCursor(pr *Procedure) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs_}
}

func (p *procedurePager) applyCursors(query *ProcedureQuery, after, before *Cursor) (*ProcedureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProcedureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *procedurePager) applyOrder(query *ProcedureQuery) *ProcedureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProcedureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProcedureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *procedurePager) orderExpr(query *ProcedureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProcedureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Procedure.
func (pr *ProcedureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedurePaginateOption,
) (*ProcedureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedurePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProcedureConnection{Edges: []*ProcedureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcedureOrderFieldCreatedAt orders Procedure by created_at.
	ProcedureOrderFieldCreatedAt = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: procedure.FieldCreatedAt,
		toTerm: procedure.ByCreatedAt,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProcedureOrderFieldUpdatedAt orders Procedure by updated_at.
	ProcedureOrderFieldUpdatedAt = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: procedure.FieldUpdatedAt,
		toTerm: procedure.ByUpdatedAt,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProcedureOrderFieldRevision orders Procedure by revision.
	ProcedureOrderFieldRevision = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.Revision, nil
		},
		column: procedure.FieldRevision,
		toTerm: procedure.ByRevision,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Revision,
			}
		},
	}
	// ProcedureOrderFieldName orders Procedure by name.
	ProcedureOrderFieldName = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.Name, nil
		},
		column: procedure.FieldName,
		toTerm: procedure.ByName,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProcedureOrderFieldStatus orders Procedure by status.
	ProcedureOrderFieldStatus = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.Status, nil
		},
		column: procedure.FieldStatus,
		toTerm: procedure.ByStatus,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Status,
			}
		},
	}
	// ProcedureOrderFieldReviewDue orders Procedure by review_due.
	ProcedureOrderFieldReviewDue = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.ReviewDue, nil
		},
		column: procedure.FieldReviewDue,
		toTerm: procedure.ByReviewDue,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.ReviewDue,
			}
		},
	}
	// ProcedureOrderFieldReviewFrequency orders Procedure by review_frequency.
	ProcedureOrderFieldReviewFrequency = &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.ReviewFrequency, nil
		},
		column: procedure.FieldReviewFrequency,
		toTerm: procedure.ByReviewFrequency,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcedureOrderField) String() string {
	var str string
	switch f.column {
	case ProcedureOrderFieldCreatedAt.column:
		str = "created_at"
	case ProcedureOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProcedureOrderFieldRevision.column:
		str = "revision"
	case ProcedureOrderFieldName.column:
		str = "name"
	case ProcedureOrderFieldStatus.column:
		str = "STATUS"
	case ProcedureOrderFieldReviewDue.column:
		str = "review_due"
	case ProcedureOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcedureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcedureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcedureOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProcedureOrderFieldCreatedAt
	case "updated_at":
		*f = *ProcedureOrderFieldUpdatedAt
	case "revision":
		*f = *ProcedureOrderFieldRevision
	case "name":
		*f = *ProcedureOrderFieldName
	case "STATUS":
		*f = *ProcedureOrderFieldStatus
	case "review_due":
		*f = *ProcedureOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ProcedureOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid ProcedureOrderField", str)
	}
	return nil
}

// ProcedureOrderField defines the ordering field of Procedure.
type ProcedureOrderField struct {
	// Value extracts the ordering value from the given Procedure.
	Value    func(*Procedure) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedure.OrderOption
	toCursor func(*Procedure) Cursor
}

// ProcedureOrder defines the ordering of Procedure.
type ProcedureOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ProcedureOrderField `json:"field"`
}

// DefaultProcedureOrder is the default ordering of Procedure.
var DefaultProcedureOrder = &ProcedureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.ID, nil
		},
		column: procedure.FieldID,
		toTerm: procedure.ByID,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Procedure into ProcedureEdge.
func (pr *Procedure) ToEdge(order *ProcedureOrder) *ProcedureEdge {
	if order == nil {
		order = DefaultProcedureOrder
	}
	return &ProcedureEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProcedureHistoryEdge is the edge representation of ProcedureHistory.
type ProcedureHistoryEdge struct {
	Node   *ProcedureHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProcedureHistoryConnection is the connection containing edges to ProcedureHistory.
type ProcedureHistoryConnection struct {
	Edges      []*ProcedureHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProcedureHistoryConnection) build(nodes []*ProcedureHistory, pager *procedurehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProcedureHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedureHistoryPaginateOption enables pagination customization.
type ProcedureHistoryPaginateOption func(*procedurehistoryPager) error

// WithProcedureHistoryOrder configures pagination ordering.
func WithProcedureHistoryOrder(order *ProcedureHistoryOrder) ProcedureHistoryPaginateOption {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	o := *order
	return func(pager *procedurehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcedureHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcedureHistoryFilter configures pagination filter.
func WithProcedureHistoryFilter(filter func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)) ProcedureHistoryPaginateOption {
	return func(pager *procedurehistoryPager) error {
		if filter == nil {
			return errors.New("ProcedureHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurehistoryPager struct {
	reverse bool
	order   *ProcedureHistoryOrder
	filter  func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)
}

func newProcedureHistoryPager(opts []ProcedureHistoryPaginateOption, reverse bool) (*procedurehistoryPager, error) {
	pager := &procedurehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcedureHistoryOrder
	}
	return pager, nil
}

func (p *procedurehistoryPager) applyFilter(query *ProcedureHistoryQuery) (*ProcedureHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurehistoryPager) toCursor(ph *ProcedureHistory) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *procedurehistoryPager) applyCursors(query *ProcedureHistoryQuery, after, before *Cursor) (*ProcedureHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcedureHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procedurehistoryPager) applyOrder(query *ProcedureHistoryQuery) *ProcedureHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcedureHistoryOrder.Field {
		query = query.Order(DefaultProcedureHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procedurehistoryPager) orderExpr(query *ProcedureHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcedureHistoryOrder.Field {
			b.Comma().Ident(DefaultProcedureHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProcedureHistory.
func (ph *ProcedureHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedureHistoryPaginateOption,
) (*ProcedureHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedureHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &ProcedureHistoryConnection{Edges: []*ProcedureHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ph = pager.applyOrder(ph)
	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcedureHistoryOrderFieldHistoryTime orders ProcedureHistory by history_time.
	ProcedureHistoryOrderFieldHistoryTime = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.HistoryTime, nil
		},
		column: procedurehistory.FieldHistoryTime,
		toTerm: procedurehistory.ByHistoryTime,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.HistoryTime,
			}
		},
	}
	// ProcedureHistoryOrderFieldCreatedAt orders ProcedureHistory by created_at.
	ProcedureHistoryOrderFieldCreatedAt = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.CreatedAt, nil
		},
		column: procedurehistory.FieldCreatedAt,
		toTerm: procedurehistory.ByCreatedAt,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.CreatedAt,
			}
		},
	}
	// ProcedureHistoryOrderFieldUpdatedAt orders ProcedureHistory by updated_at.
	ProcedureHistoryOrderFieldUpdatedAt = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.UpdatedAt, nil
		},
		column: procedurehistory.FieldUpdatedAt,
		toTerm: procedurehistory.ByUpdatedAt,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.UpdatedAt,
			}
		},
	}
	// ProcedureHistoryOrderFieldRevision orders ProcedureHistory by revision.
	ProcedureHistoryOrderFieldRevision = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.Revision, nil
		},
		column: procedurehistory.FieldRevision,
		toTerm: procedurehistory.ByRevision,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Revision,
			}
		},
	}
	// ProcedureHistoryOrderFieldName orders ProcedureHistory by name.
	ProcedureHistoryOrderFieldName = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.Name, nil
		},
		column: procedurehistory.FieldName,
		toTerm: procedurehistory.ByName,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Name,
			}
		},
	}
	// ProcedureHistoryOrderFieldStatus orders ProcedureHistory by status.
	ProcedureHistoryOrderFieldStatus = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.Status, nil
		},
		column: procedurehistory.FieldStatus,
		toTerm: procedurehistory.ByStatus,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Status,
			}
		},
	}
	// ProcedureHistoryOrderFieldReviewDue orders ProcedureHistory by review_due.
	ProcedureHistoryOrderFieldReviewDue = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.ReviewDue, nil
		},
		column: procedurehistory.FieldReviewDue,
		toTerm: procedurehistory.ByReviewDue,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.ReviewDue,
			}
		},
	}
	// ProcedureHistoryOrderFieldReviewFrequency orders ProcedureHistory by review_frequency.
	ProcedureHistoryOrderFieldReviewFrequency = &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.ReviewFrequency, nil
		},
		column: procedurehistory.FieldReviewFrequency,
		toTerm: procedurehistory.ByReviewFrequency,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcedureHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProcedureHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProcedureHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProcedureHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProcedureHistoryOrderFieldRevision.column:
		str = "revision"
	case ProcedureHistoryOrderFieldName.column:
		str = "name"
	case ProcedureHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ProcedureHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case ProcedureHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcedureHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcedureHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcedureHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProcedureHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProcedureHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProcedureHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ProcedureHistoryOrderFieldRevision
	case "name":
		*f = *ProcedureHistoryOrderFieldName
	case "STATUS":
		*f = *ProcedureHistoryOrderFieldStatus
	case "review_due":
		*f = *ProcedureHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ProcedureHistoryOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid ProcedureHistoryOrderField", str)
	}
	return nil
}

// ProcedureHistoryOrderField defines the ordering field of ProcedureHistory.
type ProcedureHistoryOrderField struct {
	// Value extracts the ordering value from the given ProcedureHistory.
	Value    func(*ProcedureHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedurehistory.OrderOption
	toCursor func(*ProcedureHistory) Cursor
}

// ProcedureHistoryOrder defines the ordering of ProcedureHistory.
type ProcedureHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProcedureHistoryOrderField `json:"field"`
}

// DefaultProcedureHistoryOrder is the default ordering of ProcedureHistory.
var DefaultProcedureHistoryOrder = &ProcedureHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.ID, nil
		},
		column: procedurehistory.FieldID,
		toTerm: procedurehistory.ByID,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProcedureHistory into ProcedureHistoryEdge.
func (ph *ProcedureHistory) ToEdge(order *ProcedureHistoryOrder) *ProcedureHistoryEdge {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	return &ProcedureHistoryEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProgramEdge is the edge representation of Program.
type ProgramEdge struct {
	Node   *Program `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProgramConnection is the connection containing edges to Program.
type ProgramConnection struct {
	Edges      []*ProgramEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProgramConnection) build(nodes []*Program, pager *programPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Program
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Program {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Program {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramPaginateOption enables pagination customization.
type ProgramPaginateOption func(*programPager) error

// WithProgramOrder configures pagination ordering.
func WithProgramOrder(order []*ProgramOrder) ProgramPaginateOption {
	return func(pager *programPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProgramFilter configures pagination filter.
func WithProgramFilter(filter func(*ProgramQuery) (*ProgramQuery, error)) ProgramPaginateOption {
	return func(pager *programPager) error {
		if filter == nil {
			return errors.New("ProgramQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programPager struct {
	reverse bool
	order   []*ProgramOrder
	filter  func(*ProgramQuery) (*ProgramQuery, error)
}

func newProgramPager(opts []ProgramPaginateOption, reverse bool) (*programPager, error) {
	pager := &programPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *programPager) applyFilter(query *ProgramQuery) (*ProgramQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programPager) toCursor(pr *Program) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(pr).Value)
	}
	return Cursor{ID: pr.ID, Value: cs_}
}

func (p *programPager) applyCursors(query *ProgramQuery, after, before *Cursor) (*ProgramQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProgramOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *programPager) applyOrder(query *ProgramQuery) *ProgramQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProgramOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProgramOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *programPager) orderExpr(query *ProgramQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProgramOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Program.
func (pr *ProgramQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramPaginateOption,
) (*ProgramConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProgramConnection{Edges: []*ProgramEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramOrderFieldCreatedAt orders Program by created_at.
	ProgramOrderFieldCreatedAt = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: program.FieldCreatedAt,
		toTerm: program.ByCreatedAt,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProgramOrderFieldUpdatedAt orders Program by updated_at.
	ProgramOrderFieldUpdatedAt = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: program.FieldUpdatedAt,
		toTerm: program.ByUpdatedAt,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProgramOrderFieldName orders Program by name.
	ProgramOrderFieldName = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.Name, nil
		},
		column: program.FieldName,
		toTerm: program.ByName,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProgramOrderFieldStatus orders Program by status.
	ProgramOrderFieldStatus = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.Status, nil
		},
		column: program.FieldStatus,
		toTerm: program.ByStatus,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Status,
			}
		},
	}
	// ProgramOrderFieldProgramType orders Program by program_type.
	ProgramOrderFieldProgramType = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.ProgramType, nil
		},
		column: program.FieldProgramType,
		toTerm: program.ByProgramType,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.ProgramType,
			}
		},
	}
	// ProgramOrderFieldFrameworkName orders Program by framework_name.
	ProgramOrderFieldFrameworkName = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.FrameworkName, nil
		},
		column: program.FieldFrameworkName,
		toTerm: program.ByFrameworkName,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.FrameworkName,
			}
		},
	}
	// ProgramOrderFieldStartDate orders Program by start_date.
	ProgramOrderFieldStartDate = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.StartDate, nil
		},
		column: program.FieldStartDate,
		toTerm: program.ByStartDate,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.StartDate,
			}
		},
	}
	// ProgramOrderFieldEndDate orders Program by end_date.
	ProgramOrderFieldEndDate = &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.EndDate, nil
		},
		column: program.FieldEndDate,
		toTerm: program.ByEndDate,
		toCursor: func(pr *Program) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramOrderField) String() string {
	var str string
	switch f.column {
	case ProgramOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramOrderFieldName.column:
		str = "name"
	case ProgramOrderFieldStatus.column:
		str = "STATUS"
	case ProgramOrderFieldProgramType.column:
		str = "PROGRAM_TYPE"
	case ProgramOrderFieldFrameworkName.column:
		str = "framework"
	case ProgramOrderFieldStartDate.column:
		str = "start_date"
	case ProgramOrderFieldEndDate.column:
		str = "end_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProgramOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramOrderFieldUpdatedAt
	case "name":
		*f = *ProgramOrderFieldName
	case "STATUS":
		*f = *ProgramOrderFieldStatus
	case "PROGRAM_TYPE":
		*f = *ProgramOrderFieldProgramType
	case "framework":
		*f = *ProgramOrderFieldFrameworkName
	case "start_date":
		*f = *ProgramOrderFieldStartDate
	case "end_date":
		*f = *ProgramOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid ProgramOrderField", str)
	}
	return nil
}

// ProgramOrderField defines the ordering field of Program.
type ProgramOrderField struct {
	// Value extracts the ordering value from the given Program.
	Value    func(*Program) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) program.OrderOption
	toCursor func(*Program) Cursor
}

// ProgramOrder defines the ordering of Program.
type ProgramOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProgramOrderField `json:"field"`
}

// DefaultProgramOrder is the default ordering of Program.
var DefaultProgramOrder = &ProgramOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.ID, nil
		},
		column: program.FieldID,
		toTerm: program.ByID,
		toCursor: func(pr *Program) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Program into ProgramEdge.
func (pr *Program) ToEdge(order *ProgramOrder) *ProgramEdge {
	if order == nil {
		order = DefaultProgramOrder
	}
	return &ProgramEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProgramHistoryEdge is the edge representation of ProgramHistory.
type ProgramHistoryEdge struct {
	Node   *ProgramHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ProgramHistoryConnection is the connection containing edges to ProgramHistory.
type ProgramHistoryConnection struct {
	Edges      []*ProgramHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ProgramHistoryConnection) build(nodes []*ProgramHistory, pager *programhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramHistoryPaginateOption enables pagination customization.
type ProgramHistoryPaginateOption func(*programhistoryPager) error

// WithProgramHistoryOrder configures pagination ordering.
func WithProgramHistoryOrder(order *ProgramHistoryOrder) ProgramHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	o := *order
	return func(pager *programhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramHistoryFilter configures pagination filter.
func WithProgramHistoryFilter(filter func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)) ProgramHistoryPaginateOption {
	return func(pager *programhistoryPager) error {
		if filter == nil {
			return errors.New("ProgramHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programhistoryPager struct {
	reverse bool
	order   *ProgramHistoryOrder
	filter  func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)
}

func newProgramHistoryPager(opts []ProgramHistoryPaginateOption, reverse bool) (*programhistoryPager, error) {
	pager := &programhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramHistoryOrder
	}
	return pager, nil
}

func (p *programhistoryPager) applyFilter(query *ProgramHistoryQuery) (*ProgramHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programhistoryPager) toCursor(ph *ProgramHistory) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *programhistoryPager) applyCursors(query *ProgramHistoryQuery, after, before *Cursor) (*ProgramHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programhistoryPager) applyOrder(query *ProgramHistoryQuery) *ProgramHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramHistoryOrder.Field {
		query = query.Order(DefaultProgramHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programhistoryPager) orderExpr(query *ProgramHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramHistory.
func (ph *ProgramHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramHistoryPaginateOption,
) (*ProgramHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &ProgramHistoryConnection{Edges: []*ProgramHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ph = pager.applyOrder(ph)
	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramHistoryOrderFieldHistoryTime orders ProgramHistory by history_time.
	ProgramHistoryOrderFieldHistoryTime = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.HistoryTime, nil
		},
		column: programhistory.FieldHistoryTime,
		toTerm: programhistory.ByHistoryTime,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.HistoryTime,
			}
		},
	}
	// ProgramHistoryOrderFieldCreatedAt orders ProgramHistory by created_at.
	ProgramHistoryOrderFieldCreatedAt = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.CreatedAt, nil
		},
		column: programhistory.FieldCreatedAt,
		toTerm: programhistory.ByCreatedAt,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.CreatedAt,
			}
		},
	}
	// ProgramHistoryOrderFieldUpdatedAt orders ProgramHistory by updated_at.
	ProgramHistoryOrderFieldUpdatedAt = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.UpdatedAt, nil
		},
		column: programhistory.FieldUpdatedAt,
		toTerm: programhistory.ByUpdatedAt,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.UpdatedAt,
			}
		},
	}
	// ProgramHistoryOrderFieldName orders ProgramHistory by name.
	ProgramHistoryOrderFieldName = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.Name, nil
		},
		column: programhistory.FieldName,
		toTerm: programhistory.ByName,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Name,
			}
		},
	}
	// ProgramHistoryOrderFieldStatus orders ProgramHistory by status.
	ProgramHistoryOrderFieldStatus = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.Status, nil
		},
		column: programhistory.FieldStatus,
		toTerm: programhistory.ByStatus,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Status,
			}
		},
	}
	// ProgramHistoryOrderFieldProgramType orders ProgramHistory by program_type.
	ProgramHistoryOrderFieldProgramType = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.ProgramType, nil
		},
		column: programhistory.FieldProgramType,
		toTerm: programhistory.ByProgramType,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.ProgramType,
			}
		},
	}
	// ProgramHistoryOrderFieldFrameworkName orders ProgramHistory by framework_name.
	ProgramHistoryOrderFieldFrameworkName = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.FrameworkName, nil
		},
		column: programhistory.FieldFrameworkName,
		toTerm: programhistory.ByFrameworkName,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.FrameworkName,
			}
		},
	}
	// ProgramHistoryOrderFieldStartDate orders ProgramHistory by start_date.
	ProgramHistoryOrderFieldStartDate = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.StartDate, nil
		},
		column: programhistory.FieldStartDate,
		toTerm: programhistory.ByStartDate,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.StartDate,
			}
		},
	}
	// ProgramHistoryOrderFieldEndDate orders ProgramHistory by end_date.
	ProgramHistoryOrderFieldEndDate = &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.EndDate, nil
		},
		column: programhistory.FieldEndDate,
		toTerm: programhistory.ByEndDate,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProgramHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProgramHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramHistoryOrderFieldName.column:
		str = "name"
	case ProgramHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ProgramHistoryOrderFieldProgramType.column:
		str = "PROGRAM_TYPE"
	case ProgramHistoryOrderFieldFrameworkName.column:
		str = "framework"
	case ProgramHistoryOrderFieldStartDate.column:
		str = "start_date"
	case ProgramHistoryOrderFieldEndDate.column:
		str = "end_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProgramHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProgramHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramHistoryOrderFieldUpdatedAt
	case "name":
		*f = *ProgramHistoryOrderFieldName
	case "STATUS":
		*f = *ProgramHistoryOrderFieldStatus
	case "PROGRAM_TYPE":
		*f = *ProgramHistoryOrderFieldProgramType
	case "framework":
		*f = *ProgramHistoryOrderFieldFrameworkName
	case "start_date":
		*f = *ProgramHistoryOrderFieldStartDate
	case "end_date":
		*f = *ProgramHistoryOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid ProgramHistoryOrderField", str)
	}
	return nil
}

// ProgramHistoryOrderField defines the ordering field of ProgramHistory.
type ProgramHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramHistory.
	Value    func(*ProgramHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programhistory.OrderOption
	toCursor func(*ProgramHistory) Cursor
}

// ProgramHistoryOrder defines the ordering of ProgramHistory.
type ProgramHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ProgramHistoryOrderField `json:"field"`
}

// DefaultProgramHistoryOrder is the default ordering of ProgramHistory.
var DefaultProgramHistoryOrder = &ProgramHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.ID, nil
		},
		column: programhistory.FieldID,
		toTerm: programhistory.ByID,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProgramHistory into ProgramHistoryEdge.
func (ph *ProgramHistory) ToEdge(order *ProgramHistoryOrder) *ProgramHistoryEdge {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	return &ProgramHistoryEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProgramMembershipEdge is the edge representation of ProgramMembership.
type ProgramMembershipEdge struct {
	Node   *ProgramMembership `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ProgramMembershipConnection is the connection containing edges to ProgramMembership.
type ProgramMembershipConnection struct {
	Edges      []*ProgramMembershipEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ProgramMembershipConnection) build(nodes []*ProgramMembership, pager *programmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipPaginateOption enables pagination customization.
type ProgramMembershipPaginateOption func(*programmembershipPager) error

// WithProgramMembershipOrder configures pagination ordering.
func WithProgramMembershipOrder(order []*ProgramMembershipOrder) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProgramMembershipFilter configures pagination filter.
func WithProgramMembershipFilter(filter func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershipPager struct {
	reverse bool
	order   []*ProgramMembershipOrder
	filter  func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)
}

func newProgramMembershipPager(opts []ProgramMembershipPaginateOption, reverse bool) (*programmembershipPager, error) {
	pager := &programmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *programmembershipPager) applyFilter(query *ProgramMembershipQuery) (*ProgramMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershipPager) toCursor(pm *ProgramMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(pm).Value)
	}
	return Cursor{ID: pm.ID, Value: cs_}
}

func (p *programmembershipPager) applyCursors(query *ProgramMembershipQuery, after, before *Cursor) (*ProgramMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProgramMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *programmembershipPager) applyOrder(query *ProgramMembershipQuery) *ProgramMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProgramMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProgramMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *programmembershipPager) orderExpr(query *ProgramMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProgramMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembership.
func (pm *ProgramMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipPaginateOption,
) (*ProgramMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pm, err = pager.applyFilter(pm); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipConnection{Edges: []*ProgramMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pm.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pm, err = pager.applyCursors(pm, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pm.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pm = pager.applyOrder(pm)
	nodes, err := pm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramMembershipOrderFieldCreatedAt orders ProgramMembership by created_at.
	ProgramMembershipOrderFieldCreatedAt = &ProgramMembershipOrderField{
		Value: func(pm *ProgramMembership) (ent.Value, error) {
			return pm.CreatedAt, nil
		},
		column: programmembership.FieldCreatedAt,
		toTerm: programmembership.ByCreatedAt,
		toCursor: func(pm *ProgramMembership) Cursor {
			return Cursor{
				ID:    pm.ID,
				Value: pm.CreatedAt,
			}
		},
	}
	// ProgramMembershipOrderFieldUpdatedAt orders ProgramMembership by updated_at.
	ProgramMembershipOrderFieldUpdatedAt = &ProgramMembershipOrderField{
		Value: func(pm *ProgramMembership) (ent.Value, error) {
			return pm.UpdatedAt, nil
		},
		column: programmembership.FieldUpdatedAt,
		toTerm: programmembership.ByUpdatedAt,
		toCursor: func(pm *ProgramMembership) Cursor {
			return Cursor{
				ID:    pm.ID,
				Value: pm.UpdatedAt,
			}
		},
	}
	// ProgramMembershipOrderFieldRole orders ProgramMembership by role.
	ProgramMembershipOrderFieldRole = &ProgramMembershipOrderField{
		Value: func(pm *ProgramMembership) (ent.Value, error) {
			return pm.Role, nil
		},
		column: programmembership.FieldRole,
		toTerm: programmembership.ByRole,
		toCursor: func(pm *ProgramMembership) Cursor {
			return Cursor{
				ID:    pm.ID,
				Value: pm.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramMembershipOrderField) String() string {
	var str string
	switch f.column {
	case ProgramMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProgramMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *ProgramMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid ProgramMembershipOrderField", str)
	}
	return nil
}

// ProgramMembershipOrderField defines the ordering field of ProgramMembership.
type ProgramMembershipOrderField struct {
	// Value extracts the ordering value from the given ProgramMembership.
	Value    func(*ProgramMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembership.OrderOption
	toCursor func(*ProgramMembership) Cursor
}

// ProgramMembershipOrder defines the ordering of ProgramMembership.
type ProgramMembershipOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ProgramMembershipOrderField `json:"field"`
}

// DefaultProgramMembershipOrder is the default ordering of ProgramMembership.
var DefaultProgramMembershipOrder = &ProgramMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipOrderField{
		Value: func(pm *ProgramMembership) (ent.Value, error) {
			return pm.ID, nil
		},
		column: programmembership.FieldID,
		toTerm: programmembership.ByID,
		toCursor: func(pm *ProgramMembership) Cursor {
			return Cursor{ID: pm.ID}
		},
	},
}

// ToEdge converts ProgramMembership into ProgramMembershipEdge.
func (pm *ProgramMembership) ToEdge(order *ProgramMembershipOrder) *ProgramMembershipEdge {
	if order == nil {
		order = DefaultProgramMembershipOrder
	}
	return &ProgramMembershipEdge{
		Node:   pm,
		Cursor: order.Field.toCursor(pm),
	}
}

// ProgramMembershipHistoryEdge is the edge representation of ProgramMembershipHistory.
type ProgramMembershipHistoryEdge struct {
	Node   *ProgramMembershipHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// ProgramMembershipHistoryConnection is the connection containing edges to ProgramMembershipHistory.
type ProgramMembershipHistoryConnection struct {
	Edges      []*ProgramMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *ProgramMembershipHistoryConnection) build(nodes []*ProgramMembershipHistory, pager *programmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipHistoryPaginateOption enables pagination customization.
type ProgramMembershipHistoryPaginateOption func(*programmembershiphistoryPager) error

// WithProgramMembershipHistoryOrder configures pagination ordering.
func WithProgramMembershipHistoryOrder(order *ProgramMembershipHistoryOrder) ProgramMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	o := *order
	return func(pager *programmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramMembershipHistoryFilter configures pagination filter.
func WithProgramMembershipHistoryFilter(filter func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)) ProgramMembershipHistoryPaginateOption {
	return func(pager *programmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershiphistoryPager struct {
	reverse bool
	order   *ProgramMembershipHistoryOrder
	filter  func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)
}

func newProgramMembershipHistoryPager(opts []ProgramMembershipHistoryPaginateOption, reverse bool) (*programmembershiphistoryPager, error) {
	pager := &programmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramMembershipHistoryOrder
	}
	return pager, nil
}

func (p *programmembershiphistoryPager) applyFilter(query *ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) toCursor(pmh *ProgramMembershipHistory) Cursor {
	return p.order.Field.toCursor(pmh)
}

func (p *programmembershiphistoryPager) applyCursors(query *ProgramMembershipHistoryQuery, after, before *Cursor) (*ProgramMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) applyOrder(query *ProgramMembershipHistoryQuery) *ProgramMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
		query = query.Order(DefaultProgramMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programmembershiphistoryPager) orderExpr(query *ProgramMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembershipHistory.
func (pmh *ProgramMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipHistoryPaginateOption,
) (*ProgramMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pmh, err = pager.applyFilter(pmh); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipHistoryConnection{Edges: []*ProgramMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pmh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pmh, err = pager.applyCursors(pmh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pmh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pmh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pmh = pager.applyOrder(pmh)
	nodes, err := pmh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramMembershipHistoryOrderFieldHistoryTime orders ProgramMembershipHistory by history_time.
	ProgramMembershipHistoryOrderFieldHistoryTime = &ProgramMembershipHistoryOrderField{
		Value: func(pmh *ProgramMembershipHistory) (ent.Value, error) {
			return pmh.HistoryTime, nil
		},
		column: programmembershiphistory.FieldHistoryTime,
		toTerm: programmembershiphistory.ByHistoryTime,
		toCursor: func(pmh *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    pmh.ID,
				Value: pmh.HistoryTime,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldCreatedAt orders ProgramMembershipHistory by created_at.
	ProgramMembershipHistoryOrderFieldCreatedAt = &ProgramMembershipHistoryOrderField{
		Value: func(pmh *ProgramMembershipHistory) (ent.Value, error) {
			return pmh.CreatedAt, nil
		},
		column: programmembershiphistory.FieldCreatedAt,
		toTerm: programmembershiphistory.ByCreatedAt,
		toCursor: func(pmh *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    pmh.ID,
				Value: pmh.CreatedAt,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldUpdatedAt orders ProgramMembershipHistory by updated_at.
	ProgramMembershipHistoryOrderFieldUpdatedAt = &ProgramMembershipHistoryOrderField{
		Value: func(pmh *ProgramMembershipHistory) (ent.Value, error) {
			return pmh.UpdatedAt, nil
		},
		column: programmembershiphistory.FieldUpdatedAt,
		toTerm: programmembershiphistory.ByUpdatedAt,
		toCursor: func(pmh *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    pmh.ID,
				Value: pmh.UpdatedAt,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldRole orders ProgramMembershipHistory by role.
	ProgramMembershipHistoryOrderFieldRole = &ProgramMembershipHistoryOrderField{
		Value: func(pmh *ProgramMembershipHistory) (ent.Value, error) {
			return pmh.Role, nil
		},
		column: programmembershiphistory.FieldRole,
		toTerm: programmembershiphistory.ByRole,
		toCursor: func(pmh *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    pmh.ID,
				Value: pmh.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProgramMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProgramMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProgramMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProgramMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *ProgramMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid ProgramMembershipHistoryOrderField", str)
	}
	return nil
}

// ProgramMembershipHistoryOrderField defines the ordering field of ProgramMembershipHistory.
type ProgramMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramMembershipHistory.
	Value    func(*ProgramMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembershiphistory.OrderOption
	toCursor func(*ProgramMembershipHistory) Cursor
}

// ProgramMembershipHistoryOrder defines the ordering of ProgramMembershipHistory.
type ProgramMembershipHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *ProgramMembershipHistoryOrderField `json:"field"`
}

// DefaultProgramMembershipHistoryOrder is the default ordering of ProgramMembershipHistory.
var DefaultProgramMembershipHistoryOrder = &ProgramMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipHistoryOrderField{
		Value: func(pmh *ProgramMembershipHistory) (ent.Value, error) {
			return pmh.ID, nil
		},
		column: programmembershiphistory.FieldID,
		toTerm: programmembershiphistory.ByID,
		toCursor: func(pmh *ProgramMembershipHistory) Cursor {
			return Cursor{ID: pmh.ID}
		},
	},
}

// ToEdge converts ProgramMembershipHistory into ProgramMembershipHistoryEdge.
func (pmh *ProgramMembershipHistory) ToEdge(order *ProgramMembershipHistoryOrder) *ProgramMembershipHistoryEdge {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	return &ProgramMembershipHistoryEdge{
		Node:   pmh,
		Cursor: order.Field.toCursor(pmh),
	}
}

// RiskEdge is the edge representation of Risk.
type RiskEdge struct {
	Node   *Risk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RiskConnection is the connection containing edges to Risk.
type RiskConnection struct {
	Edges      []*RiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *RiskConnection) build(nodes []*Risk, pager *riskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Risk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Risk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Risk {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskPaginateOption enables pagination customization.
type RiskPaginateOption func(*riskPager) error

// WithRiskOrder configures pagination ordering.
func WithRiskOrder(order []*RiskOrder) RiskPaginateOption {
	return func(pager *riskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRiskFilter configures pagination filter.
func WithRiskFilter(filter func(*RiskQuery) (*RiskQuery, error)) RiskPaginateOption {
	return func(pager *riskPager) error {
		if filter == nil {
			return errors.New("RiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskPager struct {
	reverse bool
	order   []*RiskOrder
	filter  func(*RiskQuery) (*RiskQuery, error)
}

func newRiskPager(opts []RiskPaginateOption, reverse bool) (*riskPager, error) {
	pager := &riskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *riskPager) applyFilter(query *RiskQuery) (*RiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskPager) toCursor(r *Risk) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(r).Value)
	}
	return Cursor{ID: r.ID, Value: cs_}
}

func (p *riskPager) applyCursors(query *RiskQuery, after, before *Cursor) (*RiskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRiskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *riskPager) applyOrder(query *RiskQuery) *RiskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRiskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRiskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *riskPager) orderExpr(query *RiskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRiskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Risk.
func (r *RiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskPaginateOption,
) (*RiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RiskConnection{Edges: []*RiskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RiskOrderFieldCreatedAt orders Risk by created_at.
	RiskOrderFieldCreatedAt = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.CreatedAt, nil
		},
		column: risk.FieldCreatedAt,
		toTerm: risk.ByCreatedAt,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
	// RiskOrderFieldUpdatedAt orders Risk by updated_at.
	RiskOrderFieldUpdatedAt = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.UpdatedAt, nil
		},
		column: risk.FieldUpdatedAt,
		toTerm: risk.ByUpdatedAt,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.UpdatedAt,
			}
		},
	}
	// RiskOrderFieldName orders Risk by name.
	RiskOrderFieldName = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.Name, nil
		},
		column: risk.FieldName,
		toTerm: risk.ByName,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
	// RiskOrderFieldStatus orders Risk by status.
	RiskOrderFieldStatus = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.Status, nil
		},
		column: risk.FieldStatus,
		toTerm: risk.ByStatus,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Status,
			}
		},
	}
	// RiskOrderFieldRiskType orders Risk by risk_type.
	RiskOrderFieldRiskType = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.RiskType, nil
		},
		column: risk.FieldRiskType,
		toTerm: risk.ByRiskType,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.RiskType,
			}
		},
	}
	// RiskOrderFieldCategory orders Risk by category.
	RiskOrderFieldCategory = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.Category, nil
		},
		column: risk.FieldCategory,
		toTerm: risk.ByCategory,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Category,
			}
		},
	}
	// RiskOrderFieldImpact orders Risk by impact.
	RiskOrderFieldImpact = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.Impact, nil
		},
		column: risk.FieldImpact,
		toTerm: risk.ByImpact,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Impact,
			}
		},
	}
	// RiskOrderFieldLikelihood orders Risk by likelihood.
	RiskOrderFieldLikelihood = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.Likelihood, nil
		},
		column: risk.FieldLikelihood,
		toTerm: risk.ByLikelihood,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Likelihood,
			}
		},
	}
	// RiskOrderFieldScore orders Risk by score.
	RiskOrderFieldScore = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.Score, nil
		},
		column: risk.FieldScore,
		toTerm: risk.ByScore,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Score,
			}
		},
	}
	// RiskOrderFieldBusinessCosts orders Risk by business_costs.
	RiskOrderFieldBusinessCosts = &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.BusinessCosts, nil
		},
		column: risk.FieldBusinessCosts,
		toTerm: risk.ByBusinessCosts,
		toCursor: func(r *Risk) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.BusinessCosts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RiskOrderField) String() string {
	var str string
	switch f.column {
	case RiskOrderFieldCreatedAt.column:
		str = "created_at"
	case RiskOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RiskOrderFieldName.column:
		str = "name"
	case RiskOrderFieldStatus.column:
		str = "STATUS"
	case RiskOrderFieldRiskType.column:
		str = "risk_type"
	case RiskOrderFieldCategory.column:
		str = "category"
	case RiskOrderFieldImpact.column:
		str = "IMPACT"
	case RiskOrderFieldLikelihood.column:
		str = "LIKELIHOOD"
	case RiskOrderFieldScore.column:
		str = "score"
	case RiskOrderFieldBusinessCosts.column:
		str = "business_costs"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RiskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RiskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RiskOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RiskOrderFieldCreatedAt
	case "updated_at":
		*f = *RiskOrderFieldUpdatedAt
	case "name":
		*f = *RiskOrderFieldName
	case "STATUS":
		*f = *RiskOrderFieldStatus
	case "risk_type":
		*f = *RiskOrderFieldRiskType
	case "category":
		*f = *RiskOrderFieldCategory
	case "IMPACT":
		*f = *RiskOrderFieldImpact
	case "LIKELIHOOD":
		*f = *RiskOrderFieldLikelihood
	case "score":
		*f = *RiskOrderFieldScore
	case "business_costs":
		*f = *RiskOrderFieldBusinessCosts
	default:
		return fmt.Errorf("%s is not a valid RiskOrderField", str)
	}
	return nil
}

// RiskOrderField defines the ordering field of Risk.
type RiskOrderField struct {
	// Value extracts the ordering value from the given Risk.
	Value    func(*Risk) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) risk.OrderOption
	toCursor func(*Risk) Cursor
}

// RiskOrder defines the ordering of Risk.
type RiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RiskOrderField `json:"field"`
}

// DefaultRiskOrder is the default ordering of Risk.
var DefaultRiskOrder = &RiskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.ID, nil
		},
		column: risk.FieldID,
		toTerm: risk.ByID,
		toCursor: func(r *Risk) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Risk into RiskEdge.
func (r *Risk) ToEdge(order *RiskOrder) *RiskEdge {
	if order == nil {
		order = DefaultRiskOrder
	}
	return &RiskEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RiskHistoryEdge is the edge representation of RiskHistory.
type RiskHistoryEdge struct {
	Node   *RiskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// RiskHistoryConnection is the connection containing edges to RiskHistory.
type RiskHistoryConnection struct {
	Edges      []*RiskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *RiskHistoryConnection) build(nodes []*RiskHistory, pager *riskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *RiskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RiskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RiskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskHistoryPaginateOption enables pagination customization.
type RiskHistoryPaginateOption func(*riskhistoryPager) error

// WithRiskHistoryOrder configures pagination ordering.
func WithRiskHistoryOrder(order *RiskHistoryOrder) RiskHistoryPaginateOption {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	o := *order
	return func(pager *riskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRiskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRiskHistoryFilter configures pagination filter.
func WithRiskHistoryFilter(filter func(*RiskHistoryQuery) (*RiskHistoryQuery, error)) RiskHistoryPaginateOption {
	return func(pager *riskhistoryPager) error {
		if filter == nil {
			return errors.New("RiskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskhistoryPager struct {
	reverse bool
	order   *RiskHistoryOrder
	filter  func(*RiskHistoryQuery) (*RiskHistoryQuery, error)
}

func newRiskHistoryPager(opts []RiskHistoryPaginateOption, reverse bool) (*riskhistoryPager, error) {
	pager := &riskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRiskHistoryOrder
	}
	return pager, nil
}

func (p *riskhistoryPager) applyFilter(query *RiskHistoryQuery) (*RiskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskhistoryPager) toCursor(rh *RiskHistory) Cursor {
	return p.order.Field.toCursor(rh)
}

func (p *riskhistoryPager) applyCursors(query *RiskHistoryQuery, after, before *Cursor) (*RiskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRiskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *riskhistoryPager) applyOrder(query *RiskHistoryQuery) *RiskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRiskHistoryOrder.Field {
		query = query.Order(DefaultRiskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *riskhistoryPager) orderExpr(query *RiskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRiskHistoryOrder.Field {
			b.Comma().Ident(DefaultRiskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RiskHistory.
func (rh *RiskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskHistoryPaginateOption,
) (*RiskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rh, err = pager.applyFilter(rh); err != nil {
		return nil, err
	}
	conn := &RiskHistoryConnection{Edges: []*RiskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rh, err = pager.applyCursors(rh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rh = pager.applyOrder(rh)
	nodes, err := rh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RiskHistoryOrderFieldHistoryTime orders RiskHistory by history_time.
	RiskHistoryOrderFieldHistoryTime = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.HistoryTime, nil
		},
		column: riskhistory.FieldHistoryTime,
		toTerm: riskhistory.ByHistoryTime,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.HistoryTime,
			}
		},
	}
	// RiskHistoryOrderFieldCreatedAt orders RiskHistory by created_at.
	RiskHistoryOrderFieldCreatedAt = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.CreatedAt, nil
		},
		column: riskhistory.FieldCreatedAt,
		toTerm: riskhistory.ByCreatedAt,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.CreatedAt,
			}
		},
	}
	// RiskHistoryOrderFieldUpdatedAt orders RiskHistory by updated_at.
	RiskHistoryOrderFieldUpdatedAt = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.UpdatedAt, nil
		},
		column: riskhistory.FieldUpdatedAt,
		toTerm: riskhistory.ByUpdatedAt,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.UpdatedAt,
			}
		},
	}
	// RiskHistoryOrderFieldName orders RiskHistory by name.
	RiskHistoryOrderFieldName = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.Name, nil
		},
		column: riskhistory.FieldName,
		toTerm: riskhistory.ByName,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.Name,
			}
		},
	}
	// RiskHistoryOrderFieldStatus orders RiskHistory by status.
	RiskHistoryOrderFieldStatus = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.Status, nil
		},
		column: riskhistory.FieldStatus,
		toTerm: riskhistory.ByStatus,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.Status,
			}
		},
	}
	// RiskHistoryOrderFieldRiskType orders RiskHistory by risk_type.
	RiskHistoryOrderFieldRiskType = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.RiskType, nil
		},
		column: riskhistory.FieldRiskType,
		toTerm: riskhistory.ByRiskType,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.RiskType,
			}
		},
	}
	// RiskHistoryOrderFieldCategory orders RiskHistory by category.
	RiskHistoryOrderFieldCategory = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.Category, nil
		},
		column: riskhistory.FieldCategory,
		toTerm: riskhistory.ByCategory,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.Category,
			}
		},
	}
	// RiskHistoryOrderFieldImpact orders RiskHistory by impact.
	RiskHistoryOrderFieldImpact = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.Impact, nil
		},
		column: riskhistory.FieldImpact,
		toTerm: riskhistory.ByImpact,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.Impact,
			}
		},
	}
	// RiskHistoryOrderFieldLikelihood orders RiskHistory by likelihood.
	RiskHistoryOrderFieldLikelihood = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.Likelihood, nil
		},
		column: riskhistory.FieldLikelihood,
		toTerm: riskhistory.ByLikelihood,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.Likelihood,
			}
		},
	}
	// RiskHistoryOrderFieldScore orders RiskHistory by score.
	RiskHistoryOrderFieldScore = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.Score, nil
		},
		column: riskhistory.FieldScore,
		toTerm: riskhistory.ByScore,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.Score,
			}
		},
	}
	// RiskHistoryOrderFieldBusinessCosts orders RiskHistory by business_costs.
	RiskHistoryOrderFieldBusinessCosts = &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.BusinessCosts, nil
		},
		column: riskhistory.FieldBusinessCosts,
		toTerm: riskhistory.ByBusinessCosts,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{
				ID:    rh.ID,
				Value: rh.BusinessCosts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RiskHistoryOrderField) String() string {
	var str string
	switch f.column {
	case RiskHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case RiskHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case RiskHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RiskHistoryOrderFieldName.column:
		str = "name"
	case RiskHistoryOrderFieldStatus.column:
		str = "STATUS"
	case RiskHistoryOrderFieldRiskType.column:
		str = "risk_type"
	case RiskHistoryOrderFieldCategory.column:
		str = "category"
	case RiskHistoryOrderFieldImpact.column:
		str = "IMPACT"
	case RiskHistoryOrderFieldLikelihood.column:
		str = "LIKELIHOOD"
	case RiskHistoryOrderFieldScore.column:
		str = "score"
	case RiskHistoryOrderFieldBusinessCosts.column:
		str = "business_costs"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RiskHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RiskHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RiskHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *RiskHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *RiskHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *RiskHistoryOrderFieldUpdatedAt
	case "name":
		*f = *RiskHistoryOrderFieldName
	case "STATUS":
		*f = *RiskHistoryOrderFieldStatus
	case "risk_type":
		*f = *RiskHistoryOrderFieldRiskType
	case "category":
		*f = *RiskHistoryOrderFieldCategory
	case "IMPACT":
		*f = *RiskHistoryOrderFieldImpact
	case "LIKELIHOOD":
		*f = *RiskHistoryOrderFieldLikelihood
	case "score":
		*f = *RiskHistoryOrderFieldScore
	case "business_costs":
		*f = *RiskHistoryOrderFieldBusinessCosts
	default:
		return fmt.Errorf("%s is not a valid RiskHistoryOrderField", str)
	}
	return nil
}

// RiskHistoryOrderField defines the ordering field of RiskHistory.
type RiskHistoryOrderField struct {
	// Value extracts the ordering value from the given RiskHistory.
	Value    func(*RiskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) riskhistory.OrderOption
	toCursor func(*RiskHistory) Cursor
}

// RiskHistoryOrder defines the ordering of RiskHistory.
type RiskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *RiskHistoryOrderField `json:"field"`
}

// DefaultRiskHistoryOrder is the default ordering of RiskHistory.
var DefaultRiskHistoryOrder = &RiskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.ID, nil
		},
		column: riskhistory.FieldID,
		toTerm: riskhistory.ByID,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{ID: rh.ID}
		},
	},
}

// ToEdge converts RiskHistory into RiskHistoryEdge.
func (rh *RiskHistory) ToEdge(order *RiskHistoryOrder) *RiskHistoryEdge {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	return &RiskHistoryEdge{
		Node:   rh,
		Cursor: order.Field.toCursor(rh),
	}
}

// ScanEdge is the edge representation of Scan.
type ScanEdge struct {
	Node   *Scan  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ScanConnection is the connection containing edges to Scan.
type ScanConnection struct {
	Edges      []*ScanEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *ScanConnection) build(nodes []*Scan, pager *scanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Scan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Scan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Scan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScanPaginateOption enables pagination customization.
type ScanPaginateOption func(*scanPager) error

// WithScanOrder configures pagination ordering.
func WithScanOrder(order []*ScanOrder) ScanPaginateOption {
	return func(pager *scanPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScanFilter configures pagination filter.
func WithScanFilter(filter func(*ScanQuery) (*ScanQuery, error)) ScanPaginateOption {
	return func(pager *scanPager) error {
		if filter == nil {
			return errors.New("ScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scanPager struct {
	reverse bool
	order   []*ScanOrder
	filter  func(*ScanQuery) (*ScanQuery, error)
}

func newScanPager(opts []ScanPaginateOption, reverse bool) (*scanPager, error) {
	pager := &scanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scanPager) applyFilter(query *ScanQuery) (*ScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scanPager) toCursor(s *Scan) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs_}
}

func (p *scanPager) applyCursors(query *ScanQuery, after, before *Cursor) (*ScanQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScanOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scanPager) applyOrder(query *ScanQuery) *ScanQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScanOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scanPager) orderExpr(query *ScanQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScanOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Scan.
func (s *ScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScanPaginateOption,
) (*ScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &ScanConnection{Edges: []*ScanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScanOrderFieldCreatedAt orders Scan by created_at.
	ScanOrderFieldCreatedAt = &ScanOrderField{
		Value: func(s *Scan) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: scan.FieldCreatedAt,
		toTerm: scan.ByCreatedAt,
		toCursor: func(s *Scan) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// ScanOrderFieldUpdatedAt orders Scan by updated_at.
	ScanOrderFieldUpdatedAt = &ScanOrderField{
		Value: func(s *Scan) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: scan.FieldUpdatedAt,
		toTerm: scan.ByUpdatedAt,
		toCursor: func(s *Scan) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// ScanOrderFieldScanType orders Scan by scan_type.
	ScanOrderFieldScanType = &ScanOrderField{
		Value: func(s *Scan) (ent.Value, error) {
			return s.ScanType, nil
		},
		column: scan.FieldScanType,
		toTerm: scan.ByScanType,
		toCursor: func(s *Scan) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.ScanType,
			}
		},
	}
	// ScanOrderFieldStatus orders Scan by status.
	ScanOrderFieldStatus = &ScanOrderField{
		Value: func(s *Scan) (ent.Value, error) {
			return s.Status, nil
		},
		column: scan.FieldStatus,
		toTerm: scan.ByStatus,
		toCursor: func(s *Scan) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScanOrderField) String() string {
	var str string
	switch f.column {
	case ScanOrderFieldCreatedAt.column:
		str = "created_at"
	case ScanOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScanOrderFieldScanType.column:
		str = "SCAN_TYPE"
	case ScanOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScanOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScanOrderFieldCreatedAt
	case "updated_at":
		*f = *ScanOrderFieldUpdatedAt
	case "SCAN_TYPE":
		*f = *ScanOrderFieldScanType
	case "STATUS":
		*f = *ScanOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ScanOrderField", str)
	}
	return nil
}

// ScanOrderField defines the ordering field of Scan.
type ScanOrderField struct {
	// Value extracts the ordering value from the given Scan.
	Value    func(*Scan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scan.OrderOption
	toCursor func(*Scan) Cursor
}

// ScanOrder defines the ordering of Scan.
type ScanOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ScanOrderField `json:"field"`
}

// DefaultScanOrder is the default ordering of Scan.
var DefaultScanOrder = &ScanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScanOrderField{
		Value: func(s *Scan) (ent.Value, error) {
			return s.ID, nil
		},
		column: scan.FieldID,
		toTerm: scan.ByID,
		toCursor: func(s *Scan) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Scan into ScanEdge.
func (s *Scan) ToEdge(order *ScanOrder) *ScanEdge {
	if order == nil {
		order = DefaultScanOrder
	}
	return &ScanEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ScanHistoryEdge is the edge representation of ScanHistory.
type ScanHistoryEdge struct {
	Node   *ScanHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ScanHistoryConnection is the connection containing edges to ScanHistory.
type ScanHistoryConnection struct {
	Edges      []*ScanHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ScanHistoryConnection) build(nodes []*ScanHistory, pager *scanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScanHistoryPaginateOption enables pagination customization.
type ScanHistoryPaginateOption func(*scanhistoryPager) error

// WithScanHistoryOrder configures pagination ordering.
func WithScanHistoryOrder(order *ScanHistoryOrder) ScanHistoryPaginateOption {
	if order == nil {
		order = DefaultScanHistoryOrder
	}
	o := *order
	return func(pager *scanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScanHistoryFilter configures pagination filter.
func WithScanHistoryFilter(filter func(*ScanHistoryQuery) (*ScanHistoryQuery, error)) ScanHistoryPaginateOption {
	return func(pager *scanhistoryPager) error {
		if filter == nil {
			return errors.New("ScanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scanhistoryPager struct {
	reverse bool
	order   *ScanHistoryOrder
	filter  func(*ScanHistoryQuery) (*ScanHistoryQuery, error)
}

func newScanHistoryPager(opts []ScanHistoryPaginateOption, reverse bool) (*scanhistoryPager, error) {
	pager := &scanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScanHistoryOrder
	}
	return pager, nil
}

func (p *scanhistoryPager) applyFilter(query *ScanHistoryQuery) (*ScanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scanhistoryPager) toCursor(sh *ScanHistory) Cursor {
	return p.order.Field.toCursor(sh)
}

func (p *scanhistoryPager) applyCursors(query *ScanHistoryQuery, after, before *Cursor) (*ScanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scanhistoryPager) applyOrder(query *ScanHistoryQuery) *ScanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScanHistoryOrder.Field {
		query = query.Order(DefaultScanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scanhistoryPager) orderExpr(query *ScanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScanHistoryOrder.Field {
			b.Comma().Ident(DefaultScanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScanHistory.
func (sh *ScanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScanHistoryPaginateOption,
) (*ScanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sh, err = pager.applyFilter(sh); err != nil {
		return nil, err
	}
	conn := &ScanHistoryConnection{Edges: []*ScanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sh, err = pager.applyCursors(sh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sh = pager.applyOrder(sh)
	nodes, err := sh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScanHistoryOrderFieldHistoryTime orders ScanHistory by history_time.
	ScanHistoryOrderFieldHistoryTime = &ScanHistoryOrderField{
		Value: func(sh *ScanHistory) (ent.Value, error) {
			return sh.HistoryTime, nil
		},
		column: scanhistory.FieldHistoryTime,
		toTerm: scanhistory.ByHistoryTime,
		toCursor: func(sh *ScanHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.HistoryTime,
			}
		},
	}
	// ScanHistoryOrderFieldCreatedAt orders ScanHistory by created_at.
	ScanHistoryOrderFieldCreatedAt = &ScanHistoryOrderField{
		Value: func(sh *ScanHistory) (ent.Value, error) {
			return sh.CreatedAt, nil
		},
		column: scanhistory.FieldCreatedAt,
		toTerm: scanhistory.ByCreatedAt,
		toCursor: func(sh *ScanHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.CreatedAt,
			}
		},
	}
	// ScanHistoryOrderFieldUpdatedAt orders ScanHistory by updated_at.
	ScanHistoryOrderFieldUpdatedAt = &ScanHistoryOrderField{
		Value: func(sh *ScanHistory) (ent.Value, error) {
			return sh.UpdatedAt, nil
		},
		column: scanhistory.FieldUpdatedAt,
		toTerm: scanhistory.ByUpdatedAt,
		toCursor: func(sh *ScanHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.UpdatedAt,
			}
		},
	}
	// ScanHistoryOrderFieldScanType orders ScanHistory by scan_type.
	ScanHistoryOrderFieldScanType = &ScanHistoryOrderField{
		Value: func(sh *ScanHistory) (ent.Value, error) {
			return sh.ScanType, nil
		},
		column: scanhistory.FieldScanType,
		toTerm: scanhistory.ByScanType,
		toCursor: func(sh *ScanHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.ScanType,
			}
		},
	}
	// ScanHistoryOrderFieldStatus orders ScanHistory by status.
	ScanHistoryOrderFieldStatus = &ScanHistoryOrderField{
		Value: func(sh *ScanHistory) (ent.Value, error) {
			return sh.Status, nil
		},
		column: scanhistory.FieldStatus,
		toTerm: scanhistory.ByStatus,
		toCursor: func(sh *ScanHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScanHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ScanHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ScanHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ScanHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScanHistoryOrderFieldScanType.column:
		str = "SCAN_TYPE"
	case ScanHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScanHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScanHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScanHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ScanHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ScanHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ScanHistoryOrderFieldUpdatedAt
	case "SCAN_TYPE":
		*f = *ScanHistoryOrderFieldScanType
	case "STATUS":
		*f = *ScanHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ScanHistoryOrderField", str)
	}
	return nil
}

// ScanHistoryOrderField defines the ordering field of ScanHistory.
type ScanHistoryOrderField struct {
	// Value extracts the ordering value from the given ScanHistory.
	Value    func(*ScanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scanhistory.OrderOption
	toCursor func(*ScanHistory) Cursor
}

// ScanHistoryOrder defines the ordering of ScanHistory.
type ScanHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ScanHistoryOrderField `json:"field"`
}

// DefaultScanHistoryOrder is the default ordering of ScanHistory.
var DefaultScanHistoryOrder = &ScanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScanHistoryOrderField{
		Value: func(sh *ScanHistory) (ent.Value, error) {
			return sh.ID, nil
		},
		column: scanhistory.FieldID,
		toTerm: scanhistory.ByID,
		toCursor: func(sh *ScanHistory) Cursor {
			return Cursor{ID: sh.ID}
		},
	},
}

// ToEdge converts ScanHistory into ScanHistoryEdge.
func (sh *ScanHistory) ToEdge(order *ScanHistoryOrder) *ScanHistoryEdge {
	if order == nil {
		order = DefaultScanHistoryOrder
	}
	return &ScanHistoryEdge{
		Node:   sh,
		Cursor: order.Field.toCursor(sh),
	}
}

// ScheduledJobEdge is the edge representation of ScheduledJob.
type ScheduledJobEdge struct {
	Node   *ScheduledJob `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ScheduledJobConnection is the connection containing edges to ScheduledJob.
type ScheduledJobConnection struct {
	Edges      []*ScheduledJobEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ScheduledJobConnection) build(nodes []*ScheduledJob, pager *scheduledjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobPaginateOption enables pagination customization.
type ScheduledJobPaginateOption func(*scheduledjobPager) error

// WithScheduledJobOrder configures pagination ordering.
func WithScheduledJobOrder(order []*ScheduledJobOrder) ScheduledJobPaginateOption {
	return func(pager *scheduledjobPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScheduledJobFilter configures pagination filter.
func WithScheduledJobFilter(filter func(*ScheduledJobQuery) (*ScheduledJobQuery, error)) ScheduledJobPaginateOption {
	return func(pager *scheduledjobPager) error {
		if filter == nil {
			return errors.New("ScheduledJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobPager struct {
	reverse bool
	order   []*ScheduledJobOrder
	filter  func(*ScheduledJobQuery) (*ScheduledJobQuery, error)
}

func newScheduledJobPager(opts []ScheduledJobPaginateOption, reverse bool) (*scheduledjobPager, error) {
	pager := &scheduledjobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scheduledjobPager) applyFilter(query *ScheduledJobQuery) (*ScheduledJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobPager) toCursor(sj *ScheduledJob) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(sj).Value)
	}
	return Cursor{ID: sj.ID, Value: cs_}
}

func (p *scheduledjobPager) applyCursors(query *ScheduledJobQuery, after, before *Cursor) (*ScheduledJobQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScheduledJobOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scheduledjobPager) applyOrder(query *ScheduledJobQuery) *ScheduledJobQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScheduledJobOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScheduledJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scheduledjobPager) orderExpr(query *ScheduledJobQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScheduledJobOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJob.
func (sj *ScheduledJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobPaginateOption,
) (*ScheduledJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sj, err = pager.applyFilter(sj); err != nil {
		return nil, err
	}
	conn := &ScheduledJobConnection{Edges: []*ScheduledJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sj.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sj, err = pager.applyCursors(sj, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sj.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sj.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sj = pager.applyOrder(sj)
	nodes, err := sj.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobOrderFieldCreatedAt orders ScheduledJob by created_at.
	ScheduledJobOrderFieldCreatedAt = &ScheduledJobOrderField{
		Value: func(sj *ScheduledJob) (ent.Value, error) {
			return sj.CreatedAt, nil
		},
		column: scheduledjob.FieldCreatedAt,
		toTerm: scheduledjob.ByCreatedAt,
		toCursor: func(sj *ScheduledJob) Cursor {
			return Cursor{
				ID:    sj.ID,
				Value: sj.CreatedAt,
			}
		},
	}
	// ScheduledJobOrderFieldUpdatedAt orders ScheduledJob by updated_at.
	ScheduledJobOrderFieldUpdatedAt = &ScheduledJobOrderField{
		Value: func(sj *ScheduledJob) (ent.Value, error) {
			return sj.UpdatedAt, nil
		},
		column: scheduledjob.FieldUpdatedAt,
		toTerm: scheduledjob.ByUpdatedAt,
		toCursor: func(sj *ScheduledJob) Cursor {
			return Cursor{
				ID:    sj.ID,
				Value: sj.UpdatedAt,
			}
		},
	}
	// ScheduledJobOrderFieldTitle orders ScheduledJob by title.
	ScheduledJobOrderFieldTitle = &ScheduledJobOrderField{
		Value: func(sj *ScheduledJob) (ent.Value, error) {
			return sj.Title, nil
		},
		column: scheduledjob.FieldTitle,
		toTerm: scheduledjob.ByTitle,
		toCursor: func(sj *ScheduledJob) Cursor {
			return Cursor{
				ID:    sj.ID,
				Value: sj.Title,
			}
		},
	}
	// ScheduledJobOrderFieldJobType orders ScheduledJob by job_type.
	ScheduledJobOrderFieldJobType = &ScheduledJobOrderField{
		Value: func(sj *ScheduledJob) (ent.Value, error) {
			return sj.JobType, nil
		},
		column: scheduledjob.FieldJobType,
		toTerm: scheduledjob.ByJobType,
		toCursor: func(sj *ScheduledJob) Cursor {
			return Cursor{
				ID:    sj.ID,
				Value: sj.JobType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScheduledJobOrderFieldTitle.column:
		str = "title"
	case ScheduledJobOrderFieldJobType.column:
		str = "JOB_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScheduledJobOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobOrderFieldUpdatedAt
	case "title":
		*f = *ScheduledJobOrderFieldTitle
	case "JOB_TYPE":
		*f = *ScheduledJobOrderFieldJobType
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobOrderField", str)
	}
	return nil
}

// ScheduledJobOrderField defines the ordering field of ScheduledJob.
type ScheduledJobOrderField struct {
	// Value extracts the ordering value from the given ScheduledJob.
	Value    func(*ScheduledJob) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjob.OrderOption
	toCursor func(*ScheduledJob) Cursor
}

// ScheduledJobOrder defines the ordering of ScheduledJob.
type ScheduledJobOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ScheduledJobOrderField `json:"field"`
}

// DefaultScheduledJobOrder is the default ordering of ScheduledJob.
var DefaultScheduledJobOrder = &ScheduledJobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobOrderField{
		Value: func(sj *ScheduledJob) (ent.Value, error) {
			return sj.ID, nil
		},
		column: scheduledjob.FieldID,
		toTerm: scheduledjob.ByID,
		toCursor: func(sj *ScheduledJob) Cursor {
			return Cursor{ID: sj.ID}
		},
	},
}

// ToEdge converts ScheduledJob into ScheduledJobEdge.
func (sj *ScheduledJob) ToEdge(order *ScheduledJobOrder) *ScheduledJobEdge {
	if order == nil {
		order = DefaultScheduledJobOrder
	}
	return &ScheduledJobEdge{
		Node:   sj,
		Cursor: order.Field.toCursor(sj),
	}
}

// ScheduledJobHistoryEdge is the edge representation of ScheduledJobHistory.
type ScheduledJobHistoryEdge struct {
	Node   *ScheduledJobHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// ScheduledJobHistoryConnection is the connection containing edges to ScheduledJobHistory.
type ScheduledJobHistoryConnection struct {
	Edges      []*ScheduledJobHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *ScheduledJobHistoryConnection) build(nodes []*ScheduledJobHistory, pager *scheduledjobhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJobHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJobHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJobHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobHistoryPaginateOption enables pagination customization.
type ScheduledJobHistoryPaginateOption func(*scheduledjobhistoryPager) error

// WithScheduledJobHistoryOrder configures pagination ordering.
func WithScheduledJobHistoryOrder(order *ScheduledJobHistoryOrder) ScheduledJobHistoryPaginateOption {
	if order == nil {
		order = DefaultScheduledJobHistoryOrder
	}
	o := *order
	return func(pager *scheduledjobhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScheduledJobHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScheduledJobHistoryFilter configures pagination filter.
func WithScheduledJobHistoryFilter(filter func(*ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error)) ScheduledJobHistoryPaginateOption {
	return func(pager *scheduledjobhistoryPager) error {
		if filter == nil {
			return errors.New("ScheduledJobHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobhistoryPager struct {
	reverse bool
	order   *ScheduledJobHistoryOrder
	filter  func(*ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error)
}

func newScheduledJobHistoryPager(opts []ScheduledJobHistoryPaginateOption, reverse bool) (*scheduledjobhistoryPager, error) {
	pager := &scheduledjobhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScheduledJobHistoryOrder
	}
	return pager, nil
}

func (p *scheduledjobhistoryPager) applyFilter(query *ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobhistoryPager) toCursor(sjh *ScheduledJobHistory) Cursor {
	return p.order.Field.toCursor(sjh)
}

func (p *scheduledjobhistoryPager) applyCursors(query *ScheduledJobHistoryQuery, after, before *Cursor) (*ScheduledJobHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScheduledJobHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scheduledjobhistoryPager) applyOrder(query *ScheduledJobHistoryQuery) *ScheduledJobHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScheduledJobHistoryOrder.Field {
		query = query.Order(DefaultScheduledJobHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scheduledjobhistoryPager) orderExpr(query *ScheduledJobHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScheduledJobHistoryOrder.Field {
			b.Comma().Ident(DefaultScheduledJobHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJobHistory.
func (sjh *ScheduledJobHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobHistoryPaginateOption,
) (*ScheduledJobHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sjh, err = pager.applyFilter(sjh); err != nil {
		return nil, err
	}
	conn := &ScheduledJobHistoryConnection{Edges: []*ScheduledJobHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sjh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sjh, err = pager.applyCursors(sjh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sjh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sjh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sjh = pager.applyOrder(sjh)
	nodes, err := sjh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobHistoryOrderFieldHistoryTime orders ScheduledJobHistory by history_time.
	ScheduledJobHistoryOrderFieldHistoryTime = &ScheduledJobHistoryOrderField{
		Value: func(sjh *ScheduledJobHistory) (ent.Value, error) {
			return sjh.HistoryTime, nil
		},
		column: scheduledjobhistory.FieldHistoryTime,
		toTerm: scheduledjobhistory.ByHistoryTime,
		toCursor: func(sjh *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    sjh.ID,
				Value: sjh.HistoryTime,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldCreatedAt orders ScheduledJobHistory by created_at.
	ScheduledJobHistoryOrderFieldCreatedAt = &ScheduledJobHistoryOrderField{
		Value: func(sjh *ScheduledJobHistory) (ent.Value, error) {
			return sjh.CreatedAt, nil
		},
		column: scheduledjobhistory.FieldCreatedAt,
		toTerm: scheduledjobhistory.ByCreatedAt,
		toCursor: func(sjh *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    sjh.ID,
				Value: sjh.CreatedAt,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldUpdatedAt orders ScheduledJobHistory by updated_at.
	ScheduledJobHistoryOrderFieldUpdatedAt = &ScheduledJobHistoryOrderField{
		Value: func(sjh *ScheduledJobHistory) (ent.Value, error) {
			return sjh.UpdatedAt, nil
		},
		column: scheduledjobhistory.FieldUpdatedAt,
		toTerm: scheduledjobhistory.ByUpdatedAt,
		toCursor: func(sjh *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    sjh.ID,
				Value: sjh.UpdatedAt,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldTitle orders ScheduledJobHistory by title.
	ScheduledJobHistoryOrderFieldTitle = &ScheduledJobHistoryOrderField{
		Value: func(sjh *ScheduledJobHistory) (ent.Value, error) {
			return sjh.Title, nil
		},
		column: scheduledjobhistory.FieldTitle,
		toTerm: scheduledjobhistory.ByTitle,
		toCursor: func(sjh *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    sjh.ID,
				Value: sjh.Title,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldJobType orders ScheduledJobHistory by job_type.
	ScheduledJobHistoryOrderFieldJobType = &ScheduledJobHistoryOrderField{
		Value: func(sjh *ScheduledJobHistory) (ent.Value, error) {
			return sjh.JobType, nil
		},
		column: scheduledjobhistory.FieldJobType,
		toTerm: scheduledjobhistory.ByJobType,
		toCursor: func(sjh *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    sjh.ID,
				Value: sjh.JobType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ScheduledJobHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScheduledJobHistoryOrderFieldTitle.column:
		str = "title"
	case ScheduledJobHistoryOrderFieldJobType.column:
		str = "JOB_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ScheduledJobHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ScheduledJobHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobHistoryOrderFieldUpdatedAt
	case "title":
		*f = *ScheduledJobHistoryOrderFieldTitle
	case "JOB_TYPE":
		*f = *ScheduledJobHistoryOrderFieldJobType
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobHistoryOrderField", str)
	}
	return nil
}

// ScheduledJobHistoryOrderField defines the ordering field of ScheduledJobHistory.
type ScheduledJobHistoryOrderField struct {
	// Value extracts the ordering value from the given ScheduledJobHistory.
	Value    func(*ScheduledJobHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjobhistory.OrderOption
	toCursor func(*ScheduledJobHistory) Cursor
}

// ScheduledJobHistoryOrder defines the ordering of ScheduledJobHistory.
type ScheduledJobHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *ScheduledJobHistoryOrderField `json:"field"`
}

// DefaultScheduledJobHistoryOrder is the default ordering of ScheduledJobHistory.
var DefaultScheduledJobHistoryOrder = &ScheduledJobHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobHistoryOrderField{
		Value: func(sjh *ScheduledJobHistory) (ent.Value, error) {
			return sjh.ID, nil
		},
		column: scheduledjobhistory.FieldID,
		toTerm: scheduledjobhistory.ByID,
		toCursor: func(sjh *ScheduledJobHistory) Cursor {
			return Cursor{ID: sjh.ID}
		},
	},
}

// ToEdge converts ScheduledJobHistory into ScheduledJobHistoryEdge.
func (sjh *ScheduledJobHistory) ToEdge(order *ScheduledJobHistoryOrder) *ScheduledJobHistoryEdge {
	if order == nil {
		order = DefaultScheduledJobHistoryOrder
	}
	return &ScheduledJobHistoryEdge{
		Node:   sjh,
		Cursor: order.Field.toCursor(sjh),
	}
}

// ScheduledJobRunEdge is the edge representation of ScheduledJobRun.
type ScheduledJobRunEdge struct {
	Node   *ScheduledJobRun `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ScheduledJobRunConnection is the connection containing edges to ScheduledJobRun.
type ScheduledJobRunConnection struct {
	Edges      []*ScheduledJobRunEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ScheduledJobRunConnection) build(nodes []*ScheduledJobRun, pager *scheduledjobrunPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJobRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJobRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJobRun {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobRunPaginateOption enables pagination customization.
type ScheduledJobRunPaginateOption func(*scheduledjobrunPager) error

// WithScheduledJobRunOrder configures pagination ordering.
func WithScheduledJobRunOrder(order []*ScheduledJobRunOrder) ScheduledJobRunPaginateOption {
	return func(pager *scheduledjobrunPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScheduledJobRunFilter configures pagination filter.
func WithScheduledJobRunFilter(filter func(*ScheduledJobRunQuery) (*ScheduledJobRunQuery, error)) ScheduledJobRunPaginateOption {
	return func(pager *scheduledjobrunPager) error {
		if filter == nil {
			return errors.New("ScheduledJobRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobrunPager struct {
	reverse bool
	order   []*ScheduledJobRunOrder
	filter  func(*ScheduledJobRunQuery) (*ScheduledJobRunQuery, error)
}

func newScheduledJobRunPager(opts []ScheduledJobRunPaginateOption, reverse bool) (*scheduledjobrunPager, error) {
	pager := &scheduledjobrunPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scheduledjobrunPager) applyFilter(query *ScheduledJobRunQuery) (*ScheduledJobRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobrunPager) toCursor(sjr *ScheduledJobRun) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(sjr).Value)
	}
	return Cursor{ID: sjr.ID, Value: cs_}
}

func (p *scheduledjobrunPager) applyCursors(query *ScheduledJobRunQuery, after, before *Cursor) (*ScheduledJobRunQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScheduledJobRunOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scheduledjobrunPager) applyOrder(query *ScheduledJobRunQuery) *ScheduledJobRunQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScheduledJobRunOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScheduledJobRunOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scheduledjobrunPager) orderExpr(query *ScheduledJobRunQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScheduledJobRunOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJobRun.
func (sjr *ScheduledJobRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobRunPaginateOption,
) (*ScheduledJobRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobRunPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sjr, err = pager.applyFilter(sjr); err != nil {
		return nil, err
	}
	conn := &ScheduledJobRunConnection{Edges: []*ScheduledJobRunEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sjr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sjr, err = pager.applyCursors(sjr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sjr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sjr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sjr = pager.applyOrder(sjr)
	nodes, err := sjr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobRunOrderFieldCreatedAt orders ScheduledJobRun by created_at.
	ScheduledJobRunOrderFieldCreatedAt = &ScheduledJobRunOrderField{
		Value: func(sjr *ScheduledJobRun) (ent.Value, error) {
			return sjr.CreatedAt, nil
		},
		column: scheduledjobrun.FieldCreatedAt,
		toTerm: scheduledjobrun.ByCreatedAt,
		toCursor: func(sjr *ScheduledJobRun) Cursor {
			return Cursor{
				ID:    sjr.ID,
				Value: sjr.CreatedAt,
			}
		},
	}
	// ScheduledJobRunOrderFieldUpdatedAt orders ScheduledJobRun by updated_at.
	ScheduledJobRunOrderFieldUpdatedAt = &ScheduledJobRunOrderField{
		Value: func(sjr *ScheduledJobRun) (ent.Value, error) {
			return sjr.UpdatedAt, nil
		},
		column: scheduledjobrun.FieldUpdatedAt,
		toTerm: scheduledjobrun.ByUpdatedAt,
		toCursor: func(sjr *ScheduledJobRun) Cursor {
			return Cursor{
				ID:    sjr.ID,
				Value: sjr.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobRunOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobRunOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobRunOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobRunOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScheduledJobRunOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobRunOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobRunOrderField", str)
	}
	return nil
}

// ScheduledJobRunOrderField defines the ordering field of ScheduledJobRun.
type ScheduledJobRunOrderField struct {
	// Value extracts the ordering value from the given ScheduledJobRun.
	Value    func(*ScheduledJobRun) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjobrun.OrderOption
	toCursor func(*ScheduledJobRun) Cursor
}

// ScheduledJobRunOrder defines the ordering of ScheduledJobRun.
type ScheduledJobRunOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ScheduledJobRunOrderField `json:"field"`
}

// DefaultScheduledJobRunOrder is the default ordering of ScheduledJobRun.
var DefaultScheduledJobRunOrder = &ScheduledJobRunOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobRunOrderField{
		Value: func(sjr *ScheduledJobRun) (ent.Value, error) {
			return sjr.ID, nil
		},
		column: scheduledjobrun.FieldID,
		toTerm: scheduledjobrun.ByID,
		toCursor: func(sjr *ScheduledJobRun) Cursor {
			return Cursor{ID: sjr.ID}
		},
	},
}

// ToEdge converts ScheduledJobRun into ScheduledJobRunEdge.
func (sjr *ScheduledJobRun) ToEdge(order *ScheduledJobRunOrder) *ScheduledJobRunEdge {
	if order == nil {
		order = DefaultScheduledJobRunOrder
	}
	return &ScheduledJobRunEdge{
		Node:   sjr,
		Cursor: order.Field.toCursor(sjr),
	}
}

// StandardEdge is the edge representation of Standard.
type StandardEdge struct {
	Node   *Standard `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// StandardConnection is the connection containing edges to Standard.
type StandardConnection struct {
	Edges      []*StandardEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *StandardConnection) build(nodes []*Standard, pager *standardPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Standard
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Standard {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Standard {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardPaginateOption enables pagination customization.
type StandardPaginateOption func(*standardPager) error

// WithStandardOrder configures pagination ordering.
func WithStandardOrder(order []*StandardOrder) StandardPaginateOption {
	return func(pager *standardPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithStandardFilter configures pagination filter.
func WithStandardFilter(filter func(*StandardQuery) (*StandardQuery, error)) StandardPaginateOption {
	return func(pager *standardPager) error {
		if filter == nil {
			return errors.New("StandardQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardPager struct {
	reverse bool
	order   []*StandardOrder
	filter  func(*StandardQuery) (*StandardQuery, error)
}

func newStandardPager(opts []StandardPaginateOption, reverse bool) (*standardPager, error) {
	pager := &standardPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *standardPager) applyFilter(query *StandardQuery) (*StandardQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardPager) toCursor(s *Standard) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs_}
}

func (p *standardPager) applyCursors(query *StandardQuery, after, before *Cursor) (*StandardQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultStandardOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *standardPager) applyOrder(query *StandardQuery) *StandardQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultStandardOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultStandardOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *standardPager) orderExpr(query *StandardQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultStandardOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Standard.
func (s *StandardQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardPaginateOption,
) (*StandardConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &StandardConnection{Edges: []*StandardEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StandardOrderFieldCreatedAt orders Standard by created_at.
	StandardOrderFieldCreatedAt = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: standard.FieldCreatedAt,
		toTerm: standard.ByCreatedAt,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// StandardOrderFieldUpdatedAt orders Standard by updated_at.
	StandardOrderFieldUpdatedAt = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: standard.FieldUpdatedAt,
		toTerm: standard.ByUpdatedAt,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// StandardOrderFieldRevision orders Standard by revision.
	StandardOrderFieldRevision = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.Revision, nil
		},
		column: standard.FieldRevision,
		toTerm: standard.ByRevision,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Revision,
			}
		},
	}
	// StandardOrderFieldName orders Standard by name.
	StandardOrderFieldName = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.Name, nil
		},
		column: standard.FieldName,
		toTerm: standard.ByName,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Name,
			}
		},
	}
	// StandardOrderFieldShortName orders Standard by short_name.
	StandardOrderFieldShortName = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.ShortName, nil
		},
		column: standard.FieldShortName,
		toTerm: standard.ByShortName,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.ShortName,
			}
		},
	}
	// StandardOrderFieldFramework orders Standard by framework.
	StandardOrderFieldFramework = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.Framework, nil
		},
		column: standard.FieldFramework,
		toTerm: standard.ByFramework,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Framework,
			}
		},
	}
	// StandardOrderFieldGoverningBody orders Standard by governing_body.
	StandardOrderFieldGoverningBody = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.GoverningBody, nil
		},
		column: standard.FieldGoverningBody,
		toTerm: standard.ByGoverningBody,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.GoverningBody,
			}
		},
	}
	// StandardOrderFieldStatus orders Standard by status.
	StandardOrderFieldStatus = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.Status, nil
		},
		column: standard.FieldStatus,
		toTerm: standard.ByStatus,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Status,
			}
		},
	}
	// StandardOrderFieldStandardType orders Standard by standard_type.
	StandardOrderFieldStandardType = &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.StandardType, nil
		},
		column: standard.FieldStandardType,
		toTerm: standard.ByStandardType,
		toCursor: func(s *Standard) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.StandardType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StandardOrderField) String() string {
	var str string
	switch f.column {
	case StandardOrderFieldCreatedAt.column:
		str = "created_at"
	case StandardOrderFieldUpdatedAt.column:
		str = "updated_at"
	case StandardOrderFieldRevision.column:
		str = "revision"
	case StandardOrderFieldName.column:
		str = "name"
	case StandardOrderFieldShortName.column:
		str = "short_name"
	case StandardOrderFieldFramework.column:
		str = "framework"
	case StandardOrderFieldGoverningBody.column:
		str = "governing_body"
	case StandardOrderFieldStatus.column:
		str = "STATUS"
	case StandardOrderFieldStandardType.column:
		str = "standard_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StandardOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StandardOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StandardOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *StandardOrderFieldCreatedAt
	case "updated_at":
		*f = *StandardOrderFieldUpdatedAt
	case "revision":
		*f = *StandardOrderFieldRevision
	case "name":
		*f = *StandardOrderFieldName
	case "short_name":
		*f = *StandardOrderFieldShortName
	case "framework":
		*f = *StandardOrderFieldFramework
	case "governing_body":
		*f = *StandardOrderFieldGoverningBody
	case "STATUS":
		*f = *StandardOrderFieldStatus
	case "standard_type":
		*f = *StandardOrderFieldStandardType
	default:
		return fmt.Errorf("%s is not a valid StandardOrderField", str)
	}
	return nil
}

// StandardOrderField defines the ordering field of Standard.
type StandardOrderField struct {
	// Value extracts the ordering value from the given Standard.
	Value    func(*Standard) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standard.OrderOption
	toCursor func(*Standard) Cursor
}

// StandardOrder defines the ordering of Standard.
type StandardOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *StandardOrderField `json:"field"`
}

// DefaultStandardOrder is the default ordering of Standard.
var DefaultStandardOrder = &StandardOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.ID, nil
		},
		column: standard.FieldID,
		toTerm: standard.ByID,
		toCursor: func(s *Standard) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Standard into StandardEdge.
func (s *Standard) ToEdge(order *StandardOrder) *StandardEdge {
	if order == nil {
		order = DefaultStandardOrder
	}
	return &StandardEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// StandardHistoryEdge is the edge representation of StandardHistory.
type StandardHistoryEdge struct {
	Node   *StandardHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// StandardHistoryConnection is the connection containing edges to StandardHistory.
type StandardHistoryConnection struct {
	Edges      []*StandardHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *StandardHistoryConnection) build(nodes []*StandardHistory, pager *standardhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *StandardHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *StandardHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *StandardHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardHistoryPaginateOption enables pagination customization.
type StandardHistoryPaginateOption func(*standardhistoryPager) error

// WithStandardHistoryOrder configures pagination ordering.
func WithStandardHistoryOrder(order *StandardHistoryOrder) StandardHistoryPaginateOption {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	o := *order
	return func(pager *standardhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStandardHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStandardHistoryFilter configures pagination filter.
func WithStandardHistoryFilter(filter func(*StandardHistoryQuery) (*StandardHistoryQuery, error)) StandardHistoryPaginateOption {
	return func(pager *standardhistoryPager) error {
		if filter == nil {
			return errors.New("StandardHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardhistoryPager struct {
	reverse bool
	order   *StandardHistoryOrder
	filter  func(*StandardHistoryQuery) (*StandardHistoryQuery, error)
}

func newStandardHistoryPager(opts []StandardHistoryPaginateOption, reverse bool) (*standardhistoryPager, error) {
	pager := &standardhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStandardHistoryOrder
	}
	return pager, nil
}

func (p *standardhistoryPager) applyFilter(query *StandardHistoryQuery) (*StandardHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardhistoryPager) toCursor(sh *StandardHistory) Cursor {
	return p.order.Field.toCursor(sh)
}

func (p *standardhistoryPager) applyCursors(query *StandardHistoryQuery, after, before *Cursor) (*StandardHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStandardHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *standardhistoryPager) applyOrder(query *StandardHistoryQuery) *StandardHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStandardHistoryOrder.Field {
		query = query.Order(DefaultStandardHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *standardhistoryPager) orderExpr(query *StandardHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStandardHistoryOrder.Field {
			b.Comma().Ident(DefaultStandardHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to StandardHistory.
func (sh *StandardHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardHistoryPaginateOption,
) (*StandardHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sh, err = pager.applyFilter(sh); err != nil {
		return nil, err
	}
	conn := &StandardHistoryConnection{Edges: []*StandardHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sh, err = pager.applyCursors(sh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sh = pager.applyOrder(sh)
	nodes, err := sh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StandardHistoryOrderFieldHistoryTime orders StandardHistory by history_time.
	StandardHistoryOrderFieldHistoryTime = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.HistoryTime, nil
		},
		column: standardhistory.FieldHistoryTime,
		toTerm: standardhistory.ByHistoryTime,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.HistoryTime,
			}
		},
	}
	// StandardHistoryOrderFieldCreatedAt orders StandardHistory by created_at.
	StandardHistoryOrderFieldCreatedAt = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.CreatedAt, nil
		},
		column: standardhistory.FieldCreatedAt,
		toTerm: standardhistory.ByCreatedAt,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.CreatedAt,
			}
		},
	}
	// StandardHistoryOrderFieldUpdatedAt orders StandardHistory by updated_at.
	StandardHistoryOrderFieldUpdatedAt = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.UpdatedAt, nil
		},
		column: standardhistory.FieldUpdatedAt,
		toTerm: standardhistory.ByUpdatedAt,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.UpdatedAt,
			}
		},
	}
	// StandardHistoryOrderFieldRevision orders StandardHistory by revision.
	StandardHistoryOrderFieldRevision = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.Revision, nil
		},
		column: standardhistory.FieldRevision,
		toTerm: standardhistory.ByRevision,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Revision,
			}
		},
	}
	// StandardHistoryOrderFieldName orders StandardHistory by name.
	StandardHistoryOrderFieldName = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.Name, nil
		},
		column: standardhistory.FieldName,
		toTerm: standardhistory.ByName,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Name,
			}
		},
	}
	// StandardHistoryOrderFieldShortName orders StandardHistory by short_name.
	StandardHistoryOrderFieldShortName = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.ShortName, nil
		},
		column: standardhistory.FieldShortName,
		toTerm: standardhistory.ByShortName,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.ShortName,
			}
		},
	}
	// StandardHistoryOrderFieldFramework orders StandardHistory by framework.
	StandardHistoryOrderFieldFramework = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.Framework, nil
		},
		column: standardhistory.FieldFramework,
		toTerm: standardhistory.ByFramework,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Framework,
			}
		},
	}
	// StandardHistoryOrderFieldGoverningBody orders StandardHistory by governing_body.
	StandardHistoryOrderFieldGoverningBody = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.GoverningBody, nil
		},
		column: standardhistory.FieldGoverningBody,
		toTerm: standardhistory.ByGoverningBody,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.GoverningBody,
			}
		},
	}
	// StandardHistoryOrderFieldStatus orders StandardHistory by status.
	StandardHistoryOrderFieldStatus = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.Status, nil
		},
		column: standardhistory.FieldStatus,
		toTerm: standardhistory.ByStatus,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Status,
			}
		},
	}
	// StandardHistoryOrderFieldStandardType orders StandardHistory by standard_type.
	StandardHistoryOrderFieldStandardType = &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.StandardType, nil
		},
		column: standardhistory.FieldStandardType,
		toTerm: standardhistory.ByStandardType,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.StandardType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StandardHistoryOrderField) String() string {
	var str string
	switch f.column {
	case StandardHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case StandardHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case StandardHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case StandardHistoryOrderFieldRevision.column:
		str = "revision"
	case StandardHistoryOrderFieldName.column:
		str = "name"
	case StandardHistoryOrderFieldShortName.column:
		str = "short_name"
	case StandardHistoryOrderFieldFramework.column:
		str = "framework"
	case StandardHistoryOrderFieldGoverningBody.column:
		str = "governing_body"
	case StandardHistoryOrderFieldStatus.column:
		str = "STATUS"
	case StandardHistoryOrderFieldStandardType.column:
		str = "standard_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StandardHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StandardHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StandardHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *StandardHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *StandardHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *StandardHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *StandardHistoryOrderFieldRevision
	case "name":
		*f = *StandardHistoryOrderFieldName
	case "short_name":
		*f = *StandardHistoryOrderFieldShortName
	case "framework":
		*f = *StandardHistoryOrderFieldFramework
	case "governing_body":
		*f = *StandardHistoryOrderFieldGoverningBody
	case "STATUS":
		*f = *StandardHistoryOrderFieldStatus
	case "standard_type":
		*f = *StandardHistoryOrderFieldStandardType
	default:
		return fmt.Errorf("%s is not a valid StandardHistoryOrderField", str)
	}
	return nil
}

// StandardHistoryOrderField defines the ordering field of StandardHistory.
type StandardHistoryOrderField struct {
	// Value extracts the ordering value from the given StandardHistory.
	Value    func(*StandardHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standardhistory.OrderOption
	toCursor func(*StandardHistory) Cursor
}

// StandardHistoryOrder defines the ordering of StandardHistory.
type StandardHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *StandardHistoryOrderField `json:"field"`
}

// DefaultStandardHistoryOrder is the default ordering of StandardHistory.
var DefaultStandardHistoryOrder = &StandardHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.ID, nil
		},
		column: standardhistory.FieldID,
		toTerm: standardhistory.ByID,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{ID: sh.ID}
		},
	},
}

// ToEdge converts StandardHistory into StandardHistoryEdge.
func (sh *StandardHistory) ToEdge(order *StandardHistoryOrder) *StandardHistoryEdge {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	return &StandardHistoryEdge{
		Node:   sh,
		Cursor: order.Field.toCursor(sh),
	}
}

// SubcontrolEdge is the edge representation of Subcontrol.
type SubcontrolEdge struct {
	Node   *Subcontrol `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubcontrolConnection is the connection containing edges to Subcontrol.
type SubcontrolConnection struct {
	Edges      []*SubcontrolEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubcontrolConnection) build(nodes []*Subcontrol, pager *subcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subcontrol
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subcontrol {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subcontrol {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolPaginateOption enables pagination customization.
type SubcontrolPaginateOption func(*subcontrolPager) error

// WithSubcontrolOrder configures pagination ordering.
func WithSubcontrolOrder(order []*SubcontrolOrder) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubcontrolFilter configures pagination filter.
func WithSubcontrolFilter(filter func(*SubcontrolQuery) (*SubcontrolQuery, error)) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		if filter == nil {
			return errors.New("SubcontrolQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolPager struct {
	reverse bool
	order   []*SubcontrolOrder
	filter  func(*SubcontrolQuery) (*SubcontrolQuery, error)
}

func newSubcontrolPager(opts []SubcontrolPaginateOption, reverse bool) (*subcontrolPager, error) {
	pager := &subcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subcontrolPager) applyFilter(query *SubcontrolQuery) (*SubcontrolQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolPager) toCursor(s *Subcontrol) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs_}
}

func (p *subcontrolPager) applyCursors(query *SubcontrolQuery, after, before *Cursor) (*SubcontrolQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubcontrolOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subcontrolPager) applyOrder(query *SubcontrolQuery) *SubcontrolQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubcontrolOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case SubcontrolOrderFieldControlOwnerName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubcontrolOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subcontrolPager) orderExpr(query *SubcontrolQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case SubcontrolOrderFieldControlOwnerName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubcontrolOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subcontrol.
func (s *SubcontrolQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolPaginateOption,
) (*SubcontrolConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SubcontrolConnection{Edges: []*SubcontrolEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubcontrolOrderFieldCreatedAt orders Subcontrol by created_at.
	SubcontrolOrderFieldCreatedAt = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: subcontrol.FieldCreatedAt,
		toTerm: subcontrol.ByCreatedAt,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SubcontrolOrderFieldUpdatedAt orders Subcontrol by updated_at.
	SubcontrolOrderFieldUpdatedAt = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: subcontrol.FieldUpdatedAt,
		toTerm: subcontrol.ByUpdatedAt,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SubcontrolOrderFieldStatus orders Subcontrol by status.
	SubcontrolOrderFieldStatus = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.Status, nil
		},
		column: subcontrol.FieldStatus,
		toTerm: subcontrol.ByStatus,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Status,
			}
		},
	}
	// SubcontrolOrderFieldSource orders Subcontrol by source.
	SubcontrolOrderFieldSource = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.Source, nil
		},
		column: subcontrol.FieldSource,
		toTerm: subcontrol.BySource,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Source,
			}
		},
	}
	// SubcontrolOrderFieldReferenceFramework orders Subcontrol by reference_framework.
	SubcontrolOrderFieldReferenceFramework = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			// allow for nil values for fields
			if s.ReferenceFramework == nil {
				return nil, nil
			}
			return s.ReferenceFramework, nil
		},
		column: subcontrol.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return subcontrol.ByReferenceFramework(opts...)
		},
		toCursor: func(s *Subcontrol) Cursor {
			if s.ReferenceFramework == nil {
				return Cursor{
					ID:    s.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    s.ID,
				Value: s.ReferenceFramework,
			}
		},
	}
	// SubcontrolOrderFieldControlType orders Subcontrol by control_type.
	SubcontrolOrderFieldControlType = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.ControlType, nil
		},
		column: subcontrol.FieldControlType,
		toTerm: subcontrol.ByControlType,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.ControlType,
			}
		},
	}
	// SubcontrolOrderFieldCategory orders Subcontrol by category.
	SubcontrolOrderFieldCategory = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.Category, nil
		},
		column: subcontrol.FieldCategory,
		toTerm: subcontrol.ByCategory,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Category,
			}
		},
	}
	// SubcontrolOrderFieldSubcategory orders Subcontrol by subcategory.
	SubcontrolOrderFieldSubcategory = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.Subcategory, nil
		},
		column: subcontrol.FieldSubcategory,
		toTerm: subcontrol.BySubcategory,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Subcategory,
			}
		},
	}
	// SubcontrolOrderFieldRefCode orders Subcontrol by ref_code.
	SubcontrolOrderFieldRefCode = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.RefCode, nil
		},
		column: subcontrol.FieldRefCode,
		toTerm: subcontrol.ByRefCode,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.RefCode,
			}
		},
	}
	// SubcontrolOrderFieldControlOwnerName orders by CONTROL_OWNER_name.
	SubcontrolOrderFieldControlOwnerName = &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.Value("control_owner_name")
		},
		column: "control_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByControlOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("control_owner_name"))...,
			)
		},
		toCursor: func(s *Subcontrol) Cursor {
			cv, _ := s.Value("control_owner_name")
			return Cursor{
				ID:    s.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubcontrolOrderField) String() string {
	var str string
	switch f.column {
	case SubcontrolOrderFieldCreatedAt.column:
		str = "created_at"
	case SubcontrolOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubcontrolOrderFieldStatus.column:
		str = "STATUS"
	case SubcontrolOrderFieldSource.column:
		str = "SOURCE"
	case SubcontrolOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case SubcontrolOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case SubcontrolOrderFieldCategory.column:
		str = "category"
	case SubcontrolOrderFieldSubcategory.column:
		str = "subcategory"
	case SubcontrolOrderFieldRefCode.column:
		str = "ref_code"
	case SubcontrolOrderFieldControlOwnerName.column:
		str = "CONTROL_OWNER_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubcontrolOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubcontrolOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubcontrolOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubcontrolOrderFieldCreatedAt
	case "updated_at":
		*f = *SubcontrolOrderFieldUpdatedAt
	case "STATUS":
		*f = *SubcontrolOrderFieldStatus
	case "SOURCE":
		*f = *SubcontrolOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *SubcontrolOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *SubcontrolOrderFieldControlType
	case "category":
		*f = *SubcontrolOrderFieldCategory
	case "subcategory":
		*f = *SubcontrolOrderFieldSubcategory
	case "ref_code":
		*f = *SubcontrolOrderFieldRefCode
	case "CONTROL_OWNER_name":
		*f = *SubcontrolOrderFieldControlOwnerName
	default:
		return fmt.Errorf("%s is not a valid SubcontrolOrderField", str)
	}
	return nil
}

// SubcontrolOrderField defines the ordering field of Subcontrol.
type SubcontrolOrderField struct {
	// Value extracts the ordering value from the given Subcontrol.
	Value    func(*Subcontrol) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrol.OrderOption
	toCursor func(*Subcontrol) Cursor
}

// SubcontrolOrder defines the ordering of Subcontrol.
type SubcontrolOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubcontrolOrderField `json:"field"`
}

// DefaultSubcontrolOrder is the default ordering of Subcontrol.
var DefaultSubcontrolOrder = &SubcontrolOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.ID, nil
		},
		column: subcontrol.FieldID,
		toTerm: subcontrol.ByID,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Subcontrol into SubcontrolEdge.
func (s *Subcontrol) ToEdge(order *SubcontrolOrder) *SubcontrolEdge {
	if order == nil {
		order = DefaultSubcontrolOrder
	}
	return &SubcontrolEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SubcontrolHistoryEdge is the edge representation of SubcontrolHistory.
type SubcontrolHistoryEdge struct {
	Node   *SubcontrolHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// SubcontrolHistoryConnection is the connection containing edges to SubcontrolHistory.
type SubcontrolHistoryConnection struct {
	Edges      []*SubcontrolHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *SubcontrolHistoryConnection) build(nodes []*SubcontrolHistory, pager *subcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *SubcontrolHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolHistoryPaginateOption enables pagination customization.
type SubcontrolHistoryPaginateOption func(*subcontrolhistoryPager) error

// WithSubcontrolHistoryOrder configures pagination ordering.
func WithSubcontrolHistoryOrder(order *SubcontrolHistoryOrder) SubcontrolHistoryPaginateOption {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	o := *order
	return func(pager *subcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubcontrolHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubcontrolHistoryFilter configures pagination filter.
func WithSubcontrolHistoryFilter(filter func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)) SubcontrolHistoryPaginateOption {
	return func(pager *subcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("SubcontrolHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolhistoryPager struct {
	reverse bool
	order   *SubcontrolHistoryOrder
	filter  func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)
}

func newSubcontrolHistoryPager(opts []SubcontrolHistoryPaginateOption, reverse bool) (*subcontrolhistoryPager, error) {
	pager := &subcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubcontrolHistoryOrder
	}
	return pager, nil
}

func (p *subcontrolhistoryPager) applyFilter(query *SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) toCursor(sh *SubcontrolHistory) Cursor {
	return p.order.Field.toCursor(sh)
}

func (p *subcontrolhistoryPager) applyCursors(query *SubcontrolHistoryQuery, after, before *Cursor) (*SubcontrolHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubcontrolHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) applyOrder(query *SubcontrolHistoryQuery) *SubcontrolHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
		query = query.Order(DefaultSubcontrolHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subcontrolhistoryPager) orderExpr(query *SubcontrolHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
			b.Comma().Ident(DefaultSubcontrolHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubcontrolHistory.
func (sh *SubcontrolHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolHistoryPaginateOption,
) (*SubcontrolHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sh, err = pager.applyFilter(sh); err != nil {
		return nil, err
	}
	conn := &SubcontrolHistoryConnection{Edges: []*SubcontrolHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sh, err = pager.applyCursors(sh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sh = pager.applyOrder(sh)
	nodes, err := sh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubcontrolHistoryOrderFieldHistoryTime orders SubcontrolHistory by history_time.
	SubcontrolHistoryOrderFieldHistoryTime = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.HistoryTime, nil
		},
		column: subcontrolhistory.FieldHistoryTime,
		toTerm: subcontrolhistory.ByHistoryTime,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.HistoryTime,
			}
		},
	}
	// SubcontrolHistoryOrderFieldCreatedAt orders SubcontrolHistory by created_at.
	SubcontrolHistoryOrderFieldCreatedAt = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.CreatedAt, nil
		},
		column: subcontrolhistory.FieldCreatedAt,
		toTerm: subcontrolhistory.ByCreatedAt,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.CreatedAt,
			}
		},
	}
	// SubcontrolHistoryOrderFieldUpdatedAt orders SubcontrolHistory by updated_at.
	SubcontrolHistoryOrderFieldUpdatedAt = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.UpdatedAt, nil
		},
		column: subcontrolhistory.FieldUpdatedAt,
		toTerm: subcontrolhistory.ByUpdatedAt,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.UpdatedAt,
			}
		},
	}
	// SubcontrolHistoryOrderFieldStatus orders SubcontrolHistory by status.
	SubcontrolHistoryOrderFieldStatus = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.Status, nil
		},
		column: subcontrolhistory.FieldStatus,
		toTerm: subcontrolhistory.ByStatus,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Status,
			}
		},
	}
	// SubcontrolHistoryOrderFieldSource orders SubcontrolHistory by source.
	SubcontrolHistoryOrderFieldSource = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.Source, nil
		},
		column: subcontrolhistory.FieldSource,
		toTerm: subcontrolhistory.BySource,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Source,
			}
		},
	}
	// SubcontrolHistoryOrderFieldReferenceFramework orders SubcontrolHistory by reference_framework.
	SubcontrolHistoryOrderFieldReferenceFramework = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			// allow for nil values for fields
			if sh.ReferenceFramework == nil {
				return nil, nil
			}
			return sh.ReferenceFramework, nil
		},
		column: subcontrolhistory.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) subcontrolhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return subcontrolhistory.ByReferenceFramework(opts...)
		},
		toCursor: func(sh *SubcontrolHistory) Cursor {
			if sh.ReferenceFramework == nil {
				return Cursor{
					ID:    sh.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    sh.ID,
				Value: sh.ReferenceFramework,
			}
		},
	}
	// SubcontrolHistoryOrderFieldControlType orders SubcontrolHistory by control_type.
	SubcontrolHistoryOrderFieldControlType = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.ControlType, nil
		},
		column: subcontrolhistory.FieldControlType,
		toTerm: subcontrolhistory.ByControlType,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.ControlType,
			}
		},
	}
	// SubcontrolHistoryOrderFieldCategory orders SubcontrolHistory by category.
	SubcontrolHistoryOrderFieldCategory = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.Category, nil
		},
		column: subcontrolhistory.FieldCategory,
		toTerm: subcontrolhistory.ByCategory,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Category,
			}
		},
	}
	// SubcontrolHistoryOrderFieldSubcategory orders SubcontrolHistory by subcategory.
	SubcontrolHistoryOrderFieldSubcategory = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.Subcategory, nil
		},
		column: subcontrolhistory.FieldSubcategory,
		toTerm: subcontrolhistory.BySubcategory,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.Subcategory,
			}
		},
	}
	// SubcontrolHistoryOrderFieldRefCode orders SubcontrolHistory by ref_code.
	SubcontrolHistoryOrderFieldRefCode = &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.RefCode, nil
		},
		column: subcontrolhistory.FieldRefCode,
		toTerm: subcontrolhistory.ByRefCode,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    sh.ID,
				Value: sh.RefCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubcontrolHistoryOrderField) String() string {
	var str string
	switch f.column {
	case SubcontrolHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case SubcontrolHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case SubcontrolHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubcontrolHistoryOrderFieldStatus.column:
		str = "STATUS"
	case SubcontrolHistoryOrderFieldSource.column:
		str = "SOURCE"
	case SubcontrolHistoryOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case SubcontrolHistoryOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case SubcontrolHistoryOrderFieldCategory.column:
		str = "category"
	case SubcontrolHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	case SubcontrolHistoryOrderFieldRefCode.column:
		str = "ref_code"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubcontrolHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubcontrolHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubcontrolHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *SubcontrolHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *SubcontrolHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *SubcontrolHistoryOrderFieldUpdatedAt
	case "STATUS":
		*f = *SubcontrolHistoryOrderFieldStatus
	case "SOURCE":
		*f = *SubcontrolHistoryOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *SubcontrolHistoryOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *SubcontrolHistoryOrderFieldControlType
	case "category":
		*f = *SubcontrolHistoryOrderFieldCategory
	case "subcategory":
		*f = *SubcontrolHistoryOrderFieldSubcategory
	case "ref_code":
		*f = *SubcontrolHistoryOrderFieldRefCode
	default:
		return fmt.Errorf("%s is not a valid SubcontrolHistoryOrderField", str)
	}
	return nil
}

// SubcontrolHistoryOrderField defines the ordering field of SubcontrolHistory.
type SubcontrolHistoryOrderField struct {
	// Value extracts the ordering value from the given SubcontrolHistory.
	Value    func(*SubcontrolHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrolhistory.OrderOption
	toCursor func(*SubcontrolHistory) Cursor
}

// SubcontrolHistoryOrder defines the ordering of SubcontrolHistory.
type SubcontrolHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *SubcontrolHistoryOrderField `json:"field"`
}

// DefaultSubcontrolHistoryOrder is the default ordering of SubcontrolHistory.
var DefaultSubcontrolHistoryOrder = &SubcontrolHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.ID, nil
		},
		column: subcontrolhistory.FieldID,
		toTerm: subcontrolhistory.ByID,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{ID: sh.ID}
		},
	},
}

// ToEdge converts SubcontrolHistory into SubcontrolHistoryEdge.
func (sh *SubcontrolHistory) ToEdge(order *SubcontrolHistoryOrder) *SubcontrolHistoryEdge {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	return &SubcontrolHistoryEdge{
		Node:   sh,
		Cursor: order.Field.toCursor(sh),
	}
}

// SubscriberEdge is the edge representation of Subscriber.
type SubscriberEdge struct {
	Node   *Subscriber `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubscriberConnection is the connection containing edges to Subscriber.
type SubscriberConnection struct {
	Edges      []*SubscriberEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubscriberConnection) build(nodes []*Subscriber, pager *subscriberPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subscriber
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subscriber {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subscriber {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubscriberEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubscriberEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubscriberPaginateOption enables pagination customization.
type SubscriberPaginateOption func(*subscriberPager) error

// WithSubscriberOrder configures pagination ordering.
func WithSubscriberOrder(order []*SubscriberOrder) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubscriberFilter configures pagination filter.
func WithSubscriberFilter(filter func(*SubscriberQuery) (*SubscriberQuery, error)) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		if filter == nil {
			return errors.New("SubscriberQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subscriberPager struct {
	reverse bool
	order   []*SubscriberOrder
	filter  func(*SubscriberQuery) (*SubscriberQuery, error)
}

func newSubscriberPager(opts []SubscriberPaginateOption, reverse bool) (*subscriberPager, error) {
	pager := &subscriberPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subscriberPager) applyFilter(query *SubscriberQuery) (*SubscriberQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subscriberPager) toCursor(s *Subscriber) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs_}
}

func (p *subscriberPager) applyCursors(query *SubscriberQuery, after, before *Cursor) (*SubscriberQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubscriberOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subscriberPager) applyOrder(query *SubscriberQuery) *SubscriberQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubscriberOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubscriberOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subscriberPager) orderExpr(query *SubscriberQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubscriberOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subscriber.
func (s *SubscriberQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubscriberPaginateOption,
) (*SubscriberConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubscriberPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SubscriberConnection{Edges: []*SubscriberEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubscriberOrderFieldCreatedAt orders Subscriber by created_at.
	SubscriberOrderFieldCreatedAt = &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: subscriber.FieldCreatedAt,
		toTerm: subscriber.ByCreatedAt,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SubscriberOrderFieldUpdatedAt orders Subscriber by updated_at.
	SubscriberOrderFieldUpdatedAt = &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: subscriber.FieldUpdatedAt,
		toTerm: subscriber.ByUpdatedAt,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SubscriberOrderFieldEmail orders Subscriber by email.
	SubscriberOrderFieldEmail = &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.Email, nil
		},
		column: subscriber.FieldEmail,
		toTerm: subscriber.ByEmail,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Email,
			}
		},
	}
	// SubscriberOrderFieldActive orders Subscriber by active.
	SubscriberOrderFieldActive = &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.Active, nil
		},
		column: subscriber.FieldActive,
		toTerm: subscriber.ByActive,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Active,
			}
		},
	}
	// SubscriberOrderFieldUnsubscribed orders Subscriber by unsubscribed.
	SubscriberOrderFieldUnsubscribed = &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.Unsubscribed, nil
		},
		column: subscriber.FieldUnsubscribed,
		toTerm: subscriber.ByUnsubscribed,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Unsubscribed,
			}
		},
	}
	// SubscriberOrderFieldSendAttempts orders Subscriber by send_attempts.
	SubscriberOrderFieldSendAttempts = &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.SendAttempts, nil
		},
		column: subscriber.FieldSendAttempts,
		toTerm: subscriber.BySendAttempts,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.SendAttempts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubscriberOrderField) String() string {
	var str string
	switch f.column {
	case SubscriberOrderFieldCreatedAt.column:
		str = "created_at"
	case SubscriberOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubscriberOrderFieldEmail.column:
		str = "email"
	case SubscriberOrderFieldActive.column:
		str = "active"
	case SubscriberOrderFieldUnsubscribed.column:
		str = "unsubscribed"
	case SubscriberOrderFieldSendAttempts.column:
		str = "send_attempts"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubscriberOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubscriberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubscriberOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubscriberOrderFieldCreatedAt
	case "updated_at":
		*f = *SubscriberOrderFieldUpdatedAt
	case "email":
		*f = *SubscriberOrderFieldEmail
	case "active":
		*f = *SubscriberOrderFieldActive
	case "unsubscribed":
		*f = *SubscriberOrderFieldUnsubscribed
	case "send_attempts":
		*f = *SubscriberOrderFieldSendAttempts
	default:
		return fmt.Errorf("%s is not a valid SubscriberOrderField", str)
	}
	return nil
}

// SubscriberOrderField defines the ordering field of Subscriber.
type SubscriberOrderField struct {
	// Value extracts the ordering value from the given Subscriber.
	Value    func(*Subscriber) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subscriber.OrderOption
	toCursor func(*Subscriber) Cursor
}

// SubscriberOrder defines the ordering of Subscriber.
type SubscriberOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubscriberOrderField `json:"field"`
}

// DefaultSubscriberOrder is the default ordering of Subscriber.
var DefaultSubscriberOrder = &SubscriberOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.ID, nil
		},
		column: subscriber.FieldID,
		toTerm: subscriber.ByID,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Subscriber into SubscriberEdge.
func (s *Subscriber) ToEdge(order *SubscriberOrder) *SubscriberEdge {
	if order == nil {
		order = DefaultSubscriberOrder
	}
	return &SubscriberEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TFASettingEdge is the edge representation of TFASetting.
type TFASettingEdge struct {
	Node   *TFASetting `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// TFASettingConnection is the connection containing edges to TFASetting.
type TFASettingConnection struct {
	Edges      []*TFASettingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *TFASettingConnection) build(nodes []*TFASetting, pager *tfasettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TFASetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TFASetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TFASetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TFASettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TFASettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TFASettingPaginateOption enables pagination customization.
type TFASettingPaginateOption func(*tfasettingPager) error

// WithTFASettingOrder configures pagination ordering.
func WithTFASettingOrder(order []*TFASettingOrder) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTFASettingFilter configures pagination filter.
func WithTFASettingFilter(filter func(*TFASettingQuery) (*TFASettingQuery, error)) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		if filter == nil {
			return errors.New("TFASettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tfasettingPager struct {
	reverse bool
	order   []*TFASettingOrder
	filter  func(*TFASettingQuery) (*TFASettingQuery, error)
}

func newTFASettingPager(opts []TFASettingPaginateOption, reverse bool) (*tfasettingPager, error) {
	pager := &tfasettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tfasettingPager) applyFilter(query *TFASettingQuery) (*TFASettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tfasettingPager) toCursor(ts *TFASetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(ts).Value)
	}
	return Cursor{ID: ts.ID, Value: cs_}
}

func (p *tfasettingPager) applyCursors(query *TFASettingQuery, after, before *Cursor) (*TFASettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTFASettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *tfasettingPager) applyOrder(query *TFASettingQuery) *TFASettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTFASettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTFASettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tfasettingPager) orderExpr(query *TFASettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTFASettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TFASetting.
func (ts *TFASettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TFASettingPaginateOption,
) (*TFASettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTFASettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ts, err = pager.applyFilter(ts); err != nil {
		return nil, err
	}
	conn := &TFASettingConnection{Edges: []*TFASettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ts.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ts, err = pager.applyCursors(ts, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ts.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ts.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ts = pager.applyOrder(ts)
	nodes, err := ts.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TFASettingOrderFieldCreatedAt orders TFASetting by created_at.
	TFASettingOrderFieldCreatedAt = &TFASettingOrderField{
		Value: func(ts *TFASetting) (ent.Value, error) {
			return ts.CreatedAt, nil
		},
		column: tfasetting.FieldCreatedAt,
		toTerm: tfasetting.ByCreatedAt,
		toCursor: func(ts *TFASetting) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.CreatedAt,
			}
		},
	}
	// TFASettingOrderFieldUpdatedAt orders TFASetting by updated_at.
	TFASettingOrderFieldUpdatedAt = &TFASettingOrderField{
		Value: func(ts *TFASetting) (ent.Value, error) {
			return ts.UpdatedAt, nil
		},
		column: tfasetting.FieldUpdatedAt,
		toTerm: tfasetting.ByUpdatedAt,
		toCursor: func(ts *TFASetting) Cursor {
			return Cursor{
				ID:    ts.ID,
				Value: ts.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TFASettingOrderField) String() string {
	var str string
	switch f.column {
	case TFASettingOrderFieldCreatedAt.column:
		str = "created_at"
	case TFASettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TFASettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TFASettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TFASettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TFASettingOrderFieldCreatedAt
	case "updated_at":
		*f = *TFASettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TFASettingOrderField", str)
	}
	return nil
}

// TFASettingOrderField defines the ordering field of TFASetting.
type TFASettingOrderField struct {
	// Value extracts the ordering value from the given TFASetting.
	Value    func(*TFASetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tfasetting.OrderOption
	toCursor func(*TFASetting) Cursor
}

// TFASettingOrder defines the ordering of TFASetting.
type TFASettingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *TFASettingOrderField `json:"field"`
}

// DefaultTFASettingOrder is the default ordering of TFASetting.
var DefaultTFASettingOrder = &TFASettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TFASettingOrderField{
		Value: func(ts *TFASetting) (ent.Value, error) {
			return ts.ID, nil
		},
		column: tfasetting.FieldID,
		toTerm: tfasetting.ByID,
		toCursor: func(ts *TFASetting) Cursor {
			return Cursor{ID: ts.ID}
		},
	},
}

// ToEdge converts TFASetting into TFASettingEdge.
func (ts *TFASetting) ToEdge(order *TFASettingOrder) *TFASettingEdge {
	if order == nil {
		order = DefaultTFASettingOrder
	}
	return &TFASettingEdge{
		Node:   ts,
		Cursor: order.Field.toCursor(ts),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order []*TaskOrder) TaskPaginateOption {
	return func(pager *taskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   []*TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(t *Task) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs_}
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTaskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTaskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (t *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskOrderFieldCreatedAt orders Task by created_at.
	TaskOrderFieldCreatedAt = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.CreatedAt, nil
		},
		column: task.FieldCreatedAt,
		toTerm: task.ByCreatedAt,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TaskOrderFieldUpdatedAt orders Task by updated_at.
	TaskOrderFieldUpdatedAt = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.UpdatedAt, nil
		},
		column: task.FieldUpdatedAt,
		toTerm: task.ByUpdatedAt,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
	// TaskOrderFieldTitle orders Task by title.
	TaskOrderFieldTitle = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Title, nil
		},
		column: task.FieldTitle,
		toTerm: task.ByTitle,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Title,
			}
		},
	}
	// TaskOrderFieldStatus orders Task by status.
	TaskOrderFieldStatus = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Status, nil
		},
		column: task.FieldStatus,
		toTerm: task.ByStatus,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Status,
			}
		},
	}
	// TaskOrderFieldCategory orders Task by category.
	TaskOrderFieldCategory = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Category, nil
		},
		column: task.FieldCategory,
		toTerm: task.ByCategory,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Category,
			}
		},
	}
	// TaskOrderFieldDue orders Task by due.
	TaskOrderFieldDue = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			// allow for nil values for fields
			if t.Due == nil {
				return nil, nil
			}
			return t.Due, nil
		},
		column: task.FieldDue,
		toTerm: func(opts ...sql.OrderTermOption) task.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return task.ByDue(opts...)
		},
		toCursor: func(t *Task) Cursor {
			if t.Due == nil {
				return Cursor{
					ID:    t.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    t.ID,
				Value: t.Due,
			}
		},
	}
	// TaskOrderFieldCompleted orders Task by completed.
	TaskOrderFieldCompleted = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			// allow for nil values for fields
			if t.Completed == nil {
				return nil, nil
			}
			return t.Completed, nil
		},
		column: task.FieldCompleted,
		toTerm: func(opts ...sql.OrderTermOption) task.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return task.ByCompleted(opts...)
		},
		toCursor: func(t *Task) Cursor {
			if t.Completed == nil {
				return Cursor{
					ID:    t.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    t.ID,
				Value: t.Completed,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskOrderField) String() string {
	var str string
	switch f.column {
	case TaskOrderFieldCreatedAt.column:
		str = "created_at"
	case TaskOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TaskOrderFieldTitle.column:
		str = "title"
	case TaskOrderFieldStatus.column:
		str = "STATUS"
	case TaskOrderFieldCategory.column:
		str = "category"
	case TaskOrderFieldDue.column:
		str = "due"
	case TaskOrderFieldCompleted.column:
		str = "completed"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TaskOrderFieldCreatedAt
	case "updated_at":
		*f = *TaskOrderFieldUpdatedAt
	case "title":
		*f = *TaskOrderFieldTitle
	case "STATUS":
		*f = *TaskOrderFieldStatus
	case "category":
		*f = *TaskOrderFieldCategory
	case "due":
		*f = *TaskOrderFieldDue
	case "completed":
		*f = *TaskOrderFieldCompleted
	default:
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(t *Task) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (t *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TaskHistoryEdge is the edge representation of TaskHistory.
type TaskHistoryEdge struct {
	Node   *TaskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TaskHistoryConnection is the connection containing edges to TaskHistory.
type TaskHistoryConnection struct {
	Edges      []*TaskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TaskHistoryConnection) build(nodes []*TaskHistory, pager *taskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TaskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TaskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TaskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskHistoryPaginateOption enables pagination customization.
type TaskHistoryPaginateOption func(*taskhistoryPager) error

// WithTaskHistoryOrder configures pagination ordering.
func WithTaskHistoryOrder(order *TaskHistoryOrder) TaskHistoryPaginateOption {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	o := *order
	return func(pager *taskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskHistoryFilter configures pagination filter.
func WithTaskHistoryFilter(filter func(*TaskHistoryQuery) (*TaskHistoryQuery, error)) TaskHistoryPaginateOption {
	return func(pager *taskhistoryPager) error {
		if filter == nil {
			return errors.New("TaskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskhistoryPager struct {
	reverse bool
	order   *TaskHistoryOrder
	filter  func(*TaskHistoryQuery) (*TaskHistoryQuery, error)
}

func newTaskHistoryPager(opts []TaskHistoryPaginateOption, reverse bool) (*taskhistoryPager, error) {
	pager := &taskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskHistoryOrder
	}
	return pager, nil
}

func (p *taskhistoryPager) applyFilter(query *TaskHistoryQuery) (*TaskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskhistoryPager) toCursor(th *TaskHistory) Cursor {
	return p.order.Field.toCursor(th)
}

func (p *taskhistoryPager) applyCursors(query *TaskHistoryQuery, after, before *Cursor) (*TaskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTaskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskhistoryPager) applyOrder(query *TaskHistoryQuery) *TaskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTaskHistoryOrder.Field {
		query = query.Order(DefaultTaskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *taskhistoryPager) orderExpr(query *TaskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTaskHistoryOrder.Field {
			b.Comma().Ident(DefaultTaskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TaskHistory.
func (th *TaskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskHistoryPaginateOption,
) (*TaskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if th, err = pager.applyFilter(th); err != nil {
		return nil, err
	}
	conn := &TaskHistoryConnection{Edges: []*TaskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := th.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if th, err = pager.applyCursors(th, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		th.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := th.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	th = pager.applyOrder(th)
	nodes, err := th.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskHistoryOrderFieldHistoryTime orders TaskHistory by history_time.
	TaskHistoryOrderFieldHistoryTime = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.HistoryTime, nil
		},
		column: taskhistory.FieldHistoryTime,
		toTerm: taskhistory.ByHistoryTime,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.HistoryTime,
			}
		},
	}
	// TaskHistoryOrderFieldCreatedAt orders TaskHistory by created_at.
	TaskHistoryOrderFieldCreatedAt = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.CreatedAt, nil
		},
		column: taskhistory.FieldCreatedAt,
		toTerm: taskhistory.ByCreatedAt,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.CreatedAt,
			}
		},
	}
	// TaskHistoryOrderFieldUpdatedAt orders TaskHistory by updated_at.
	TaskHistoryOrderFieldUpdatedAt = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.UpdatedAt, nil
		},
		column: taskhistory.FieldUpdatedAt,
		toTerm: taskhistory.ByUpdatedAt,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.UpdatedAt,
			}
		},
	}
	// TaskHistoryOrderFieldTitle orders TaskHistory by title.
	TaskHistoryOrderFieldTitle = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.Title, nil
		},
		column: taskhistory.FieldTitle,
		toTerm: taskhistory.ByTitle,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.Title,
			}
		},
	}
	// TaskHistoryOrderFieldStatus orders TaskHistory by status.
	TaskHistoryOrderFieldStatus = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.Status, nil
		},
		column: taskhistory.FieldStatus,
		toTerm: taskhistory.ByStatus,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.Status,
			}
		},
	}
	// TaskHistoryOrderFieldCategory orders TaskHistory by category.
	TaskHistoryOrderFieldCategory = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.Category, nil
		},
		column: taskhistory.FieldCategory,
		toTerm: taskhistory.ByCategory,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.Category,
			}
		},
	}
	// TaskHistoryOrderFieldDue orders TaskHistory by due.
	TaskHistoryOrderFieldDue = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			// allow for nil values for fields
			if th.Due == nil {
				return nil, nil
			}
			return th.Due, nil
		},
		column: taskhistory.FieldDue,
		toTerm: func(opts ...sql.OrderTermOption) taskhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return taskhistory.ByDue(opts...)
		},
		toCursor: func(th *TaskHistory) Cursor {
			if th.Due == nil {
				return Cursor{
					ID:    th.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    th.ID,
				Value: th.Due,
			}
		},
	}
	// TaskHistoryOrderFieldCompleted orders TaskHistory by completed.
	TaskHistoryOrderFieldCompleted = &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			// allow for nil values for fields
			if th.Completed == nil {
				return nil, nil
			}
			return th.Completed, nil
		},
		column: taskhistory.FieldCompleted,
		toTerm: func(opts ...sql.OrderTermOption) taskhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return taskhistory.ByCompleted(opts...)
		},
		toCursor: func(th *TaskHistory) Cursor {
			if th.Completed == nil {
				return Cursor{
					ID:    th.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    th.ID,
				Value: th.Completed,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TaskHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TaskHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TaskHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TaskHistoryOrderFieldTitle.column:
		str = "title"
	case TaskHistoryOrderFieldStatus.column:
		str = "STATUS"
	case TaskHistoryOrderFieldCategory.column:
		str = "category"
	case TaskHistoryOrderFieldDue.column:
		str = "due"
	case TaskHistoryOrderFieldCompleted.column:
		str = "completed"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TaskHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TaskHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TaskHistoryOrderFieldUpdatedAt
	case "title":
		*f = *TaskHistoryOrderFieldTitle
	case "STATUS":
		*f = *TaskHistoryOrderFieldStatus
	case "category":
		*f = *TaskHistoryOrderFieldCategory
	case "due":
		*f = *TaskHistoryOrderFieldDue
	case "completed":
		*f = *TaskHistoryOrderFieldCompleted
	default:
		return fmt.Errorf("%s is not a valid TaskHistoryOrderField", str)
	}
	return nil
}

// TaskHistoryOrderField defines the ordering field of TaskHistory.
type TaskHistoryOrderField struct {
	// Value extracts the ordering value from the given TaskHistory.
	Value    func(*TaskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) taskhistory.OrderOption
	toCursor func(*TaskHistory) Cursor
}

// TaskHistoryOrder defines the ordering of TaskHistory.
type TaskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TaskHistoryOrderField `json:"field"`
}

// DefaultTaskHistoryOrder is the default ordering of TaskHistory.
var DefaultTaskHistoryOrder = &TaskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.ID, nil
		},
		column: taskhistory.FieldID,
		toTerm: taskhistory.ByID,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{ID: th.ID}
		},
	},
}

// ToEdge converts TaskHistory into TaskHistoryEdge.
func (th *TaskHistory) ToEdge(order *TaskHistoryOrder) *TaskHistoryEdge {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	return &TaskHistoryEdge{
		Node:   th,
		Cursor: order.Field.toCursor(th),
	}
}

// TemplateEdge is the edge representation of Template.
type TemplateEdge struct {
	Node   *Template `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TemplateConnection is the connection containing edges to Template.
type TemplateConnection struct {
	Edges      []*TemplateEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *TemplateConnection) build(nodes []*Template, pager *templatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Template
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Template {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Template {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplatePaginateOption enables pagination customization.
type TemplatePaginateOption func(*templatePager) error

// WithTemplateOrder configures pagination ordering.
func WithTemplateOrder(order []*TemplateOrder) TemplatePaginateOption {
	return func(pager *templatePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTemplateFilter configures pagination filter.
func WithTemplateFilter(filter func(*TemplateQuery) (*TemplateQuery, error)) TemplatePaginateOption {
	return func(pager *templatePager) error {
		if filter == nil {
			return errors.New("TemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatePager struct {
	reverse bool
	order   []*TemplateOrder
	filter  func(*TemplateQuery) (*TemplateQuery, error)
}

func newTemplatePager(opts []TemplatePaginateOption, reverse bool) (*templatePager, error) {
	pager := &templatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *templatePager) applyFilter(query *TemplateQuery) (*TemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatePager) toCursor(t *Template) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs_}
}

func (p *templatePager) applyCursors(query *TemplateQuery, after, before *Cursor) (*TemplateQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTemplateOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *templatePager) applyOrder(query *TemplateQuery) *TemplateQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTemplateOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *templatePager) orderExpr(query *TemplateQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTemplateOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Template.
func (t *TemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplatePaginateOption,
) (*TemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TemplateConnection{Edges: []*TemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateOrderFieldCreatedAt orders Template by created_at.
	TemplateOrderFieldCreatedAt = &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.CreatedAt, nil
		},
		column: template.FieldCreatedAt,
		toTerm: template.ByCreatedAt,
		toCursor: func(t *Template) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TemplateOrderFieldUpdatedAt orders Template by updated_at.
	TemplateOrderFieldUpdatedAt = &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.UpdatedAt, nil
		},
		column: template.FieldUpdatedAt,
		toTerm: template.ByUpdatedAt,
		toCursor: func(t *Template) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
	// TemplateOrderFieldName orders Template by name.
	TemplateOrderFieldName = &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.Name, nil
		},
		column: template.FieldName,
		toTerm: template.ByName,
		toCursor: func(t *Template) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Name,
			}
		},
	}
	// TemplateOrderFieldTemplateType orders Template by template_type.
	TemplateOrderFieldTemplateType = &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.TemplateType, nil
		},
		column: template.FieldTemplateType,
		toTerm: template.ByTemplateType,
		toCursor: func(t *Template) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.TemplateType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateOrderField) String() string {
	var str string
	switch f.column {
	case TemplateOrderFieldCreatedAt.column:
		str = "created_at"
	case TemplateOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TemplateOrderFieldName.column:
		str = "name"
	case TemplateOrderFieldTemplateType.column:
		str = "TEMPLATE_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TemplateOrderFieldCreatedAt
	case "updated_at":
		*f = *TemplateOrderFieldUpdatedAt
	case "name":
		*f = *TemplateOrderFieldName
	case "TEMPLATE_TYPE":
		*f = *TemplateOrderFieldTemplateType
	default:
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

// TemplateOrderField defines the ordering field of Template.
type TemplateOrderField struct {
	// Value extracts the ordering value from the given Template.
	Value    func(*Template) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) template.OrderOption
	toCursor func(*Template) Cursor
}

// TemplateOrder defines the ordering of Template.
type TemplateOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TemplateOrderField `json:"field"`
}

// DefaultTemplateOrder is the default ordering of Template.
var DefaultTemplateOrder = &TemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.ID, nil
		},
		column: template.FieldID,
		toTerm: template.ByID,
		toCursor: func(t *Template) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Template into TemplateEdge.
func (t *Template) ToEdge(order *TemplateOrder) *TemplateEdge {
	if order == nil {
		order = DefaultTemplateOrder
	}
	return &TemplateEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TemplateHistoryEdge is the edge representation of TemplateHistory.
type TemplateHistoryEdge struct {
	Node   *TemplateHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TemplateHistoryConnection is the connection containing edges to TemplateHistory.
type TemplateHistoryConnection struct {
	Edges      []*TemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TemplateHistoryConnection) build(nodes []*TemplateHistory, pager *templatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplateHistoryPaginateOption enables pagination customization.
type TemplateHistoryPaginateOption func(*templatehistoryPager) error

// WithTemplateHistoryOrder configures pagination ordering.
func WithTemplateHistoryOrder(order *TemplateHistoryOrder) TemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	o := *order
	return func(pager *templatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateHistoryFilter configures pagination filter.
func WithTemplateHistoryFilter(filter func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)) TemplateHistoryPaginateOption {
	return func(pager *templatehistoryPager) error {
		if filter == nil {
			return errors.New("TemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatehistoryPager struct {
	reverse bool
	order   *TemplateHistoryOrder
	filter  func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)
}

func newTemplateHistoryPager(opts []TemplateHistoryPaginateOption, reverse bool) (*templatehistoryPager, error) {
	pager := &templatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateHistoryOrder
	}
	return pager, nil
}

func (p *templatehistoryPager) applyFilter(query *TemplateHistoryQuery) (*TemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatehistoryPager) toCursor(th *TemplateHistory) Cursor {
	return p.order.Field.toCursor(th)
}

func (p *templatehistoryPager) applyCursors(query *TemplateHistoryQuery, after, before *Cursor) (*TemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *templatehistoryPager) applyOrder(query *TemplateHistoryQuery) *TemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTemplateHistoryOrder.Field {
		query = query.Order(DefaultTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *templatehistoryPager) orderExpr(query *TemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TemplateHistory.
func (th *TemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplateHistoryPaginateOption,
) (*TemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if th, err = pager.applyFilter(th); err != nil {
		return nil, err
	}
	conn := &TemplateHistoryConnection{Edges: []*TemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := th.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if th, err = pager.applyCursors(th, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		th.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := th.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	th = pager.applyOrder(th)
	nodes, err := th.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateHistoryOrderFieldHistoryTime orders TemplateHistory by history_time.
	TemplateHistoryOrderFieldHistoryTime = &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.HistoryTime, nil
		},
		column: templatehistory.FieldHistoryTime,
		toTerm: templatehistory.ByHistoryTime,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.HistoryTime,
			}
		},
	}
	// TemplateHistoryOrderFieldCreatedAt orders TemplateHistory by created_at.
	TemplateHistoryOrderFieldCreatedAt = &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.CreatedAt, nil
		},
		column: templatehistory.FieldCreatedAt,
		toTerm: templatehistory.ByCreatedAt,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.CreatedAt,
			}
		},
	}
	// TemplateHistoryOrderFieldUpdatedAt orders TemplateHistory by updated_at.
	TemplateHistoryOrderFieldUpdatedAt = &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.UpdatedAt, nil
		},
		column: templatehistory.FieldUpdatedAt,
		toTerm: templatehistory.ByUpdatedAt,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.UpdatedAt,
			}
		},
	}
	// TemplateHistoryOrderFieldName orders TemplateHistory by name.
	TemplateHistoryOrderFieldName = &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.Name, nil
		},
		column: templatehistory.FieldName,
		toTerm: templatehistory.ByName,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.Name,
			}
		},
	}
	// TemplateHistoryOrderFieldTemplateType orders TemplateHistory by template_type.
	TemplateHistoryOrderFieldTemplateType = &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.TemplateType, nil
		},
		column: templatehistory.FieldTemplateType,
		toTerm: templatehistory.ByTemplateType,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.TemplateType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TemplateHistoryOrderFieldName.column:
		str = "name"
	case TemplateHistoryOrderFieldTemplateType.column:
		str = "TEMPLATE_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TemplateHistoryOrderFieldUpdatedAt
	case "name":
		*f = *TemplateHistoryOrderFieldName
	case "TEMPLATE_TYPE":
		*f = *TemplateHistoryOrderFieldTemplateType
	default:
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

// TemplateHistoryOrderField defines the ordering field of TemplateHistory.
type TemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given TemplateHistory.
	Value    func(*TemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) templatehistory.OrderOption
	toCursor func(*TemplateHistory) Cursor
}

// TemplateHistoryOrder defines the ordering of TemplateHistory.
type TemplateHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TemplateHistoryOrderField `json:"field"`
}

// DefaultTemplateHistoryOrder is the default ordering of TemplateHistory.
var DefaultTemplateHistoryOrder = &TemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.ID, nil
		},
		column: templatehistory.FieldID,
		toTerm: templatehistory.ByID,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{ID: th.ID}
		},
	},
}

// ToEdge converts TemplateHistory into TemplateHistoryEdge.
func (th *TemplateHistory) ToEdge(order *TemplateHistoryOrder) *TemplateHistoryEdge {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	return &TemplateHistoryEdge{
		Node:   th,
		Cursor: order.Field.toCursor(th),
	}
}

// TrustCenterEdge is the edge representation of TrustCenter.
type TrustCenterEdge struct {
	Node   *TrustCenter `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TrustCenterConnection is the connection containing edges to TrustCenter.
type TrustCenterConnection struct {
	Edges      []*TrustCenterEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TrustCenterConnection) build(nodes []*TrustCenter, pager *trustcenterPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenter {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterPaginateOption enables pagination customization.
type TrustCenterPaginateOption func(*trustcenterPager) error

// WithTrustCenterOrder configures pagination ordering.
func WithTrustCenterOrder(order []*TrustCenterOrder) TrustCenterPaginateOption {
	return func(pager *trustcenterPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterFilter configures pagination filter.
func WithTrustCenterFilter(filter func(*TrustCenterQuery) (*TrustCenterQuery, error)) TrustCenterPaginateOption {
	return func(pager *trustcenterPager) error {
		if filter == nil {
			return errors.New("TrustCenterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterPager struct {
	reverse bool
	order   []*TrustCenterOrder
	filter  func(*TrustCenterQuery) (*TrustCenterQuery, error)
}

func newTrustCenterPager(opts []TrustCenterPaginateOption, reverse bool) (*trustcenterPager, error) {
	pager := &trustcenterPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterPager) applyFilter(query *TrustCenterQuery) (*TrustCenterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterPager) toCursor(tc *TrustCenter) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(tc).Value)
	}
	return Cursor{ID: tc.ID, Value: cs_}
}

func (p *trustcenterPager) applyCursors(query *TrustCenterQuery, after, before *Cursor) (*TrustCenterQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterPager) applyOrder(query *TrustCenterQuery) *TrustCenterQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterPager) orderExpr(query *TrustCenterQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenter.
func (tc *TrustCenterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterPaginateOption,
) (*TrustCenterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tc, err = pager.applyFilter(tc); err != nil {
		return nil, err
	}
	conn := &TrustCenterConnection{Edges: []*TrustCenterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := tc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tc, err = pager.applyCursors(tc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		tc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tc = pager.applyOrder(tc)
	nodes, err := tc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterOrderFieldCreatedAt orders TrustCenter by created_at.
	TrustCenterOrderFieldCreatedAt = &TrustCenterOrderField{
		Value: func(tc *TrustCenter) (ent.Value, error) {
			return tc.CreatedAt, nil
		},
		column: trustcenter.FieldCreatedAt,
		toTerm: trustcenter.ByCreatedAt,
		toCursor: func(tc *TrustCenter) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.CreatedAt,
			}
		},
	}
	// TrustCenterOrderFieldUpdatedAt orders TrustCenter by updated_at.
	TrustCenterOrderFieldUpdatedAt = &TrustCenterOrderField{
		Value: func(tc *TrustCenter) (ent.Value, error) {
			return tc.UpdatedAt, nil
		},
		column: trustcenter.FieldUpdatedAt,
		toTerm: trustcenter.ByUpdatedAt,
		toCursor: func(tc *TrustCenter) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterOrderField", str)
	}
	return nil
}

// TrustCenterOrderField defines the ordering field of TrustCenter.
type TrustCenterOrderField struct {
	// Value extracts the ordering value from the given TrustCenter.
	Value    func(*TrustCenter) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenter.OrderOption
	toCursor func(*TrustCenter) Cursor
}

// TrustCenterOrder defines the ordering of TrustCenter.
type TrustCenterOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TrustCenterOrderField `json:"field"`
}

// DefaultTrustCenterOrder is the default ordering of TrustCenter.
var DefaultTrustCenterOrder = &TrustCenterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterOrderField{
		Value: func(tc *TrustCenter) (ent.Value, error) {
			return tc.ID, nil
		},
		column: trustcenter.FieldID,
		toTerm: trustcenter.ByID,
		toCursor: func(tc *TrustCenter) Cursor {
			return Cursor{ID: tc.ID}
		},
	},
}

// ToEdge converts TrustCenter into TrustCenterEdge.
func (tc *TrustCenter) ToEdge(order *TrustCenterOrder) *TrustCenterEdge {
	if order == nil {
		order = DefaultTrustCenterOrder
	}
	return &TrustCenterEdge{
		Node:   tc,
		Cursor: order.Field.toCursor(tc),
	}
}

// TrustCenterHistoryEdge is the edge representation of TrustCenterHistory.
type TrustCenterHistoryEdge struct {
	Node   *TrustCenterHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// TrustCenterHistoryConnection is the connection containing edges to TrustCenterHistory.
type TrustCenterHistoryConnection struct {
	Edges      []*TrustCenterHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *TrustCenterHistoryConnection) build(nodes []*TrustCenterHistory, pager *trustcenterhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterHistoryPaginateOption enables pagination customization.
type TrustCenterHistoryPaginateOption func(*trustcenterhistoryPager) error

// WithTrustCenterHistoryOrder configures pagination ordering.
func WithTrustCenterHistoryOrder(order *TrustCenterHistoryOrder) TrustCenterHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterHistoryOrder
	}
	o := *order
	return func(pager *trustcenterhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterHistoryFilter configures pagination filter.
func WithTrustCenterHistoryFilter(filter func(*TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error)) TrustCenterHistoryPaginateOption {
	return func(pager *trustcenterhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterhistoryPager struct {
	reverse bool
	order   *TrustCenterHistoryOrder
	filter  func(*TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error)
}

func newTrustCenterHistoryPager(opts []TrustCenterHistoryPaginateOption, reverse bool) (*trustcenterhistoryPager, error) {
	pager := &trustcenterhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterhistoryPager) applyFilter(query *TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterhistoryPager) toCursor(tch *TrustCenterHistory) Cursor {
	return p.order.Field.toCursor(tch)
}

func (p *trustcenterhistoryPager) applyCursors(query *TrustCenterHistoryQuery, after, before *Cursor) (*TrustCenterHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterhistoryPager) applyOrder(query *TrustCenterHistoryQuery) *TrustCenterHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterhistoryPager) orderExpr(query *TrustCenterHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterHistory.
func (tch *TrustCenterHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterHistoryPaginateOption,
) (*TrustCenterHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tch, err = pager.applyFilter(tch); err != nil {
		return nil, err
	}
	conn := &TrustCenterHistoryConnection{Edges: []*TrustCenterHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := tch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tch, err = pager.applyCursors(tch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		tch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tch = pager.applyOrder(tch)
	nodes, err := tch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterHistoryOrderFieldHistoryTime orders TrustCenterHistory by history_time.
	TrustCenterHistoryOrderFieldHistoryTime = &TrustCenterHistoryOrderField{
		Value: func(tch *TrustCenterHistory) (ent.Value, error) {
			return tch.HistoryTime, nil
		},
		column: trustcenterhistory.FieldHistoryTime,
		toTerm: trustcenterhistory.ByHistoryTime,
		toCursor: func(tch *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    tch.ID,
				Value: tch.HistoryTime,
			}
		},
	}
	// TrustCenterHistoryOrderFieldCreatedAt orders TrustCenterHistory by created_at.
	TrustCenterHistoryOrderFieldCreatedAt = &TrustCenterHistoryOrderField{
		Value: func(tch *TrustCenterHistory) (ent.Value, error) {
			return tch.CreatedAt, nil
		},
		column: trustcenterhistory.FieldCreatedAt,
		toTerm: trustcenterhistory.ByCreatedAt,
		toCursor: func(tch *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    tch.ID,
				Value: tch.CreatedAt,
			}
		},
	}
	// TrustCenterHistoryOrderFieldUpdatedAt orders TrustCenterHistory by updated_at.
	TrustCenterHistoryOrderFieldUpdatedAt = &TrustCenterHistoryOrderField{
		Value: func(tch *TrustCenterHistory) (ent.Value, error) {
			return tch.UpdatedAt, nil
		},
		column: trustcenterhistory.FieldUpdatedAt,
		toTerm: trustcenterhistory.ByUpdatedAt,
		toCursor: func(tch *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    tch.ID,
				Value: tch.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterHistoryOrderField", str)
	}
	return nil
}

// TrustCenterHistoryOrderField defines the ordering field of TrustCenterHistory.
type TrustCenterHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterHistory.
	Value    func(*TrustCenterHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterhistory.OrderOption
	toCursor func(*TrustCenterHistory) Cursor
}

// TrustCenterHistoryOrder defines the ordering of TrustCenterHistory.
type TrustCenterHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *TrustCenterHistoryOrderField `json:"field"`
}

// DefaultTrustCenterHistoryOrder is the default ordering of TrustCenterHistory.
var DefaultTrustCenterHistoryOrder = &TrustCenterHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterHistoryOrderField{
		Value: func(tch *TrustCenterHistory) (ent.Value, error) {
			return tch.ID, nil
		},
		column: trustcenterhistory.FieldID,
		toTerm: trustcenterhistory.ByID,
		toCursor: func(tch *TrustCenterHistory) Cursor {
			return Cursor{ID: tch.ID}
		},
	},
}

// ToEdge converts TrustCenterHistory into TrustCenterHistoryEdge.
func (tch *TrustCenterHistory) ToEdge(order *TrustCenterHistoryOrder) *TrustCenterHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterHistoryOrder
	}
	return &TrustCenterHistoryEdge{
		Node:   tch,
		Cursor: order.Field.toCursor(tch),
	}
}

// TrustCenterSettingEdge is the edge representation of TrustCenterSetting.
type TrustCenterSettingEdge struct {
	Node   *TrustCenterSetting `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// TrustCenterSettingConnection is the connection containing edges to TrustCenterSetting.
type TrustCenterSettingConnection struct {
	Edges      []*TrustCenterSettingEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *TrustCenterSettingConnection) build(nodes []*TrustCenterSetting, pager *trustcentersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSettingPaginateOption enables pagination customization.
type TrustCenterSettingPaginateOption func(*trustcentersettingPager) error

// WithTrustCenterSettingOrder configures pagination ordering.
func WithTrustCenterSettingOrder(order []*TrustCenterSettingOrder) TrustCenterSettingPaginateOption {
	return func(pager *trustcentersettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterSettingFilter configures pagination filter.
func WithTrustCenterSettingFilter(filter func(*TrustCenterSettingQuery) (*TrustCenterSettingQuery, error)) TrustCenterSettingPaginateOption {
	return func(pager *trustcentersettingPager) error {
		if filter == nil {
			return errors.New("TrustCenterSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersettingPager struct {
	reverse bool
	order   []*TrustCenterSettingOrder
	filter  func(*TrustCenterSettingQuery) (*TrustCenterSettingQuery, error)
}

func newTrustCenterSettingPager(opts []TrustCenterSettingPaginateOption, reverse bool) (*trustcentersettingPager, error) {
	pager := &trustcentersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentersettingPager) applyFilter(query *TrustCenterSettingQuery) (*TrustCenterSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersettingPager) toCursor(tcs *TrustCenterSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(tcs).Value)
	}
	return Cursor{ID: tcs.ID, Value: cs_}
}

func (p *trustcentersettingPager) applyCursors(query *TrustCenterSettingQuery, after, before *Cursor) (*TrustCenterSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentersettingPager) applyOrder(query *TrustCenterSettingQuery) *TrustCenterSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentersettingPager) orderExpr(query *TrustCenterSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSetting.
func (tcs *TrustCenterSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSettingPaginateOption,
) (*TrustCenterSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tcs, err = pager.applyFilter(tcs); err != nil {
		return nil, err
	}
	conn := &TrustCenterSettingConnection{Edges: []*TrustCenterSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := tcs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tcs, err = pager.applyCursors(tcs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		tcs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tcs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tcs = pager.applyOrder(tcs)
	nodes, err := tcs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSettingOrderFieldCreatedAt orders TrustCenterSetting by created_at.
	TrustCenterSettingOrderFieldCreatedAt = &TrustCenterSettingOrderField{
		Value: func(tcs *TrustCenterSetting) (ent.Value, error) {
			return tcs.CreatedAt, nil
		},
		column: trustcentersetting.FieldCreatedAt,
		toTerm: trustcentersetting.ByCreatedAt,
		toCursor: func(tcs *TrustCenterSetting) Cursor {
			return Cursor{
				ID:    tcs.ID,
				Value: tcs.CreatedAt,
			}
		},
	}
	// TrustCenterSettingOrderFieldUpdatedAt orders TrustCenterSetting by updated_at.
	TrustCenterSettingOrderFieldUpdatedAt = &TrustCenterSettingOrderField{
		Value: func(tcs *TrustCenterSetting) (ent.Value, error) {
			return tcs.UpdatedAt, nil
		},
		column: trustcentersetting.FieldUpdatedAt,
		toTerm: trustcentersetting.ByUpdatedAt,
		toCursor: func(tcs *TrustCenterSetting) Cursor {
			return Cursor{
				ID:    tcs.ID,
				Value: tcs.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSettingOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSettingOrderField", str)
	}
	return nil
}

// TrustCenterSettingOrderField defines the ordering field of TrustCenterSetting.
type TrustCenterSettingOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSetting.
	Value    func(*TrustCenterSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersetting.OrderOption
	toCursor func(*TrustCenterSetting) Cursor
}

// TrustCenterSettingOrder defines the ordering of TrustCenterSetting.
type TrustCenterSettingOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *TrustCenterSettingOrderField `json:"field"`
}

// DefaultTrustCenterSettingOrder is the default ordering of TrustCenterSetting.
var DefaultTrustCenterSettingOrder = &TrustCenterSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSettingOrderField{
		Value: func(tcs *TrustCenterSetting) (ent.Value, error) {
			return tcs.ID, nil
		},
		column: trustcentersetting.FieldID,
		toTerm: trustcentersetting.ByID,
		toCursor: func(tcs *TrustCenterSetting) Cursor {
			return Cursor{ID: tcs.ID}
		},
	},
}

// ToEdge converts TrustCenterSetting into TrustCenterSettingEdge.
func (tcs *TrustCenterSetting) ToEdge(order *TrustCenterSettingOrder) *TrustCenterSettingEdge {
	if order == nil {
		order = DefaultTrustCenterSettingOrder
	}
	return &TrustCenterSettingEdge{
		Node:   tcs,
		Cursor: order.Field.toCursor(tcs),
	}
}

// TrustCenterSettingHistoryEdge is the edge representation of TrustCenterSettingHistory.
type TrustCenterSettingHistoryEdge struct {
	Node   *TrustCenterSettingHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// TrustCenterSettingHistoryConnection is the connection containing edges to TrustCenterSettingHistory.
type TrustCenterSettingHistoryConnection struct {
	Edges      []*TrustCenterSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *TrustCenterSettingHistoryConnection) build(nodes []*TrustCenterSettingHistory, pager *trustcentersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSettingHistoryPaginateOption enables pagination customization.
type TrustCenterSettingHistoryPaginateOption func(*trustcentersettinghistoryPager) error

// WithTrustCenterSettingHistoryOrder configures pagination ordering.
func WithTrustCenterSettingHistoryOrder(order *TrustCenterSettingHistoryOrder) TrustCenterSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterSettingHistoryOrder
	}
	o := *order
	return func(pager *trustcentersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterSettingHistoryFilter configures pagination filter.
func WithTrustCenterSettingHistoryFilter(filter func(*TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error)) TrustCenterSettingHistoryPaginateOption {
	return func(pager *trustcentersettinghistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersettinghistoryPager struct {
	reverse bool
	order   *TrustCenterSettingHistoryOrder
	filter  func(*TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error)
}

func newTrustCenterSettingHistoryPager(opts []TrustCenterSettingHistoryPaginateOption, reverse bool) (*trustcentersettinghistoryPager, error) {
	pager := &trustcentersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterSettingHistoryOrder
	}
	return pager, nil
}

func (p *trustcentersettinghistoryPager) applyFilter(query *TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersettinghistoryPager) toCursor(tcsh *TrustCenterSettingHistory) Cursor {
	return p.order.Field.toCursor(tcsh)
}

func (p *trustcentersettinghistoryPager) applyCursors(query *TrustCenterSettingHistoryQuery, after, before *Cursor) (*TrustCenterSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentersettinghistoryPager) applyOrder(query *TrustCenterSettingHistoryQuery) *TrustCenterSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterSettingHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentersettinghistoryPager) orderExpr(query *TrustCenterSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSettingHistory.
func (tcsh *TrustCenterSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSettingHistoryPaginateOption,
) (*TrustCenterSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tcsh, err = pager.applyFilter(tcsh); err != nil {
		return nil, err
	}
	conn := &TrustCenterSettingHistoryConnection{Edges: []*TrustCenterSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := tcsh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tcsh, err = pager.applyCursors(tcsh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		tcsh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tcsh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tcsh = pager.applyOrder(tcsh)
	nodes, err := tcsh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSettingHistoryOrderFieldHistoryTime orders TrustCenterSettingHistory by history_time.
	TrustCenterSettingHistoryOrderFieldHistoryTime = &TrustCenterSettingHistoryOrderField{
		Value: func(tcsh *TrustCenterSettingHistory) (ent.Value, error) {
			return tcsh.HistoryTime, nil
		},
		column: trustcentersettinghistory.FieldHistoryTime,
		toTerm: trustcentersettinghistory.ByHistoryTime,
		toCursor: func(tcsh *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    tcsh.ID,
				Value: tcsh.HistoryTime,
			}
		},
	}
	// TrustCenterSettingHistoryOrderFieldCreatedAt orders TrustCenterSettingHistory by created_at.
	TrustCenterSettingHistoryOrderFieldCreatedAt = &TrustCenterSettingHistoryOrderField{
		Value: func(tcsh *TrustCenterSettingHistory) (ent.Value, error) {
			return tcsh.CreatedAt, nil
		},
		column: trustcentersettinghistory.FieldCreatedAt,
		toTerm: trustcentersettinghistory.ByCreatedAt,
		toCursor: func(tcsh *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    tcsh.ID,
				Value: tcsh.CreatedAt,
			}
		},
	}
	// TrustCenterSettingHistoryOrderFieldUpdatedAt orders TrustCenterSettingHistory by updated_at.
	TrustCenterSettingHistoryOrderFieldUpdatedAt = &TrustCenterSettingHistoryOrderField{
		Value: func(tcsh *TrustCenterSettingHistory) (ent.Value, error) {
			return tcsh.UpdatedAt, nil
		},
		column: trustcentersettinghistory.FieldUpdatedAt,
		toTerm: trustcentersettinghistory.ByUpdatedAt,
		toCursor: func(tcsh *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    tcsh.ID,
				Value: tcsh.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSettingHistoryOrderField", str)
	}
	return nil
}

// TrustCenterSettingHistoryOrderField defines the ordering field of TrustCenterSettingHistory.
type TrustCenterSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSettingHistory.
	Value    func(*TrustCenterSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersettinghistory.OrderOption
	toCursor func(*TrustCenterSettingHistory) Cursor
}

// TrustCenterSettingHistoryOrder defines the ordering of TrustCenterSettingHistory.
type TrustCenterSettingHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *TrustCenterSettingHistoryOrderField `json:"field"`
}

// DefaultTrustCenterSettingHistoryOrder is the default ordering of TrustCenterSettingHistory.
var DefaultTrustCenterSettingHistoryOrder = &TrustCenterSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSettingHistoryOrderField{
		Value: func(tcsh *TrustCenterSettingHistory) (ent.Value, error) {
			return tcsh.ID, nil
		},
		column: trustcentersettinghistory.FieldID,
		toTerm: trustcentersettinghistory.ByID,
		toCursor: func(tcsh *TrustCenterSettingHistory) Cursor {
			return Cursor{ID: tcsh.ID}
		},
	},
}

// ToEdge converts TrustCenterSettingHistory into TrustCenterSettingHistoryEdge.
func (tcsh *TrustCenterSettingHistory) ToEdge(order *TrustCenterSettingHistoryOrder) *TrustCenterSettingHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterSettingHistoryOrder
	}
	return &TrustCenterSettingHistoryEdge{
		Node:   tcsh,
		Cursor: order.Field.toCursor(tcsh),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order []*UserOrder) UserPaginateOption {
	return func(pager *userPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   []*UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(u).Value)
	}
	return Cursor{ID: u.ID, Value: cs_}
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
	// UserOrderFieldFirstName orders User by first_name.
	UserOrderFieldFirstName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.FirstName, nil
		},
		column: user.FieldFirstName,
		toTerm: user.ByFirstName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.FirstName,
			}
		},
	}
	// UserOrderFieldLastName orders User by last_name.
	UserOrderFieldLastName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.LastName, nil
		},
		column: user.FieldLastName,
		toTerm: user.ByLastName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.LastName,
			}
		},
	}
	// UserOrderFieldDisplayName orders User by display_name.
	UserOrderFieldDisplayName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.DisplayName, nil
		},
		column: user.FieldDisplayName,
		toTerm: user.ByDisplayName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "created_at"
	case UserOrderFieldUpdatedAt.column:
		str = "updated_at"
	case UserOrderFieldFirstName.column:
		str = "first_name"
	case UserOrderFieldLastName.column:
		str = "last_name"
	case UserOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserOrderFieldCreatedAt
	case "updated_at":
		*f = *UserOrderFieldUpdatedAt
	case "first_name":
		*f = *UserOrderFieldFirstName
	case "last_name":
		*f = *UserOrderFieldLastName
	case "display_name":
		*f = *UserOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserHistoryEdge is the edge representation of UserHistory.
type UserHistoryEdge struct {
	Node   *UserHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserHistoryConnection is the connection containing edges to UserHistory.
type UserHistoryConnection struct {
	Edges      []*UserHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserHistoryConnection) build(nodes []*UserHistory, pager *userhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserHistoryPaginateOption enables pagination customization.
type UserHistoryPaginateOption func(*userhistoryPager) error

// WithUserHistoryOrder configures pagination ordering.
func WithUserHistoryOrder(order *UserHistoryOrder) UserHistoryPaginateOption {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	o := *order
	return func(pager *userhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserHistoryFilter configures pagination filter.
func WithUserHistoryFilter(filter func(*UserHistoryQuery) (*UserHistoryQuery, error)) UserHistoryPaginateOption {
	return func(pager *userhistoryPager) error {
		if filter == nil {
			return errors.New("UserHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userhistoryPager struct {
	reverse bool
	order   *UserHistoryOrder
	filter  func(*UserHistoryQuery) (*UserHistoryQuery, error)
}

func newUserHistoryPager(opts []UserHistoryPaginateOption, reverse bool) (*userhistoryPager, error) {
	pager := &userhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserHistoryOrder
	}
	return pager, nil
}

func (p *userhistoryPager) applyFilter(query *UserHistoryQuery) (*UserHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userhistoryPager) toCursor(uh *UserHistory) Cursor {
	return p.order.Field.toCursor(uh)
}

func (p *userhistoryPager) applyCursors(query *UserHistoryQuery, after, before *Cursor) (*UserHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userhistoryPager) applyOrder(query *UserHistoryQuery) *UserHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserHistoryOrder.Field {
		query = query.Order(DefaultUserHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userhistoryPager) orderExpr(query *UserHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserHistoryOrder.Field {
			b.Comma().Ident(DefaultUserHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserHistory.
func (uh *UserHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserHistoryPaginateOption,
) (*UserHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if uh, err = pager.applyFilter(uh); err != nil {
		return nil, err
	}
	conn := &UserHistoryConnection{Edges: []*UserHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := uh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if uh, err = pager.applyCursors(uh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		uh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := uh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	uh = pager.applyOrder(uh)
	nodes, err := uh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserHistoryOrderFieldHistoryTime orders UserHistory by history_time.
	UserHistoryOrderFieldHistoryTime = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.HistoryTime, nil
		},
		column: userhistory.FieldHistoryTime,
		toTerm: userhistory.ByHistoryTime,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.HistoryTime,
			}
		},
	}
	// UserHistoryOrderFieldCreatedAt orders UserHistory by created_at.
	UserHistoryOrderFieldCreatedAt = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.CreatedAt, nil
		},
		column: userhistory.FieldCreatedAt,
		toTerm: userhistory.ByCreatedAt,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.CreatedAt,
			}
		},
	}
	// UserHistoryOrderFieldUpdatedAt orders UserHistory by updated_at.
	UserHistoryOrderFieldUpdatedAt = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.UpdatedAt, nil
		},
		column: userhistory.FieldUpdatedAt,
		toTerm: userhistory.ByUpdatedAt,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.UpdatedAt,
			}
		},
	}
	// UserHistoryOrderFieldFirstName orders UserHistory by first_name.
	UserHistoryOrderFieldFirstName = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.FirstName, nil
		},
		column: userhistory.FieldFirstName,
		toTerm: userhistory.ByFirstName,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.FirstName,
			}
		},
	}
	// UserHistoryOrderFieldLastName orders UserHistory by last_name.
	UserHistoryOrderFieldLastName = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.LastName, nil
		},
		column: userhistory.FieldLastName,
		toTerm: userhistory.ByLastName,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.LastName,
			}
		},
	}
	// UserHistoryOrderFieldDisplayName orders UserHistory by display_name.
	UserHistoryOrderFieldDisplayName = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.DisplayName, nil
		},
		column: userhistory.FieldDisplayName,
		toTerm: userhistory.ByDisplayName,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case UserHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case UserHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case UserHistoryOrderFieldFirstName.column:
		str = "first_name"
	case UserHistoryOrderFieldLastName.column:
		str = "last_name"
	case UserHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *UserHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *UserHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *UserHistoryOrderFieldUpdatedAt
	case "first_name":
		*f = *UserHistoryOrderFieldFirstName
	case "last_name":
		*f = *UserHistoryOrderFieldLastName
	case "display_name":
		*f = *UserHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

// UserHistoryOrderField defines the ordering field of UserHistory.
type UserHistoryOrderField struct {
	// Value extracts the ordering value from the given UserHistory.
	Value    func(*UserHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userhistory.OrderOption
	toCursor func(*UserHistory) Cursor
}

// UserHistoryOrder defines the ordering of UserHistory.
type UserHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserHistoryOrderField `json:"field"`
}

// DefaultUserHistoryOrder is the default ordering of UserHistory.
var DefaultUserHistoryOrder = &UserHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.ID, nil
		},
		column: userhistory.FieldID,
		toTerm: userhistory.ByID,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{ID: uh.ID}
		},
	},
}

// ToEdge converts UserHistory into UserHistoryEdge.
func (uh *UserHistory) ToEdge(order *UserHistoryOrder) *UserHistoryEdge {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	return &UserHistoryEdge{
		Node:   uh,
		Cursor: order.Field.toCursor(uh),
	}
}

// UserSettingEdge is the edge representation of UserSetting.
type UserSettingEdge struct {
	Node   *UserSetting `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserSettingConnection is the connection containing edges to UserSetting.
type UserSettingConnection struct {
	Edges      []*UserSettingEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserSettingConnection) build(nodes []*UserSetting, pager *usersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingPaginateOption enables pagination customization.
type UserSettingPaginateOption func(*usersettingPager) error

// WithUserSettingOrder configures pagination ordering.
func WithUserSettingOrder(order []*UserSettingOrder) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserSettingFilter configures pagination filter.
func WithUserSettingFilter(filter func(*UserSettingQuery) (*UserSettingQuery, error)) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		if filter == nil {
			return errors.New("UserSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettingPager struct {
	reverse bool
	order   []*UserSettingOrder
	filter  func(*UserSettingQuery) (*UserSettingQuery, error)
}

func newUserSettingPager(opts []UserSettingPaginateOption, reverse bool) (*usersettingPager, error) {
	pager := &usersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *usersettingPager) applyFilter(query *UserSettingQuery) (*UserSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettingPager) toCursor(us *UserSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(us).Value)
	}
	return Cursor{ID: us.ID, Value: cs_}
}

func (p *usersettingPager) applyCursors(query *UserSettingQuery, after, before *Cursor) (*UserSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *usersettingPager) applyOrder(query *UserSettingQuery) *UserSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *usersettingPager) orderExpr(query *UserSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSetting.
func (us *UserSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingPaginateOption,
) (*UserSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserSettingConnection{Edges: []*UserSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := us.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSettingOrderFieldCreatedAt orders UserSetting by created_at.
	UserSettingOrderFieldCreatedAt = &UserSettingOrderField{
		Value: func(us *UserSetting) (ent.Value, error) {
			return us.CreatedAt, nil
		},
		column: usersetting.FieldCreatedAt,
		toTerm: usersetting.ByCreatedAt,
		toCursor: func(us *UserSetting) Cursor {
			return Cursor{
				ID:    us.ID,
				Value: us.CreatedAt,
			}
		},
	}
	// UserSettingOrderFieldUpdatedAt orders UserSetting by updated_at.
	UserSettingOrderFieldUpdatedAt = &UserSettingOrderField{
		Value: func(us *UserSetting) (ent.Value, error) {
			return us.UpdatedAt, nil
		},
		column: usersetting.FieldUpdatedAt,
		toTerm: usersetting.ByUpdatedAt,
		toCursor: func(us *UserSetting) Cursor {
			return Cursor{
				ID:    us.ID,
				Value: us.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSettingOrderField) String() string {
	var str string
	switch f.column {
	case UserSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case UserSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *UserSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSettingOrderField", str)
	}
	return nil
}

// UserSettingOrderField defines the ordering field of UserSetting.
type UserSettingOrderField struct {
	// Value extracts the ordering value from the given UserSetting.
	Value    func(*UserSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersetting.OrderOption
	toCursor func(*UserSetting) Cursor
}

// UserSettingOrder defines the ordering of UserSetting.
type UserSettingOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserSettingOrderField `json:"field"`
}

// DefaultUserSettingOrder is the default ordering of UserSetting.
var DefaultUserSettingOrder = &UserSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingOrderField{
		Value: func(us *UserSetting) (ent.Value, error) {
			return us.ID, nil
		},
		column: usersetting.FieldID,
		toTerm: usersetting.ByID,
		toCursor: func(us *UserSetting) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserSetting into UserSettingEdge.
func (us *UserSetting) ToEdge(order *UserSettingOrder) *UserSettingEdge {
	if order == nil {
		order = DefaultUserSettingOrder
	}
	return &UserSettingEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}

// UserSettingHistoryEdge is the edge representation of UserSettingHistory.
type UserSettingHistoryEdge struct {
	Node   *UserSettingHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// UserSettingHistoryConnection is the connection containing edges to UserSettingHistory.
type UserSettingHistoryConnection struct {
	Edges      []*UserSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *UserSettingHistoryConnection) build(nodes []*UserSettingHistory, pager *usersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingHistoryPaginateOption enables pagination customization.
type UserSettingHistoryPaginateOption func(*usersettinghistoryPager) error

// WithUserSettingHistoryOrder configures pagination ordering.
func WithUserSettingHistoryOrder(order *UserSettingHistoryOrder) UserSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	o := *order
	return func(pager *usersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSettingHistoryFilter configures pagination filter.
func WithUserSettingHistoryFilter(filter func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)) UserSettingHistoryPaginateOption {
	return func(pager *usersettinghistoryPager) error {
		if filter == nil {
			return errors.New("UserSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettinghistoryPager struct {
	reverse bool
	order   *UserSettingHistoryOrder
	filter  func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)
}

func newUserSettingHistoryPager(opts []UserSettingHistoryPaginateOption, reverse bool) (*usersettinghistoryPager, error) {
	pager := &usersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSettingHistoryOrder
	}
	return pager, nil
}

func (p *usersettinghistoryPager) applyFilter(query *UserSettingHistoryQuery) (*UserSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettinghistoryPager) toCursor(ush *UserSettingHistory) Cursor {
	return p.order.Field.toCursor(ush)
}

func (p *usersettinghistoryPager) applyCursors(query *UserSettingHistoryQuery, after, before *Cursor) (*UserSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersettinghistoryPager) applyOrder(query *UserSettingHistoryQuery) *UserSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSettingHistoryOrder.Field {
		query = query.Order(DefaultUserSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersettinghistoryPager) orderExpr(query *UserSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultUserSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSettingHistory.
func (ush *UserSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingHistoryPaginateOption,
) (*UserSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ush, err = pager.applyFilter(ush); err != nil {
		return nil, err
	}
	conn := &UserSettingHistoryConnection{Edges: []*UserSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ush.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ush, err = pager.applyCursors(ush, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ush.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ush.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ush = pager.applyOrder(ush)
	nodes, err := ush.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSettingHistoryOrderFieldHistoryTime orders UserSettingHistory by history_time.
	UserSettingHistoryOrderFieldHistoryTime = &UserSettingHistoryOrderField{
		Value: func(ush *UserSettingHistory) (ent.Value, error) {
			return ush.HistoryTime, nil
		},
		column: usersettinghistory.FieldHistoryTime,
		toTerm: usersettinghistory.ByHistoryTime,
		toCursor: func(ush *UserSettingHistory) Cursor {
			return Cursor{
				ID:    ush.ID,
				Value: ush.HistoryTime,
			}
		},
	}
	// UserSettingHistoryOrderFieldCreatedAt orders UserSettingHistory by created_at.
	UserSettingHistoryOrderFieldCreatedAt = &UserSettingHistoryOrderField{
		Value: func(ush *UserSettingHistory) (ent.Value, error) {
			return ush.CreatedAt, nil
		},
		column: usersettinghistory.FieldCreatedAt,
		toTerm: usersettinghistory.ByCreatedAt,
		toCursor: func(ush *UserSettingHistory) Cursor {
			return Cursor{
				ID:    ush.ID,
				Value: ush.CreatedAt,
			}
		},
	}
	// UserSettingHistoryOrderFieldUpdatedAt orders UserSettingHistory by updated_at.
	UserSettingHistoryOrderFieldUpdatedAt = &UserSettingHistoryOrderField{
		Value: func(ush *UserSettingHistory) (ent.Value, error) {
			return ush.UpdatedAt, nil
		},
		column: usersettinghistory.FieldUpdatedAt,
		toTerm: usersettinghistory.ByUpdatedAt,
		toCursor: func(ush *UserSettingHistory) Cursor {
			return Cursor{
				ID:    ush.ID,
				Value: ush.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case UserSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case UserSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *UserSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *UserSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *UserSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSettingHistoryOrderField", str)
	}
	return nil
}

// UserSettingHistoryOrderField defines the ordering field of UserSettingHistory.
type UserSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given UserSettingHistory.
	Value    func(*UserSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersettinghistory.OrderOption
	toCursor func(*UserSettingHistory) Cursor
}

// UserSettingHistoryOrder defines the ordering of UserSettingHistory.
type UserSettingHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *UserSettingHistoryOrderField `json:"field"`
}

// DefaultUserSettingHistoryOrder is the default ordering of UserSettingHistory.
var DefaultUserSettingHistoryOrder = &UserSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingHistoryOrderField{
		Value: func(ush *UserSettingHistory) (ent.Value, error) {
			return ush.ID, nil
		},
		column: usersettinghistory.FieldID,
		toTerm: usersettinghistory.ByID,
		toCursor: func(ush *UserSettingHistory) Cursor {
			return Cursor{ID: ush.ID}
		},
	},
}

// ToEdge converts UserSettingHistory into UserSettingHistoryEdge.
func (ush *UserSettingHistory) ToEdge(order *UserSettingHistoryOrder) *UserSettingHistoryEdge {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	return &UserSettingHistoryEdge{
		Node:   ush,
		Cursor: order.Field.toCursor(ush),
	}
}

// WebauthnEdge is the edge representation of Webauthn.
type WebauthnEdge struct {
	Node   *Webauthn `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// WebauthnConnection is the connection containing edges to Webauthn.
type WebauthnConnection struct {
	Edges      []*WebauthnEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *WebauthnConnection) build(nodes []*Webauthn, pager *webauthnPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Webauthn
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Webauthn {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Webauthn {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebauthnEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebauthnEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebauthnPaginateOption enables pagination customization.
type WebauthnPaginateOption func(*webauthnPager) error

// WithWebauthnOrder configures pagination ordering.
func WithWebauthnOrder(order *WebauthnOrder) WebauthnPaginateOption {
	if order == nil {
		order = DefaultWebauthnOrder
	}
	o := *order
	return func(pager *webauthnPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebauthnOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebauthnFilter configures pagination filter.
func WithWebauthnFilter(filter func(*WebauthnQuery) (*WebauthnQuery, error)) WebauthnPaginateOption {
	return func(pager *webauthnPager) error {
		if filter == nil {
			return errors.New("WebauthnQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type webauthnPager struct {
	reverse bool
	order   *WebauthnOrder
	filter  func(*WebauthnQuery) (*WebauthnQuery, error)
}

func newWebauthnPager(opts []WebauthnPaginateOption, reverse bool) (*webauthnPager, error) {
	pager := &webauthnPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebauthnOrder
	}
	return pager, nil
}

func (p *webauthnPager) applyFilter(query *WebauthnQuery) (*WebauthnQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *webauthnPager) toCursor(w *Webauthn) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *webauthnPager) applyCursors(query *WebauthnQuery, after, before *Cursor) (*WebauthnQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWebauthnOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *webauthnPager) applyOrder(query *WebauthnQuery) *WebauthnQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWebauthnOrder.Field {
		query = query.Order(DefaultWebauthnOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *webauthnPager) orderExpr(query *WebauthnQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebauthnOrder.Field {
			b.Comma().Ident(DefaultWebauthnOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Webauthn.
func (w *WebauthnQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebauthnPaginateOption,
) (*WebauthnConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebauthnPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WebauthnConnection{Edges: []*WebauthnEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := w.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebauthnOrderFieldCreatedAt orders Webauthn by created_at.
	WebauthnOrderFieldCreatedAt = &WebauthnOrderField{
		Value: func(w *Webauthn) (ent.Value, error) {
			return w.CreatedAt, nil
		},
		column: webauthn.FieldCreatedAt,
		toTerm: webauthn.ByCreatedAt,
		toCursor: func(w *Webauthn) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.CreatedAt,
			}
		},
	}
	// WebauthnOrderFieldUpdatedAt orders Webauthn by updated_at.
	WebauthnOrderFieldUpdatedAt = &WebauthnOrderField{
		Value: func(w *Webauthn) (ent.Value, error) {
			return w.UpdatedAt, nil
		},
		column: webauthn.FieldUpdatedAt,
		toTerm: webauthn.ByUpdatedAt,
		toCursor: func(w *Webauthn) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebauthnOrderField) String() string {
	var str string
	switch f.column {
	case WebauthnOrderFieldCreatedAt.column:
		str = "created_at"
	case WebauthnOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebauthnOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebauthnOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebauthnOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WebauthnOrderFieldCreatedAt
	case "updated_at":
		*f = *WebauthnOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WebauthnOrderField", str)
	}
	return nil
}

// WebauthnOrderField defines the ordering field of Webauthn.
type WebauthnOrderField struct {
	// Value extracts the ordering value from the given Webauthn.
	Value    func(*Webauthn) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) webauthn.OrderOption
	toCursor func(*Webauthn) Cursor
}

// WebauthnOrder defines the ordering of Webauthn.
type WebauthnOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *WebauthnOrderField `json:"field"`
}

// DefaultWebauthnOrder is the default ordering of Webauthn.
var DefaultWebauthnOrder = &WebauthnOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WebauthnOrderField{
		Value: func(w *Webauthn) (ent.Value, error) {
			return w.ID, nil
		},
		column: webauthn.FieldID,
		toTerm: webauthn.ByID,
		toCursor: func(w *Webauthn) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Webauthn into WebauthnEdge.
func (w *Webauthn) ToEdge(order *WebauthnOrder) *WebauthnEdge {
	if order == nil {
		order = DefaultWebauthnOrder
	}
	return &WebauthnEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
