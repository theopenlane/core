// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/assessment"
	"github.com/theopenlane/core/internal/ent/generated/assessmenthistory"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponse"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponsehistory"
	"github.com/theopenlane/core/internal/ent/generated/asset"
	"github.com/theopenlane/core/internal/ent/generated/assethistory"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementation"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/customdomain"
	"github.com/theopenlane/core/internal/ent/generated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/customtypeenum"
	"github.com/theopenlane/core/internal/ent/generated/directoryaccount"
	"github.com/theopenlane/core/internal/ent/generated/directoryaccounthistory"
	"github.com/theopenlane/core/internal/ent/generated/directorygroup"
	"github.com/theopenlane/core/internal/ent/generated/directorygrouphistory"
	"github.com/theopenlane/core/internal/ent/generated/directorymembership"
	"github.com/theopenlane/core/internal/ent/generated/directorymembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/directorysyncrun"
	"github.com/theopenlane/core/internal/ent/generated/dnsverification"
	"github.com/theopenlane/core/internal/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/evidence"
	"github.com/theopenlane/core/internal/ent/generated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/generated/export"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/finding"
	"github.com/theopenlane/core/internal/ent/generated/findingcontrol"
	"github.com/theopenlane/core/internal/ent/generated/findingcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/findinghistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/jobresult"
	"github.com/theopenlane/core/internal/ent/generated/jobrunner"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnerregistrationtoken"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnertoken"
	"github.com/theopenlane/core/internal/ent/generated/jobtemplate"
	"github.com/theopenlane/core/internal/ent/generated/jobtemplatehistory"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomain"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrol"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/notification"
	"github.com/theopenlane/core/internal/ent/generated/onboarding"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscription"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/remediation"
	"github.com/theopenlane/core/internal/ent/generated/remediationhistory"
	"github.com/theopenlane/core/internal/ent/generated/review"
	"github.com/theopenlane/core/internal/ent/generated/reviewhistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/scan"
	"github.com/theopenlane/core/internal/ent/generated/scanhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobrun"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subprocessor"
	"github.com/theopenlane/core/internal/ent/generated/subprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/tagdefinition"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcenter"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliance"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliancehistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdoc"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdochistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterentity"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterentityhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessor"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfig"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfighistory"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/vulnerability"
	"github.com/theopenlane/core/internal/ent/generated/vulnerabilityhistory"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignment"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignmenthistory"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignmenttarget"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignmenttargethistory"
	"github.com/theopenlane/core/internal/ent/generated/workflowdefinition"
	"github.com/theopenlane/core/internal/ent/generated/workflowdefinitionhistory"
	"github.com/theopenlane/core/internal/ent/generated/workflowevent"
	"github.com/theopenlane/core/internal/ent/generated/workfloweventhistory"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstance"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstancehistory"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectref"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectrefhistory"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// paginateLimit calculates the limit for pagination based on the first and last arguments.
// and returns the limit multiplied by 10.
// This is to ensure we overfetch the data to get the number of requested results.
func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first * 10
	} else if last != nil {
		limit = *last * 10
	}
	return limit
}

// APITokenEdge is the edge representation of APIToken.
type APITokenEdge struct {
	Node   *APIToken `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// APITokenConnection is the connection containing edges to APIToken.
type APITokenConnection struct {
	Edges      []*APITokenEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *APITokenConnection) build(nodes []*APIToken, pager *apitokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *APIToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *APIToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *APIToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*APITokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &APITokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// APITokenPaginateOption enables pagination customization.
type APITokenPaginateOption func(*apitokenPager) error

// WithAPITokenOrder configures pagination ordering.
func WithAPITokenOrder(order []*APITokenOrder) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAPITokenFilter configures pagination filter.
func WithAPITokenFilter(filter func(*APITokenQuery) (*APITokenQuery, error)) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		if filter == nil {
			return errors.New("APITokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apitokenPager struct {
	reverse bool
	order   []*APITokenOrder
	filter  func(*APITokenQuery) (*APITokenQuery, error)
}

func newAPITokenPager(opts []APITokenPaginateOption, reverse bool) (*apitokenPager, error) {
	pager := &apitokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *apitokenPager) applyFilter(query *APITokenQuery) (*APITokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apitokenPager) toCursor(_m *APIToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *apitokenPager) applyCursors(query *APITokenQuery, after, before *Cursor) (*APITokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAPITokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *apitokenPager) applyOrder(query *APITokenQuery) *APITokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAPITokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAPITokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *apitokenPager) orderExpr(query *APITokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAPITokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to APIToken.
func (_m *APITokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...APITokenPaginateOption,
) (*APITokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAPITokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &APITokenConnection{Edges: []*APITokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// APITokenOrderFieldCreatedAt orders APIToken by created_at.
	APITokenOrderFieldCreatedAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: apitoken.FieldCreatedAt,
		toTerm: apitoken.ByCreatedAt,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// APITokenOrderFieldUpdatedAt orders APIToken by updated_at.
	APITokenOrderFieldUpdatedAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: apitoken.FieldUpdatedAt,
		toTerm: apitoken.ByUpdatedAt,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// APITokenOrderFieldName orders APIToken by name.
	APITokenOrderFieldName = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.Name, nil
		},
		column: apitoken.FieldName,
		toTerm: apitoken.ByName,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// APITokenOrderFieldExpiresAt orders APIToken by expires_at.
	APITokenOrderFieldExpiresAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: apitoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) apitoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return apitoken.ByExpiresAt(opts...)
		},
		toCursor: func(_m *APIToken) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// APITokenOrderFieldLastUsedAt orders APIToken by last_used_at.
	APITokenOrderFieldLastUsedAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: apitoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) apitoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return apitoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *APIToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// APITokenOrderFieldIsActive orders APIToken by is_active.
	APITokenOrderFieldIsActive = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.IsActive, nil
		},
		column: apitoken.FieldIsActive,
		toTerm: apitoken.ByIsActive,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsActive,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f APITokenOrderField) String() string {
	var str string
	switch f.column {
	case APITokenOrderFieldCreatedAt.column:
		str = "created_at"
	case APITokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case APITokenOrderFieldName.column:
		str = "name"
	case APITokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case APITokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case APITokenOrderFieldIsActive.column:
		str = "is_active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f APITokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *APITokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("APITokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *APITokenOrderFieldCreatedAt
	case "updated_at":
		*f = *APITokenOrderFieldUpdatedAt
	case "name":
		*f = *APITokenOrderFieldName
	case "expires_at":
		*f = *APITokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *APITokenOrderFieldLastUsedAt
	case "is_active":
		*f = *APITokenOrderFieldIsActive
	default:
		return fmt.Errorf("%s is not a valid APITokenOrderField", str)
	}
	return nil
}

// APITokenOrderField defines the ordering field of APIToken.
type APITokenOrderField struct {
	// Value extracts the ordering value from the given APIToken.
	Value    func(*APIToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apitoken.OrderOption
	toCursor func(*APIToken) Cursor
}

// APITokenOrder defines the ordering of APIToken.
type APITokenOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *APITokenOrderField `json:"field"`
}

// DefaultAPITokenOrder is the default ordering of APIToken.
var DefaultAPITokenOrder = &APITokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: apitoken.FieldID,
		toTerm: apitoken.ByID,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts APIToken into APITokenEdge.
func (_m *APIToken) ToEdge(order *APITokenOrder) *APITokenEdge {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	return &APITokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ActionPlanEdge is the edge representation of ActionPlan.
type ActionPlanEdge struct {
	Node   *ActionPlan `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ActionPlanConnection is the connection containing edges to ActionPlan.
type ActionPlanConnection struct {
	Edges      []*ActionPlanEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ActionPlanConnection) build(nodes []*ActionPlan, pager *actionplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ActionPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanPaginateOption enables pagination customization.
type ActionPlanPaginateOption func(*actionplanPager) error

// WithActionPlanOrder configures pagination ordering.
func WithActionPlanOrder(order []*ActionPlanOrder) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithActionPlanFilter configures pagination filter.
func WithActionPlanFilter(filter func(*ActionPlanQuery) (*ActionPlanQuery, error)) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		if filter == nil {
			return errors.New("ActionPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanPager struct {
	reverse bool
	order   []*ActionPlanOrder
	filter  func(*ActionPlanQuery) (*ActionPlanQuery, error)
}

func newActionPlanPager(opts []ActionPlanPaginateOption, reverse bool) (*actionplanPager, error) {
	pager := &actionplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *actionplanPager) applyFilter(query *ActionPlanQuery) (*ActionPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanPager) toCursor(_m *ActionPlan) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *actionplanPager) applyCursors(query *ActionPlanQuery, after, before *Cursor) (*ActionPlanQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultActionPlanOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *actionplanPager) applyOrder(query *ActionPlanQuery) *ActionPlanQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultActionPlanOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultActionPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *actionplanPager) orderExpr(query *ActionPlanQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultActionPlanOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlan.
func (_m *ActionPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanPaginateOption,
) (*ActionPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ActionPlanConnection{Edges: []*ActionPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ActionPlanOrderFieldCreatedAt orders ActionPlan by created_at.
	ActionPlanOrderFieldCreatedAt = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: actionplan.FieldCreatedAt,
		toTerm: actionplan.ByCreatedAt,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ActionPlanOrderFieldUpdatedAt orders ActionPlan by updated_at.
	ActionPlanOrderFieldUpdatedAt = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: actionplan.FieldUpdatedAt,
		toTerm: actionplan.ByUpdatedAt,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ActionPlanOrderFieldRevision orders ActionPlan by revision.
	ActionPlanOrderFieldRevision = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: actionplan.FieldRevision,
		toTerm: actionplan.ByRevision,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ActionPlanOrderFieldName orders ActionPlan by name.
	ActionPlanOrderFieldName = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Name, nil
		},
		column: actionplan.FieldName,
		toTerm: actionplan.ByName,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ActionPlanOrderFieldStatus orders ActionPlan by status.
	ActionPlanOrderFieldStatus = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Status, nil
		},
		column: actionplan.FieldStatus,
		toTerm: actionplan.ByStatus,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ActionPlanOrderFieldReviewDue orders ActionPlan by review_due.
	ActionPlanOrderFieldReviewDue = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: actionplan.FieldReviewDue,
		toTerm: actionplan.ByReviewDue,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ActionPlanOrderFieldReviewFrequency orders ActionPlan by review_frequency.
	ActionPlanOrderFieldReviewFrequency = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: actionplan.FieldReviewFrequency,
		toTerm: actionplan.ByReviewFrequency,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
	// ActionPlanOrderFieldTitle orders ActionPlan by title.
	ActionPlanOrderFieldTitle = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Title, nil
		},
		column: actionplan.FieldTitle,
		toTerm: actionplan.ByTitle,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ActionPlanOrderFieldDueDate orders ActionPlan by due_date.
	ActionPlanOrderFieldDueDate = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: actionplan.FieldDueDate,
		toTerm: actionplan.ByDueDate,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
	// ActionPlanOrderFieldPriority orders ActionPlan by priority.
	ActionPlanOrderFieldPriority = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Priority, nil
		},
		column: actionplan.FieldPriority,
		toTerm: actionplan.ByPriority,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Priority,
			}
		},
	}
	// ActionPlanOrderFieldSource orders ActionPlan by source.
	ActionPlanOrderFieldSource = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Source, nil
		},
		column: actionplan.FieldSource,
		toTerm: actionplan.BySource,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActionPlanOrderField) String() string {
	var str string
	switch f.column {
	case ActionPlanOrderFieldCreatedAt.column:
		str = "created_at"
	case ActionPlanOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ActionPlanOrderFieldRevision.column:
		str = "revision"
	case ActionPlanOrderFieldName.column:
		str = "name"
	case ActionPlanOrderFieldStatus.column:
		str = "STATUS"
	case ActionPlanOrderFieldReviewDue.column:
		str = "review_due"
	case ActionPlanOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case ActionPlanOrderFieldTitle.column:
		str = "title"
	case ActionPlanOrderFieldDueDate.column:
		str = "due_date"
	case ActionPlanOrderFieldPriority.column:
		str = "PRIORITY"
	case ActionPlanOrderFieldSource.column:
		str = "source"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActionPlanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActionPlanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActionPlanOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ActionPlanOrderFieldCreatedAt
	case "updated_at":
		*f = *ActionPlanOrderFieldUpdatedAt
	case "revision":
		*f = *ActionPlanOrderFieldRevision
	case "name":
		*f = *ActionPlanOrderFieldName
	case "STATUS":
		*f = *ActionPlanOrderFieldStatus
	case "review_due":
		*f = *ActionPlanOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ActionPlanOrderFieldReviewFrequency
	case "title":
		*f = *ActionPlanOrderFieldTitle
	case "due_date":
		*f = *ActionPlanOrderFieldDueDate
	case "PRIORITY":
		*f = *ActionPlanOrderFieldPriority
	case "source":
		*f = *ActionPlanOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid ActionPlanOrderField", str)
	}
	return nil
}

// ActionPlanOrderField defines the ordering field of ActionPlan.
type ActionPlanOrderField struct {
	// Value extracts the ordering value from the given ActionPlan.
	Value    func(*ActionPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplan.OrderOption
	toCursor func(*ActionPlan) Cursor
}

// ActionPlanOrder defines the ordering of ActionPlan.
type ActionPlanOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ActionPlanOrderField `json:"field"`
}

// DefaultActionPlanOrder is the default ordering of ActionPlan.
var DefaultActionPlanOrder = &ActionPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.ID, nil
		},
		column: actionplan.FieldID,
		toTerm: actionplan.ByID,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ActionPlan into ActionPlanEdge.
func (_m *ActionPlan) ToEdge(order *ActionPlanOrder) *ActionPlanEdge {
	if order == nil {
		order = DefaultActionPlanOrder
	}
	return &ActionPlanEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ActionPlanHistoryEdge is the edge representation of ActionPlanHistory.
type ActionPlanHistoryEdge struct {
	Node   *ActionPlanHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ActionPlanHistoryConnection is the connection containing edges to ActionPlanHistory.
type ActionPlanHistoryConnection struct {
	Edges      []*ActionPlanHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ActionPlanHistoryConnection) build(nodes []*ActionPlanHistory, pager *actionplanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ActionPlanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanHistoryPaginateOption enables pagination customization.
type ActionPlanHistoryPaginateOption func(*actionplanhistoryPager) error

// WithActionPlanHistoryOrder configures pagination ordering.
func WithActionPlanHistoryOrder(order *ActionPlanHistoryOrder) ActionPlanHistoryPaginateOption {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	o := *order
	return func(pager *actionplanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActionPlanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActionPlanHistoryFilter configures pagination filter.
func WithActionPlanHistoryFilter(filter func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)) ActionPlanHistoryPaginateOption {
	return func(pager *actionplanhistoryPager) error {
		if filter == nil {
			return errors.New("ActionPlanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanhistoryPager struct {
	reverse bool
	order   *ActionPlanHistoryOrder
	filter  func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)
}

func newActionPlanHistoryPager(opts []ActionPlanHistoryPaginateOption, reverse bool) (*actionplanhistoryPager, error) {
	pager := &actionplanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActionPlanHistoryOrder
	}
	return pager, nil
}

func (p *actionplanhistoryPager) applyFilter(query *ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanhistoryPager) toCursor(_m *ActionPlanHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *actionplanhistoryPager) applyCursors(query *ActionPlanHistoryQuery, after, before *Cursor) (*ActionPlanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultActionPlanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *actionplanhistoryPager) applyOrder(query *ActionPlanHistoryQuery) *ActionPlanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultActionPlanHistoryOrder.Field {
		query = query.Order(DefaultActionPlanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *actionplanhistoryPager) orderExpr(query *ActionPlanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultActionPlanHistoryOrder.Field {
			b.Comma().Ident(DefaultActionPlanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlanHistory.
func (_m *ActionPlanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanHistoryPaginateOption,
) (*ActionPlanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ActionPlanHistoryConnection{Edges: []*ActionPlanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ActionPlanHistoryOrderFieldHistoryTime orders ActionPlanHistory by history_time.
	ActionPlanHistoryOrderFieldHistoryTime = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: actionplanhistory.FieldHistoryTime,
		toTerm: actionplanhistory.ByHistoryTime,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ActionPlanHistoryOrderFieldCreatedAt orders ActionPlanHistory by created_at.
	ActionPlanHistoryOrderFieldCreatedAt = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: actionplanhistory.FieldCreatedAt,
		toTerm: actionplanhistory.ByCreatedAt,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ActionPlanHistoryOrderFieldUpdatedAt orders ActionPlanHistory by updated_at.
	ActionPlanHistoryOrderFieldUpdatedAt = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: actionplanhistory.FieldUpdatedAt,
		toTerm: actionplanhistory.ByUpdatedAt,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ActionPlanHistoryOrderFieldRevision orders ActionPlanHistory by revision.
	ActionPlanHistoryOrderFieldRevision = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: actionplanhistory.FieldRevision,
		toTerm: actionplanhistory.ByRevision,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ActionPlanHistoryOrderFieldName orders ActionPlanHistory by name.
	ActionPlanHistoryOrderFieldName = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: actionplanhistory.FieldName,
		toTerm: actionplanhistory.ByName,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ActionPlanHistoryOrderFieldStatus orders ActionPlanHistory by status.
	ActionPlanHistoryOrderFieldStatus = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: actionplanhistory.FieldStatus,
		toTerm: actionplanhistory.ByStatus,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ActionPlanHistoryOrderFieldReviewDue orders ActionPlanHistory by review_due.
	ActionPlanHistoryOrderFieldReviewDue = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: actionplanhistory.FieldReviewDue,
		toTerm: actionplanhistory.ByReviewDue,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ActionPlanHistoryOrderFieldReviewFrequency orders ActionPlanHistory by review_frequency.
	ActionPlanHistoryOrderFieldReviewFrequency = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: actionplanhistory.FieldReviewFrequency,
		toTerm: actionplanhistory.ByReviewFrequency,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
	// ActionPlanHistoryOrderFieldTitle orders ActionPlanHistory by title.
	ActionPlanHistoryOrderFieldTitle = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: actionplanhistory.FieldTitle,
		toTerm: actionplanhistory.ByTitle,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ActionPlanHistoryOrderFieldDueDate orders ActionPlanHistory by due_date.
	ActionPlanHistoryOrderFieldDueDate = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: actionplanhistory.FieldDueDate,
		toTerm: actionplanhistory.ByDueDate,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
	// ActionPlanHistoryOrderFieldPriority orders ActionPlanHistory by priority.
	ActionPlanHistoryOrderFieldPriority = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Priority, nil
		},
		column: actionplanhistory.FieldPriority,
		toTerm: actionplanhistory.ByPriority,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Priority,
			}
		},
	}
	// ActionPlanHistoryOrderFieldSource orders ActionPlanHistory by source.
	ActionPlanHistoryOrderFieldSource = &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: actionplanhistory.FieldSource,
		toTerm: actionplanhistory.BySource,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActionPlanHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ActionPlanHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ActionPlanHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ActionPlanHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ActionPlanHistoryOrderFieldRevision.column:
		str = "revision"
	case ActionPlanHistoryOrderFieldName.column:
		str = "name"
	case ActionPlanHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ActionPlanHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case ActionPlanHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case ActionPlanHistoryOrderFieldTitle.column:
		str = "title"
	case ActionPlanHistoryOrderFieldDueDate.column:
		str = "due_date"
	case ActionPlanHistoryOrderFieldPriority.column:
		str = "PRIORITY"
	case ActionPlanHistoryOrderFieldSource.column:
		str = "source"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActionPlanHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActionPlanHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActionPlanHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ActionPlanHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ActionPlanHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ActionPlanHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ActionPlanHistoryOrderFieldRevision
	case "name":
		*f = *ActionPlanHistoryOrderFieldName
	case "STATUS":
		*f = *ActionPlanHistoryOrderFieldStatus
	case "review_due":
		*f = *ActionPlanHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ActionPlanHistoryOrderFieldReviewFrequency
	case "title":
		*f = *ActionPlanHistoryOrderFieldTitle
	case "due_date":
		*f = *ActionPlanHistoryOrderFieldDueDate
	case "PRIORITY":
		*f = *ActionPlanHistoryOrderFieldPriority
	case "source":
		*f = *ActionPlanHistoryOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid ActionPlanHistoryOrderField", str)
	}
	return nil
}

// ActionPlanHistoryOrderField defines the ordering field of ActionPlanHistory.
type ActionPlanHistoryOrderField struct {
	// Value extracts the ordering value from the given ActionPlanHistory.
	Value    func(*ActionPlanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplanhistory.OrderOption
	toCursor func(*ActionPlanHistory) Cursor
}

// ActionPlanHistoryOrder defines the ordering of ActionPlanHistory.
type ActionPlanHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ActionPlanHistoryOrderField `json:"field"`
}

// DefaultActionPlanHistoryOrder is the default ordering of ActionPlanHistory.
var DefaultActionPlanHistoryOrder = &ActionPlanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanHistoryOrderField{
		Value: func(_m *ActionPlanHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: actionplanhistory.FieldID,
		toTerm: actionplanhistory.ByID,
		toCursor: func(_m *ActionPlanHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ActionPlanHistory into ActionPlanHistoryEdge.
func (_m *ActionPlanHistory) ToEdge(order *ActionPlanHistoryOrder) *ActionPlanHistoryEdge {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	return &ActionPlanHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentEdge is the edge representation of Assessment.
type AssessmentEdge struct {
	Node   *Assessment `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AssessmentConnection is the connection containing edges to Assessment.
type AssessmentConnection struct {
	Edges      []*AssessmentEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AssessmentConnection) build(nodes []*Assessment, pager *assessmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Assessment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Assessment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Assessment {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentPaginateOption enables pagination customization.
type AssessmentPaginateOption func(*assessmentPager) error

// WithAssessmentOrder configures pagination ordering.
func WithAssessmentOrder(order []*AssessmentOrder) AssessmentPaginateOption {
	return func(pager *assessmentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssessmentFilter configures pagination filter.
func WithAssessmentFilter(filter func(*AssessmentQuery) (*AssessmentQuery, error)) AssessmentPaginateOption {
	return func(pager *assessmentPager) error {
		if filter == nil {
			return errors.New("AssessmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentPager struct {
	reverse bool
	order   []*AssessmentOrder
	filter  func(*AssessmentQuery) (*AssessmentQuery, error)
}

func newAssessmentPager(opts []AssessmentPaginateOption, reverse bool) (*assessmentPager, error) {
	pager := &assessmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assessmentPager) applyFilter(query *AssessmentQuery) (*AssessmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentPager) toCursor(_m *Assessment) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *assessmentPager) applyCursors(query *AssessmentQuery, after, before *Cursor) (*AssessmentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssessmentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assessmentPager) applyOrder(query *AssessmentQuery) *AssessmentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssessmentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssessmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assessmentPager) orderExpr(query *AssessmentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssessmentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Assessment.
func (_m *AssessmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentPaginateOption,
) (*AssessmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentConnection{Edges: []*AssessmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentOrderFieldCreatedAt orders Assessment by created_at.
	AssessmentOrderFieldCreatedAt = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessment.FieldCreatedAt,
		toTerm: assessment.ByCreatedAt,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentOrderFieldUpdatedAt orders Assessment by updated_at.
	AssessmentOrderFieldUpdatedAt = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessment.FieldUpdatedAt,
		toTerm: assessment.ByUpdatedAt,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentOrderFieldName orders Assessment by name.
	AssessmentOrderFieldName = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.Name, nil
		},
		column: assessment.FieldName,
		toTerm: assessment.ByName,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// AssessmentOrderFieldAssessmentType orders Assessment by assessment_type.
	AssessmentOrderFieldAssessmentType = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.AssessmentType, nil
		},
		column: assessment.FieldAssessmentType,
		toTerm: assessment.ByAssessmentType,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssessmentType,
			}
		},
	}
	// AssessmentOrderFieldResponseDueDuration orders Assessment by response_due_duration.
	AssessmentOrderFieldResponseDueDuration = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.ResponseDueDuration, nil
		},
		column: assessment.FieldResponseDueDuration,
		toTerm: assessment.ByResponseDueDuration,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ResponseDueDuration,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentOrderFieldName.column:
		str = "name"
	case AssessmentOrderFieldAssessmentType.column:
		str = "assessment_type"
	case AssessmentOrderFieldResponseDueDuration.column:
		str = "response_due_duration"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssessmentOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentOrderFieldUpdatedAt
	case "name":
		*f = *AssessmentOrderFieldName
	case "assessment_type":
		*f = *AssessmentOrderFieldAssessmentType
	case "response_due_duration":
		*f = *AssessmentOrderFieldResponseDueDuration
	default:
		return fmt.Errorf("%s is not a valid AssessmentOrderField", str)
	}
	return nil
}

// AssessmentOrderField defines the ordering field of Assessment.
type AssessmentOrderField struct {
	// Value extracts the ordering value from the given Assessment.
	Value    func(*Assessment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessment.OrderOption
	toCursor func(*Assessment) Cursor
}

// AssessmentOrder defines the ordering of Assessment.
type AssessmentOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AssessmentOrderField `json:"field"`
}

// DefaultAssessmentOrder is the default ordering of Assessment.
var DefaultAssessmentOrder = &AssessmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessment.FieldID,
		toTerm: assessment.ByID,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Assessment into AssessmentEdge.
func (_m *Assessment) ToEdge(order *AssessmentOrder) *AssessmentEdge {
	if order == nil {
		order = DefaultAssessmentOrder
	}
	return &AssessmentEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentHistoryEdge is the edge representation of AssessmentHistory.
type AssessmentHistoryEdge struct {
	Node   *AssessmentHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// AssessmentHistoryConnection is the connection containing edges to AssessmentHistory.
type AssessmentHistoryConnection struct {
	Edges      []*AssessmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *AssessmentHistoryConnection) build(nodes []*AssessmentHistory, pager *assessmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentHistoryPaginateOption enables pagination customization.
type AssessmentHistoryPaginateOption func(*assessmenthistoryPager) error

// WithAssessmentHistoryOrder configures pagination ordering.
func WithAssessmentHistoryOrder(order *AssessmentHistoryOrder) AssessmentHistoryPaginateOption {
	if order == nil {
		order = DefaultAssessmentHistoryOrder
	}
	o := *order
	return func(pager *assessmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssessmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssessmentHistoryFilter configures pagination filter.
func WithAssessmentHistoryFilter(filter func(*AssessmentHistoryQuery) (*AssessmentHistoryQuery, error)) AssessmentHistoryPaginateOption {
	return func(pager *assessmenthistoryPager) error {
		if filter == nil {
			return errors.New("AssessmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmenthistoryPager struct {
	reverse bool
	order   *AssessmentHistoryOrder
	filter  func(*AssessmentHistoryQuery) (*AssessmentHistoryQuery, error)
}

func newAssessmentHistoryPager(opts []AssessmentHistoryPaginateOption, reverse bool) (*assessmenthistoryPager, error) {
	pager := &assessmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssessmentHistoryOrder
	}
	return pager, nil
}

func (p *assessmenthistoryPager) applyFilter(query *AssessmentHistoryQuery) (*AssessmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmenthistoryPager) toCursor(_m *AssessmentHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *assessmenthistoryPager) applyCursors(query *AssessmentHistoryQuery, after, before *Cursor) (*AssessmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssessmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assessmenthistoryPager) applyOrder(query *AssessmentHistoryQuery) *AssessmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssessmentHistoryOrder.Field {
		query = query.Order(DefaultAssessmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assessmenthistoryPager) orderExpr(query *AssessmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssessmentHistoryOrder.Field {
			b.Comma().Ident(DefaultAssessmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentHistory.
func (_m *AssessmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentHistoryPaginateOption,
) (*AssessmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentHistoryConnection{Edges: []*AssessmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentHistoryOrderFieldHistoryTime orders AssessmentHistory by history_time.
	AssessmentHistoryOrderFieldHistoryTime = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: assessmenthistory.FieldHistoryTime,
		toTerm: assessmenthistory.ByHistoryTime,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// AssessmentHistoryOrderFieldCreatedAt orders AssessmentHistory by created_at.
	AssessmentHistoryOrderFieldCreatedAt = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessmenthistory.FieldCreatedAt,
		toTerm: assessmenthistory.ByCreatedAt,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentHistoryOrderFieldUpdatedAt orders AssessmentHistory by updated_at.
	AssessmentHistoryOrderFieldUpdatedAt = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessmenthistory.FieldUpdatedAt,
		toTerm: assessmenthistory.ByUpdatedAt,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentHistoryOrderFieldName orders AssessmentHistory by name.
	AssessmentHistoryOrderFieldName = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: assessmenthistory.FieldName,
		toTerm: assessmenthistory.ByName,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// AssessmentHistoryOrderFieldAssessmentType orders AssessmentHistory by assessment_type.
	AssessmentHistoryOrderFieldAssessmentType = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.AssessmentType, nil
		},
		column: assessmenthistory.FieldAssessmentType,
		toTerm: assessmenthistory.ByAssessmentType,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssessmentType,
			}
		},
	}
	// AssessmentHistoryOrderFieldResponseDueDuration orders AssessmentHistory by response_due_duration.
	AssessmentHistoryOrderFieldResponseDueDuration = &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.ResponseDueDuration, nil
		},
		column: assessmenthistory.FieldResponseDueDuration,
		toTerm: assessmenthistory.ByResponseDueDuration,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ResponseDueDuration,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssessmentHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentHistoryOrderFieldName.column:
		str = "name"
	case AssessmentHistoryOrderFieldAssessmentType.column:
		str = "assessment_type"
	case AssessmentHistoryOrderFieldResponseDueDuration.column:
		str = "response_due_duration"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssessmentHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssessmentHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentHistoryOrderFieldUpdatedAt
	case "name":
		*f = *AssessmentHistoryOrderFieldName
	case "assessment_type":
		*f = *AssessmentHistoryOrderFieldAssessmentType
	case "response_due_duration":
		*f = *AssessmentHistoryOrderFieldResponseDueDuration
	default:
		return fmt.Errorf("%s is not a valid AssessmentHistoryOrderField", str)
	}
	return nil
}

// AssessmentHistoryOrderField defines the ordering field of AssessmentHistory.
type AssessmentHistoryOrderField struct {
	// Value extracts the ordering value from the given AssessmentHistory.
	Value    func(*AssessmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmenthistory.OrderOption
	toCursor func(*AssessmentHistory) Cursor
}

// AssessmentHistoryOrder defines the ordering of AssessmentHistory.
type AssessmentHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *AssessmentHistoryOrderField `json:"field"`
}

// DefaultAssessmentHistoryOrder is the default ordering of AssessmentHistory.
var DefaultAssessmentHistoryOrder = &AssessmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentHistoryOrderField{
		Value: func(_m *AssessmentHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessmenthistory.FieldID,
		toTerm: assessmenthistory.ByID,
		toCursor: func(_m *AssessmentHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssessmentHistory into AssessmentHistoryEdge.
func (_m *AssessmentHistory) ToEdge(order *AssessmentHistoryOrder) *AssessmentHistoryEdge {
	if order == nil {
		order = DefaultAssessmentHistoryOrder
	}
	return &AssessmentHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentResponseEdge is the edge representation of AssessmentResponse.
type AssessmentResponseEdge struct {
	Node   *AssessmentResponse `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// AssessmentResponseConnection is the connection containing edges to AssessmentResponse.
type AssessmentResponseConnection struct {
	Edges      []*AssessmentResponseEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *AssessmentResponseConnection) build(nodes []*AssessmentResponse, pager *assessmentresponsePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentResponse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentResponse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentResponse {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentResponseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentResponseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentResponsePaginateOption enables pagination customization.
type AssessmentResponsePaginateOption func(*assessmentresponsePager) error

// WithAssessmentResponseOrder configures pagination ordering.
func WithAssessmentResponseOrder(order []*AssessmentResponseOrder) AssessmentResponsePaginateOption {
	return func(pager *assessmentresponsePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssessmentResponseFilter configures pagination filter.
func WithAssessmentResponseFilter(filter func(*AssessmentResponseQuery) (*AssessmentResponseQuery, error)) AssessmentResponsePaginateOption {
	return func(pager *assessmentresponsePager) error {
		if filter == nil {
			return errors.New("AssessmentResponseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentresponsePager struct {
	reverse bool
	order   []*AssessmentResponseOrder
	filter  func(*AssessmentResponseQuery) (*AssessmentResponseQuery, error)
}

func newAssessmentResponsePager(opts []AssessmentResponsePaginateOption, reverse bool) (*assessmentresponsePager, error) {
	pager := &assessmentresponsePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assessmentresponsePager) applyFilter(query *AssessmentResponseQuery) (*AssessmentResponseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentresponsePager) toCursor(_m *AssessmentResponse) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *assessmentresponsePager) applyCursors(query *AssessmentResponseQuery, after, before *Cursor) (*AssessmentResponseQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssessmentResponseOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assessmentresponsePager) applyOrder(query *AssessmentResponseQuery) *AssessmentResponseQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssessmentResponseOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssessmentResponseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assessmentresponsePager) orderExpr(query *AssessmentResponseQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssessmentResponseOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentResponse.
func (_m *AssessmentResponseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentResponsePaginateOption,
) (*AssessmentResponseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentResponsePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentResponseConnection{Edges: []*AssessmentResponseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentResponseOrderFieldCreatedAt orders AssessmentResponse by created_at.
	AssessmentResponseOrderFieldCreatedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessmentresponse.FieldCreatedAt,
		toTerm: assessmentresponse.ByCreatedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldUpdatedAt orders AssessmentResponse by updated_at.
	AssessmentResponseOrderFieldUpdatedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessmentresponse.FieldUpdatedAt,
		toTerm: assessmentresponse.ByUpdatedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldEmail orders AssessmentResponse by email.
	AssessmentResponseOrderFieldEmail = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.Email, nil
		},
		column: assessmentresponse.FieldEmail,
		toTerm: assessmentresponse.ByEmail,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// AssessmentResponseOrderFieldSendAttempts orders AssessmentResponse by send_attempts.
	AssessmentResponseOrderFieldSendAttempts = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: assessmentresponse.FieldSendAttempts,
		toTerm: assessmentresponse.BySendAttempts,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
	// AssessmentResponseOrderFieldStatus orders AssessmentResponse by status.
	AssessmentResponseOrderFieldStatus = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.Status, nil
		},
		column: assessmentresponse.FieldStatus,
		toTerm: assessmentresponse.ByStatus,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// AssessmentResponseOrderFieldAssignedAt orders AssessmentResponse by assigned_at.
	AssessmentResponseOrderFieldAssignedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.AssignedAt, nil
		},
		column: assessmentresponse.FieldAssignedAt,
		toTerm: assessmentresponse.ByAssignedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssignedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldStartedAt orders AssessmentResponse by started_at.
	AssessmentResponseOrderFieldStartedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: assessmentresponse.FieldStartedAt,
		toTerm: assessmentresponse.ByStartedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldCompletedAt orders AssessmentResponse by completed_at.
	AssessmentResponseOrderFieldCompletedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.CompletedAt, nil
		},
		column: assessmentresponse.FieldCompletedAt,
		toTerm: assessmentresponse.ByCompletedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CompletedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldDueDate orders AssessmentResponse by due_date.
	AssessmentResponseOrderFieldDueDate = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: assessmentresponse.FieldDueDate,
		toTerm: assessmentresponse.ByDueDate,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentResponseOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentResponseOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentResponseOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentResponseOrderFieldEmail.column:
		str = "email"
	case AssessmentResponseOrderFieldSendAttempts.column:
		str = "send_attempts"
	case AssessmentResponseOrderFieldStatus.column:
		str = "status"
	case AssessmentResponseOrderFieldAssignedAt.column:
		str = "assigned_at"
	case AssessmentResponseOrderFieldStartedAt.column:
		str = "started_at"
	case AssessmentResponseOrderFieldCompletedAt.column:
		str = "completed_at"
	case AssessmentResponseOrderFieldDueDate.column:
		str = "due_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentResponseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentResponseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentResponseOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssessmentResponseOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentResponseOrderFieldUpdatedAt
	case "email":
		*f = *AssessmentResponseOrderFieldEmail
	case "send_attempts":
		*f = *AssessmentResponseOrderFieldSendAttempts
	case "status":
		*f = *AssessmentResponseOrderFieldStatus
	case "assigned_at":
		*f = *AssessmentResponseOrderFieldAssignedAt
	case "started_at":
		*f = *AssessmentResponseOrderFieldStartedAt
	case "completed_at":
		*f = *AssessmentResponseOrderFieldCompletedAt
	case "due_date":
		*f = *AssessmentResponseOrderFieldDueDate
	default:
		return fmt.Errorf("%s is not a valid AssessmentResponseOrderField", str)
	}
	return nil
}

// AssessmentResponseOrderField defines the ordering field of AssessmentResponse.
type AssessmentResponseOrderField struct {
	// Value extracts the ordering value from the given AssessmentResponse.
	Value    func(*AssessmentResponse) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmentresponse.OrderOption
	toCursor func(*AssessmentResponse) Cursor
}

// AssessmentResponseOrder defines the ordering of AssessmentResponse.
type AssessmentResponseOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *AssessmentResponseOrderField `json:"field"`
}

// DefaultAssessmentResponseOrder is the default ordering of AssessmentResponse.
var DefaultAssessmentResponseOrder = &AssessmentResponseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessmentresponse.FieldID,
		toTerm: assessmentresponse.ByID,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssessmentResponse into AssessmentResponseEdge.
func (_m *AssessmentResponse) ToEdge(order *AssessmentResponseOrder) *AssessmentResponseEdge {
	if order == nil {
		order = DefaultAssessmentResponseOrder
	}
	return &AssessmentResponseEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentResponseHistoryEdge is the edge representation of AssessmentResponseHistory.
type AssessmentResponseHistoryEdge struct {
	Node   *AssessmentResponseHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// AssessmentResponseHistoryConnection is the connection containing edges to AssessmentResponseHistory.
type AssessmentResponseHistoryConnection struct {
	Edges      []*AssessmentResponseHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *AssessmentResponseHistoryConnection) build(nodes []*AssessmentResponseHistory, pager *assessmentresponsehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentResponseHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentResponseHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentResponseHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentResponseHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentResponseHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentResponseHistoryPaginateOption enables pagination customization.
type AssessmentResponseHistoryPaginateOption func(*assessmentresponsehistoryPager) error

// WithAssessmentResponseHistoryOrder configures pagination ordering.
func WithAssessmentResponseHistoryOrder(order *AssessmentResponseHistoryOrder) AssessmentResponseHistoryPaginateOption {
	if order == nil {
		order = DefaultAssessmentResponseHistoryOrder
	}
	o := *order
	return func(pager *assessmentresponsehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssessmentResponseHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssessmentResponseHistoryFilter configures pagination filter.
func WithAssessmentResponseHistoryFilter(filter func(*AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error)) AssessmentResponseHistoryPaginateOption {
	return func(pager *assessmentresponsehistoryPager) error {
		if filter == nil {
			return errors.New("AssessmentResponseHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentresponsehistoryPager struct {
	reverse bool
	order   *AssessmentResponseHistoryOrder
	filter  func(*AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error)
}

func newAssessmentResponseHistoryPager(opts []AssessmentResponseHistoryPaginateOption, reverse bool) (*assessmentresponsehistoryPager, error) {
	pager := &assessmentresponsehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssessmentResponseHistoryOrder
	}
	return pager, nil
}

func (p *assessmentresponsehistoryPager) applyFilter(query *AssessmentResponseHistoryQuery) (*AssessmentResponseHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentresponsehistoryPager) toCursor(_m *AssessmentResponseHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *assessmentresponsehistoryPager) applyCursors(query *AssessmentResponseHistoryQuery, after, before *Cursor) (*AssessmentResponseHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssessmentResponseHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assessmentresponsehistoryPager) applyOrder(query *AssessmentResponseHistoryQuery) *AssessmentResponseHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssessmentResponseHistoryOrder.Field {
		query = query.Order(DefaultAssessmentResponseHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assessmentresponsehistoryPager) orderExpr(query *AssessmentResponseHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssessmentResponseHistoryOrder.Field {
			b.Comma().Ident(DefaultAssessmentResponseHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentResponseHistory.
func (_m *AssessmentResponseHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentResponseHistoryPaginateOption,
) (*AssessmentResponseHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentResponseHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentResponseHistoryConnection{Edges: []*AssessmentResponseHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentResponseHistoryOrderFieldHistoryTime orders AssessmentResponseHistory by history_time.
	AssessmentResponseHistoryOrderFieldHistoryTime = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: assessmentresponsehistory.FieldHistoryTime,
		toTerm: assessmentresponsehistory.ByHistoryTime,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldCreatedAt orders AssessmentResponseHistory by created_at.
	AssessmentResponseHistoryOrderFieldCreatedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessmentresponsehistory.FieldCreatedAt,
		toTerm: assessmentresponsehistory.ByCreatedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldUpdatedAt orders AssessmentResponseHistory by updated_at.
	AssessmentResponseHistoryOrderFieldUpdatedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessmentresponsehistory.FieldUpdatedAt,
		toTerm: assessmentresponsehistory.ByUpdatedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldEmail orders AssessmentResponseHistory by email.
	AssessmentResponseHistoryOrderFieldEmail = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.Email, nil
		},
		column: assessmentresponsehistory.FieldEmail,
		toTerm: assessmentresponsehistory.ByEmail,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldSendAttempts orders AssessmentResponseHistory by send_attempts.
	AssessmentResponseHistoryOrderFieldSendAttempts = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: assessmentresponsehistory.FieldSendAttempts,
		toTerm: assessmentresponsehistory.BySendAttempts,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldStatus orders AssessmentResponseHistory by status.
	AssessmentResponseHistoryOrderFieldStatus = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: assessmentresponsehistory.FieldStatus,
		toTerm: assessmentresponsehistory.ByStatus,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldAssignedAt orders AssessmentResponseHistory by assigned_at.
	AssessmentResponseHistoryOrderFieldAssignedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.AssignedAt, nil
		},
		column: assessmentresponsehistory.FieldAssignedAt,
		toTerm: assessmentresponsehistory.ByAssignedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssignedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldStartedAt orders AssessmentResponseHistory by started_at.
	AssessmentResponseHistoryOrderFieldStartedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: assessmentresponsehistory.FieldStartedAt,
		toTerm: assessmentresponsehistory.ByStartedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldCompletedAt orders AssessmentResponseHistory by completed_at.
	AssessmentResponseHistoryOrderFieldCompletedAt = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.CompletedAt, nil
		},
		column: assessmentresponsehistory.FieldCompletedAt,
		toTerm: assessmentresponsehistory.ByCompletedAt,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CompletedAt,
			}
		},
	}
	// AssessmentResponseHistoryOrderFieldDueDate orders AssessmentResponseHistory by due_date.
	AssessmentResponseHistoryOrderFieldDueDate = &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: assessmentresponsehistory.FieldDueDate,
		toTerm: assessmentresponsehistory.ByDueDate,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentResponseHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentResponseHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssessmentResponseHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentResponseHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentResponseHistoryOrderFieldEmail.column:
		str = "email"
	case AssessmentResponseHistoryOrderFieldSendAttempts.column:
		str = "send_attempts"
	case AssessmentResponseHistoryOrderFieldStatus.column:
		str = "status"
	case AssessmentResponseHistoryOrderFieldAssignedAt.column:
		str = "assigned_at"
	case AssessmentResponseHistoryOrderFieldStartedAt.column:
		str = "started_at"
	case AssessmentResponseHistoryOrderFieldCompletedAt.column:
		str = "completed_at"
	case AssessmentResponseHistoryOrderFieldDueDate.column:
		str = "due_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentResponseHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentResponseHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentResponseHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssessmentResponseHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssessmentResponseHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentResponseHistoryOrderFieldUpdatedAt
	case "email":
		*f = *AssessmentResponseHistoryOrderFieldEmail
	case "send_attempts":
		*f = *AssessmentResponseHistoryOrderFieldSendAttempts
	case "status":
		*f = *AssessmentResponseHistoryOrderFieldStatus
	case "assigned_at":
		*f = *AssessmentResponseHistoryOrderFieldAssignedAt
	case "started_at":
		*f = *AssessmentResponseHistoryOrderFieldStartedAt
	case "completed_at":
		*f = *AssessmentResponseHistoryOrderFieldCompletedAt
	case "due_date":
		*f = *AssessmentResponseHistoryOrderFieldDueDate
	default:
		return fmt.Errorf("%s is not a valid AssessmentResponseHistoryOrderField", str)
	}
	return nil
}

// AssessmentResponseHistoryOrderField defines the ordering field of AssessmentResponseHistory.
type AssessmentResponseHistoryOrderField struct {
	// Value extracts the ordering value from the given AssessmentResponseHistory.
	Value    func(*AssessmentResponseHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmentresponsehistory.OrderOption
	toCursor func(*AssessmentResponseHistory) Cursor
}

// AssessmentResponseHistoryOrder defines the ordering of AssessmentResponseHistory.
type AssessmentResponseHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *AssessmentResponseHistoryOrderField `json:"field"`
}

// DefaultAssessmentResponseHistoryOrder is the default ordering of AssessmentResponseHistory.
var DefaultAssessmentResponseHistoryOrder = &AssessmentResponseHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentResponseHistoryOrderField{
		Value: func(_m *AssessmentResponseHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessmentresponsehistory.FieldID,
		toTerm: assessmentresponsehistory.ByID,
		toCursor: func(_m *AssessmentResponseHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssessmentResponseHistory into AssessmentResponseHistoryEdge.
func (_m *AssessmentResponseHistory) ToEdge(order *AssessmentResponseHistoryOrder) *AssessmentResponseHistoryEdge {
	if order == nil {
		order = DefaultAssessmentResponseHistoryOrder
	}
	return &AssessmentResponseHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssetEdge is the edge representation of Asset.
type AssetEdge struct {
	Node   *Asset `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AssetConnection is the connection containing edges to Asset.
type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AssetConnection) build(nodes []*Asset, pager *assetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Asset
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Asset {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Asset {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetPaginateOption enables pagination customization.
type AssetPaginateOption func(*assetPager) error

// WithAssetOrder configures pagination ordering.
func WithAssetOrder(order []*AssetOrder) AssetPaginateOption {
	return func(pager *assetPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssetFilter configures pagination filter.
func WithAssetFilter(filter func(*AssetQuery) (*AssetQuery, error)) AssetPaginateOption {
	return func(pager *assetPager) error {
		if filter == nil {
			return errors.New("AssetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetPager struct {
	reverse bool
	order   []*AssetOrder
	filter  func(*AssetQuery) (*AssetQuery, error)
}

func newAssetPager(opts []AssetPaginateOption, reverse bool) (*assetPager, error) {
	pager := &assetPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assetPager) applyFilter(query *AssetQuery) (*AssetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetPager) toCursor(_m *Asset) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *assetPager) applyCursors(query *AssetQuery, after, before *Cursor) (*AssetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assetPager) applyOrder(query *AssetQuery) *AssetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assetPager) orderExpr(query *AssetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Asset.
func (_m *AssetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetPaginateOption,
) (*AssetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssetConnection{Edges: []*AssetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetOrderFieldCreatedAt orders Asset by created_at.
	AssetOrderFieldCreatedAt = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: asset.FieldCreatedAt,
		toTerm: asset.ByCreatedAt,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssetOrderFieldUpdatedAt orders Asset by updated_at.
	AssetOrderFieldUpdatedAt = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: asset.FieldUpdatedAt,
		toTerm: asset.ByUpdatedAt,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssetOrderFieldAssetType orders Asset by asset_type.
	AssetOrderFieldAssetType = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.AssetType, nil
		},
		column: asset.FieldAssetType,
		toTerm: asset.ByAssetType,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssetType,
			}
		},
	}
	// AssetOrderFieldName orders Asset by name.
	AssetOrderFieldName = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.Name, nil
		},
		column: asset.FieldName,
		toTerm: asset.ByName,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetOrderField) String() string {
	var str string
	switch f.column {
	case AssetOrderFieldCreatedAt.column:
		str = "created_at"
	case AssetOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssetOrderFieldAssetType.column:
		str = "ASSET_TYPE"
	case AssetOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssetOrderFieldCreatedAt
	case "updated_at":
		*f = *AssetOrderFieldUpdatedAt
	case "ASSET_TYPE":
		*f = *AssetOrderFieldAssetType
	case "name":
		*f = *AssetOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AssetOrderField", str)
	}
	return nil
}

// AssetOrderField defines the ordering field of Asset.
type AssetOrderField struct {
	// Value extracts the ordering value from the given Asset.
	Value    func(*Asset) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) asset.OrderOption
	toCursor func(*Asset) Cursor
}

// AssetOrder defines the ordering of Asset.
type AssetOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AssetOrderField `json:"field"`
}

// DefaultAssetOrder is the default ordering of Asset.
var DefaultAssetOrder = &AssetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.ID, nil
		},
		column: asset.FieldID,
		toTerm: asset.ByID,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Asset into AssetEdge.
func (_m *Asset) ToEdge(order *AssetOrder) *AssetEdge {
	if order == nil {
		order = DefaultAssetOrder
	}
	return &AssetEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssetHistoryEdge is the edge representation of AssetHistory.
type AssetHistoryEdge struct {
	Node   *AssetHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// AssetHistoryConnection is the connection containing edges to AssetHistory.
type AssetHistoryConnection struct {
	Edges      []*AssetHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *AssetHistoryConnection) build(nodes []*AssetHistory, pager *assethistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssetHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssetHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssetHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetHistoryPaginateOption enables pagination customization.
type AssetHistoryPaginateOption func(*assethistoryPager) error

// WithAssetHistoryOrder configures pagination ordering.
func WithAssetHistoryOrder(order *AssetHistoryOrder) AssetHistoryPaginateOption {
	if order == nil {
		order = DefaultAssetHistoryOrder
	}
	o := *order
	return func(pager *assethistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetHistoryFilter configures pagination filter.
func WithAssetHistoryFilter(filter func(*AssetHistoryQuery) (*AssetHistoryQuery, error)) AssetHistoryPaginateOption {
	return func(pager *assethistoryPager) error {
		if filter == nil {
			return errors.New("AssetHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assethistoryPager struct {
	reverse bool
	order   *AssetHistoryOrder
	filter  func(*AssetHistoryQuery) (*AssetHistoryQuery, error)
}

func newAssetHistoryPager(opts []AssetHistoryPaginateOption, reverse bool) (*assethistoryPager, error) {
	pager := &assethistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetHistoryOrder
	}
	return pager, nil
}

func (p *assethistoryPager) applyFilter(query *AssetHistoryQuery) (*AssetHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assethistoryPager) toCursor(_m *AssetHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *assethistoryPager) applyCursors(query *AssetHistoryQuery, after, before *Cursor) (*AssetHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAssetHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *assethistoryPager) applyOrder(query *AssetHistoryQuery) *AssetHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAssetHistoryOrder.Field {
		query = query.Order(DefaultAssetHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *assethistoryPager) orderExpr(query *AssetHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetHistoryOrder.Field {
			b.Comma().Ident(DefaultAssetHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssetHistory.
func (_m *AssetHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetHistoryPaginateOption,
) (*AssetHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssetHistoryConnection{Edges: []*AssetHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetHistoryOrderFieldHistoryTime orders AssetHistory by history_time.
	AssetHistoryOrderFieldHistoryTime = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: assethistory.FieldHistoryTime,
		toTerm: assethistory.ByHistoryTime,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// AssetHistoryOrderFieldCreatedAt orders AssetHistory by created_at.
	AssetHistoryOrderFieldCreatedAt = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assethistory.FieldCreatedAt,
		toTerm: assethistory.ByCreatedAt,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssetHistoryOrderFieldUpdatedAt orders AssetHistory by updated_at.
	AssetHistoryOrderFieldUpdatedAt = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assethistory.FieldUpdatedAt,
		toTerm: assethistory.ByUpdatedAt,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssetHistoryOrderFieldAssetType orders AssetHistory by asset_type.
	AssetHistoryOrderFieldAssetType = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.AssetType, nil
		},
		column: assethistory.FieldAssetType,
		toTerm: assethistory.ByAssetType,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssetType,
			}
		},
	}
	// AssetHistoryOrderFieldName orders AssetHistory by name.
	AssetHistoryOrderFieldName = &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: assethistory.FieldName,
		toTerm: assethistory.ByName,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetHistoryOrderField) String() string {
	var str string
	switch f.column {
	case AssetHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case AssetHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case AssetHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssetHistoryOrderFieldAssetType.column:
		str = "ASSET_TYPE"
	case AssetHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *AssetHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *AssetHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *AssetHistoryOrderFieldUpdatedAt
	case "ASSET_TYPE":
		*f = *AssetHistoryOrderFieldAssetType
	case "name":
		*f = *AssetHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AssetHistoryOrderField", str)
	}
	return nil
}

// AssetHistoryOrderField defines the ordering field of AssetHistory.
type AssetHistoryOrderField struct {
	// Value extracts the ordering value from the given AssetHistory.
	Value    func(*AssetHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assethistory.OrderOption
	toCursor func(*AssetHistory) Cursor
}

// AssetHistoryOrder defines the ordering of AssetHistory.
type AssetHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *AssetHistoryOrderField `json:"field"`
}

// DefaultAssetHistoryOrder is the default ordering of AssetHistory.
var DefaultAssetHistoryOrder = &AssetHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssetHistoryOrderField{
		Value: func(_m *AssetHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assethistory.FieldID,
		toTerm: assethistory.ByID,
		toCursor: func(_m *AssetHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssetHistory into AssetHistoryEdge.
func (_m *AssetHistory) ToEdge(order *AssetHistoryOrder) *AssetHistoryEdge {
	if order == nil {
		order = DefaultAssetHistoryOrder
	}
	return &AssetHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ContactEdge is the edge representation of Contact.
type ContactEdge struct {
	Node   *Contact `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ContactConnection is the connection containing edges to Contact.
type ContactConnection struct {
	Edges      []*ContactEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ContactConnection) build(nodes []*Contact, pager *contactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Contact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Contact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Contact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactPaginateOption enables pagination customization.
type ContactPaginateOption func(*contactPager) error

// WithContactOrder configures pagination ordering.
func WithContactOrder(order []*ContactOrder) ContactPaginateOption {
	return func(pager *contactPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithContactFilter configures pagination filter.
func WithContactFilter(filter func(*ContactQuery) (*ContactQuery, error)) ContactPaginateOption {
	return func(pager *contactPager) error {
		if filter == nil {
			return errors.New("ContactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contactPager struct {
	reverse bool
	order   []*ContactOrder
	filter  func(*ContactQuery) (*ContactQuery, error)
}

func newContactPager(opts []ContactPaginateOption, reverse bool) (*contactPager, error) {
	pager := &contactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *contactPager) applyFilter(query *ContactQuery) (*ContactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contactPager) toCursor(_m *Contact) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *contactPager) applyCursors(query *ContactQuery, after, before *Cursor) (*ContactQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultContactOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *contactPager) applyOrder(query *ContactQuery) *ContactQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultContactOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultContactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *contactPager) orderExpr(query *ContactQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultContactOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Contact.
func (_m *ContactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactPaginateOption,
) (*ContactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ContactConnection{Edges: []*ContactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactOrderFieldCreatedAt orders Contact by created_at.
	ContactOrderFieldCreatedAt = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: contact.FieldCreatedAt,
		toTerm: contact.ByCreatedAt,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ContactOrderFieldUpdatedAt orders Contact by updated_at.
	ContactOrderFieldUpdatedAt = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: contact.FieldUpdatedAt,
		toTerm: contact.ByUpdatedAt,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ContactOrderFieldFullName orders Contact by full_name.
	ContactOrderFieldFullName = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.FullName, nil
		},
		column: contact.FieldFullName,
		toTerm: contact.ByFullName,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FullName,
			}
		},
	}
	// ContactOrderFieldTitle orders Contact by title.
	ContactOrderFieldTitle = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Title, nil
		},
		column: contact.FieldTitle,
		toTerm: contact.ByTitle,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ContactOrderFieldCompany orders Contact by company.
	ContactOrderFieldCompany = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Company, nil
		},
		column: contact.FieldCompany,
		toTerm: contact.ByCompany,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Company,
			}
		},
	}
	// ContactOrderFieldEmail orders Contact by email.
	ContactOrderFieldEmail = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Email, nil
		},
		column: contact.FieldEmail,
		toTerm: contact.ByEmail,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// ContactOrderFieldStatus orders Contact by status.
	ContactOrderFieldStatus = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Status, nil
		},
		column: contact.FieldStatus,
		toTerm: contact.ByStatus,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactOrderField) String() string {
	var str string
	switch f.column {
	case ContactOrderFieldCreatedAt.column:
		str = "created_at"
	case ContactOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ContactOrderFieldFullName.column:
		str = "full_name"
	case ContactOrderFieldTitle.column:
		str = "title"
	case ContactOrderFieldCompany.column:
		str = "company"
	case ContactOrderFieldEmail.column:
		str = "email"
	case ContactOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ContactOrderFieldCreatedAt
	case "updated_at":
		*f = *ContactOrderFieldUpdatedAt
	case "full_name":
		*f = *ContactOrderFieldFullName
	case "title":
		*f = *ContactOrderFieldTitle
	case "company":
		*f = *ContactOrderFieldCompany
	case "email":
		*f = *ContactOrderFieldEmail
	case "STATUS":
		*f = *ContactOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ContactOrderField", str)
	}
	return nil
}

// ContactOrderField defines the ordering field of Contact.
type ContactOrderField struct {
	// Value extracts the ordering value from the given Contact.
	Value    func(*Contact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contact.OrderOption
	toCursor func(*Contact) Cursor
}

// ContactOrder defines the ordering of Contact.
type ContactOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ContactOrderField `json:"field"`
}

// DefaultContactOrder is the default ordering of Contact.
var DefaultContactOrder = &ContactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.ID, nil
		},
		column: contact.FieldID,
		toTerm: contact.ByID,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Contact into ContactEdge.
func (_m *Contact) ToEdge(order *ContactOrder) *ContactEdge {
	if order == nil {
		order = DefaultContactOrder
	}
	return &ContactEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ContactHistoryEdge is the edge representation of ContactHistory.
type ContactHistoryEdge struct {
	Node   *ContactHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ContactHistoryConnection is the connection containing edges to ContactHistory.
type ContactHistoryConnection struct {
	Edges      []*ContactHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ContactHistoryConnection) build(nodes []*ContactHistory, pager *contacthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ContactHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ContactHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ContactHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactHistoryPaginateOption enables pagination customization.
type ContactHistoryPaginateOption func(*contacthistoryPager) error

// WithContactHistoryOrder configures pagination ordering.
func WithContactHistoryOrder(order *ContactHistoryOrder) ContactHistoryPaginateOption {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	o := *order
	return func(pager *contacthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactHistoryFilter configures pagination filter.
func WithContactHistoryFilter(filter func(*ContactHistoryQuery) (*ContactHistoryQuery, error)) ContactHistoryPaginateOption {
	return func(pager *contacthistoryPager) error {
		if filter == nil {
			return errors.New("ContactHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contacthistoryPager struct {
	reverse bool
	order   *ContactHistoryOrder
	filter  func(*ContactHistoryQuery) (*ContactHistoryQuery, error)
}

func newContactHistoryPager(opts []ContactHistoryPaginateOption, reverse bool) (*contacthistoryPager, error) {
	pager := &contacthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactHistoryOrder
	}
	return pager, nil
}

func (p *contacthistoryPager) applyFilter(query *ContactHistoryQuery) (*ContactHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contacthistoryPager) toCursor(_m *ContactHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *contacthistoryPager) applyCursors(query *ContactHistoryQuery, after, before *Cursor) (*ContactHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contacthistoryPager) applyOrder(query *ContactHistoryQuery) *ContactHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactHistoryOrder.Field {
		query = query.Order(DefaultContactHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contacthistoryPager) orderExpr(query *ContactHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactHistoryOrder.Field {
			b.Comma().Ident(DefaultContactHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ContactHistory.
func (_m *ContactHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactHistoryPaginateOption,
) (*ContactHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ContactHistoryConnection{Edges: []*ContactHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactHistoryOrderFieldHistoryTime orders ContactHistory by history_time.
	ContactHistoryOrderFieldHistoryTime = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: contacthistory.FieldHistoryTime,
		toTerm: contacthistory.ByHistoryTime,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ContactHistoryOrderFieldCreatedAt orders ContactHistory by created_at.
	ContactHistoryOrderFieldCreatedAt = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: contacthistory.FieldCreatedAt,
		toTerm: contacthistory.ByCreatedAt,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ContactHistoryOrderFieldUpdatedAt orders ContactHistory by updated_at.
	ContactHistoryOrderFieldUpdatedAt = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: contacthistory.FieldUpdatedAt,
		toTerm: contacthistory.ByUpdatedAt,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ContactHistoryOrderFieldFullName orders ContactHistory by full_name.
	ContactHistoryOrderFieldFullName = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.FullName, nil
		},
		column: contacthistory.FieldFullName,
		toTerm: contacthistory.ByFullName,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FullName,
			}
		},
	}
	// ContactHistoryOrderFieldTitle orders ContactHistory by title.
	ContactHistoryOrderFieldTitle = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: contacthistory.FieldTitle,
		toTerm: contacthistory.ByTitle,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ContactHistoryOrderFieldCompany orders ContactHistory by company.
	ContactHistoryOrderFieldCompany = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Company, nil
		},
		column: contacthistory.FieldCompany,
		toTerm: contacthistory.ByCompany,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Company,
			}
		},
	}
	// ContactHistoryOrderFieldEmail orders ContactHistory by email.
	ContactHistoryOrderFieldEmail = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Email, nil
		},
		column: contacthistory.FieldEmail,
		toTerm: contacthistory.ByEmail,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// ContactHistoryOrderFieldStatus orders ContactHistory by status.
	ContactHistoryOrderFieldStatus = &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: contacthistory.FieldStatus,
		toTerm: contacthistory.ByStatus,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ContactHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ContactHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ContactHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ContactHistoryOrderFieldFullName.column:
		str = "full_name"
	case ContactHistoryOrderFieldTitle.column:
		str = "title"
	case ContactHistoryOrderFieldCompany.column:
		str = "company"
	case ContactHistoryOrderFieldEmail.column:
		str = "email"
	case ContactHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ContactHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ContactHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ContactHistoryOrderFieldUpdatedAt
	case "full_name":
		*f = *ContactHistoryOrderFieldFullName
	case "title":
		*f = *ContactHistoryOrderFieldTitle
	case "company":
		*f = *ContactHistoryOrderFieldCompany
	case "email":
		*f = *ContactHistoryOrderFieldEmail
	case "STATUS":
		*f = *ContactHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ContactHistoryOrderField", str)
	}
	return nil
}

// ContactHistoryOrderField defines the ordering field of ContactHistory.
type ContactHistoryOrderField struct {
	// Value extracts the ordering value from the given ContactHistory.
	Value    func(*ContactHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contacthistory.OrderOption
	toCursor func(*ContactHistory) Cursor
}

// ContactHistoryOrder defines the ordering of ContactHistory.
type ContactHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ContactHistoryOrderField `json:"field"`
}

// DefaultContactHistoryOrder is the default ordering of ContactHistory.
var DefaultContactHistoryOrder = &ContactHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactHistoryOrderField{
		Value: func(_m *ContactHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: contacthistory.FieldID,
		toTerm: contacthistory.ByID,
		toCursor: func(_m *ContactHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ContactHistory into ContactHistoryEdge.
func (_m *ContactHistory) ToEdge(order *ContactHistoryOrder) *ContactHistoryEdge {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	return &ContactHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlEdge is the edge representation of Control.
type ControlEdge struct {
	Node   *Control `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ControlConnection is the connection containing edges to Control.
type ControlConnection struct {
	Edges      []*ControlEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ControlConnection) build(nodes []*Control, pager *controlPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Control
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Control {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Control {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlPaginateOption enables pagination customization.
type ControlPaginateOption func(*controlPager) error

// WithControlOrder configures pagination ordering.
func WithControlOrder(order []*ControlOrder) ControlPaginateOption {
	return func(pager *controlPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlFilter configures pagination filter.
func WithControlFilter(filter func(*ControlQuery) (*ControlQuery, error)) ControlPaginateOption {
	return func(pager *controlPager) error {
		if filter == nil {
			return errors.New("ControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlPager struct {
	reverse bool
	order   []*ControlOrder
	filter  func(*ControlQuery) (*ControlQuery, error)
}

func newControlPager(opts []ControlPaginateOption, reverse bool) (*controlPager, error) {
	pager := &controlPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlPager) applyFilter(query *ControlQuery) (*ControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlPager) toCursor(_m *Control) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *controlPager) applyCursors(query *ControlQuery, after, before *Cursor) (*ControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlPager) applyOrder(query *ControlQuery) *ControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case ControlOrderFieldControlOwnerName.column, ControlOrderFieldDelegateName.column, ControlOrderFieldResponsiblePartyName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlPager) orderExpr(query *ControlQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case ControlOrderFieldControlOwnerName.column, ControlOrderFieldDelegateName.column, ControlOrderFieldResponsiblePartyName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Control.
func (_m *ControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlPaginateOption,
) (*ControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlConnection{Edges: []*ControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlOrderFieldCreatedAt orders Control by created_at.
	ControlOrderFieldCreatedAt = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: control.FieldCreatedAt,
		toTerm: control.ByCreatedAt,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlOrderFieldUpdatedAt orders Control by updated_at.
	ControlOrderFieldUpdatedAt = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: control.FieldUpdatedAt,
		toTerm: control.ByUpdatedAt,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlOrderFieldTitle orders Control by title.
	ControlOrderFieldTitle = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Title, nil
		},
		column: control.FieldTitle,
		toTerm: control.ByTitle,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ControlOrderFieldStatus orders Control by status.
	ControlOrderFieldStatus = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Status, nil
		},
		column: control.FieldStatus,
		toTerm: control.ByStatus,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlOrderFieldSource orders Control by source.
	ControlOrderFieldSource = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Source, nil
		},
		column: control.FieldSource,
		toTerm: control.BySource,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlOrderFieldReferenceFramework orders Control by reference_framework.
	ControlOrderFieldReferenceFramework = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: control.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return control.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *Control) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// ControlOrderFieldControlType orders Control by control_type.
	ControlOrderFieldControlType = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.ControlType, nil
		},
		column: control.FieldControlType,
		toTerm: control.ByControlType,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlType,
			}
		},
	}
	// ControlOrderFieldCategory orders Control by category.
	ControlOrderFieldCategory = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Category, nil
		},
		column: control.FieldCategory,
		toTerm: control.ByCategory,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlOrderFieldSubcategory orders Control by subcategory.
	ControlOrderFieldSubcategory = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: control.FieldSubcategory,
		toTerm: control.BySubcategory,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// ControlOrderFieldRefCode orders Control by ref_code.
	ControlOrderFieldRefCode = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: control.FieldRefCode,
		toTerm: control.ByRefCode,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
	// ControlOrderFieldControlOwnerName orders by CONTROL_OWNER_name.
	ControlOrderFieldControlOwnerName = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Value("control_owner_name")
		},
		column: "control_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByControlOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("control_owner_name"))...,
			)
		},
		toCursor: func(_m *Control) Cursor {
			cv, _ := _m.Value("control_owner_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// ControlOrderFieldDelegateName orders by DELEGATE_name.
	ControlOrderFieldDelegateName = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Value("delegate_name")
		},
		column: "delegate_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByDelegateField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("delegate_name"))...,
			)
		},
		toCursor: func(_m *Control) Cursor {
			cv, _ := _m.Value("delegate_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// ControlOrderFieldResponsiblePartyName orders by RESPONSIBLE_PARTY_name.
	ControlOrderFieldResponsiblePartyName = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Value("responsible_party_name")
		},
		column: "responsible_party_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByResponsiblePartyField(
				entity.FieldName,
				append(opts, sql.OrderSelectAs("responsible_party_name"))...,
			)
		},
		toCursor: func(_m *Control) Cursor {
			cv, _ := _m.Value("responsible_party_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlOrderField) String() string {
	var str string
	switch f.column {
	case ControlOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlOrderFieldTitle.column:
		str = "title"
	case ControlOrderFieldStatus.column:
		str = "STATUS"
	case ControlOrderFieldSource.column:
		str = "SOURCE"
	case ControlOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case ControlOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case ControlOrderFieldCategory.column:
		str = "category"
	case ControlOrderFieldSubcategory.column:
		str = "subcategory"
	case ControlOrderFieldRefCode.column:
		str = "ref_code"
	case ControlOrderFieldControlOwnerName.column:
		str = "CONTROL_OWNER_name"
	case ControlOrderFieldDelegateName.column:
		str = "DELEGATE_name"
	case ControlOrderFieldResponsiblePartyName.column:
		str = "RESPONSIBLE_PARTY_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlOrderFieldUpdatedAt
	case "title":
		*f = *ControlOrderFieldTitle
	case "STATUS":
		*f = *ControlOrderFieldStatus
	case "SOURCE":
		*f = *ControlOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *ControlOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *ControlOrderFieldControlType
	case "category":
		*f = *ControlOrderFieldCategory
	case "subcategory":
		*f = *ControlOrderFieldSubcategory
	case "ref_code":
		*f = *ControlOrderFieldRefCode
	case "CONTROL_OWNER_name":
		*f = *ControlOrderFieldControlOwnerName
	case "DELEGATE_name":
		*f = *ControlOrderFieldDelegateName
	case "RESPONSIBLE_PARTY_name":
		*f = *ControlOrderFieldResponsiblePartyName
	default:
		return fmt.Errorf("%s is not a valid ControlOrderField", str)
	}
	return nil
}

// ControlOrderField defines the ordering field of Control.
type ControlOrderField struct {
	// Value extracts the ordering value from the given Control.
	Value    func(*Control) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) control.OrderOption
	toCursor func(*Control) Cursor
}

// ControlOrder defines the ordering of Control.
type ControlOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ControlOrderField `json:"field"`
}

// DefaultControlOrder is the default ordering of Control.
var DefaultControlOrder = &ControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.ID, nil
		},
		column: control.FieldID,
		toTerm: control.ByID,
		toCursor: func(_m *Control) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Control into ControlEdge.
func (_m *Control) ToEdge(order *ControlOrder) *ControlEdge {
	if order == nil {
		order = DefaultControlOrder
	}
	return &ControlEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlHistoryEdge is the edge representation of ControlHistory.
type ControlHistoryEdge struct {
	Node   *ControlHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ControlHistoryConnection is the connection containing edges to ControlHistory.
type ControlHistoryConnection struct {
	Edges      []*ControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ControlHistoryConnection) build(nodes []*ControlHistory, pager *controlhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlHistoryPaginateOption enables pagination customization.
type ControlHistoryPaginateOption func(*controlhistoryPager) error

// WithControlHistoryOrder configures pagination ordering.
func WithControlHistoryOrder(order *ControlHistoryOrder) ControlHistoryPaginateOption {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	o := *order
	return func(pager *controlhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlHistoryFilter configures pagination filter.
func WithControlHistoryFilter(filter func(*ControlHistoryQuery) (*ControlHistoryQuery, error)) ControlHistoryPaginateOption {
	return func(pager *controlhistoryPager) error {
		if filter == nil {
			return errors.New("ControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlhistoryPager struct {
	reverse bool
	order   *ControlHistoryOrder
	filter  func(*ControlHistoryQuery) (*ControlHistoryQuery, error)
}

func newControlHistoryPager(opts []ControlHistoryPaginateOption, reverse bool) (*controlhistoryPager, error) {
	pager := &controlhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlHistoryOrder
	}
	return pager, nil
}

func (p *controlhistoryPager) applyFilter(query *ControlHistoryQuery) (*ControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlhistoryPager) toCursor(_m *ControlHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *controlhistoryPager) applyCursors(query *ControlHistoryQuery, after, before *Cursor) (*ControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlhistoryPager) applyOrder(query *ControlHistoryQuery) *ControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlHistoryOrder.Field {
		query = query.Order(DefaultControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlhistoryPager) orderExpr(query *ControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlHistoryOrder.Field {
			b.Comma().Ident(DefaultControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlHistory.
func (_m *ControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlHistoryPaginateOption,
) (*ControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlHistoryConnection{Edges: []*ControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlHistoryOrderFieldHistoryTime orders ControlHistory by history_time.
	ControlHistoryOrderFieldHistoryTime = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: controlhistory.FieldHistoryTime,
		toTerm: controlhistory.ByHistoryTime,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ControlHistoryOrderFieldCreatedAt orders ControlHistory by created_at.
	ControlHistoryOrderFieldCreatedAt = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlhistory.FieldCreatedAt,
		toTerm: controlhistory.ByCreatedAt,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlHistoryOrderFieldUpdatedAt orders ControlHistory by updated_at.
	ControlHistoryOrderFieldUpdatedAt = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlhistory.FieldUpdatedAt,
		toTerm: controlhistory.ByUpdatedAt,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlHistoryOrderFieldTitle orders ControlHistory by title.
	ControlHistoryOrderFieldTitle = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: controlhistory.FieldTitle,
		toTerm: controlhistory.ByTitle,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ControlHistoryOrderFieldStatus orders ControlHistory by status.
	ControlHistoryOrderFieldStatus = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlhistory.FieldStatus,
		toTerm: controlhistory.ByStatus,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlHistoryOrderFieldSource orders ControlHistory by source.
	ControlHistoryOrderFieldSource = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: controlhistory.FieldSource,
		toTerm: controlhistory.BySource,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlHistoryOrderFieldReferenceFramework orders ControlHistory by reference_framework.
	ControlHistoryOrderFieldReferenceFramework = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: controlhistory.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) controlhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return controlhistory.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *ControlHistory) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// ControlHistoryOrderFieldControlType orders ControlHistory by control_type.
	ControlHistoryOrderFieldControlType = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.ControlType, nil
		},
		column: controlhistory.FieldControlType,
		toTerm: controlhistory.ByControlType,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlType,
			}
		},
	}
	// ControlHistoryOrderFieldCategory orders ControlHistory by category.
	ControlHistoryOrderFieldCategory = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: controlhistory.FieldCategory,
		toTerm: controlhistory.ByCategory,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlHistoryOrderFieldSubcategory orders ControlHistory by subcategory.
	ControlHistoryOrderFieldSubcategory = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: controlhistory.FieldSubcategory,
		toTerm: controlhistory.BySubcategory,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// ControlHistoryOrderFieldRefCode orders ControlHistory by ref_code.
	ControlHistoryOrderFieldRefCode = &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: controlhistory.FieldRefCode,
		toTerm: controlhistory.ByRefCode,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlHistoryOrderFieldTitle.column:
		str = "title"
	case ControlHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ControlHistoryOrderFieldSource.column:
		str = "SOURCE"
	case ControlHistoryOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case ControlHistoryOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case ControlHistoryOrderFieldCategory.column:
		str = "category"
	case ControlHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	case ControlHistoryOrderFieldRefCode.column:
		str = "ref_code"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlHistoryOrderFieldUpdatedAt
	case "title":
		*f = *ControlHistoryOrderFieldTitle
	case "STATUS":
		*f = *ControlHistoryOrderFieldStatus
	case "SOURCE":
		*f = *ControlHistoryOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *ControlHistoryOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *ControlHistoryOrderFieldControlType
	case "category":
		*f = *ControlHistoryOrderFieldCategory
	case "subcategory":
		*f = *ControlHistoryOrderFieldSubcategory
	case "ref_code":
		*f = *ControlHistoryOrderFieldRefCode
	default:
		return fmt.Errorf("%s is not a valid ControlHistoryOrderField", str)
	}
	return nil
}

// ControlHistoryOrderField defines the ordering field of ControlHistory.
type ControlHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlHistory.
	Value    func(*ControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlhistory.OrderOption
	toCursor func(*ControlHistory) Cursor
}

// ControlHistoryOrder defines the ordering of ControlHistory.
type ControlHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ControlHistoryOrderField `json:"field"`
}

// DefaultControlHistoryOrder is the default ordering of ControlHistory.
var DefaultControlHistoryOrder = &ControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlHistoryOrderField{
		Value: func(_m *ControlHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlhistory.FieldID,
		toTerm: controlhistory.ByID,
		toCursor: func(_m *ControlHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlHistory into ControlHistoryEdge.
func (_m *ControlHistory) ToEdge(order *ControlHistoryOrder) *ControlHistoryEdge {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	return &ControlHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlImplementationEdge is the edge representation of ControlImplementation.
type ControlImplementationEdge struct {
	Node   *ControlImplementation `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// ControlImplementationConnection is the connection containing edges to ControlImplementation.
type ControlImplementationConnection struct {
	Edges      []*ControlImplementationEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *ControlImplementationConnection) build(nodes []*ControlImplementation, pager *controlimplementationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlImplementation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlImplementation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlImplementation {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlImplementationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlImplementationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlImplementationPaginateOption enables pagination customization.
type ControlImplementationPaginateOption func(*controlimplementationPager) error

// WithControlImplementationOrder configures pagination ordering.
func WithControlImplementationOrder(order []*ControlImplementationOrder) ControlImplementationPaginateOption {
	return func(pager *controlimplementationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlImplementationFilter configures pagination filter.
func WithControlImplementationFilter(filter func(*ControlImplementationQuery) (*ControlImplementationQuery, error)) ControlImplementationPaginateOption {
	return func(pager *controlimplementationPager) error {
		if filter == nil {
			return errors.New("ControlImplementationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlimplementationPager struct {
	reverse bool
	order   []*ControlImplementationOrder
	filter  func(*ControlImplementationQuery) (*ControlImplementationQuery, error)
}

func newControlImplementationPager(opts []ControlImplementationPaginateOption, reverse bool) (*controlimplementationPager, error) {
	pager := &controlimplementationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlimplementationPager) applyFilter(query *ControlImplementationQuery) (*ControlImplementationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlimplementationPager) toCursor(_m *ControlImplementation) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *controlimplementationPager) applyCursors(query *ControlImplementationQuery, after, before *Cursor) (*ControlImplementationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlImplementationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlimplementationPager) applyOrder(query *ControlImplementationQuery) *ControlImplementationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlImplementationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlImplementationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlimplementationPager) orderExpr(query *ControlImplementationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlImplementationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlImplementation.
func (_m *ControlImplementationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlImplementationPaginateOption,
) (*ControlImplementationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlImplementationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlImplementationConnection{Edges: []*ControlImplementationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlImplementationOrderFieldCreatedAt orders ControlImplementation by created_at.
	ControlImplementationOrderFieldCreatedAt = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlimplementation.FieldCreatedAt,
		toTerm: controlimplementation.ByCreatedAt,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlImplementationOrderFieldUpdatedAt orders ControlImplementation by updated_at.
	ControlImplementationOrderFieldUpdatedAt = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlimplementation.FieldUpdatedAt,
		toTerm: controlimplementation.ByUpdatedAt,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlImplementationOrderFieldStatus orders ControlImplementation by status.
	ControlImplementationOrderFieldStatus = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlimplementation.FieldStatus,
		toTerm: controlimplementation.ByStatus,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlImplementationOrderFieldImplementationDate orders ControlImplementation by implementation_date.
	ControlImplementationOrderFieldImplementationDate = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.ImplementationDate, nil
		},
		column: controlimplementation.FieldImplementationDate,
		toTerm: controlimplementation.ByImplementationDate,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ImplementationDate,
			}
		},
	}
	// ControlImplementationOrderFieldVerified orders ControlImplementation by verified.
	ControlImplementationOrderFieldVerified = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.Verified, nil
		},
		column: controlimplementation.FieldVerified,
		toTerm: controlimplementation.ByVerified,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Verified,
			}
		},
	}
	// ControlImplementationOrderFieldVerificationDate orders ControlImplementation by verification_date.
	ControlImplementationOrderFieldVerificationDate = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.VerificationDate, nil
		},
		column: controlimplementation.FieldVerificationDate,
		toTerm: controlimplementation.ByVerificationDate,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.VerificationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlImplementationOrderField) String() string {
	var str string
	switch f.column {
	case ControlImplementationOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlImplementationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlImplementationOrderFieldStatus.column:
		str = "STATUS"
	case ControlImplementationOrderFieldImplementationDate.column:
		str = "implementation_date"
	case ControlImplementationOrderFieldVerified.column:
		str = "verified"
	case ControlImplementationOrderFieldVerificationDate.column:
		str = "verification_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlImplementationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlImplementationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlImplementationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlImplementationOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlImplementationOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlImplementationOrderFieldStatus
	case "implementation_date":
		*f = *ControlImplementationOrderFieldImplementationDate
	case "verified":
		*f = *ControlImplementationOrderFieldVerified
	case "verification_date":
		*f = *ControlImplementationOrderFieldVerificationDate
	default:
		return fmt.Errorf("%s is not a valid ControlImplementationOrderField", str)
	}
	return nil
}

// ControlImplementationOrderField defines the ordering field of ControlImplementation.
type ControlImplementationOrderField struct {
	// Value extracts the ordering value from the given ControlImplementation.
	Value    func(*ControlImplementation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlimplementation.OrderOption
	toCursor func(*ControlImplementation) Cursor
}

// ControlImplementationOrder defines the ordering of ControlImplementation.
type ControlImplementationOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *ControlImplementationOrderField `json:"field"`
}

// DefaultControlImplementationOrder is the default ordering of ControlImplementation.
var DefaultControlImplementationOrder = &ControlImplementationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlimplementation.FieldID,
		toTerm: controlimplementation.ByID,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlImplementation into ControlImplementationEdge.
func (_m *ControlImplementation) ToEdge(order *ControlImplementationOrder) *ControlImplementationEdge {
	if order == nil {
		order = DefaultControlImplementationOrder
	}
	return &ControlImplementationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlImplementationHistoryEdge is the edge representation of ControlImplementationHistory.
type ControlImplementationHistoryEdge struct {
	Node   *ControlImplementationHistory `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// ControlImplementationHistoryConnection is the connection containing edges to ControlImplementationHistory.
type ControlImplementationHistoryConnection struct {
	Edges      []*ControlImplementationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *ControlImplementationHistoryConnection) build(nodes []*ControlImplementationHistory, pager *controlimplementationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlImplementationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlImplementationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlImplementationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlImplementationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlImplementationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlImplementationHistoryPaginateOption enables pagination customization.
type ControlImplementationHistoryPaginateOption func(*controlimplementationhistoryPager) error

// WithControlImplementationHistoryOrder configures pagination ordering.
func WithControlImplementationHistoryOrder(order *ControlImplementationHistoryOrder) ControlImplementationHistoryPaginateOption {
	if order == nil {
		order = DefaultControlImplementationHistoryOrder
	}
	o := *order
	return func(pager *controlimplementationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlImplementationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlImplementationHistoryFilter configures pagination filter.
func WithControlImplementationHistoryFilter(filter func(*ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error)) ControlImplementationHistoryPaginateOption {
	return func(pager *controlimplementationhistoryPager) error {
		if filter == nil {
			return errors.New("ControlImplementationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlimplementationhistoryPager struct {
	reverse bool
	order   *ControlImplementationHistoryOrder
	filter  func(*ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error)
}

func newControlImplementationHistoryPager(opts []ControlImplementationHistoryPaginateOption, reverse bool) (*controlimplementationhistoryPager, error) {
	pager := &controlimplementationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlImplementationHistoryOrder
	}
	return pager, nil
}

func (p *controlimplementationhistoryPager) applyFilter(query *ControlImplementationHistoryQuery) (*ControlImplementationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlimplementationhistoryPager) toCursor(_m *ControlImplementationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *controlimplementationhistoryPager) applyCursors(query *ControlImplementationHistoryQuery, after, before *Cursor) (*ControlImplementationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlImplementationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlimplementationhistoryPager) applyOrder(query *ControlImplementationHistoryQuery) *ControlImplementationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlImplementationHistoryOrder.Field {
		query = query.Order(DefaultControlImplementationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlimplementationhistoryPager) orderExpr(query *ControlImplementationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlImplementationHistoryOrder.Field {
			b.Comma().Ident(DefaultControlImplementationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlImplementationHistory.
func (_m *ControlImplementationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlImplementationHistoryPaginateOption,
) (*ControlImplementationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlImplementationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlImplementationHistoryConnection{Edges: []*ControlImplementationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlImplementationHistoryOrderFieldHistoryTime orders ControlImplementationHistory by history_time.
	ControlImplementationHistoryOrderFieldHistoryTime = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: controlimplementationhistory.FieldHistoryTime,
		toTerm: controlimplementationhistory.ByHistoryTime,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldCreatedAt orders ControlImplementationHistory by created_at.
	ControlImplementationHistoryOrderFieldCreatedAt = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlimplementationhistory.FieldCreatedAt,
		toTerm: controlimplementationhistory.ByCreatedAt,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldUpdatedAt orders ControlImplementationHistory by updated_at.
	ControlImplementationHistoryOrderFieldUpdatedAt = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlimplementationhistory.FieldUpdatedAt,
		toTerm: controlimplementationhistory.ByUpdatedAt,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldStatus orders ControlImplementationHistory by status.
	ControlImplementationHistoryOrderFieldStatus = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlimplementationhistory.FieldStatus,
		toTerm: controlimplementationhistory.ByStatus,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldImplementationDate orders ControlImplementationHistory by implementation_date.
	ControlImplementationHistoryOrderFieldImplementationDate = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.ImplementationDate, nil
		},
		column: controlimplementationhistory.FieldImplementationDate,
		toTerm: controlimplementationhistory.ByImplementationDate,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ImplementationDate,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldVerified orders ControlImplementationHistory by verified.
	ControlImplementationHistoryOrderFieldVerified = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.Verified, nil
		},
		column: controlimplementationhistory.FieldVerified,
		toTerm: controlimplementationhistory.ByVerified,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Verified,
			}
		},
	}
	// ControlImplementationHistoryOrderFieldVerificationDate orders ControlImplementationHistory by verification_date.
	ControlImplementationHistoryOrderFieldVerificationDate = &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.VerificationDate, nil
		},
		column: controlimplementationhistory.FieldVerificationDate,
		toTerm: controlimplementationhistory.ByVerificationDate,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.VerificationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlImplementationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlImplementationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlImplementationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlImplementationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlImplementationHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ControlImplementationHistoryOrderFieldImplementationDate.column:
		str = "implementation_date"
	case ControlImplementationHistoryOrderFieldVerified.column:
		str = "verified"
	case ControlImplementationHistoryOrderFieldVerificationDate.column:
		str = "verification_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlImplementationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlImplementationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlImplementationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlImplementationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlImplementationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlImplementationHistoryOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlImplementationHistoryOrderFieldStatus
	case "implementation_date":
		*f = *ControlImplementationHistoryOrderFieldImplementationDate
	case "verified":
		*f = *ControlImplementationHistoryOrderFieldVerified
	case "verification_date":
		*f = *ControlImplementationHistoryOrderFieldVerificationDate
	default:
		return fmt.Errorf("%s is not a valid ControlImplementationHistoryOrderField", str)
	}
	return nil
}

// ControlImplementationHistoryOrderField defines the ordering field of ControlImplementationHistory.
type ControlImplementationHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlImplementationHistory.
	Value    func(*ControlImplementationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlimplementationhistory.OrderOption
	toCursor func(*ControlImplementationHistory) Cursor
}

// ControlImplementationHistoryOrder defines the ordering of ControlImplementationHistory.
type ControlImplementationHistoryOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *ControlImplementationHistoryOrderField `json:"field"`
}

// DefaultControlImplementationHistoryOrder is the default ordering of ControlImplementationHistory.
var DefaultControlImplementationHistoryOrder = &ControlImplementationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlImplementationHistoryOrderField{
		Value: func(_m *ControlImplementationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlimplementationhistory.FieldID,
		toTerm: controlimplementationhistory.ByID,
		toCursor: func(_m *ControlImplementationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlImplementationHistory into ControlImplementationHistoryEdge.
func (_m *ControlImplementationHistory) ToEdge(order *ControlImplementationHistoryOrder) *ControlImplementationHistoryEdge {
	if order == nil {
		order = DefaultControlImplementationHistoryOrder
	}
	return &ControlImplementationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlObjectiveEdge is the edge representation of ControlObjective.
type ControlObjectiveEdge struct {
	Node   *ControlObjective `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ControlObjectiveConnection is the connection containing edges to ControlObjective.
type ControlObjectiveConnection struct {
	Edges      []*ControlObjectiveEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ControlObjectiveConnection) build(nodes []*ControlObjective, pager *controlobjectivePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlObjective
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjective {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjective {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectivePaginateOption enables pagination customization.
type ControlObjectivePaginateOption func(*controlobjectivePager) error

// WithControlObjectiveOrder configures pagination ordering.
func WithControlObjectiveOrder(order []*ControlObjectiveOrder) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlObjectiveFilter configures pagination filter.
func WithControlObjectiveFilter(filter func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		if filter == nil {
			return errors.New("ControlObjectiveQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivePager struct {
	reverse bool
	order   []*ControlObjectiveOrder
	filter  func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)
}

func newControlObjectivePager(opts []ControlObjectivePaginateOption, reverse bool) (*controlobjectivePager, error) {
	pager := &controlobjectivePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlobjectivePager) applyFilter(query *ControlObjectiveQuery) (*ControlObjectiveQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivePager) toCursor(_m *ControlObjective) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *controlobjectivePager) applyCursors(query *ControlObjectiveQuery, after, before *Cursor) (*ControlObjectiveQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlObjectiveOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlobjectivePager) applyOrder(query *ControlObjectiveQuery) *ControlObjectiveQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlObjectiveOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlObjectiveOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlobjectivePager) orderExpr(query *ControlObjectiveQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlObjectiveOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjective.
func (_m *ControlObjectiveQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectivePaginateOption,
) (*ControlObjectiveConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectivePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveConnection{Edges: []*ControlObjectiveEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlObjectiveOrderFieldCreatedAt orders ControlObjective by created_at.
	ControlObjectiveOrderFieldCreatedAt = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlobjective.FieldCreatedAt,
		toTerm: controlobjective.ByCreatedAt,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlObjectiveOrderFieldUpdatedAt orders ControlObjective by updated_at.
	ControlObjectiveOrderFieldUpdatedAt = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlobjective.FieldUpdatedAt,
		toTerm: controlobjective.ByUpdatedAt,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlObjectiveOrderFieldRevision orders ControlObjective by revision.
	ControlObjectiveOrderFieldRevision = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: controlobjective.FieldRevision,
		toTerm: controlobjective.ByRevision,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ControlObjectiveOrderFieldName orders ControlObjective by name.
	ControlObjectiveOrderFieldName = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Name, nil
		},
		column: controlobjective.FieldName,
		toTerm: controlobjective.ByName,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ControlObjectiveOrderFieldStatus orders ControlObjective by status.
	ControlObjectiveOrderFieldStatus = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlobjective.FieldStatus,
		toTerm: controlobjective.ByStatus,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlObjectiveOrderFieldSource orders ControlObjective by source.
	ControlObjectiveOrderFieldSource = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Source, nil
		},
		column: controlobjective.FieldSource,
		toTerm: controlobjective.BySource,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlObjectiveOrderFieldControlObjectiveType orders ControlObjective by control_objective_type.
	ControlObjectiveOrderFieldControlObjectiveType = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.ControlObjectiveType, nil
		},
		column: controlobjective.FieldControlObjectiveType,
		toTerm: controlobjective.ByControlObjectiveType,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlObjectiveType,
			}
		},
	}
	// ControlObjectiveOrderFieldCategory orders ControlObjective by category.
	ControlObjectiveOrderFieldCategory = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Category, nil
		},
		column: controlobjective.FieldCategory,
		toTerm: controlobjective.ByCategory,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlObjectiveOrderFieldSubcategory orders ControlObjective by subcategory.
	ControlObjectiveOrderFieldSubcategory = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: controlobjective.FieldSubcategory,
		toTerm: controlobjective.BySubcategory,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlObjectiveOrderField) String() string {
	var str string
	switch f.column {
	case ControlObjectiveOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlObjectiveOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlObjectiveOrderFieldRevision.column:
		str = "revision"
	case ControlObjectiveOrderFieldName.column:
		str = "name"
	case ControlObjectiveOrderFieldStatus.column:
		str = "status"
	case ControlObjectiveOrderFieldSource.column:
		str = "SOURCE"
	case ControlObjectiveOrderFieldControlObjectiveType.column:
		str = "control_objective_type"
	case ControlObjectiveOrderFieldCategory.column:
		str = "category"
	case ControlObjectiveOrderFieldSubcategory.column:
		str = "subcategory"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlObjectiveOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlObjectiveOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlObjectiveOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlObjectiveOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlObjectiveOrderFieldUpdatedAt
	case "revision":
		*f = *ControlObjectiveOrderFieldRevision
	case "name":
		*f = *ControlObjectiveOrderFieldName
	case "status":
		*f = *ControlObjectiveOrderFieldStatus
	case "SOURCE":
		*f = *ControlObjectiveOrderFieldSource
	case "control_objective_type":
		*f = *ControlObjectiveOrderFieldControlObjectiveType
	case "category":
		*f = *ControlObjectiveOrderFieldCategory
	case "subcategory":
		*f = *ControlObjectiveOrderFieldSubcategory
	default:
		return fmt.Errorf("%s is not a valid ControlObjectiveOrderField", str)
	}
	return nil
}

// ControlObjectiveOrderField defines the ordering field of ControlObjective.
type ControlObjectiveOrderField struct {
	// Value extracts the ordering value from the given ControlObjective.
	Value    func(*ControlObjective) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjective.OrderOption
	toCursor func(*ControlObjective) Cursor
}

// ControlObjectiveOrder defines the ordering of ControlObjective.
type ControlObjectiveOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ControlObjectiveOrderField `json:"field"`
}

// DefaultControlObjectiveOrder is the default ordering of ControlObjective.
var DefaultControlObjectiveOrder = &ControlObjectiveOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlobjective.FieldID,
		toTerm: controlobjective.ByID,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlObjective into ControlObjectiveEdge.
func (_m *ControlObjective) ToEdge(order *ControlObjectiveOrder) *ControlObjectiveEdge {
	if order == nil {
		order = DefaultControlObjectiveOrder
	}
	return &ControlObjectiveEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlObjectiveHistoryEdge is the edge representation of ControlObjectiveHistory.
type ControlObjectiveHistoryEdge struct {
	Node   *ControlObjectiveHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// ControlObjectiveHistoryConnection is the connection containing edges to ControlObjectiveHistory.
type ControlObjectiveHistoryConnection struct {
	Edges      []*ControlObjectiveHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *ControlObjectiveHistoryConnection) build(nodes []*ControlObjectiveHistory, pager *controlobjectivehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlObjectiveHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectiveHistoryPaginateOption enables pagination customization.
type ControlObjectiveHistoryPaginateOption func(*controlobjectivehistoryPager) error

// WithControlObjectiveHistoryOrder configures pagination ordering.
func WithControlObjectiveHistoryOrder(order *ControlObjectiveHistoryOrder) ControlObjectiveHistoryPaginateOption {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	o := *order
	return func(pager *controlobjectivehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlObjectiveHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlObjectiveHistoryFilter configures pagination filter.
func WithControlObjectiveHistoryFilter(filter func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)) ControlObjectiveHistoryPaginateOption {
	return func(pager *controlobjectivehistoryPager) error {
		if filter == nil {
			return errors.New("ControlObjectiveHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivehistoryPager struct {
	reverse bool
	order   *ControlObjectiveHistoryOrder
	filter  func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)
}

func newControlObjectiveHistoryPager(opts []ControlObjectiveHistoryPaginateOption, reverse bool) (*controlobjectivehistoryPager, error) {
	pager := &controlobjectivehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlObjectiveHistoryOrder
	}
	return pager, nil
}

func (p *controlobjectivehistoryPager) applyFilter(query *ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) toCursor(_m *ControlObjectiveHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *controlobjectivehistoryPager) applyCursors(query *ControlObjectiveHistoryQuery, after, before *Cursor) (*ControlObjectiveHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlObjectiveHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) applyOrder(query *ControlObjectiveHistoryQuery) *ControlObjectiveHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
		query = query.Order(DefaultControlObjectiveHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlobjectivehistoryPager) orderExpr(query *ControlObjectiveHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
			b.Comma().Ident(DefaultControlObjectiveHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjectiveHistory.
func (_m *ControlObjectiveHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectiveHistoryPaginateOption,
) (*ControlObjectiveHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectiveHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveHistoryConnection{Edges: []*ControlObjectiveHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlObjectiveHistoryOrderFieldHistoryTime orders ControlObjectiveHistory by history_time.
	ControlObjectiveHistoryOrderFieldHistoryTime = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: controlobjectivehistory.FieldHistoryTime,
		toTerm: controlobjectivehistory.ByHistoryTime,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldCreatedAt orders ControlObjectiveHistory by created_at.
	ControlObjectiveHistoryOrderFieldCreatedAt = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlobjectivehistory.FieldCreatedAt,
		toTerm: controlobjectivehistory.ByCreatedAt,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldUpdatedAt orders ControlObjectiveHistory by updated_at.
	ControlObjectiveHistoryOrderFieldUpdatedAt = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlobjectivehistory.FieldUpdatedAt,
		toTerm: controlobjectivehistory.ByUpdatedAt,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldRevision orders ControlObjectiveHistory by revision.
	ControlObjectiveHistoryOrderFieldRevision = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: controlobjectivehistory.FieldRevision,
		toTerm: controlobjectivehistory.ByRevision,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldName orders ControlObjectiveHistory by name.
	ControlObjectiveHistoryOrderFieldName = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: controlobjectivehistory.FieldName,
		toTerm: controlobjectivehistory.ByName,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldStatus orders ControlObjectiveHistory by status.
	ControlObjectiveHistoryOrderFieldStatus = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlobjectivehistory.FieldStatus,
		toTerm: controlobjectivehistory.ByStatus,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldSource orders ControlObjectiveHistory by source.
	ControlObjectiveHistoryOrderFieldSource = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: controlobjectivehistory.FieldSource,
		toTerm: controlobjectivehistory.BySource,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldControlObjectiveType orders ControlObjectiveHistory by control_objective_type.
	ControlObjectiveHistoryOrderFieldControlObjectiveType = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.ControlObjectiveType, nil
		},
		column: controlobjectivehistory.FieldControlObjectiveType,
		toTerm: controlobjectivehistory.ByControlObjectiveType,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlObjectiveType,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldCategory orders ControlObjectiveHistory by category.
	ControlObjectiveHistoryOrderFieldCategory = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: controlobjectivehistory.FieldCategory,
		toTerm: controlobjectivehistory.ByCategory,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlObjectiveHistoryOrderFieldSubcategory orders ControlObjectiveHistory by subcategory.
	ControlObjectiveHistoryOrderFieldSubcategory = &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: controlobjectivehistory.FieldSubcategory,
		toTerm: controlobjectivehistory.BySubcategory,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlObjectiveHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ControlObjectiveHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ControlObjectiveHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlObjectiveHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlObjectiveHistoryOrderFieldRevision.column:
		str = "revision"
	case ControlObjectiveHistoryOrderFieldName.column:
		str = "name"
	case ControlObjectiveHistoryOrderFieldStatus.column:
		str = "status"
	case ControlObjectiveHistoryOrderFieldSource.column:
		str = "SOURCE"
	case ControlObjectiveHistoryOrderFieldControlObjectiveType.column:
		str = "control_objective_type"
	case ControlObjectiveHistoryOrderFieldCategory.column:
		str = "category"
	case ControlObjectiveHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlObjectiveHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlObjectiveHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlObjectiveHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ControlObjectiveHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ControlObjectiveHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlObjectiveHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ControlObjectiveHistoryOrderFieldRevision
	case "name":
		*f = *ControlObjectiveHistoryOrderFieldName
	case "status":
		*f = *ControlObjectiveHistoryOrderFieldStatus
	case "SOURCE":
		*f = *ControlObjectiveHistoryOrderFieldSource
	case "control_objective_type":
		*f = *ControlObjectiveHistoryOrderFieldControlObjectiveType
	case "category":
		*f = *ControlObjectiveHistoryOrderFieldCategory
	case "subcategory":
		*f = *ControlObjectiveHistoryOrderFieldSubcategory
	default:
		return fmt.Errorf("%s is not a valid ControlObjectiveHistoryOrderField", str)
	}
	return nil
}

// ControlObjectiveHistoryOrderField defines the ordering field of ControlObjectiveHistory.
type ControlObjectiveHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlObjectiveHistory.
	Value    func(*ControlObjectiveHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjectivehistory.OrderOption
	toCursor func(*ControlObjectiveHistory) Cursor
}

// ControlObjectiveHistoryOrder defines the ordering of ControlObjectiveHistory.
type ControlObjectiveHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *ControlObjectiveHistoryOrderField `json:"field"`
}

// DefaultControlObjectiveHistoryOrder is the default ordering of ControlObjectiveHistory.
var DefaultControlObjectiveHistoryOrder = &ControlObjectiveHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveHistoryOrderField{
		Value: func(_m *ControlObjectiveHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlobjectivehistory.FieldID,
		toTerm: controlobjectivehistory.ByID,
		toCursor: func(_m *ControlObjectiveHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlObjectiveHistory into ControlObjectiveHistoryEdge.
func (_m *ControlObjectiveHistory) ToEdge(order *ControlObjectiveHistoryOrder) *ControlObjectiveHistoryEdge {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	return &ControlObjectiveHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CustomDomainEdge is the edge representation of CustomDomain.
type CustomDomainEdge struct {
	Node   *CustomDomain `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CustomDomainConnection is the connection containing edges to CustomDomain.
type CustomDomainConnection struct {
	Edges      []*CustomDomainEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CustomDomainConnection) build(nodes []*CustomDomain, pager *customdomainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomDomain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomDomain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomDomain {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomDomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomDomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomDomainPaginateOption enables pagination customization.
type CustomDomainPaginateOption func(*customdomainPager) error

// WithCustomDomainOrder configures pagination ordering.
func WithCustomDomainOrder(order []*CustomDomainOrder) CustomDomainPaginateOption {
	return func(pager *customdomainPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomDomainFilter configures pagination filter.
func WithCustomDomainFilter(filter func(*CustomDomainQuery) (*CustomDomainQuery, error)) CustomDomainPaginateOption {
	return func(pager *customdomainPager) error {
		if filter == nil {
			return errors.New("CustomDomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customdomainPager struct {
	reverse bool
	order   []*CustomDomainOrder
	filter  func(*CustomDomainQuery) (*CustomDomainQuery, error)
}

func newCustomDomainPager(opts []CustomDomainPaginateOption, reverse bool) (*customdomainPager, error) {
	pager := &customdomainPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customdomainPager) applyFilter(query *CustomDomainQuery) (*CustomDomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customdomainPager) toCursor(_m *CustomDomain) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *customdomainPager) applyCursors(query *CustomDomainQuery, after, before *Cursor) (*CustomDomainQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomDomainOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *customdomainPager) applyOrder(query *CustomDomainQuery) *CustomDomainQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomDomainOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomDomainOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customdomainPager) orderExpr(query *CustomDomainQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomDomainOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomDomain.
func (_m *CustomDomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomDomainPaginateOption,
) (*CustomDomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomDomainPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CustomDomainConnection{Edges: []*CustomDomainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomDomainOrderFieldCreatedAt orders CustomDomain by created_at.
	CustomDomainOrderFieldCreatedAt = &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: customdomain.FieldCreatedAt,
		toTerm: customdomain.ByCreatedAt,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CustomDomainOrderFieldUpdatedAt orders CustomDomain by updated_at.
	CustomDomainOrderFieldUpdatedAt = &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: customdomain.FieldUpdatedAt,
		toTerm: customdomain.ByUpdatedAt,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CustomDomainOrderFieldCnameRecord orders CustomDomain by cname_record.
	CustomDomainOrderFieldCnameRecord = &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.CnameRecord, nil
		},
		column: customdomain.FieldCnameRecord,
		toTerm: customdomain.ByCnameRecord,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CnameRecord,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomDomainOrderField) String() string {
	var str string
	switch f.column {
	case CustomDomainOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomDomainOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomDomainOrderFieldCnameRecord.column:
		str = "cname_record"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomDomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomDomainOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CustomDomainOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomDomainOrderFieldUpdatedAt
	case "cname_record":
		*f = *CustomDomainOrderFieldCnameRecord
	default:
		return fmt.Errorf("%s is not a valid CustomDomainOrderField", str)
	}
	return nil
}

// CustomDomainOrderField defines the ordering field of CustomDomain.
type CustomDomainOrderField struct {
	// Value extracts the ordering value from the given CustomDomain.
	Value    func(*CustomDomain) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customdomain.OrderOption
	toCursor func(*CustomDomain) Cursor
}

// CustomDomainOrder defines the ordering of CustomDomain.
type CustomDomainOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CustomDomainOrderField `json:"field"`
}

// DefaultCustomDomainOrder is the default ordering of CustomDomain.
var DefaultCustomDomainOrder = &CustomDomainOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.ID, nil
		},
		column: customdomain.FieldID,
		toTerm: customdomain.ByID,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CustomDomain into CustomDomainEdge.
func (_m *CustomDomain) ToEdge(order *CustomDomainOrder) *CustomDomainEdge {
	if order == nil {
		order = DefaultCustomDomainOrder
	}
	return &CustomDomainEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CustomDomainHistoryEdge is the edge representation of CustomDomainHistory.
type CustomDomainHistoryEdge struct {
	Node   *CustomDomainHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// CustomDomainHistoryConnection is the connection containing edges to CustomDomainHistory.
type CustomDomainHistoryConnection struct {
	Edges      []*CustomDomainHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *CustomDomainHistoryConnection) build(nodes []*CustomDomainHistory, pager *customdomainhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomDomainHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomDomainHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomDomainHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomDomainHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomDomainHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomDomainHistoryPaginateOption enables pagination customization.
type CustomDomainHistoryPaginateOption func(*customdomainhistoryPager) error

// WithCustomDomainHistoryOrder configures pagination ordering.
func WithCustomDomainHistoryOrder(order *CustomDomainHistoryOrder) CustomDomainHistoryPaginateOption {
	if order == nil {
		order = DefaultCustomDomainHistoryOrder
	}
	o := *order
	return func(pager *customdomainhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomDomainHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomDomainHistoryFilter configures pagination filter.
func WithCustomDomainHistoryFilter(filter func(*CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error)) CustomDomainHistoryPaginateOption {
	return func(pager *customdomainhistoryPager) error {
		if filter == nil {
			return errors.New("CustomDomainHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customdomainhistoryPager struct {
	reverse bool
	order   *CustomDomainHistoryOrder
	filter  func(*CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error)
}

func newCustomDomainHistoryPager(opts []CustomDomainHistoryPaginateOption, reverse bool) (*customdomainhistoryPager, error) {
	pager := &customdomainhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomDomainHistoryOrder
	}
	return pager, nil
}

func (p *customdomainhistoryPager) applyFilter(query *CustomDomainHistoryQuery) (*CustomDomainHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customdomainhistoryPager) toCursor(_m *CustomDomainHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *customdomainhistoryPager) applyCursors(query *CustomDomainHistoryQuery, after, before *Cursor) (*CustomDomainHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCustomDomainHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *customdomainhistoryPager) applyOrder(query *CustomDomainHistoryQuery) *CustomDomainHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCustomDomainHistoryOrder.Field {
		query = query.Order(DefaultCustomDomainHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *customdomainhistoryPager) orderExpr(query *CustomDomainHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCustomDomainHistoryOrder.Field {
			b.Comma().Ident(DefaultCustomDomainHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomDomainHistory.
func (_m *CustomDomainHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomDomainHistoryPaginateOption,
) (*CustomDomainHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomDomainHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CustomDomainHistoryConnection{Edges: []*CustomDomainHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomDomainHistoryOrderFieldHistoryTime orders CustomDomainHistory by history_time.
	CustomDomainHistoryOrderFieldHistoryTime = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: customdomainhistory.FieldHistoryTime,
		toTerm: customdomainhistory.ByHistoryTime,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// CustomDomainHistoryOrderFieldCreatedAt orders CustomDomainHistory by created_at.
	CustomDomainHistoryOrderFieldCreatedAt = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: customdomainhistory.FieldCreatedAt,
		toTerm: customdomainhistory.ByCreatedAt,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CustomDomainHistoryOrderFieldUpdatedAt orders CustomDomainHistory by updated_at.
	CustomDomainHistoryOrderFieldUpdatedAt = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: customdomainhistory.FieldUpdatedAt,
		toTerm: customdomainhistory.ByUpdatedAt,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CustomDomainHistoryOrderFieldCnameRecord orders CustomDomainHistory by cname_record.
	CustomDomainHistoryOrderFieldCnameRecord = &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.CnameRecord, nil
		},
		column: customdomainhistory.FieldCnameRecord,
		toTerm: customdomainhistory.ByCnameRecord,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CnameRecord,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomDomainHistoryOrderField) String() string {
	var str string
	switch f.column {
	case CustomDomainHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case CustomDomainHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomDomainHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomDomainHistoryOrderFieldCnameRecord.column:
		str = "cname_record"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomDomainHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomDomainHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *CustomDomainHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *CustomDomainHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomDomainHistoryOrderFieldUpdatedAt
	case "cname_record":
		*f = *CustomDomainHistoryOrderFieldCnameRecord
	default:
		return fmt.Errorf("%s is not a valid CustomDomainHistoryOrderField", str)
	}
	return nil
}

// CustomDomainHistoryOrderField defines the ordering field of CustomDomainHistory.
type CustomDomainHistoryOrderField struct {
	// Value extracts the ordering value from the given CustomDomainHistory.
	Value    func(*CustomDomainHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customdomainhistory.OrderOption
	toCursor func(*CustomDomainHistory) Cursor
}

// CustomDomainHistoryOrder defines the ordering of CustomDomainHistory.
type CustomDomainHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *CustomDomainHistoryOrderField `json:"field"`
}

// DefaultCustomDomainHistoryOrder is the default ordering of CustomDomainHistory.
var DefaultCustomDomainHistoryOrder = &CustomDomainHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomDomainHistoryOrderField{
		Value: func(_m *CustomDomainHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: customdomainhistory.FieldID,
		toTerm: customdomainhistory.ByID,
		toCursor: func(_m *CustomDomainHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CustomDomainHistory into CustomDomainHistoryEdge.
func (_m *CustomDomainHistory) ToEdge(order *CustomDomainHistoryOrder) *CustomDomainHistoryEdge {
	if order == nil {
		order = DefaultCustomDomainHistoryOrder
	}
	return &CustomDomainHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CustomTypeEnumEdge is the edge representation of CustomTypeEnum.
type CustomTypeEnumEdge struct {
	Node   *CustomTypeEnum `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CustomTypeEnumConnection is the connection containing edges to CustomTypeEnum.
type CustomTypeEnumConnection struct {
	Edges      []*CustomTypeEnumEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CustomTypeEnumConnection) build(nodes []*CustomTypeEnum, pager *customtypeenumPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomTypeEnum
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomTypeEnum {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomTypeEnum {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomTypeEnumEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomTypeEnumEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomTypeEnumPaginateOption enables pagination customization.
type CustomTypeEnumPaginateOption func(*customtypeenumPager) error

// WithCustomTypeEnumOrder configures pagination ordering.
func WithCustomTypeEnumOrder(order []*CustomTypeEnumOrder) CustomTypeEnumPaginateOption {
	return func(pager *customtypeenumPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomTypeEnumFilter configures pagination filter.
func WithCustomTypeEnumFilter(filter func(*CustomTypeEnumQuery) (*CustomTypeEnumQuery, error)) CustomTypeEnumPaginateOption {
	return func(pager *customtypeenumPager) error {
		if filter == nil {
			return errors.New("CustomTypeEnumQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customtypeenumPager struct {
	reverse bool
	order   []*CustomTypeEnumOrder
	filter  func(*CustomTypeEnumQuery) (*CustomTypeEnumQuery, error)
}

func newCustomTypeEnumPager(opts []CustomTypeEnumPaginateOption, reverse bool) (*customtypeenumPager, error) {
	pager := &customtypeenumPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customtypeenumPager) applyFilter(query *CustomTypeEnumQuery) (*CustomTypeEnumQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customtypeenumPager) toCursor(_m *CustomTypeEnum) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *customtypeenumPager) applyCursors(query *CustomTypeEnumQuery, after, before *Cursor) (*CustomTypeEnumQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomTypeEnumOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *customtypeenumPager) applyOrder(query *CustomTypeEnumQuery) *CustomTypeEnumQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomTypeEnumOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomTypeEnumOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customtypeenumPager) orderExpr(query *CustomTypeEnumQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomTypeEnumOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomTypeEnum.
func (_m *CustomTypeEnumQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomTypeEnumPaginateOption,
) (*CustomTypeEnumConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomTypeEnumPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CustomTypeEnumConnection{Edges: []*CustomTypeEnumEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomTypeEnumOrderFieldCreatedAt orders CustomTypeEnum by created_at.
	CustomTypeEnumOrderFieldCreatedAt = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: customtypeenum.FieldCreatedAt,
		toTerm: customtypeenum.ByCreatedAt,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CustomTypeEnumOrderFieldUpdatedAt orders CustomTypeEnum by updated_at.
	CustomTypeEnumOrderFieldUpdatedAt = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: customtypeenum.FieldUpdatedAt,
		toTerm: customtypeenum.ByUpdatedAt,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomTypeEnumOrderField) String() string {
	var str string
	switch f.column {
	case CustomTypeEnumOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomTypeEnumOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomTypeEnumOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomTypeEnumOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomTypeEnumOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CustomTypeEnumOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomTypeEnumOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid CustomTypeEnumOrderField", str)
	}
	return nil
}

// CustomTypeEnumOrderField defines the ordering field of CustomTypeEnum.
type CustomTypeEnumOrderField struct {
	// Value extracts the ordering value from the given CustomTypeEnum.
	Value    func(*CustomTypeEnum) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customtypeenum.OrderOption
	toCursor func(*CustomTypeEnum) Cursor
}

// CustomTypeEnumOrder defines the ordering of CustomTypeEnum.
type CustomTypeEnumOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CustomTypeEnumOrderField `json:"field"`
}

// DefaultCustomTypeEnumOrder is the default ordering of CustomTypeEnum.
var DefaultCustomTypeEnumOrder = &CustomTypeEnumOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.ID, nil
		},
		column: customtypeenum.FieldID,
		toTerm: customtypeenum.ByID,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CustomTypeEnum into CustomTypeEnumEdge.
func (_m *CustomTypeEnum) ToEdge(order *CustomTypeEnumOrder) *CustomTypeEnumEdge {
	if order == nil {
		order = DefaultCustomTypeEnumOrder
	}
	return &CustomTypeEnumEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DNSVerificationEdge is the edge representation of DNSVerification.
type DNSVerificationEdge struct {
	Node   *DNSVerification `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// DNSVerificationConnection is the connection containing edges to DNSVerification.
type DNSVerificationConnection struct {
	Edges      []*DNSVerificationEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *DNSVerificationConnection) build(nodes []*DNSVerification, pager *dnsverificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DNSVerification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSVerification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSVerification {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSVerificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSVerificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSVerificationPaginateOption enables pagination customization.
type DNSVerificationPaginateOption func(*dnsverificationPager) error

// WithDNSVerificationOrder configures pagination ordering.
func WithDNSVerificationOrder(order []*DNSVerificationOrder) DNSVerificationPaginateOption {
	return func(pager *dnsverificationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDNSVerificationFilter configures pagination filter.
func WithDNSVerificationFilter(filter func(*DNSVerificationQuery) (*DNSVerificationQuery, error)) DNSVerificationPaginateOption {
	return func(pager *dnsverificationPager) error {
		if filter == nil {
			return errors.New("DNSVerificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsverificationPager struct {
	reverse bool
	order   []*DNSVerificationOrder
	filter  func(*DNSVerificationQuery) (*DNSVerificationQuery, error)
}

func newDNSVerificationPager(opts []DNSVerificationPaginateOption, reverse bool) (*dnsverificationPager, error) {
	pager := &dnsverificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *dnsverificationPager) applyFilter(query *DNSVerificationQuery) (*DNSVerificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsverificationPager) toCursor(_m *DNSVerification) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *dnsverificationPager) applyCursors(query *DNSVerificationQuery, after, before *Cursor) (*DNSVerificationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDNSVerificationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *dnsverificationPager) applyOrder(query *DNSVerificationQuery) *DNSVerificationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDNSVerificationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDNSVerificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *dnsverificationPager) orderExpr(query *DNSVerificationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDNSVerificationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSVerification.
func (_m *DNSVerificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSVerificationPaginateOption,
) (*DNSVerificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSVerificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DNSVerificationConnection{Edges: []*DNSVerificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DNSVerificationOrderFieldCreatedAt orders DNSVerification by created_at.
	DNSVerificationOrderFieldCreatedAt = &DNSVerificationOrderField{
		Value: func(_m *DNSVerification) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: dnsverification.FieldCreatedAt,
		toTerm: dnsverification.ByCreatedAt,
		toCursor: func(_m *DNSVerification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DNSVerificationOrderFieldUpdatedAt orders DNSVerification by updated_at.
	DNSVerificationOrderFieldUpdatedAt = &DNSVerificationOrderField{
		Value: func(_m *DNSVerification) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: dnsverification.FieldUpdatedAt,
		toTerm: dnsverification.ByUpdatedAt,
		toCursor: func(_m *DNSVerification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DNSVerificationOrderField) String() string {
	var str string
	switch f.column {
	case DNSVerificationOrderFieldCreatedAt.column:
		str = "created_at"
	case DNSVerificationOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DNSVerificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DNSVerificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DNSVerificationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DNSVerificationOrderFieldCreatedAt
	case "updated_at":
		*f = *DNSVerificationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DNSVerificationOrderField", str)
	}
	return nil
}

// DNSVerificationOrderField defines the ordering field of DNSVerification.
type DNSVerificationOrderField struct {
	// Value extracts the ordering value from the given DNSVerification.
	Value    func(*DNSVerification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsverification.OrderOption
	toCursor func(*DNSVerification) Cursor
}

// DNSVerificationOrder defines the ordering of DNSVerification.
type DNSVerificationOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *DNSVerificationOrderField `json:"field"`
}

// DefaultDNSVerificationOrder is the default ordering of DNSVerification.
var DefaultDNSVerificationOrder = &DNSVerificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSVerificationOrderField{
		Value: func(_m *DNSVerification) (ent.Value, error) {
			return _m.ID, nil
		},
		column: dnsverification.FieldID,
		toTerm: dnsverification.ByID,
		toCursor: func(_m *DNSVerification) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DNSVerification into DNSVerificationEdge.
func (_m *DNSVerification) ToEdge(order *DNSVerificationOrder) *DNSVerificationEdge {
	if order == nil {
		order = DefaultDNSVerificationOrder
	}
	return &DNSVerificationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DNSVerificationHistoryEdge is the edge representation of DNSVerificationHistory.
type DNSVerificationHistoryEdge struct {
	Node   *DNSVerificationHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// DNSVerificationHistoryConnection is the connection containing edges to DNSVerificationHistory.
type DNSVerificationHistoryConnection struct {
	Edges      []*DNSVerificationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *DNSVerificationHistoryConnection) build(nodes []*DNSVerificationHistory, pager *dnsverificationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DNSVerificationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSVerificationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSVerificationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSVerificationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSVerificationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSVerificationHistoryPaginateOption enables pagination customization.
type DNSVerificationHistoryPaginateOption func(*dnsverificationhistoryPager) error

// WithDNSVerificationHistoryOrder configures pagination ordering.
func WithDNSVerificationHistoryOrder(order *DNSVerificationHistoryOrder) DNSVerificationHistoryPaginateOption {
	if order == nil {
		order = DefaultDNSVerificationHistoryOrder
	}
	o := *order
	return func(pager *dnsverificationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSVerificationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSVerificationHistoryFilter configures pagination filter.
func WithDNSVerificationHistoryFilter(filter func(*DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error)) DNSVerificationHistoryPaginateOption {
	return func(pager *dnsverificationhistoryPager) error {
		if filter == nil {
			return errors.New("DNSVerificationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsverificationhistoryPager struct {
	reverse bool
	order   *DNSVerificationHistoryOrder
	filter  func(*DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error)
}

func newDNSVerificationHistoryPager(opts []DNSVerificationHistoryPaginateOption, reverse bool) (*dnsverificationhistoryPager, error) {
	pager := &dnsverificationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSVerificationHistoryOrder
	}
	return pager, nil
}

func (p *dnsverificationhistoryPager) applyFilter(query *DNSVerificationHistoryQuery) (*DNSVerificationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsverificationhistoryPager) toCursor(_m *DNSVerificationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *dnsverificationhistoryPager) applyCursors(query *DNSVerificationHistoryQuery, after, before *Cursor) (*DNSVerificationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDNSVerificationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dnsverificationhistoryPager) applyOrder(query *DNSVerificationHistoryQuery) *DNSVerificationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDNSVerificationHistoryOrder.Field {
		query = query.Order(DefaultDNSVerificationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dnsverificationhistoryPager) orderExpr(query *DNSVerificationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDNSVerificationHistoryOrder.Field {
			b.Comma().Ident(DefaultDNSVerificationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSVerificationHistory.
func (_m *DNSVerificationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSVerificationHistoryPaginateOption,
) (*DNSVerificationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSVerificationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DNSVerificationHistoryConnection{Edges: []*DNSVerificationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DNSVerificationHistoryOrderFieldHistoryTime orders DNSVerificationHistory by history_time.
	DNSVerificationHistoryOrderFieldHistoryTime = &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: dnsverificationhistory.FieldHistoryTime,
		toTerm: dnsverificationhistory.ByHistoryTime,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DNSVerificationHistoryOrderFieldCreatedAt orders DNSVerificationHistory by created_at.
	DNSVerificationHistoryOrderFieldCreatedAt = &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: dnsverificationhistory.FieldCreatedAt,
		toTerm: dnsverificationhistory.ByCreatedAt,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DNSVerificationHistoryOrderFieldUpdatedAt orders DNSVerificationHistory by updated_at.
	DNSVerificationHistoryOrderFieldUpdatedAt = &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: dnsverificationhistory.FieldUpdatedAt,
		toTerm: dnsverificationhistory.ByUpdatedAt,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DNSVerificationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DNSVerificationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DNSVerificationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DNSVerificationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DNSVerificationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DNSVerificationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DNSVerificationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DNSVerificationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DNSVerificationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DNSVerificationHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DNSVerificationHistoryOrderField", str)
	}
	return nil
}

// DNSVerificationHistoryOrderField defines the ordering field of DNSVerificationHistory.
type DNSVerificationHistoryOrderField struct {
	// Value extracts the ordering value from the given DNSVerificationHistory.
	Value    func(*DNSVerificationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsverificationhistory.OrderOption
	toCursor func(*DNSVerificationHistory) Cursor
}

// DNSVerificationHistoryOrder defines the ordering of DNSVerificationHistory.
type DNSVerificationHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *DNSVerificationHistoryOrderField `json:"field"`
}

// DefaultDNSVerificationHistoryOrder is the default ordering of DNSVerificationHistory.
var DefaultDNSVerificationHistoryOrder = &DNSVerificationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSVerificationHistoryOrderField{
		Value: func(_m *DNSVerificationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: dnsverificationhistory.FieldID,
		toTerm: dnsverificationhistory.ByID,
		toCursor: func(_m *DNSVerificationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DNSVerificationHistory into DNSVerificationHistoryEdge.
func (_m *DNSVerificationHistory) ToEdge(order *DNSVerificationHistoryOrder) *DNSVerificationHistoryEdge {
	if order == nil {
		order = DefaultDNSVerificationHistoryOrder
	}
	return &DNSVerificationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryAccountEdge is the edge representation of DirectoryAccount.
type DirectoryAccountEdge struct {
	Node   *DirectoryAccount `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DirectoryAccountConnection is the connection containing edges to DirectoryAccount.
type DirectoryAccountConnection struct {
	Edges      []*DirectoryAccountEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *DirectoryAccountConnection) build(nodes []*DirectoryAccount, pager *directoryaccountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryAccount
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryAccount {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryAccount {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryAccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryAccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryAccountPaginateOption enables pagination customization.
type DirectoryAccountPaginateOption func(*directoryaccountPager) error

// WithDirectoryAccountOrder configures pagination ordering.
func WithDirectoryAccountOrder(order []*DirectoryAccountOrder) DirectoryAccountPaginateOption {
	return func(pager *directoryaccountPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectoryAccountFilter configures pagination filter.
func WithDirectoryAccountFilter(filter func(*DirectoryAccountQuery) (*DirectoryAccountQuery, error)) DirectoryAccountPaginateOption {
	return func(pager *directoryaccountPager) error {
		if filter == nil {
			return errors.New("DirectoryAccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directoryaccountPager struct {
	reverse bool
	order   []*DirectoryAccountOrder
	filter  func(*DirectoryAccountQuery) (*DirectoryAccountQuery, error)
}

func newDirectoryAccountPager(opts []DirectoryAccountPaginateOption, reverse bool) (*directoryaccountPager, error) {
	pager := &directoryaccountPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directoryaccountPager) applyFilter(query *DirectoryAccountQuery) (*DirectoryAccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directoryaccountPager) toCursor(_m *DirectoryAccount) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directoryaccountPager) applyCursors(query *DirectoryAccountQuery, after, before *Cursor) (*DirectoryAccountQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectoryAccountOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directoryaccountPager) applyOrder(query *DirectoryAccountQuery) *DirectoryAccountQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectoryAccountOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectoryAccountOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directoryaccountPager) orderExpr(query *DirectoryAccountQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectoryAccountOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryAccount.
func (_m *DirectoryAccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryAccountPaginateOption,
) (*DirectoryAccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryAccountPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryAccountConnection{Edges: []*DirectoryAccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryAccountOrderFieldCreatedAt orders DirectoryAccount by created_at.
	DirectoryAccountOrderFieldCreatedAt = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directoryaccount.FieldCreatedAt,
		toTerm: directoryaccount.ByCreatedAt,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryAccountOrderFieldUpdatedAt orders DirectoryAccount by updated_at.
	DirectoryAccountOrderFieldUpdatedAt = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directoryaccount.FieldUpdatedAt,
		toTerm: directoryaccount.ByUpdatedAt,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryAccountOrderFieldExternalID orders DirectoryAccount by external_id.
	DirectoryAccountOrderFieldExternalID = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directoryaccount.FieldExternalID,
		toTerm: directoryaccount.ByExternalID,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryAccountOrderFieldCanonicalEmail orders DirectoryAccount by canonical_email.
	DirectoryAccountOrderFieldCanonicalEmail = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			// allow for nil values for fields
			if _m.CanonicalEmail == nil {
				return nil, nil
			}
			return _m.CanonicalEmail, nil
		},
		column: directoryaccount.FieldCanonicalEmail,
		toTerm: func(opts ...sql.OrderTermOption) directoryaccount.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directoryaccount.ByCanonicalEmail(opts...)
		},
		toCursor: func(_m *DirectoryAccount) Cursor {
			if _m.CanonicalEmail == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.CanonicalEmail,
			}
		},
	}
	// DirectoryAccountOrderFieldDisplayName orders DirectoryAccount by display_name.
	DirectoryAccountOrderFieldDisplayName = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directoryaccount.FieldDisplayName,
		toTerm: directoryaccount.ByDisplayName,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryAccountOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryAccountOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryAccountOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryAccountOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryAccountOrderFieldCanonicalEmail.column:
		str = "canonical_email"
	case DirectoryAccountOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryAccountOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryAccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryAccountOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectoryAccountOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryAccountOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryAccountOrderFieldExternalID
	case "canonical_email":
		*f = *DirectoryAccountOrderFieldCanonicalEmail
	case "display_name":
		*f = *DirectoryAccountOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryAccountOrderField", str)
	}
	return nil
}

// DirectoryAccountOrderField defines the ordering field of DirectoryAccount.
type DirectoryAccountOrderField struct {
	// Value extracts the ordering value from the given DirectoryAccount.
	Value    func(*DirectoryAccount) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directoryaccount.OrderOption
	toCursor func(*DirectoryAccount) Cursor
}

// DirectoryAccountOrder defines the ordering of DirectoryAccount.
type DirectoryAccountOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DirectoryAccountOrderField `json:"field"`
}

// DefaultDirectoryAccountOrder is the default ordering of DirectoryAccount.
var DefaultDirectoryAccountOrder = &DirectoryAccountOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directoryaccount.FieldID,
		toTerm: directoryaccount.ByID,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryAccount into DirectoryAccountEdge.
func (_m *DirectoryAccount) ToEdge(order *DirectoryAccountOrder) *DirectoryAccountEdge {
	if order == nil {
		order = DefaultDirectoryAccountOrder
	}
	return &DirectoryAccountEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryAccountHistoryEdge is the edge representation of DirectoryAccountHistory.
type DirectoryAccountHistoryEdge struct {
	Node   *DirectoryAccountHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// DirectoryAccountHistoryConnection is the connection containing edges to DirectoryAccountHistory.
type DirectoryAccountHistoryConnection struct {
	Edges      []*DirectoryAccountHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *DirectoryAccountHistoryConnection) build(nodes []*DirectoryAccountHistory, pager *directoryaccounthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryAccountHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryAccountHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryAccountHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryAccountHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryAccountHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryAccountHistoryPaginateOption enables pagination customization.
type DirectoryAccountHistoryPaginateOption func(*directoryaccounthistoryPager) error

// WithDirectoryAccountHistoryOrder configures pagination ordering.
func WithDirectoryAccountHistoryOrder(order *DirectoryAccountHistoryOrder) DirectoryAccountHistoryPaginateOption {
	if order == nil {
		order = DefaultDirectoryAccountHistoryOrder
	}
	o := *order
	return func(pager *directoryaccounthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDirectoryAccountHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDirectoryAccountHistoryFilter configures pagination filter.
func WithDirectoryAccountHistoryFilter(filter func(*DirectoryAccountHistoryQuery) (*DirectoryAccountHistoryQuery, error)) DirectoryAccountHistoryPaginateOption {
	return func(pager *directoryaccounthistoryPager) error {
		if filter == nil {
			return errors.New("DirectoryAccountHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directoryaccounthistoryPager struct {
	reverse bool
	order   *DirectoryAccountHistoryOrder
	filter  func(*DirectoryAccountHistoryQuery) (*DirectoryAccountHistoryQuery, error)
}

func newDirectoryAccountHistoryPager(opts []DirectoryAccountHistoryPaginateOption, reverse bool) (*directoryaccounthistoryPager, error) {
	pager := &directoryaccounthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDirectoryAccountHistoryOrder
	}
	return pager, nil
}

func (p *directoryaccounthistoryPager) applyFilter(query *DirectoryAccountHistoryQuery) (*DirectoryAccountHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directoryaccounthistoryPager) toCursor(_m *DirectoryAccountHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *directoryaccounthistoryPager) applyCursors(query *DirectoryAccountHistoryQuery, after, before *Cursor) (*DirectoryAccountHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDirectoryAccountHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *directoryaccounthistoryPager) applyOrder(query *DirectoryAccountHistoryQuery) *DirectoryAccountHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDirectoryAccountHistoryOrder.Field {
		query = query.Order(DefaultDirectoryAccountHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *directoryaccounthistoryPager) orderExpr(query *DirectoryAccountHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDirectoryAccountHistoryOrder.Field {
			b.Comma().Ident(DefaultDirectoryAccountHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryAccountHistory.
func (_m *DirectoryAccountHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryAccountHistoryPaginateOption,
) (*DirectoryAccountHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryAccountHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryAccountHistoryConnection{Edges: []*DirectoryAccountHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryAccountHistoryOrderFieldHistoryTime orders DirectoryAccountHistory by history_time.
	DirectoryAccountHistoryOrderFieldHistoryTime = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: directoryaccounthistory.FieldHistoryTime,
		toTerm: directoryaccounthistory.ByHistoryTime,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldCreatedAt orders DirectoryAccountHistory by created_at.
	DirectoryAccountHistoryOrderFieldCreatedAt = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directoryaccounthistory.FieldCreatedAt,
		toTerm: directoryaccounthistory.ByCreatedAt,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldUpdatedAt orders DirectoryAccountHistory by updated_at.
	DirectoryAccountHistoryOrderFieldUpdatedAt = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directoryaccounthistory.FieldUpdatedAt,
		toTerm: directoryaccounthistory.ByUpdatedAt,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldExternalID orders DirectoryAccountHistory by external_id.
	DirectoryAccountHistoryOrderFieldExternalID = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directoryaccounthistory.FieldExternalID,
		toTerm: directoryaccounthistory.ByExternalID,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldCanonicalEmail orders DirectoryAccountHistory by canonical_email.
	DirectoryAccountHistoryOrderFieldCanonicalEmail = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.CanonicalEmail == nil {
				return nil, nil
			}
			return _m.CanonicalEmail, nil
		},
		column: directoryaccounthistory.FieldCanonicalEmail,
		toTerm: func(opts ...sql.OrderTermOption) directoryaccounthistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directoryaccounthistory.ByCanonicalEmail(opts...)
		},
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			if _m.CanonicalEmail == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.CanonicalEmail,
			}
		},
	}
	// DirectoryAccountHistoryOrderFieldDisplayName orders DirectoryAccountHistory by display_name.
	DirectoryAccountHistoryOrderFieldDisplayName = &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directoryaccounthistory.FieldDisplayName,
		toTerm: directoryaccounthistory.ByDisplayName,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryAccountHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryAccountHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DirectoryAccountHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryAccountHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryAccountHistoryOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryAccountHistoryOrderFieldCanonicalEmail.column:
		str = "canonical_email"
	case DirectoryAccountHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryAccountHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryAccountHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryAccountHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DirectoryAccountHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DirectoryAccountHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryAccountHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryAccountHistoryOrderFieldExternalID
	case "canonical_email":
		*f = *DirectoryAccountHistoryOrderFieldCanonicalEmail
	case "display_name":
		*f = *DirectoryAccountHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryAccountHistoryOrderField", str)
	}
	return nil
}

// DirectoryAccountHistoryOrderField defines the ordering field of DirectoryAccountHistory.
type DirectoryAccountHistoryOrderField struct {
	// Value extracts the ordering value from the given DirectoryAccountHistory.
	Value    func(*DirectoryAccountHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directoryaccounthistory.OrderOption
	toCursor func(*DirectoryAccountHistory) Cursor
}

// DirectoryAccountHistoryOrder defines the ordering of DirectoryAccountHistory.
type DirectoryAccountHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *DirectoryAccountHistoryOrderField `json:"field"`
}

// DefaultDirectoryAccountHistoryOrder is the default ordering of DirectoryAccountHistory.
var DefaultDirectoryAccountHistoryOrder = &DirectoryAccountHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryAccountHistoryOrderField{
		Value: func(_m *DirectoryAccountHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directoryaccounthistory.FieldID,
		toTerm: directoryaccounthistory.ByID,
		toCursor: func(_m *DirectoryAccountHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryAccountHistory into DirectoryAccountHistoryEdge.
func (_m *DirectoryAccountHistory) ToEdge(order *DirectoryAccountHistoryOrder) *DirectoryAccountHistoryEdge {
	if order == nil {
		order = DefaultDirectoryAccountHistoryOrder
	}
	return &DirectoryAccountHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryGroupEdge is the edge representation of DirectoryGroup.
type DirectoryGroupEdge struct {
	Node   *DirectoryGroup `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// DirectoryGroupConnection is the connection containing edges to DirectoryGroup.
type DirectoryGroupConnection struct {
	Edges      []*DirectoryGroupEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *DirectoryGroupConnection) build(nodes []*DirectoryGroup, pager *directorygroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryGroupPaginateOption enables pagination customization.
type DirectoryGroupPaginateOption func(*directorygroupPager) error

// WithDirectoryGroupOrder configures pagination ordering.
func WithDirectoryGroupOrder(order []*DirectoryGroupOrder) DirectoryGroupPaginateOption {
	return func(pager *directorygroupPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectoryGroupFilter configures pagination filter.
func WithDirectoryGroupFilter(filter func(*DirectoryGroupQuery) (*DirectoryGroupQuery, error)) DirectoryGroupPaginateOption {
	return func(pager *directorygroupPager) error {
		if filter == nil {
			return errors.New("DirectoryGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorygroupPager struct {
	reverse bool
	order   []*DirectoryGroupOrder
	filter  func(*DirectoryGroupQuery) (*DirectoryGroupQuery, error)
}

func newDirectoryGroupPager(opts []DirectoryGroupPaginateOption, reverse bool) (*directorygroupPager, error) {
	pager := &directorygroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directorygroupPager) applyFilter(query *DirectoryGroupQuery) (*DirectoryGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorygroupPager) toCursor(_m *DirectoryGroup) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directorygroupPager) applyCursors(query *DirectoryGroupQuery, after, before *Cursor) (*DirectoryGroupQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectoryGroupOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directorygroupPager) applyOrder(query *DirectoryGroupQuery) *DirectoryGroupQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectoryGroupOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectoryGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directorygroupPager) orderExpr(query *DirectoryGroupQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectoryGroupOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryGroup.
func (_m *DirectoryGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryGroupPaginateOption,
) (*DirectoryGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryGroupConnection{Edges: []*DirectoryGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryGroupOrderFieldCreatedAt orders DirectoryGroup by created_at.
	DirectoryGroupOrderFieldCreatedAt = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorygroup.FieldCreatedAt,
		toTerm: directorygroup.ByCreatedAt,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryGroupOrderFieldUpdatedAt orders DirectoryGroup by updated_at.
	DirectoryGroupOrderFieldUpdatedAt = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorygroup.FieldUpdatedAt,
		toTerm: directorygroup.ByUpdatedAt,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryGroupOrderFieldExternalID orders DirectoryGroup by external_id.
	DirectoryGroupOrderFieldExternalID = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directorygroup.FieldExternalID,
		toTerm: directorygroup.ByExternalID,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryGroupOrderFieldEmail orders DirectoryGroup by email.
	DirectoryGroupOrderFieldEmail = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Email == nil {
				return nil, nil
			}
			return _m.Email, nil
		},
		column: directorygroup.FieldEmail,
		toTerm: func(opts ...sql.OrderTermOption) directorygroup.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directorygroup.ByEmail(opts...)
		},
		toCursor: func(_m *DirectoryGroup) Cursor {
			if _m.Email == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// DirectoryGroupOrderFieldDisplayName orders DirectoryGroup by display_name.
	DirectoryGroupOrderFieldDisplayName = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directorygroup.FieldDisplayName,
		toTerm: directorygroup.ByDisplayName,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryGroupOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryGroupOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryGroupOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryGroupOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryGroupOrderFieldEmail.column:
		str = "email"
	case DirectoryGroupOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryGroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryGroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryGroupOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectoryGroupOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryGroupOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryGroupOrderFieldExternalID
	case "email":
		*f = *DirectoryGroupOrderFieldEmail
	case "display_name":
		*f = *DirectoryGroupOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryGroupOrderField", str)
	}
	return nil
}

// DirectoryGroupOrderField defines the ordering field of DirectoryGroup.
type DirectoryGroupOrderField struct {
	// Value extracts the ordering value from the given DirectoryGroup.
	Value    func(*DirectoryGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorygroup.OrderOption
	toCursor func(*DirectoryGroup) Cursor
}

// DirectoryGroupOrder defines the ordering of DirectoryGroup.
type DirectoryGroupOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *DirectoryGroupOrderField `json:"field"`
}

// DefaultDirectoryGroupOrder is the default ordering of DirectoryGroup.
var DefaultDirectoryGroupOrder = &DirectoryGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorygroup.FieldID,
		toTerm: directorygroup.ByID,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryGroup into DirectoryGroupEdge.
func (_m *DirectoryGroup) ToEdge(order *DirectoryGroupOrder) *DirectoryGroupEdge {
	if order == nil {
		order = DefaultDirectoryGroupOrder
	}
	return &DirectoryGroupEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryGroupHistoryEdge is the edge representation of DirectoryGroupHistory.
type DirectoryGroupHistoryEdge struct {
	Node   *DirectoryGroupHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// DirectoryGroupHistoryConnection is the connection containing edges to DirectoryGroupHistory.
type DirectoryGroupHistoryConnection struct {
	Edges      []*DirectoryGroupHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *DirectoryGroupHistoryConnection) build(nodes []*DirectoryGroupHistory, pager *directorygrouphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryGroupHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryGroupHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryGroupHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryGroupHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryGroupHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryGroupHistoryPaginateOption enables pagination customization.
type DirectoryGroupHistoryPaginateOption func(*directorygrouphistoryPager) error

// WithDirectoryGroupHistoryOrder configures pagination ordering.
func WithDirectoryGroupHistoryOrder(order *DirectoryGroupHistoryOrder) DirectoryGroupHistoryPaginateOption {
	if order == nil {
		order = DefaultDirectoryGroupHistoryOrder
	}
	o := *order
	return func(pager *directorygrouphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDirectoryGroupHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDirectoryGroupHistoryFilter configures pagination filter.
func WithDirectoryGroupHistoryFilter(filter func(*DirectoryGroupHistoryQuery) (*DirectoryGroupHistoryQuery, error)) DirectoryGroupHistoryPaginateOption {
	return func(pager *directorygrouphistoryPager) error {
		if filter == nil {
			return errors.New("DirectoryGroupHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorygrouphistoryPager struct {
	reverse bool
	order   *DirectoryGroupHistoryOrder
	filter  func(*DirectoryGroupHistoryQuery) (*DirectoryGroupHistoryQuery, error)
}

func newDirectoryGroupHistoryPager(opts []DirectoryGroupHistoryPaginateOption, reverse bool) (*directorygrouphistoryPager, error) {
	pager := &directorygrouphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDirectoryGroupHistoryOrder
	}
	return pager, nil
}

func (p *directorygrouphistoryPager) applyFilter(query *DirectoryGroupHistoryQuery) (*DirectoryGroupHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorygrouphistoryPager) toCursor(_m *DirectoryGroupHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *directorygrouphistoryPager) applyCursors(query *DirectoryGroupHistoryQuery, after, before *Cursor) (*DirectoryGroupHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDirectoryGroupHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *directorygrouphistoryPager) applyOrder(query *DirectoryGroupHistoryQuery) *DirectoryGroupHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDirectoryGroupHistoryOrder.Field {
		query = query.Order(DefaultDirectoryGroupHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *directorygrouphistoryPager) orderExpr(query *DirectoryGroupHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDirectoryGroupHistoryOrder.Field {
			b.Comma().Ident(DefaultDirectoryGroupHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryGroupHistory.
func (_m *DirectoryGroupHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryGroupHistoryPaginateOption,
) (*DirectoryGroupHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryGroupHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryGroupHistoryConnection{Edges: []*DirectoryGroupHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryGroupHistoryOrderFieldHistoryTime orders DirectoryGroupHistory by history_time.
	DirectoryGroupHistoryOrderFieldHistoryTime = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: directorygrouphistory.FieldHistoryTime,
		toTerm: directorygrouphistory.ByHistoryTime,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldCreatedAt orders DirectoryGroupHistory by created_at.
	DirectoryGroupHistoryOrderFieldCreatedAt = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorygrouphistory.FieldCreatedAt,
		toTerm: directorygrouphistory.ByCreatedAt,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldUpdatedAt orders DirectoryGroupHistory by updated_at.
	DirectoryGroupHistoryOrderFieldUpdatedAt = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorygrouphistory.FieldUpdatedAt,
		toTerm: directorygrouphistory.ByUpdatedAt,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldExternalID orders DirectoryGroupHistory by external_id.
	DirectoryGroupHistoryOrderFieldExternalID = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directorygrouphistory.FieldExternalID,
		toTerm: directorygrouphistory.ByExternalID,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldEmail orders DirectoryGroupHistory by email.
	DirectoryGroupHistoryOrderFieldEmail = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Email == nil {
				return nil, nil
			}
			return _m.Email, nil
		},
		column: directorygrouphistory.FieldEmail,
		toTerm: func(opts ...sql.OrderTermOption) directorygrouphistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directorygrouphistory.ByEmail(opts...)
		},
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			if _m.Email == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// DirectoryGroupHistoryOrderFieldDisplayName orders DirectoryGroupHistory by display_name.
	DirectoryGroupHistoryOrderFieldDisplayName = &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directorygrouphistory.FieldDisplayName,
		toTerm: directorygrouphistory.ByDisplayName,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryGroupHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryGroupHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DirectoryGroupHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryGroupHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryGroupHistoryOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryGroupHistoryOrderFieldEmail.column:
		str = "email"
	case DirectoryGroupHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryGroupHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryGroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryGroupHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DirectoryGroupHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DirectoryGroupHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryGroupHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryGroupHistoryOrderFieldExternalID
	case "email":
		*f = *DirectoryGroupHistoryOrderFieldEmail
	case "display_name":
		*f = *DirectoryGroupHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryGroupHistoryOrderField", str)
	}
	return nil
}

// DirectoryGroupHistoryOrderField defines the ordering field of DirectoryGroupHistory.
type DirectoryGroupHistoryOrderField struct {
	// Value extracts the ordering value from the given DirectoryGroupHistory.
	Value    func(*DirectoryGroupHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorygrouphistory.OrderOption
	toCursor func(*DirectoryGroupHistory) Cursor
}

// DirectoryGroupHistoryOrder defines the ordering of DirectoryGroupHistory.
type DirectoryGroupHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *DirectoryGroupHistoryOrderField `json:"field"`
}

// DefaultDirectoryGroupHistoryOrder is the default ordering of DirectoryGroupHistory.
var DefaultDirectoryGroupHistoryOrder = &DirectoryGroupHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryGroupHistoryOrderField{
		Value: func(_m *DirectoryGroupHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorygrouphistory.FieldID,
		toTerm: directorygrouphistory.ByID,
		toCursor: func(_m *DirectoryGroupHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryGroupHistory into DirectoryGroupHistoryEdge.
func (_m *DirectoryGroupHistory) ToEdge(order *DirectoryGroupHistoryOrder) *DirectoryGroupHistoryEdge {
	if order == nil {
		order = DefaultDirectoryGroupHistoryOrder
	}
	return &DirectoryGroupHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryMembershipEdge is the edge representation of DirectoryMembership.
type DirectoryMembershipEdge struct {
	Node   *DirectoryMembership `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DirectoryMembershipConnection is the connection containing edges to DirectoryMembership.
type DirectoryMembershipConnection struct {
	Edges      []*DirectoryMembershipEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DirectoryMembershipConnection) build(nodes []*DirectoryMembership, pager *directorymembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryMembershipPaginateOption enables pagination customization.
type DirectoryMembershipPaginateOption func(*directorymembershipPager) error

// WithDirectoryMembershipOrder configures pagination ordering.
func WithDirectoryMembershipOrder(order []*DirectoryMembershipOrder) DirectoryMembershipPaginateOption {
	return func(pager *directorymembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectoryMembershipFilter configures pagination filter.
func WithDirectoryMembershipFilter(filter func(*DirectoryMembershipQuery) (*DirectoryMembershipQuery, error)) DirectoryMembershipPaginateOption {
	return func(pager *directorymembershipPager) error {
		if filter == nil {
			return errors.New("DirectoryMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorymembershipPager struct {
	reverse bool
	order   []*DirectoryMembershipOrder
	filter  func(*DirectoryMembershipQuery) (*DirectoryMembershipQuery, error)
}

func newDirectoryMembershipPager(opts []DirectoryMembershipPaginateOption, reverse bool) (*directorymembershipPager, error) {
	pager := &directorymembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directorymembershipPager) applyFilter(query *DirectoryMembershipQuery) (*DirectoryMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorymembershipPager) toCursor(_m *DirectoryMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directorymembershipPager) applyCursors(query *DirectoryMembershipQuery, after, before *Cursor) (*DirectoryMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectoryMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directorymembershipPager) applyOrder(query *DirectoryMembershipQuery) *DirectoryMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectoryMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectoryMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directorymembershipPager) orderExpr(query *DirectoryMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectoryMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryMembership.
func (_m *DirectoryMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryMembershipPaginateOption,
) (*DirectoryMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryMembershipConnection{Edges: []*DirectoryMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryMembershipOrderFieldCreatedAt orders DirectoryMembership by created_at.
	DirectoryMembershipOrderFieldCreatedAt = &DirectoryMembershipOrderField{
		Value: func(_m *DirectoryMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorymembership.FieldCreatedAt,
		toTerm: directorymembership.ByCreatedAt,
		toCursor: func(_m *DirectoryMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryMembershipOrderFieldUpdatedAt orders DirectoryMembership by updated_at.
	DirectoryMembershipOrderFieldUpdatedAt = &DirectoryMembershipOrderField{
		Value: func(_m *DirectoryMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorymembership.FieldUpdatedAt,
		toTerm: directorymembership.ByUpdatedAt,
		toCursor: func(_m *DirectoryMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryMembershipOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectoryMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryMembershipOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DirectoryMembershipOrderField", str)
	}
	return nil
}

// DirectoryMembershipOrderField defines the ordering field of DirectoryMembership.
type DirectoryMembershipOrderField struct {
	// Value extracts the ordering value from the given DirectoryMembership.
	Value    func(*DirectoryMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorymembership.OrderOption
	toCursor func(*DirectoryMembership) Cursor
}

// DirectoryMembershipOrder defines the ordering of DirectoryMembership.
type DirectoryMembershipOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DirectoryMembershipOrderField `json:"field"`
}

// DefaultDirectoryMembershipOrder is the default ordering of DirectoryMembership.
var DefaultDirectoryMembershipOrder = &DirectoryMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryMembershipOrderField{
		Value: func(_m *DirectoryMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorymembership.FieldID,
		toTerm: directorymembership.ByID,
		toCursor: func(_m *DirectoryMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryMembership into DirectoryMembershipEdge.
func (_m *DirectoryMembership) ToEdge(order *DirectoryMembershipOrder) *DirectoryMembershipEdge {
	if order == nil {
		order = DefaultDirectoryMembershipOrder
	}
	return &DirectoryMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryMembershipHistoryEdge is the edge representation of DirectoryMembershipHistory.
type DirectoryMembershipHistoryEdge struct {
	Node   *DirectoryMembershipHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// DirectoryMembershipHistoryConnection is the connection containing edges to DirectoryMembershipHistory.
type DirectoryMembershipHistoryConnection struct {
	Edges      []*DirectoryMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *DirectoryMembershipHistoryConnection) build(nodes []*DirectoryMembershipHistory, pager *directorymembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryMembershipHistoryPaginateOption enables pagination customization.
type DirectoryMembershipHistoryPaginateOption func(*directorymembershiphistoryPager) error

// WithDirectoryMembershipHistoryOrder configures pagination ordering.
func WithDirectoryMembershipHistoryOrder(order *DirectoryMembershipHistoryOrder) DirectoryMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultDirectoryMembershipHistoryOrder
	}
	o := *order
	return func(pager *directorymembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDirectoryMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDirectoryMembershipHistoryFilter configures pagination filter.
func WithDirectoryMembershipHistoryFilter(filter func(*DirectoryMembershipHistoryQuery) (*DirectoryMembershipHistoryQuery, error)) DirectoryMembershipHistoryPaginateOption {
	return func(pager *directorymembershiphistoryPager) error {
		if filter == nil {
			return errors.New("DirectoryMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorymembershiphistoryPager struct {
	reverse bool
	order   *DirectoryMembershipHistoryOrder
	filter  func(*DirectoryMembershipHistoryQuery) (*DirectoryMembershipHistoryQuery, error)
}

func newDirectoryMembershipHistoryPager(opts []DirectoryMembershipHistoryPaginateOption, reverse bool) (*directorymembershiphistoryPager, error) {
	pager := &directorymembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDirectoryMembershipHistoryOrder
	}
	return pager, nil
}

func (p *directorymembershiphistoryPager) applyFilter(query *DirectoryMembershipHistoryQuery) (*DirectoryMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorymembershiphistoryPager) toCursor(_m *DirectoryMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *directorymembershiphistoryPager) applyCursors(query *DirectoryMembershipHistoryQuery, after, before *Cursor) (*DirectoryMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDirectoryMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *directorymembershiphistoryPager) applyOrder(query *DirectoryMembershipHistoryQuery) *DirectoryMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDirectoryMembershipHistoryOrder.Field {
		query = query.Order(DefaultDirectoryMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *directorymembershiphistoryPager) orderExpr(query *DirectoryMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDirectoryMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultDirectoryMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryMembershipHistory.
func (_m *DirectoryMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryMembershipHistoryPaginateOption,
) (*DirectoryMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryMembershipHistoryConnection{Edges: []*DirectoryMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryMembershipHistoryOrderFieldHistoryTime orders DirectoryMembershipHistory by history_time.
	DirectoryMembershipHistoryOrderFieldHistoryTime = &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: directorymembershiphistory.FieldHistoryTime,
		toTerm: directorymembershiphistory.ByHistoryTime,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DirectoryMembershipHistoryOrderFieldCreatedAt orders DirectoryMembershipHistory by created_at.
	DirectoryMembershipHistoryOrderFieldCreatedAt = &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorymembershiphistory.FieldCreatedAt,
		toTerm: directorymembershiphistory.ByCreatedAt,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryMembershipHistoryOrderFieldUpdatedAt orders DirectoryMembershipHistory by updated_at.
	DirectoryMembershipHistoryOrderFieldUpdatedAt = &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorymembershiphistory.FieldUpdatedAt,
		toTerm: directorymembershiphistory.ByUpdatedAt,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DirectoryMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DirectoryMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DirectoryMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryMembershipHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DirectoryMembershipHistoryOrderField", str)
	}
	return nil
}

// DirectoryMembershipHistoryOrderField defines the ordering field of DirectoryMembershipHistory.
type DirectoryMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given DirectoryMembershipHistory.
	Value    func(*DirectoryMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorymembershiphistory.OrderOption
	toCursor func(*DirectoryMembershipHistory) Cursor
}

// DirectoryMembershipHistoryOrder defines the ordering of DirectoryMembershipHistory.
type DirectoryMembershipHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *DirectoryMembershipHistoryOrderField `json:"field"`
}

// DefaultDirectoryMembershipHistoryOrder is the default ordering of DirectoryMembershipHistory.
var DefaultDirectoryMembershipHistoryOrder = &DirectoryMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryMembershipHistoryOrderField{
		Value: func(_m *DirectoryMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorymembershiphistory.FieldID,
		toTerm: directorymembershiphistory.ByID,
		toCursor: func(_m *DirectoryMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryMembershipHistory into DirectoryMembershipHistoryEdge.
func (_m *DirectoryMembershipHistory) ToEdge(order *DirectoryMembershipHistoryOrder) *DirectoryMembershipHistoryEdge {
	if order == nil {
		order = DefaultDirectoryMembershipHistoryOrder
	}
	return &DirectoryMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectorySyncRunEdge is the edge representation of DirectorySyncRun.
type DirectorySyncRunEdge struct {
	Node   *DirectorySyncRun `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DirectorySyncRunConnection is the connection containing edges to DirectorySyncRun.
type DirectorySyncRunConnection struct {
	Edges      []*DirectorySyncRunEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *DirectorySyncRunConnection) build(nodes []*DirectorySyncRun, pager *directorysyncrunPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectorySyncRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectorySyncRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectorySyncRun {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectorySyncRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectorySyncRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectorySyncRunPaginateOption enables pagination customization.
type DirectorySyncRunPaginateOption func(*directorysyncrunPager) error

// WithDirectorySyncRunOrder configures pagination ordering.
func WithDirectorySyncRunOrder(order []*DirectorySyncRunOrder) DirectorySyncRunPaginateOption {
	return func(pager *directorysyncrunPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectorySyncRunFilter configures pagination filter.
func WithDirectorySyncRunFilter(filter func(*DirectorySyncRunQuery) (*DirectorySyncRunQuery, error)) DirectorySyncRunPaginateOption {
	return func(pager *directorysyncrunPager) error {
		if filter == nil {
			return errors.New("DirectorySyncRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorysyncrunPager struct {
	reverse bool
	order   []*DirectorySyncRunOrder
	filter  func(*DirectorySyncRunQuery) (*DirectorySyncRunQuery, error)
}

func newDirectorySyncRunPager(opts []DirectorySyncRunPaginateOption, reverse bool) (*directorysyncrunPager, error) {
	pager := &directorysyncrunPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directorysyncrunPager) applyFilter(query *DirectorySyncRunQuery) (*DirectorySyncRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorysyncrunPager) toCursor(_m *DirectorySyncRun) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directorysyncrunPager) applyCursors(query *DirectorySyncRunQuery, after, before *Cursor) (*DirectorySyncRunQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectorySyncRunOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directorysyncrunPager) applyOrder(query *DirectorySyncRunQuery) *DirectorySyncRunQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectorySyncRunOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectorySyncRunOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directorysyncrunPager) orderExpr(query *DirectorySyncRunQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectorySyncRunOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectorySyncRun.
func (_m *DirectorySyncRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectorySyncRunPaginateOption,
) (*DirectorySyncRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectorySyncRunPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectorySyncRunConnection{Edges: []*DirectorySyncRunEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectorySyncRunOrderFieldCreatedAt orders DirectorySyncRun by created_at.
	DirectorySyncRunOrderFieldCreatedAt = &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorysyncrun.FieldCreatedAt,
		toTerm: directorysyncrun.ByCreatedAt,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectorySyncRunOrderFieldUpdatedAt orders DirectorySyncRun by updated_at.
	DirectorySyncRunOrderFieldUpdatedAt = &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorysyncrun.FieldUpdatedAt,
		toTerm: directorysyncrun.ByUpdatedAt,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectorySyncRunOrderFieldStartedAt orders DirectorySyncRun by started_at.
	DirectorySyncRunOrderFieldStartedAt = &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: directorysyncrun.FieldStartedAt,
		toTerm: directorysyncrun.ByStartedAt,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectorySyncRunOrderField) String() string {
	var str string
	switch f.column {
	case DirectorySyncRunOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectorySyncRunOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectorySyncRunOrderFieldStartedAt.column:
		str = "started_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectorySyncRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectorySyncRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectorySyncRunOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectorySyncRunOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectorySyncRunOrderFieldUpdatedAt
	case "started_at":
		*f = *DirectorySyncRunOrderFieldStartedAt
	default:
		return fmt.Errorf("%s is not a valid DirectorySyncRunOrderField", str)
	}
	return nil
}

// DirectorySyncRunOrderField defines the ordering field of DirectorySyncRun.
type DirectorySyncRunOrderField struct {
	// Value extracts the ordering value from the given DirectorySyncRun.
	Value    func(*DirectorySyncRun) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorysyncrun.OrderOption
	toCursor func(*DirectorySyncRun) Cursor
}

// DirectorySyncRunOrder defines the ordering of DirectorySyncRun.
type DirectorySyncRunOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DirectorySyncRunOrderField `json:"field"`
}

// DefaultDirectorySyncRunOrder is the default ordering of DirectorySyncRun.
var DefaultDirectorySyncRunOrder = &DirectorySyncRunOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorysyncrun.FieldID,
		toTerm: directorysyncrun.ByID,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectorySyncRun into DirectorySyncRunEdge.
func (_m *DirectorySyncRun) ToEdge(order *DirectorySyncRunOrder) *DirectorySyncRunEdge {
	if order == nil {
		order = DefaultDirectorySyncRunOrder
	}
	return &DirectorySyncRunEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DocumentDataEdge is the edge representation of DocumentData.
type DocumentDataEdge struct {
	Node   *DocumentData `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// DocumentDataConnection is the connection containing edges to DocumentData.
type DocumentDataConnection struct {
	Edges      []*DocumentDataEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *DocumentDataConnection) build(nodes []*DocumentData, pager *documentdataPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DocumentData
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentData {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentData {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataPaginateOption enables pagination customization.
type DocumentDataPaginateOption func(*documentdataPager) error

// WithDocumentDataOrder configures pagination ordering.
func WithDocumentDataOrder(order []*DocumentDataOrder) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDocumentDataFilter configures pagination filter.
func WithDocumentDataFilter(filter func(*DocumentDataQuery) (*DocumentDataQuery, error)) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		if filter == nil {
			return errors.New("DocumentDataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdataPager struct {
	reverse bool
	order   []*DocumentDataOrder
	filter  func(*DocumentDataQuery) (*DocumentDataQuery, error)
}

func newDocumentDataPager(opts []DocumentDataPaginateOption, reverse bool) (*documentdataPager, error) {
	pager := &documentdataPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *documentdataPager) applyFilter(query *DocumentDataQuery) (*DocumentDataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdataPager) toCursor(_m *DocumentData) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *documentdataPager) applyCursors(query *DocumentDataQuery, after, before *Cursor) (*DocumentDataQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDocumentDataOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *documentdataPager) applyOrder(query *DocumentDataQuery) *DocumentDataQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDocumentDataOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDocumentDataOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *documentdataPager) orderExpr(query *DocumentDataQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDocumentDataOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentData.
func (_m *DocumentDataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataPaginateOption,
) (*DocumentDataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DocumentDataConnection{Edges: []*DocumentDataEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentDataOrderFieldCreatedAt orders DocumentData by created_at.
	DocumentDataOrderFieldCreatedAt = &DocumentDataOrderField{
		Value: func(_m *DocumentData) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: documentdata.FieldCreatedAt,
		toTerm: documentdata.ByCreatedAt,
		toCursor: func(_m *DocumentData) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DocumentDataOrderFieldUpdatedAt orders DocumentData by updated_at.
	DocumentDataOrderFieldUpdatedAt = &DocumentDataOrderField{
		Value: func(_m *DocumentData) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: documentdata.FieldUpdatedAt,
		toTerm: documentdata.ByUpdatedAt,
		toCursor: func(_m *DocumentData) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentDataOrderField) String() string {
	var str string
	switch f.column {
	case DocumentDataOrderFieldCreatedAt.column:
		str = "created_at"
	case DocumentDataOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentDataOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentDataOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentDataOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DocumentDataOrderFieldCreatedAt
	case "updated_at":
		*f = *DocumentDataOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentDataOrderField", str)
	}
	return nil
}

// DocumentDataOrderField defines the ordering field of DocumentData.
type DocumentDataOrderField struct {
	// Value extracts the ordering value from the given DocumentData.
	Value    func(*DocumentData) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdata.OrderOption
	toCursor func(*DocumentData) Cursor
}

// DocumentDataOrder defines the ordering of DocumentData.
type DocumentDataOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *DocumentDataOrderField `json:"field"`
}

// DefaultDocumentDataOrder is the default ordering of DocumentData.
var DefaultDocumentDataOrder = &DocumentDataOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataOrderField{
		Value: func(_m *DocumentData) (ent.Value, error) {
			return _m.ID, nil
		},
		column: documentdata.FieldID,
		toTerm: documentdata.ByID,
		toCursor: func(_m *DocumentData) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DocumentData into DocumentDataEdge.
func (_m *DocumentData) ToEdge(order *DocumentDataOrder) *DocumentDataEdge {
	if order == nil {
		order = DefaultDocumentDataOrder
	}
	return &DocumentDataEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DocumentDataHistoryEdge is the edge representation of DocumentDataHistory.
type DocumentDataHistoryEdge struct {
	Node   *DocumentDataHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DocumentDataHistoryConnection is the connection containing edges to DocumentDataHistory.
type DocumentDataHistoryConnection struct {
	Edges      []*DocumentDataHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DocumentDataHistoryConnection) build(nodes []*DocumentDataHistory, pager *documentdatahistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DocumentDataHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataHistoryPaginateOption enables pagination customization.
type DocumentDataHistoryPaginateOption func(*documentdatahistoryPager) error

// WithDocumentDataHistoryOrder configures pagination ordering.
func WithDocumentDataHistoryOrder(order *DocumentDataHistoryOrder) DocumentDataHistoryPaginateOption {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	o := *order
	return func(pager *documentdatahistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentDataHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentDataHistoryFilter configures pagination filter.
func WithDocumentDataHistoryFilter(filter func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)) DocumentDataHistoryPaginateOption {
	return func(pager *documentdatahistoryPager) error {
		if filter == nil {
			return errors.New("DocumentDataHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdatahistoryPager struct {
	reverse bool
	order   *DocumentDataHistoryOrder
	filter  func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)
}

func newDocumentDataHistoryPager(opts []DocumentDataHistoryPaginateOption, reverse bool) (*documentdatahistoryPager, error) {
	pager := &documentdatahistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentDataHistoryOrder
	}
	return pager, nil
}

func (p *documentdatahistoryPager) applyFilter(query *DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdatahistoryPager) toCursor(_m *DocumentDataHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *documentdatahistoryPager) applyCursors(query *DocumentDataHistoryQuery, after, before *Cursor) (*DocumentDataHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentDataHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentdatahistoryPager) applyOrder(query *DocumentDataHistoryQuery) *DocumentDataHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
		query = query.Order(DefaultDocumentDataHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentdatahistoryPager) orderExpr(query *DocumentDataHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
			b.Comma().Ident(DefaultDocumentDataHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentDataHistory.
func (_m *DocumentDataHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataHistoryPaginateOption,
) (*DocumentDataHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DocumentDataHistoryConnection{Edges: []*DocumentDataHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentDataHistoryOrderFieldHistoryTime orders DocumentDataHistory by history_time.
	DocumentDataHistoryOrderFieldHistoryTime = &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: documentdatahistory.FieldHistoryTime,
		toTerm: documentdatahistory.ByHistoryTime,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// DocumentDataHistoryOrderFieldCreatedAt orders DocumentDataHistory by created_at.
	DocumentDataHistoryOrderFieldCreatedAt = &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: documentdatahistory.FieldCreatedAt,
		toTerm: documentdatahistory.ByCreatedAt,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DocumentDataHistoryOrderFieldUpdatedAt orders DocumentDataHistory by updated_at.
	DocumentDataHistoryOrderFieldUpdatedAt = &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: documentdatahistory.FieldUpdatedAt,
		toTerm: documentdatahistory.ByUpdatedAt,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentDataHistoryOrderField) String() string {
	var str string
	switch f.column {
	case DocumentDataHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case DocumentDataHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case DocumentDataHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentDataHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentDataHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentDataHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *DocumentDataHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *DocumentDataHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *DocumentDataHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentDataHistoryOrderField", str)
	}
	return nil
}

// DocumentDataHistoryOrderField defines the ordering field of DocumentDataHistory.
type DocumentDataHistoryOrderField struct {
	// Value extracts the ordering value from the given DocumentDataHistory.
	Value    func(*DocumentDataHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdatahistory.OrderOption
	toCursor func(*DocumentDataHistory) Cursor
}

// DocumentDataHistoryOrder defines the ordering of DocumentDataHistory.
type DocumentDataHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DocumentDataHistoryOrderField `json:"field"`
}

// DefaultDocumentDataHistoryOrder is the default ordering of DocumentDataHistory.
var DefaultDocumentDataHistoryOrder = &DocumentDataHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataHistoryOrderField{
		Value: func(_m *DocumentDataHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: documentdatahistory.FieldID,
		toTerm: documentdatahistory.ByID,
		toCursor: func(_m *DocumentDataHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DocumentDataHistory into DocumentDataHistoryEdge.
func (_m *DocumentDataHistory) ToEdge(order *DocumentDataHistoryOrder) *DocumentDataHistoryEdge {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	return &DocumentDataHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityEdge is the edge representation of Entity.
type EntityEdge struct {
	Node   *Entity `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EntityConnection is the connection containing edges to Entity.
type EntityConnection struct {
	Edges      []*EntityEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *EntityConnection) build(nodes []*Entity, pager *entityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Entity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Entity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Entity {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityPaginateOption enables pagination customization.
type EntityPaginateOption func(*entityPager) error

// WithEntityOrder configures pagination ordering.
func WithEntityOrder(order []*EntityOrder) EntityPaginateOption {
	return func(pager *entityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEntityFilter configures pagination filter.
func WithEntityFilter(filter func(*EntityQuery) (*EntityQuery, error)) EntityPaginateOption {
	return func(pager *entityPager) error {
		if filter == nil {
			return errors.New("EntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityPager struct {
	reverse bool
	order   []*EntityOrder
	filter  func(*EntityQuery) (*EntityQuery, error)
}

func newEntityPager(opts []EntityPaginateOption, reverse bool) (*entityPager, error) {
	pager := &entityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *entityPager) applyFilter(query *EntityQuery) (*EntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityPager) toCursor(_m *Entity) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *entityPager) applyCursors(query *EntityQuery, after, before *Cursor) (*EntityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEntityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *entityPager) applyOrder(query *EntityQuery) *EntityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEntityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *entityPager) orderExpr(query *EntityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEntityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Entity.
func (_m *EntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityPaginateOption,
) (*EntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityConnection{Edges: []*EntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityOrderFieldCreatedAt orders Entity by created_at.
	EntityOrderFieldCreatedAt = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entity.FieldCreatedAt,
		toTerm: entity.ByCreatedAt,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityOrderFieldUpdatedAt orders Entity by updated_at.
	EntityOrderFieldUpdatedAt = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entity.FieldUpdatedAt,
		toTerm: entity.ByUpdatedAt,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityOrderFieldName orders Entity by name.
	EntityOrderFieldName = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entity.FieldName,
		toTerm: entity.ByName,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EntityOrderFieldDisplayName orders Entity by display_name.
	EntityOrderFieldDisplayName = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: entity.FieldDisplayName,
		toTerm: entity.ByDisplayName,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
	// EntityOrderFieldStatus orders Entity by status.
	EntityOrderFieldStatus = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.Status, nil
		},
		column: entity.FieldStatus,
		toTerm: entity.ByStatus,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityOrderField) String() string {
	var str string
	switch f.column {
	case EntityOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityOrderFieldName.column:
		str = "name"
	case EntityOrderFieldDisplayName.column:
		str = "display_name"
	case EntityOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityOrderFieldUpdatedAt
	case "name":
		*f = *EntityOrderFieldName
	case "display_name":
		*f = *EntityOrderFieldDisplayName
	case "status":
		*f = *EntityOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

// EntityOrderField defines the ordering field of Entity.
type EntityOrderField struct {
	// Value extracts the ordering value from the given Entity.
	Value    func(*Entity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entity.OrderOption
	toCursor func(*Entity) Cursor
}

// EntityOrder defines the ordering of Entity.
type EntityOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EntityOrderField `json:"field"`
}

// DefaultEntityOrder is the default ordering of Entity.
var DefaultEntityOrder = &EntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entity.FieldID,
		toTerm: entity.ByID,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Entity into EntityEdge.
func (_m *Entity) ToEdge(order *EntityOrder) *EntityEdge {
	if order == nil {
		order = DefaultEntityOrder
	}
	return &EntityEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityHistoryEdge is the edge representation of EntityHistory.
type EntityHistoryEdge struct {
	Node   *EntityHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EntityHistoryConnection is the connection containing edges to EntityHistory.
type EntityHistoryConnection struct {
	Edges      []*EntityHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EntityHistoryConnection) build(nodes []*EntityHistory, pager *entityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityHistoryPaginateOption enables pagination customization.
type EntityHistoryPaginateOption func(*entityhistoryPager) error

// WithEntityHistoryOrder configures pagination ordering.
func WithEntityHistoryOrder(order *EntityHistoryOrder) EntityHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	o := *order
	return func(pager *entityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityHistoryFilter configures pagination filter.
func WithEntityHistoryFilter(filter func(*EntityHistoryQuery) (*EntityHistoryQuery, error)) EntityHistoryPaginateOption {
	return func(pager *entityhistoryPager) error {
		if filter == nil {
			return errors.New("EntityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityhistoryPager struct {
	reverse bool
	order   *EntityHistoryOrder
	filter  func(*EntityHistoryQuery) (*EntityHistoryQuery, error)
}

func newEntityHistoryPager(opts []EntityHistoryPaginateOption, reverse bool) (*entityhistoryPager, error) {
	pager := &entityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityHistoryOrder
	}
	return pager, nil
}

func (p *entityhistoryPager) applyFilter(query *EntityHistoryQuery) (*EntityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityhistoryPager) toCursor(_m *EntityHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *entityhistoryPager) applyCursors(query *EntityHistoryQuery, after, before *Cursor) (*EntityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entityhistoryPager) applyOrder(query *EntityHistoryQuery) *EntityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityHistoryOrder.Field {
		query = query.Order(DefaultEntityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entityhistoryPager) orderExpr(query *EntityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityHistory.
func (_m *EntityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityHistoryPaginateOption,
) (*EntityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityHistoryConnection{Edges: []*EntityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityHistoryOrderFieldHistoryTime orders EntityHistory by history_time.
	EntityHistoryOrderFieldHistoryTime = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: entityhistory.FieldHistoryTime,
		toTerm: entityhistory.ByHistoryTime,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EntityHistoryOrderFieldCreatedAt orders EntityHistory by created_at.
	EntityHistoryOrderFieldCreatedAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entityhistory.FieldCreatedAt,
		toTerm: entityhistory.ByCreatedAt,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityHistoryOrderFieldUpdatedAt orders EntityHistory by updated_at.
	EntityHistoryOrderFieldUpdatedAt = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entityhistory.FieldUpdatedAt,
		toTerm: entityhistory.ByUpdatedAt,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityHistoryOrderFieldName orders EntityHistory by name.
	EntityHistoryOrderFieldName = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entityhistory.FieldName,
		toTerm: entityhistory.ByName,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EntityHistoryOrderFieldDisplayName orders EntityHistory by display_name.
	EntityHistoryOrderFieldDisplayName = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: entityhistory.FieldDisplayName,
		toTerm: entityhistory.ByDisplayName,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
	// EntityHistoryOrderFieldStatus orders EntityHistory by status.
	EntityHistoryOrderFieldStatus = &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: entityhistory.FieldStatus,
		toTerm: entityhistory.ByStatus,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EntityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityHistoryOrderFieldName.column:
		str = "name"
	case EntityHistoryOrderFieldDisplayName.column:
		str = "display_name"
	case EntityHistoryOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EntityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EntityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EntityHistoryOrderFieldName
	case "display_name":
		*f = *EntityHistoryOrderFieldDisplayName
	case "status":
		*f = *EntityHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

// EntityHistoryOrderField defines the ordering field of EntityHistory.
type EntityHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityHistory.
	Value    func(*EntityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entityhistory.OrderOption
	toCursor func(*EntityHistory) Cursor
}

// EntityHistoryOrder defines the ordering of EntityHistory.
type EntityHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EntityHistoryOrderField `json:"field"`
}

// DefaultEntityHistoryOrder is the default ordering of EntityHistory.
var DefaultEntityHistoryOrder = &EntityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityHistoryOrderField{
		Value: func(_m *EntityHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entityhistory.FieldID,
		toTerm: entityhistory.ByID,
		toCursor: func(_m *EntityHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EntityHistory into EntityHistoryEdge.
func (_m *EntityHistory) ToEdge(order *EntityHistoryOrder) *EntityHistoryEdge {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	return &EntityHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityTypeEdge is the edge representation of EntityType.
type EntityTypeEdge struct {
	Node   *EntityType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// EntityTypeConnection is the connection containing edges to EntityType.
type EntityTypeConnection struct {
	Edges      []*EntityTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *EntityTypeConnection) build(nodes []*EntityType, pager *entitytypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityType {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypePaginateOption enables pagination customization.
type EntityTypePaginateOption func(*entitytypePager) error

// WithEntityTypeOrder configures pagination ordering.
func WithEntityTypeOrder(order []*EntityTypeOrder) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEntityTypeFilter configures pagination filter.
func WithEntityTypeFilter(filter func(*EntityTypeQuery) (*EntityTypeQuery, error)) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		if filter == nil {
			return errors.New("EntityTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypePager struct {
	reverse bool
	order   []*EntityTypeOrder
	filter  func(*EntityTypeQuery) (*EntityTypeQuery, error)
}

func newEntityTypePager(opts []EntityTypePaginateOption, reverse bool) (*entitytypePager, error) {
	pager := &entitytypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *entitytypePager) applyFilter(query *EntityTypeQuery) (*EntityTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypePager) toCursor(_m *EntityType) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *entitytypePager) applyCursors(query *EntityTypeQuery, after, before *Cursor) (*EntityTypeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEntityTypeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *entitytypePager) applyOrder(query *EntityTypeQuery) *EntityTypeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEntityTypeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEntityTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *entitytypePager) orderExpr(query *EntityTypeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEntityTypeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityType.
func (_m *EntityTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypePaginateOption,
) (*EntityTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityTypeConnection{Edges: []*EntityTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeOrderFieldCreatedAt orders EntityType by created_at.
	EntityTypeOrderFieldCreatedAt = &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entitytype.FieldCreatedAt,
		toTerm: entitytype.ByCreatedAt,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityTypeOrderFieldUpdatedAt orders EntityType by updated_at.
	EntityTypeOrderFieldUpdatedAt = &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entitytype.FieldUpdatedAt,
		toTerm: entitytype.ByUpdatedAt,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityTypeOrderFieldName orders EntityType by name.
	EntityTypeOrderFieldName = &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entitytype.FieldName,
		toTerm: entitytype.ByName,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityTypeOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityTypeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityTypeOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityTypeOrderFieldUpdatedAt
	case "name":
		*f = *EntityTypeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

// EntityTypeOrderField defines the ordering field of EntityType.
type EntityTypeOrderField struct {
	// Value extracts the ordering value from the given EntityType.
	Value    func(*EntityType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytype.OrderOption
	toCursor func(*EntityType) Cursor
}

// EntityTypeOrder defines the ordering of EntityType.
type EntityTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *EntityTypeOrderField `json:"field"`
}

// DefaultEntityTypeOrder is the default ordering of EntityType.
var DefaultEntityTypeOrder = &EntityTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entitytype.FieldID,
		toTerm: entitytype.ByID,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EntityType into EntityTypeEdge.
func (_m *EntityType) ToEdge(order *EntityTypeOrder) *EntityTypeEdge {
	if order == nil {
		order = DefaultEntityTypeOrder
	}
	return &EntityTypeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityTypeHistoryEdge is the edge representation of EntityTypeHistory.
type EntityTypeHistoryEdge struct {
	Node   *EntityTypeHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EntityTypeHistoryConnection is the connection containing edges to EntityTypeHistory.
type EntityTypeHistoryConnection struct {
	Edges      []*EntityTypeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *EntityTypeHistoryConnection) build(nodes []*EntityTypeHistory, pager *entitytypehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityTypeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypeHistoryPaginateOption enables pagination customization.
type EntityTypeHistoryPaginateOption func(*entitytypehistoryPager) error

// WithEntityTypeHistoryOrder configures pagination ordering.
func WithEntityTypeHistoryOrder(order *EntityTypeHistoryOrder) EntityTypeHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	o := *order
	return func(pager *entitytypehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityTypeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityTypeHistoryFilter configures pagination filter.
func WithEntityTypeHistoryFilter(filter func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)) EntityTypeHistoryPaginateOption {
	return func(pager *entitytypehistoryPager) error {
		if filter == nil {
			return errors.New("EntityTypeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypehistoryPager struct {
	reverse bool
	order   *EntityTypeHistoryOrder
	filter  func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)
}

func newEntityTypeHistoryPager(opts []EntityTypeHistoryPaginateOption, reverse bool) (*entitytypehistoryPager, error) {
	pager := &entitytypehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityTypeHistoryOrder
	}
	return pager, nil
}

func (p *entitytypehistoryPager) applyFilter(query *EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypehistoryPager) toCursor(_m *EntityTypeHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *entitytypehistoryPager) applyCursors(query *EntityTypeHistoryQuery, after, before *Cursor) (*EntityTypeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityTypeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitytypehistoryPager) applyOrder(query *EntityTypeHistoryQuery) *EntityTypeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
		query = query.Order(DefaultEntityTypeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitytypehistoryPager) orderExpr(query *EntityTypeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityTypeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityTypeHistory.
func (_m *EntityTypeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypeHistoryPaginateOption,
) (*EntityTypeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityTypeHistoryConnection{Edges: []*EntityTypeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeHistoryOrderFieldHistoryTime orders EntityTypeHistory by history_time.
	EntityTypeHistoryOrderFieldHistoryTime = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: entitytypehistory.FieldHistoryTime,
		toTerm: entitytypehistory.ByHistoryTime,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EntityTypeHistoryOrderFieldCreatedAt orders EntityTypeHistory by created_at.
	EntityTypeHistoryOrderFieldCreatedAt = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entitytypehistory.FieldCreatedAt,
		toTerm: entitytypehistory.ByCreatedAt,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityTypeHistoryOrderFieldUpdatedAt orders EntityTypeHistory by updated_at.
	EntityTypeHistoryOrderFieldUpdatedAt = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entitytypehistory.FieldUpdatedAt,
		toTerm: entitytypehistory.ByUpdatedAt,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityTypeHistoryOrderFieldName orders EntityTypeHistory by name.
	EntityTypeHistoryOrderFieldName = &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entitytypehistory.FieldName,
		toTerm: entitytypehistory.ByName,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EntityTypeHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityTypeHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityTypeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EntityTypeHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EntityTypeHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityTypeHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EntityTypeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

// EntityTypeHistoryOrderField defines the ordering field of EntityTypeHistory.
type EntityTypeHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityTypeHistory.
	Value    func(*EntityTypeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytypehistory.OrderOption
	toCursor func(*EntityTypeHistory) Cursor
}

// EntityTypeHistoryOrder defines the ordering of EntityTypeHistory.
type EntityTypeHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EntityTypeHistoryOrderField `json:"field"`
}

// DefaultEntityTypeHistoryOrder is the default ordering of EntityTypeHistory.
var DefaultEntityTypeHistoryOrder = &EntityTypeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeHistoryOrderField{
		Value: func(_m *EntityTypeHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entitytypehistory.FieldID,
		toTerm: entitytypehistory.ByID,
		toCursor: func(_m *EntityTypeHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EntityTypeHistory into EntityTypeHistoryEdge.
func (_m *EntityTypeHistory) ToEdge(order *EntityTypeHistoryOrder) *EntityTypeHistoryEdge {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	return &EntityTypeHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EventConnection) build(nodes []*Event, pager *eventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order []*EventOrder) EventPaginateOption {
	return func(pager *eventPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	reverse bool
	order   []*EventOrder
	filter  func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption, reverse bool) (*eventPager, error) {
	pager := &eventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(_m *Event) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) (*EventQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEventOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *eventPager) applyOrder(query *EventQuery) *EventQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEventOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *eventPager) orderExpr(query *EventQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEventOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (_m *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EventConnection{Edges: []*EventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EventOrderFieldCreatedAt orders Event by created_at.
	EventOrderFieldCreatedAt = &EventOrderField{
		Value: func(_m *Event) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: event.FieldCreatedAt,
		toTerm: event.ByCreatedAt,
		toCursor: func(_m *Event) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EventOrderFieldUpdatedAt orders Event by updated_at.
	EventOrderFieldUpdatedAt = &EventOrderField{
		Value: func(_m *Event) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: event.FieldUpdatedAt,
		toTerm: event.ByUpdatedAt,
		toCursor: func(_m *Event) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventOrderField) String() string {
	var str string
	switch f.column {
	case EventOrderFieldCreatedAt.column:
		str = "created_at"
	case EventOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EventOrderFieldCreatedAt
	case "updated_at":
		*f = *EventOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid EventOrderField", str)
	}
	return nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	// Value extracts the ordering value from the given Event.
	Value    func(*Event) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) event.OrderOption
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EventOrderField{
		Value: func(_m *Event) (ent.Value, error) {
			return _m.ID, nil
		},
		column: event.FieldID,
		toTerm: event.ByID,
		toCursor: func(_m *Event) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (_m *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EvidenceEdge is the edge representation of Evidence.
type EvidenceEdge struct {
	Node   *Evidence `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// EvidenceConnection is the connection containing edges to Evidence.
type EvidenceConnection struct {
	Edges      []*EvidenceEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *EvidenceConnection) build(nodes []*Evidence, pager *evidencePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Evidence
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Evidence {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Evidence {
			return nodes[i]
		}
	}
	c.Edges = make([]*EvidenceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EvidenceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EvidencePaginateOption enables pagination customization.
type EvidencePaginateOption func(*evidencePager) error

// WithEvidenceOrder configures pagination ordering.
func WithEvidenceOrder(order []*EvidenceOrder) EvidencePaginateOption {
	return func(pager *evidencePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEvidenceFilter configures pagination filter.
func WithEvidenceFilter(filter func(*EvidenceQuery) (*EvidenceQuery, error)) EvidencePaginateOption {
	return func(pager *evidencePager) error {
		if filter == nil {
			return errors.New("EvidenceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type evidencePager struct {
	reverse bool
	order   []*EvidenceOrder
	filter  func(*EvidenceQuery) (*EvidenceQuery, error)
}

func newEvidencePager(opts []EvidencePaginateOption, reverse bool) (*evidencePager, error) {
	pager := &evidencePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *evidencePager) applyFilter(query *EvidenceQuery) (*EvidenceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *evidencePager) toCursor(_m *Evidence) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *evidencePager) applyCursors(query *EvidenceQuery, after, before *Cursor) (*EvidenceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEvidenceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *evidencePager) applyOrder(query *EvidenceQuery) *EvidenceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEvidenceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEvidenceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *evidencePager) orderExpr(query *EvidenceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEvidenceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Evidence.
func (_m *EvidenceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EvidencePaginateOption,
) (*EvidenceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEvidencePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EvidenceConnection{Edges: []*EvidenceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EvidenceOrderFieldCreatedAt orders Evidence by created_at.
	EvidenceOrderFieldCreatedAt = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: evidence.FieldCreatedAt,
		toTerm: evidence.ByCreatedAt,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EvidenceOrderFieldUpdatedAt orders Evidence by updated_at.
	EvidenceOrderFieldUpdatedAt = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: evidence.FieldUpdatedAt,
		toTerm: evidence.ByUpdatedAt,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EvidenceOrderFieldName orders Evidence by name.
	EvidenceOrderFieldName = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.Name, nil
		},
		column: evidence.FieldName,
		toTerm: evidence.ByName,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EvidenceOrderFieldCreationDate orders Evidence by creation_date.
	EvidenceOrderFieldCreationDate = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.CreationDate, nil
		},
		column: evidence.FieldCreationDate,
		toTerm: evidence.ByCreationDate,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreationDate,
			}
		},
	}
	// EvidenceOrderFieldRenewalDate orders Evidence by renewal_date.
	EvidenceOrderFieldRenewalDate = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.RenewalDate, nil
		},
		column: evidence.FieldRenewalDate,
		toTerm: evidence.ByRenewalDate,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RenewalDate,
			}
		},
	}
	// EvidenceOrderFieldStatus orders Evidence by status.
	EvidenceOrderFieldStatus = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.Status, nil
		},
		column: evidence.FieldStatus,
		toTerm: evidence.ByStatus,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EvidenceOrderField) String() string {
	var str string
	switch f.column {
	case EvidenceOrderFieldCreatedAt.column:
		str = "created_at"
	case EvidenceOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EvidenceOrderFieldName.column:
		str = "name"
	case EvidenceOrderFieldCreationDate.column:
		str = "creation_date"
	case EvidenceOrderFieldRenewalDate.column:
		str = "renewal_date"
	case EvidenceOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EvidenceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EvidenceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EvidenceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EvidenceOrderFieldCreatedAt
	case "updated_at":
		*f = *EvidenceOrderFieldUpdatedAt
	case "name":
		*f = *EvidenceOrderFieldName
	case "creation_date":
		*f = *EvidenceOrderFieldCreationDate
	case "renewal_date":
		*f = *EvidenceOrderFieldRenewalDate
	case "STATUS":
		*f = *EvidenceOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EvidenceOrderField", str)
	}
	return nil
}

// EvidenceOrderField defines the ordering field of Evidence.
type EvidenceOrderField struct {
	// Value extracts the ordering value from the given Evidence.
	Value    func(*Evidence) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) evidence.OrderOption
	toCursor func(*Evidence) Cursor
}

// EvidenceOrder defines the ordering of Evidence.
type EvidenceOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *EvidenceOrderField `json:"field"`
}

// DefaultEvidenceOrder is the default ordering of Evidence.
var DefaultEvidenceOrder = &EvidenceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.ID, nil
		},
		column: evidence.FieldID,
		toTerm: evidence.ByID,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Evidence into EvidenceEdge.
func (_m *Evidence) ToEdge(order *EvidenceOrder) *EvidenceEdge {
	if order == nil {
		order = DefaultEvidenceOrder
	}
	return &EvidenceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EvidenceHistoryEdge is the edge representation of EvidenceHistory.
type EvidenceHistoryEdge struct {
	Node   *EvidenceHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// EvidenceHistoryConnection is the connection containing edges to EvidenceHistory.
type EvidenceHistoryConnection struct {
	Edges      []*EvidenceHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *EvidenceHistoryConnection) build(nodes []*EvidenceHistory, pager *evidencehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EvidenceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EvidenceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EvidenceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EvidenceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EvidenceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EvidenceHistoryPaginateOption enables pagination customization.
type EvidenceHistoryPaginateOption func(*evidencehistoryPager) error

// WithEvidenceHistoryOrder configures pagination ordering.
func WithEvidenceHistoryOrder(order *EvidenceHistoryOrder) EvidenceHistoryPaginateOption {
	if order == nil {
		order = DefaultEvidenceHistoryOrder
	}
	o := *order
	return func(pager *evidencehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEvidenceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEvidenceHistoryFilter configures pagination filter.
func WithEvidenceHistoryFilter(filter func(*EvidenceHistoryQuery) (*EvidenceHistoryQuery, error)) EvidenceHistoryPaginateOption {
	return func(pager *evidencehistoryPager) error {
		if filter == nil {
			return errors.New("EvidenceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type evidencehistoryPager struct {
	reverse bool
	order   *EvidenceHistoryOrder
	filter  func(*EvidenceHistoryQuery) (*EvidenceHistoryQuery, error)
}

func newEvidenceHistoryPager(opts []EvidenceHistoryPaginateOption, reverse bool) (*evidencehistoryPager, error) {
	pager := &evidencehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEvidenceHistoryOrder
	}
	return pager, nil
}

func (p *evidencehistoryPager) applyFilter(query *EvidenceHistoryQuery) (*EvidenceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *evidencehistoryPager) toCursor(_m *EvidenceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *evidencehistoryPager) applyCursors(query *EvidenceHistoryQuery, after, before *Cursor) (*EvidenceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEvidenceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *evidencehistoryPager) applyOrder(query *EvidenceHistoryQuery) *EvidenceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEvidenceHistoryOrder.Field {
		query = query.Order(DefaultEvidenceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *evidencehistoryPager) orderExpr(query *EvidenceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEvidenceHistoryOrder.Field {
			b.Comma().Ident(DefaultEvidenceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EvidenceHistory.
func (_m *EvidenceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EvidenceHistoryPaginateOption,
) (*EvidenceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEvidenceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EvidenceHistoryConnection{Edges: []*EvidenceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EvidenceHistoryOrderFieldHistoryTime orders EvidenceHistory by history_time.
	EvidenceHistoryOrderFieldHistoryTime = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: evidencehistory.FieldHistoryTime,
		toTerm: evidencehistory.ByHistoryTime,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// EvidenceHistoryOrderFieldCreatedAt orders EvidenceHistory by created_at.
	EvidenceHistoryOrderFieldCreatedAt = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: evidencehistory.FieldCreatedAt,
		toTerm: evidencehistory.ByCreatedAt,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EvidenceHistoryOrderFieldUpdatedAt orders EvidenceHistory by updated_at.
	EvidenceHistoryOrderFieldUpdatedAt = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: evidencehistory.FieldUpdatedAt,
		toTerm: evidencehistory.ByUpdatedAt,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EvidenceHistoryOrderFieldName orders EvidenceHistory by name.
	EvidenceHistoryOrderFieldName = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: evidencehistory.FieldName,
		toTerm: evidencehistory.ByName,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EvidenceHistoryOrderFieldCreationDate orders EvidenceHistory by creation_date.
	EvidenceHistoryOrderFieldCreationDate = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.CreationDate, nil
		},
		column: evidencehistory.FieldCreationDate,
		toTerm: evidencehistory.ByCreationDate,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreationDate,
			}
		},
	}
	// EvidenceHistoryOrderFieldRenewalDate orders EvidenceHistory by renewal_date.
	EvidenceHistoryOrderFieldRenewalDate = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.RenewalDate, nil
		},
		column: evidencehistory.FieldRenewalDate,
		toTerm: evidencehistory.ByRenewalDate,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RenewalDate,
			}
		},
	}
	// EvidenceHistoryOrderFieldStatus orders EvidenceHistory by status.
	EvidenceHistoryOrderFieldStatus = &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: evidencehistory.FieldStatus,
		toTerm: evidencehistory.ByStatus,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EvidenceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EvidenceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case EvidenceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case EvidenceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EvidenceHistoryOrderFieldName.column:
		str = "name"
	case EvidenceHistoryOrderFieldCreationDate.column:
		str = "creation_date"
	case EvidenceHistoryOrderFieldRenewalDate.column:
		str = "renewal_date"
	case EvidenceHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EvidenceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EvidenceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EvidenceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *EvidenceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *EvidenceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *EvidenceHistoryOrderFieldUpdatedAt
	case "name":
		*f = *EvidenceHistoryOrderFieldName
	case "creation_date":
		*f = *EvidenceHistoryOrderFieldCreationDate
	case "renewal_date":
		*f = *EvidenceHistoryOrderFieldRenewalDate
	case "STATUS":
		*f = *EvidenceHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EvidenceHistoryOrderField", str)
	}
	return nil
}

// EvidenceHistoryOrderField defines the ordering field of EvidenceHistory.
type EvidenceHistoryOrderField struct {
	// Value extracts the ordering value from the given EvidenceHistory.
	Value    func(*EvidenceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) evidencehistory.OrderOption
	toCursor func(*EvidenceHistory) Cursor
}

// EvidenceHistoryOrder defines the ordering of EvidenceHistory.
type EvidenceHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *EvidenceHistoryOrderField `json:"field"`
}

// DefaultEvidenceHistoryOrder is the default ordering of EvidenceHistory.
var DefaultEvidenceHistoryOrder = &EvidenceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EvidenceHistoryOrderField{
		Value: func(_m *EvidenceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: evidencehistory.FieldID,
		toTerm: evidencehistory.ByID,
		toCursor: func(_m *EvidenceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EvidenceHistory into EvidenceHistoryEdge.
func (_m *EvidenceHistory) ToEdge(order *EvidenceHistoryOrder) *EvidenceHistoryEdge {
	if order == nil {
		order = DefaultEvidenceHistoryOrder
	}
	return &EvidenceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ExportEdge is the edge representation of Export.
type ExportEdge struct {
	Node   *Export `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ExportConnection is the connection containing edges to Export.
type ExportConnection struct {
	Edges      []*ExportEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ExportConnection) build(nodes []*Export, pager *exportPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Export
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Export {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Export {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExportEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExportEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExportPaginateOption enables pagination customization.
type ExportPaginateOption func(*exportPager) error

// WithExportOrder configures pagination ordering.
func WithExportOrder(order []*ExportOrder) ExportPaginateOption {
	return func(pager *exportPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithExportFilter configures pagination filter.
func WithExportFilter(filter func(*ExportQuery) (*ExportQuery, error)) ExportPaginateOption {
	return func(pager *exportPager) error {
		if filter == nil {
			return errors.New("ExportQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exportPager struct {
	reverse bool
	order   []*ExportOrder
	filter  func(*ExportQuery) (*ExportQuery, error)
}

func newExportPager(opts []ExportPaginateOption, reverse bool) (*exportPager, error) {
	pager := &exportPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *exportPager) applyFilter(query *ExportQuery) (*ExportQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exportPager) toCursor(_m *Export) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *exportPager) applyCursors(query *ExportQuery, after, before *Cursor) (*ExportQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultExportOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *exportPager) applyOrder(query *ExportQuery) *ExportQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultExportOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultExportOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *exportPager) orderExpr(query *ExportQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultExportOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Export.
func (_m *ExportQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExportPaginateOption,
) (*ExportConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExportPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ExportConnection{Edges: []*ExportEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ExportOrderFieldCreatedAt orders Export by created_at.
	ExportOrderFieldCreatedAt = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: export.FieldCreatedAt,
		toTerm: export.ByCreatedAt,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ExportOrderFieldUpdatedAt orders Export by updated_at.
	ExportOrderFieldUpdatedAt = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: export.FieldUpdatedAt,
		toTerm: export.ByUpdatedAt,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ExportOrderFieldExportType orders Export by export_type.
	ExportOrderFieldExportType = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.ExportType, nil
		},
		column: export.FieldExportType,
		toTerm: export.ByExportType,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExportType,
			}
		},
	}
	// ExportOrderFieldFormat orders Export by format.
	ExportOrderFieldFormat = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.Format, nil
		},
		column: export.FieldFormat,
		toTerm: export.ByFormat,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Format,
			}
		},
	}
	// ExportOrderFieldStatus orders Export by status.
	ExportOrderFieldStatus = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.Status, nil
		},
		column: export.FieldStatus,
		toTerm: export.ByStatus,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ExportOrderField) String() string {
	var str string
	switch f.column {
	case ExportOrderFieldCreatedAt.column:
		str = "created_at"
	case ExportOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ExportOrderFieldExportType.column:
		str = "export_type"
	case ExportOrderFieldFormat.column:
		str = "format"
	case ExportOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ExportOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ExportOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ExportOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ExportOrderFieldCreatedAt
	case "updated_at":
		*f = *ExportOrderFieldUpdatedAt
	case "export_type":
		*f = *ExportOrderFieldExportType
	case "format":
		*f = *ExportOrderFieldFormat
	case "status":
		*f = *ExportOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ExportOrderField", str)
	}
	return nil
}

// ExportOrderField defines the ordering field of Export.
type ExportOrderField struct {
	// Value extracts the ordering value from the given Export.
	Value    func(*Export) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) export.OrderOption
	toCursor func(*Export) Cursor
}

// ExportOrder defines the ordering of Export.
type ExportOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ExportOrderField `json:"field"`
}

// DefaultExportOrder is the default ordering of Export.
var DefaultExportOrder = &ExportOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.ID, nil
		},
		column: export.FieldID,
		toTerm: export.ByID,
		toCursor: func(_m *Export) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Export into ExportEdge.
func (_m *Export) ToEdge(order *ExportOrder) *ExportEdge {
	if order == nil {
		order = DefaultExportOrder
	}
	return &ExportEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order []*FileOrder) FilePaginateOption {
	return func(pager *filePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   []*FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(_m *File) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFileOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFileOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (_m *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileOrderFieldCreatedAt orders File by created_at.
	FileOrderFieldCreatedAt = &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: file.FieldCreatedAt,
		toTerm: file.ByCreatedAt,
		toCursor: func(_m *File) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FileOrderFieldUpdatedAt orders File by updated_at.
	FileOrderFieldUpdatedAt = &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: file.FieldUpdatedAt,
		toTerm: file.ByUpdatedAt,
		toCursor: func(_m *File) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FileOrderFieldLastAccessedAt orders File by last_accessed_at.
	FileOrderFieldLastAccessedAt = &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastAccessedAt == nil {
				return nil, nil
			}
			return _m.LastAccessedAt, nil
		},
		column: file.FieldLastAccessedAt,
		toTerm: func(opts ...sql.OrderTermOption) file.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return file.ByLastAccessedAt(opts...)
		},
		toCursor: func(_m *File) Cursor {
			if _m.LastAccessedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastAccessedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileOrderField) String() string {
	var str string
	switch f.column {
	case FileOrderFieldCreatedAt.column:
		str = "created_at"
	case FileOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FileOrderFieldLastAccessedAt.column:
		str = "last_accessed_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FileOrderFieldCreatedAt
	case "updated_at":
		*f = *FileOrderFieldUpdatedAt
	case "last_accessed_at":
		*f = *FileOrderFieldLastAccessedAt
	default:
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(_m *File) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (_m *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileHistoryEdge is the edge representation of FileHistory.
type FileHistoryEdge struct {
	Node   *FileHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileHistoryConnection is the connection containing edges to FileHistory.
type FileHistoryConnection struct {
	Edges      []*FileHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *FileHistoryConnection) build(nodes []*FileHistory, pager *filehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FileHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileHistoryPaginateOption enables pagination customization.
type FileHistoryPaginateOption func(*filehistoryPager) error

// WithFileHistoryOrder configures pagination ordering.
func WithFileHistoryOrder(order *FileHistoryOrder) FileHistoryPaginateOption {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	o := *order
	return func(pager *filehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileHistoryFilter configures pagination filter.
func WithFileHistoryFilter(filter func(*FileHistoryQuery) (*FileHistoryQuery, error)) FileHistoryPaginateOption {
	return func(pager *filehistoryPager) error {
		if filter == nil {
			return errors.New("FileHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filehistoryPager struct {
	reverse bool
	order   *FileHistoryOrder
	filter  func(*FileHistoryQuery) (*FileHistoryQuery, error)
}

func newFileHistoryPager(opts []FileHistoryPaginateOption, reverse bool) (*filehistoryPager, error) {
	pager := &filehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileHistoryOrder
	}
	return pager, nil
}

func (p *filehistoryPager) applyFilter(query *FileHistoryQuery) (*FileHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filehistoryPager) toCursor(_m *FileHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *filehistoryPager) applyCursors(query *FileHistoryQuery, after, before *Cursor) (*FileHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filehistoryPager) applyOrder(query *FileHistoryQuery) *FileHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileHistoryOrder.Field {
		query = query.Order(DefaultFileHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filehistoryPager) orderExpr(query *FileHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileHistoryOrder.Field {
			b.Comma().Ident(DefaultFileHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileHistory.
func (_m *FileHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileHistoryPaginateOption,
) (*FileHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileHistoryConnection{Edges: []*FileHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileHistoryOrderFieldHistoryTime orders FileHistory by history_time.
	FileHistoryOrderFieldHistoryTime = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: filehistory.FieldHistoryTime,
		toTerm: filehistory.ByHistoryTime,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// FileHistoryOrderFieldCreatedAt orders FileHistory by created_at.
	FileHistoryOrderFieldCreatedAt = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: filehistory.FieldCreatedAt,
		toTerm: filehistory.ByCreatedAt,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FileHistoryOrderFieldUpdatedAt orders FileHistory by updated_at.
	FileHistoryOrderFieldUpdatedAt = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: filehistory.FieldUpdatedAt,
		toTerm: filehistory.ByUpdatedAt,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FileHistoryOrderFieldLastAccessedAt orders FileHistory by last_accessed_at.
	FileHistoryOrderFieldLastAccessedAt = &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastAccessedAt == nil {
				return nil, nil
			}
			return _m.LastAccessedAt, nil
		},
		column: filehistory.FieldLastAccessedAt,
		toTerm: func(opts ...sql.OrderTermOption) filehistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return filehistory.ByLastAccessedAt(opts...)
		},
		toCursor: func(_m *FileHistory) Cursor {
			if _m.LastAccessedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastAccessedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FileHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FileHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FileHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FileHistoryOrderFieldLastAccessedAt.column:
		str = "last_accessed_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FileHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FileHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FileHistoryOrderFieldUpdatedAt
	case "last_accessed_at":
		*f = *FileHistoryOrderFieldLastAccessedAt
	default:
		return fmt.Errorf("%s is not a valid FileHistoryOrderField", str)
	}
	return nil
}

// FileHistoryOrderField defines the ordering field of FileHistory.
type FileHistoryOrderField struct {
	// Value extracts the ordering value from the given FileHistory.
	Value    func(*FileHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filehistory.OrderOption
	toCursor func(*FileHistory) Cursor
}

// FileHistoryOrder defines the ordering of FileHistory.
type FileHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileHistoryOrderField `json:"field"`
}

// DefaultFileHistoryOrder is the default ordering of FileHistory.
var DefaultFileHistoryOrder = &FileHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileHistoryOrderField{
		Value: func(_m *FileHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: filehistory.FieldID,
		toTerm: filehistory.ByID,
		toCursor: func(_m *FileHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FileHistory into FileHistoryEdge.
func (_m *FileHistory) ToEdge(order *FileHistoryOrder) *FileHistoryEdge {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	return &FileHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingEdge is the edge representation of Finding.
type FindingEdge struct {
	Node   *Finding `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FindingConnection is the connection containing edges to Finding.
type FindingConnection struct {
	Edges      []*FindingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *FindingConnection) build(nodes []*Finding, pager *findingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Finding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Finding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Finding {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingPaginateOption enables pagination customization.
type FindingPaginateOption func(*findingPager) error

// WithFindingOrder configures pagination ordering.
func WithFindingOrder(order []*FindingOrder) FindingPaginateOption {
	return func(pager *findingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFindingFilter configures pagination filter.
func WithFindingFilter(filter func(*FindingQuery) (*FindingQuery, error)) FindingPaginateOption {
	return func(pager *findingPager) error {
		if filter == nil {
			return errors.New("FindingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingPager struct {
	reverse bool
	order   []*FindingOrder
	filter  func(*FindingQuery) (*FindingQuery, error)
}

func newFindingPager(opts []FindingPaginateOption, reverse bool) (*findingPager, error) {
	pager := &findingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *findingPager) applyFilter(query *FindingQuery) (*FindingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingPager) toCursor(_m *Finding) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *findingPager) applyCursors(query *FindingQuery, after, before *Cursor) (*FindingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFindingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *findingPager) applyOrder(query *FindingQuery) *FindingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFindingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFindingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *findingPager) orderExpr(query *FindingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFindingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Finding.
func (_m *FindingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingPaginateOption,
) (*FindingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingConnection{Edges: []*FindingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingOrderFieldCreatedAt orders Finding by created_at.
	FindingOrderFieldCreatedAt = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: finding.FieldCreatedAt,
		toTerm: finding.ByCreatedAt,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingOrderFieldUpdatedAt orders Finding by updated_at.
	FindingOrderFieldUpdatedAt = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: finding.FieldUpdatedAt,
		toTerm: finding.ByUpdatedAt,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FindingOrderFieldExternalID orders Finding by external_id.
	FindingOrderFieldExternalID = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: finding.FieldExternalID,
		toTerm: finding.ByExternalID,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// FindingOrderFieldExternalOwnerID orders Finding by external_owner_id.
	FindingOrderFieldExternalOwnerID = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: finding.FieldExternalOwnerID,
		toTerm: finding.ByExternalOwnerID,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// FindingOrderFieldCategory orders Finding by category.
	FindingOrderFieldCategory = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.Category, nil
		},
		column: finding.FieldCategory,
		toTerm: finding.ByCategory,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// FindingOrderFieldSeverity orders Finding by severity.
	FindingOrderFieldSeverity = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: finding.FieldSeverity,
		toTerm: finding.BySeverity,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingOrderField) String() string {
	var str string
	switch f.column {
	case FindingOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FindingOrderFieldExternalID.column:
		str = "external_id"
	case FindingOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case FindingOrderFieldCategory.column:
		str = "category"
	case FindingOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FindingOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingOrderFieldUpdatedAt
	case "external_id":
		*f = *FindingOrderFieldExternalID
	case "external_owner_id":
		*f = *FindingOrderFieldExternalOwnerID
	case "category":
		*f = *FindingOrderFieldCategory
	case "severity":
		*f = *FindingOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid FindingOrderField", str)
	}
	return nil
}

// FindingOrderField defines the ordering field of Finding.
type FindingOrderField struct {
	// Value extracts the ordering value from the given Finding.
	Value    func(*Finding) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) finding.OrderOption
	toCursor func(*Finding) Cursor
}

// FindingOrder defines the ordering of Finding.
type FindingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FindingOrderField `json:"field"`
}

// DefaultFindingOrder is the default ordering of Finding.
var DefaultFindingOrder = &FindingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.ID, nil
		},
		column: finding.FieldID,
		toTerm: finding.ByID,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Finding into FindingEdge.
func (_m *Finding) ToEdge(order *FindingOrder) *FindingEdge {
	if order == nil {
		order = DefaultFindingOrder
	}
	return &FindingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingControlEdge is the edge representation of FindingControl.
type FindingControlEdge struct {
	Node   *FindingControl `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// FindingControlConnection is the connection containing edges to FindingControl.
type FindingControlConnection struct {
	Edges      []*FindingControlEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *FindingControlConnection) build(nodes []*FindingControl, pager *findingcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FindingControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FindingControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FindingControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingControlPaginateOption enables pagination customization.
type FindingControlPaginateOption func(*findingcontrolPager) error

// WithFindingControlOrder configures pagination ordering.
func WithFindingControlOrder(order []*FindingControlOrder) FindingControlPaginateOption {
	return func(pager *findingcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFindingControlFilter configures pagination filter.
func WithFindingControlFilter(filter func(*FindingControlQuery) (*FindingControlQuery, error)) FindingControlPaginateOption {
	return func(pager *findingcontrolPager) error {
		if filter == nil {
			return errors.New("FindingControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingcontrolPager struct {
	reverse bool
	order   []*FindingControlOrder
	filter  func(*FindingControlQuery) (*FindingControlQuery, error)
}

func newFindingControlPager(opts []FindingControlPaginateOption, reverse bool) (*findingcontrolPager, error) {
	pager := &findingcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *findingcontrolPager) applyFilter(query *FindingControlQuery) (*FindingControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingcontrolPager) toCursor(_m *FindingControl) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *findingcontrolPager) applyCursors(query *FindingControlQuery, after, before *Cursor) (*FindingControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFindingControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *findingcontrolPager) applyOrder(query *FindingControlQuery) *FindingControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFindingControlOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFindingControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *findingcontrolPager) orderExpr(query *FindingControlQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFindingControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to FindingControl.
func (_m *FindingControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingControlPaginateOption,
) (*FindingControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingControlConnection{Edges: []*FindingControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingControlOrderFieldCreatedAt orders FindingControl by created_at.
	FindingControlOrderFieldCreatedAt = &FindingControlOrderField{
		Value: func(_m *FindingControl) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: findingcontrol.FieldCreatedAt,
		toTerm: findingcontrol.ByCreatedAt,
		toCursor: func(_m *FindingControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingControlOrderFieldUpdatedAt orders FindingControl by updated_at.
	FindingControlOrderFieldUpdatedAt = &FindingControlOrderField{
		Value: func(_m *FindingControl) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: findingcontrol.FieldUpdatedAt,
		toTerm: findingcontrol.ByUpdatedAt,
		toCursor: func(_m *FindingControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingControlOrderField) String() string {
	var str string
	switch f.column {
	case FindingControlOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FindingControlOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingControlOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FindingControlOrderField", str)
	}
	return nil
}

// FindingControlOrderField defines the ordering field of FindingControl.
type FindingControlOrderField struct {
	// Value extracts the ordering value from the given FindingControl.
	Value    func(*FindingControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) findingcontrol.OrderOption
	toCursor func(*FindingControl) Cursor
}

// FindingControlOrder defines the ordering of FindingControl.
type FindingControlOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *FindingControlOrderField `json:"field"`
}

// DefaultFindingControlOrder is the default ordering of FindingControl.
var DefaultFindingControlOrder = &FindingControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingControlOrderField{
		Value: func(_m *FindingControl) (ent.Value, error) {
			return _m.ID, nil
		},
		column: findingcontrol.FieldID,
		toTerm: findingcontrol.ByID,
		toCursor: func(_m *FindingControl) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FindingControl into FindingControlEdge.
func (_m *FindingControl) ToEdge(order *FindingControlOrder) *FindingControlEdge {
	if order == nil {
		order = DefaultFindingControlOrder
	}
	return &FindingControlEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingControlHistoryEdge is the edge representation of FindingControlHistory.
type FindingControlHistoryEdge struct {
	Node   *FindingControlHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// FindingControlHistoryConnection is the connection containing edges to FindingControlHistory.
type FindingControlHistoryConnection struct {
	Edges      []*FindingControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *FindingControlHistoryConnection) build(nodes []*FindingControlHistory, pager *findingcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FindingControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FindingControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FindingControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingControlHistoryPaginateOption enables pagination customization.
type FindingControlHistoryPaginateOption func(*findingcontrolhistoryPager) error

// WithFindingControlHistoryOrder configures pagination ordering.
func WithFindingControlHistoryOrder(order *FindingControlHistoryOrder) FindingControlHistoryPaginateOption {
	if order == nil {
		order = DefaultFindingControlHistoryOrder
	}
	o := *order
	return func(pager *findingcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingControlHistoryFilter configures pagination filter.
func WithFindingControlHistoryFilter(filter func(*FindingControlHistoryQuery) (*FindingControlHistoryQuery, error)) FindingControlHistoryPaginateOption {
	return func(pager *findingcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("FindingControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingcontrolhistoryPager struct {
	reverse bool
	order   *FindingControlHistoryOrder
	filter  func(*FindingControlHistoryQuery) (*FindingControlHistoryQuery, error)
}

func newFindingControlHistoryPager(opts []FindingControlHistoryPaginateOption, reverse bool) (*findingcontrolhistoryPager, error) {
	pager := &findingcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingControlHistoryOrder
	}
	return pager, nil
}

func (p *findingcontrolhistoryPager) applyFilter(query *FindingControlHistoryQuery) (*FindingControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingcontrolhistoryPager) toCursor(_m *FindingControlHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *findingcontrolhistoryPager) applyCursors(query *FindingControlHistoryQuery, after, before *Cursor) (*FindingControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFindingControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *findingcontrolhistoryPager) applyOrder(query *FindingControlHistoryQuery) *FindingControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFindingControlHistoryOrder.Field {
		query = query.Order(DefaultFindingControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *findingcontrolhistoryPager) orderExpr(query *FindingControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFindingControlHistoryOrder.Field {
			b.Comma().Ident(DefaultFindingControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FindingControlHistory.
func (_m *FindingControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingControlHistoryPaginateOption,
) (*FindingControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingControlHistoryConnection{Edges: []*FindingControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingControlHistoryOrderFieldHistoryTime orders FindingControlHistory by history_time.
	FindingControlHistoryOrderFieldHistoryTime = &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: findingcontrolhistory.FieldHistoryTime,
		toTerm: findingcontrolhistory.ByHistoryTime,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// FindingControlHistoryOrderFieldCreatedAt orders FindingControlHistory by created_at.
	FindingControlHistoryOrderFieldCreatedAt = &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: findingcontrolhistory.FieldCreatedAt,
		toTerm: findingcontrolhistory.ByCreatedAt,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingControlHistoryOrderFieldUpdatedAt orders FindingControlHistory by updated_at.
	FindingControlHistoryOrderFieldUpdatedAt = &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: findingcontrolhistory.FieldUpdatedAt,
		toTerm: findingcontrolhistory.ByUpdatedAt,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FindingControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FindingControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FindingControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FindingControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingControlHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FindingControlHistoryOrderField", str)
	}
	return nil
}

// FindingControlHistoryOrderField defines the ordering field of FindingControlHistory.
type FindingControlHistoryOrderField struct {
	// Value extracts the ordering value from the given FindingControlHistory.
	Value    func(*FindingControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) findingcontrolhistory.OrderOption
	toCursor func(*FindingControlHistory) Cursor
}

// FindingControlHistoryOrder defines the ordering of FindingControlHistory.
type FindingControlHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *FindingControlHistoryOrderField `json:"field"`
}

// DefaultFindingControlHistoryOrder is the default ordering of FindingControlHistory.
var DefaultFindingControlHistoryOrder = &FindingControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingControlHistoryOrderField{
		Value: func(_m *FindingControlHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: findingcontrolhistory.FieldID,
		toTerm: findingcontrolhistory.ByID,
		toCursor: func(_m *FindingControlHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FindingControlHistory into FindingControlHistoryEdge.
func (_m *FindingControlHistory) ToEdge(order *FindingControlHistoryOrder) *FindingControlHistoryEdge {
	if order == nil {
		order = DefaultFindingControlHistoryOrder
	}
	return &FindingControlHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingHistoryEdge is the edge representation of FindingHistory.
type FindingHistoryEdge struct {
	Node   *FindingHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// FindingHistoryConnection is the connection containing edges to FindingHistory.
type FindingHistoryConnection struct {
	Edges      []*FindingHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *FindingHistoryConnection) build(nodes []*FindingHistory, pager *findinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FindingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FindingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FindingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingHistoryPaginateOption enables pagination customization.
type FindingHistoryPaginateOption func(*findinghistoryPager) error

// WithFindingHistoryOrder configures pagination ordering.
func WithFindingHistoryOrder(order *FindingHistoryOrder) FindingHistoryPaginateOption {
	if order == nil {
		order = DefaultFindingHistoryOrder
	}
	o := *order
	return func(pager *findinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingHistoryFilter configures pagination filter.
func WithFindingHistoryFilter(filter func(*FindingHistoryQuery) (*FindingHistoryQuery, error)) FindingHistoryPaginateOption {
	return func(pager *findinghistoryPager) error {
		if filter == nil {
			return errors.New("FindingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findinghistoryPager struct {
	reverse bool
	order   *FindingHistoryOrder
	filter  func(*FindingHistoryQuery) (*FindingHistoryQuery, error)
}

func newFindingHistoryPager(opts []FindingHistoryPaginateOption, reverse bool) (*findinghistoryPager, error) {
	pager := &findinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingHistoryOrder
	}
	return pager, nil
}

func (p *findinghistoryPager) applyFilter(query *FindingHistoryQuery) (*FindingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findinghistoryPager) toCursor(_m *FindingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *findinghistoryPager) applyCursors(query *FindingHistoryQuery, after, before *Cursor) (*FindingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFindingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *findinghistoryPager) applyOrder(query *FindingHistoryQuery) *FindingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFindingHistoryOrder.Field {
		query = query.Order(DefaultFindingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *findinghistoryPager) orderExpr(query *FindingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFindingHistoryOrder.Field {
			b.Comma().Ident(DefaultFindingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FindingHistory.
func (_m *FindingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingHistoryPaginateOption,
) (*FindingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingHistoryConnection{Edges: []*FindingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingHistoryOrderFieldHistoryTime orders FindingHistory by history_time.
	FindingHistoryOrderFieldHistoryTime = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: findinghistory.FieldHistoryTime,
		toTerm: findinghistory.ByHistoryTime,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// FindingHistoryOrderFieldCreatedAt orders FindingHistory by created_at.
	FindingHistoryOrderFieldCreatedAt = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: findinghistory.FieldCreatedAt,
		toTerm: findinghistory.ByCreatedAt,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingHistoryOrderFieldUpdatedAt orders FindingHistory by updated_at.
	FindingHistoryOrderFieldUpdatedAt = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: findinghistory.FieldUpdatedAt,
		toTerm: findinghistory.ByUpdatedAt,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FindingHistoryOrderFieldExternalID orders FindingHistory by external_id.
	FindingHistoryOrderFieldExternalID = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: findinghistory.FieldExternalID,
		toTerm: findinghistory.ByExternalID,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// FindingHistoryOrderFieldExternalOwnerID orders FindingHistory by external_owner_id.
	FindingHistoryOrderFieldExternalOwnerID = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: findinghistory.FieldExternalOwnerID,
		toTerm: findinghistory.ByExternalOwnerID,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// FindingHistoryOrderFieldCategory orders FindingHistory by category.
	FindingHistoryOrderFieldCategory = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: findinghistory.FieldCategory,
		toTerm: findinghistory.ByCategory,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// FindingHistoryOrderFieldSeverity orders FindingHistory by severity.
	FindingHistoryOrderFieldSeverity = &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: findinghistory.FieldSeverity,
		toTerm: findinghistory.BySeverity,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case FindingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case FindingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FindingHistoryOrderFieldExternalID.column:
		str = "external_id"
	case FindingHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case FindingHistoryOrderFieldCategory.column:
		str = "category"
	case FindingHistoryOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *FindingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *FindingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *FindingHistoryOrderFieldExternalID
	case "external_owner_id":
		*f = *FindingHistoryOrderFieldExternalOwnerID
	case "category":
		*f = *FindingHistoryOrderFieldCategory
	case "severity":
		*f = *FindingHistoryOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid FindingHistoryOrderField", str)
	}
	return nil
}

// FindingHistoryOrderField defines the ordering field of FindingHistory.
type FindingHistoryOrderField struct {
	// Value extracts the ordering value from the given FindingHistory.
	Value    func(*FindingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) findinghistory.OrderOption
	toCursor func(*FindingHistory) Cursor
}

// FindingHistoryOrder defines the ordering of FindingHistory.
type FindingHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *FindingHistoryOrderField `json:"field"`
}

// DefaultFindingHistoryOrder is the default ordering of FindingHistory.
var DefaultFindingHistoryOrder = &FindingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingHistoryOrderField{
		Value: func(_m *FindingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: findinghistory.FieldID,
		toTerm: findinghistory.ByID,
		toCursor: func(_m *FindingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FindingHistory into FindingHistoryEdge.
func (_m *FindingHistory) ToEdge(order *FindingHistoryOrder) *FindingHistoryEdge {
	if order == nil {
		order = DefaultFindingHistoryOrder
	}
	return &FindingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupEdge is the edge representation of Group.
type GroupEdge struct {
	Node   *Group `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GroupConnection is the connection containing edges to Group.
type GroupConnection struct {
	Edges      []*GroupEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *GroupConnection) build(nodes []*Group, pager *groupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Group
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Group {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Group {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupPaginateOption enables pagination customization.
type GroupPaginateOption func(*groupPager) error

// WithGroupOrder configures pagination ordering.
func WithGroupOrder(order []*GroupOrder) GroupPaginateOption {
	return func(pager *groupPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupFilter configures pagination filter.
func WithGroupFilter(filter func(*GroupQuery) (*GroupQuery, error)) GroupPaginateOption {
	return func(pager *groupPager) error {
		if filter == nil {
			return errors.New("GroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupPager struct {
	reverse bool
	order   []*GroupOrder
	filter  func(*GroupQuery) (*GroupQuery, error)
}

func newGroupPager(opts []GroupPaginateOption, reverse bool) (*groupPager, error) {
	pager := &groupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupPager) applyFilter(query *GroupQuery) (*GroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupPager) toCursor(_m *Group) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *groupPager) applyCursors(query *GroupQuery, after, before *Cursor) (*GroupQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupPager) applyOrder(query *GroupQuery) *GroupQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupPager) orderExpr(query *GroupQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Group.
func (_m *GroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupPaginateOption,
) (*GroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupConnection{Edges: []*GroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupOrderFieldCreatedAt orders Group by created_at.
	GroupOrderFieldCreatedAt = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: group.FieldCreatedAt,
		toTerm: group.ByCreatedAt,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupOrderFieldUpdatedAt orders Group by updated_at.
	GroupOrderFieldUpdatedAt = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: group.FieldUpdatedAt,
		toTerm: group.ByUpdatedAt,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupOrderFieldName orders Group by name.
	GroupOrderFieldName = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.Name, nil
		},
		column: group.FieldName,
		toTerm: group.ByName,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// GroupOrderFieldDisplayName orders Group by display_name.
	GroupOrderFieldDisplayName = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: group.FieldDisplayName,
		toTerm: group.ByDisplayName,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupOrderField) String() string {
	var str string
	switch f.column {
	case GroupOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupOrderFieldName.column:
		str = "name"
	case GroupOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupOrderFieldUpdatedAt
	case "name":
		*f = *GroupOrderFieldName
	case "display_name":
		*f = *GroupOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

// GroupOrderField defines the ordering field of Group.
type GroupOrderField struct {
	// Value extracts the ordering value from the given Group.
	Value    func(*Group) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) group.OrderOption
	toCursor func(*Group) Cursor
}

// GroupOrder defines the ordering of Group.
type GroupOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *GroupOrderField `json:"field"`
}

// DefaultGroupOrder is the default ordering of Group.
var DefaultGroupOrder = &GroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.ID, nil
		},
		column: group.FieldID,
		toTerm: group.ByID,
		toCursor: func(_m *Group) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Group into GroupEdge.
func (_m *Group) ToEdge(order *GroupOrder) *GroupEdge {
	if order == nil {
		order = DefaultGroupOrder
	}
	return &GroupEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupHistoryEdge is the edge representation of GroupHistory.
type GroupHistoryEdge struct {
	Node   *GroupHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupHistoryConnection is the connection containing edges to GroupHistory.
type GroupHistoryConnection struct {
	Edges      []*GroupHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupHistoryConnection) build(nodes []*GroupHistory, pager *grouphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupHistoryPaginateOption enables pagination customization.
type GroupHistoryPaginateOption func(*grouphistoryPager) error

// WithGroupHistoryOrder configures pagination ordering.
func WithGroupHistoryOrder(order *GroupHistoryOrder) GroupHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	o := *order
	return func(pager *grouphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupHistoryFilter configures pagination filter.
func WithGroupHistoryFilter(filter func(*GroupHistoryQuery) (*GroupHistoryQuery, error)) GroupHistoryPaginateOption {
	return func(pager *grouphistoryPager) error {
		if filter == nil {
			return errors.New("GroupHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type grouphistoryPager struct {
	reverse bool
	order   *GroupHistoryOrder
	filter  func(*GroupHistoryQuery) (*GroupHistoryQuery, error)
}

func newGroupHistoryPager(opts []GroupHistoryPaginateOption, reverse bool) (*grouphistoryPager, error) {
	pager := &grouphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupHistoryOrder
	}
	return pager, nil
}

func (p *grouphistoryPager) applyFilter(query *GroupHistoryQuery) (*GroupHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *grouphistoryPager) toCursor(_m *GroupHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *grouphistoryPager) applyCursors(query *GroupHistoryQuery, after, before *Cursor) (*GroupHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *grouphistoryPager) applyOrder(query *GroupHistoryQuery) *GroupHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupHistoryOrder.Field {
		query = query.Order(DefaultGroupHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *grouphistoryPager) orderExpr(query *GroupHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupHistory.
func (_m *GroupHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupHistoryPaginateOption,
) (*GroupHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupHistoryConnection{Edges: []*GroupHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupHistoryOrderFieldHistoryTime orders GroupHistory by history_time.
	GroupHistoryOrderFieldHistoryTime = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: grouphistory.FieldHistoryTime,
		toTerm: grouphistory.ByHistoryTime,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// GroupHistoryOrderFieldCreatedAt orders GroupHistory by created_at.
	GroupHistoryOrderFieldCreatedAt = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: grouphistory.FieldCreatedAt,
		toTerm: grouphistory.ByCreatedAt,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupHistoryOrderFieldUpdatedAt orders GroupHistory by updated_at.
	GroupHistoryOrderFieldUpdatedAt = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: grouphistory.FieldUpdatedAt,
		toTerm: grouphistory.ByUpdatedAt,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupHistoryOrderFieldName orders GroupHistory by name.
	GroupHistoryOrderFieldName = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: grouphistory.FieldName,
		toTerm: grouphistory.ByName,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// GroupHistoryOrderFieldDisplayName orders GroupHistory by display_name.
	GroupHistoryOrderFieldDisplayName = &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: grouphistory.FieldDisplayName,
		toTerm: grouphistory.ByDisplayName,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupHistoryOrderFieldName.column:
		str = "name"
	case GroupHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupHistoryOrderFieldUpdatedAt
	case "name":
		*f = *GroupHistoryOrderFieldName
	case "display_name":
		*f = *GroupHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

// GroupHistoryOrderField defines the ordering field of GroupHistory.
type GroupHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupHistory.
	Value    func(*GroupHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) grouphistory.OrderOption
	toCursor func(*GroupHistory) Cursor
}

// GroupHistoryOrder defines the ordering of GroupHistory.
type GroupHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupHistoryOrderField `json:"field"`
}

// DefaultGroupHistoryOrder is the default ordering of GroupHistory.
var DefaultGroupHistoryOrder = &GroupHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupHistoryOrderField{
		Value: func(_m *GroupHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: grouphistory.FieldID,
		toTerm: grouphistory.ByID,
		toCursor: func(_m *GroupHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupHistory into GroupHistoryEdge.
func (_m *GroupHistory) ToEdge(order *GroupHistoryOrder) *GroupHistoryEdge {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	return &GroupHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupMembershipEdge is the edge representation of GroupMembership.
type GroupMembershipEdge struct {
	Node   *GroupMembership `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// GroupMembershipConnection is the connection containing edges to GroupMembership.
type GroupMembershipConnection struct {
	Edges      []*GroupMembershipEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *GroupMembershipConnection) build(nodes []*GroupMembership, pager *groupmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipPaginateOption enables pagination customization.
type GroupMembershipPaginateOption func(*groupmembershipPager) error

// WithGroupMembershipOrder configures pagination ordering.
func WithGroupMembershipOrder(order []*GroupMembershipOrder) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupMembershipFilter configures pagination filter.
func WithGroupMembershipFilter(filter func(*GroupMembershipQuery) (*GroupMembershipQuery, error)) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		if filter == nil {
			return errors.New("GroupMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershipPager struct {
	reverse bool
	order   []*GroupMembershipOrder
	filter  func(*GroupMembershipQuery) (*GroupMembershipQuery, error)
}

func newGroupMembershipPager(opts []GroupMembershipPaginateOption, reverse bool) (*groupmembershipPager, error) {
	pager := &groupmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupmembershipPager) applyFilter(query *GroupMembershipQuery) (*GroupMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershipPager) toCursor(_m *GroupMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *groupmembershipPager) applyCursors(query *GroupMembershipQuery, after, before *Cursor) (*GroupMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupmembershipPager) applyOrder(query *GroupMembershipQuery) *GroupMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupmembershipPager) orderExpr(query *GroupMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembership.
func (_m *GroupMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipPaginateOption,
) (*GroupMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupMembershipConnection{Edges: []*GroupMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupMembershipOrderFieldCreatedAt orders GroupMembership by created_at.
	GroupMembershipOrderFieldCreatedAt = &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupmembership.FieldCreatedAt,
		toTerm: groupmembership.ByCreatedAt,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupMembershipOrderFieldUpdatedAt orders GroupMembership by updated_at.
	GroupMembershipOrderFieldUpdatedAt = &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupmembership.FieldUpdatedAt,
		toTerm: groupmembership.ByUpdatedAt,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupMembershipOrderFieldRole orders GroupMembership by role.
	GroupMembershipOrderFieldRole = &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.Role, nil
		},
		column: groupmembership.FieldRole,
		toTerm: groupmembership.ByRole,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupMembershipOrderField) String() string {
	var str string
	switch f.column {
	case GroupMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *GroupMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid GroupMembershipOrderField", str)
	}
	return nil
}

// GroupMembershipOrderField defines the ordering field of GroupMembership.
type GroupMembershipOrderField struct {
	// Value extracts the ordering value from the given GroupMembership.
	Value    func(*GroupMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembership.OrderOption
	toCursor func(*GroupMembership) Cursor
}

// GroupMembershipOrder defines the ordering of GroupMembership.
type GroupMembershipOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *GroupMembershipOrderField `json:"field"`
}

// DefaultGroupMembershipOrder is the default ordering of GroupMembership.
var DefaultGroupMembershipOrder = &GroupMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupmembership.FieldID,
		toTerm: groupmembership.ByID,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupMembership into GroupMembershipEdge.
func (_m *GroupMembership) ToEdge(order *GroupMembershipOrder) *GroupMembershipEdge {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	return &GroupMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupMembershipHistoryEdge is the edge representation of GroupMembershipHistory.
type GroupMembershipHistoryEdge struct {
	Node   *GroupMembershipHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// GroupMembershipHistoryConnection is the connection containing edges to GroupMembershipHistory.
type GroupMembershipHistoryConnection struct {
	Edges      []*GroupMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *GroupMembershipHistoryConnection) build(nodes []*GroupMembershipHistory, pager *groupmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipHistoryPaginateOption enables pagination customization.
type GroupMembershipHistoryPaginateOption func(*groupmembershiphistoryPager) error

// WithGroupMembershipHistoryOrder configures pagination ordering.
func WithGroupMembershipHistoryOrder(order *GroupMembershipHistoryOrder) GroupMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	o := *order
	return func(pager *groupmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipHistoryFilter configures pagination filter.
func WithGroupMembershipHistoryFilter(filter func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)) GroupMembershipHistoryPaginateOption {
	return func(pager *groupmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("GroupMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershiphistoryPager struct {
	reverse bool
	order   *GroupMembershipHistoryOrder
	filter  func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)
}

func newGroupMembershipHistoryPager(opts []GroupMembershipHistoryPaginateOption, reverse bool) (*groupmembershiphistoryPager, error) {
	pager := &groupmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipHistoryOrder
	}
	return pager, nil
}

func (p *groupmembershiphistoryPager) applyFilter(query *GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) toCursor(_m *GroupMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *groupmembershiphistoryPager) applyCursors(query *GroupMembershipHistoryQuery, after, before *Cursor) (*GroupMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) applyOrder(query *GroupMembershipHistoryQuery) *GroupMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
		query = query.Order(DefaultGroupMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershiphistoryPager) orderExpr(query *GroupMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembershipHistory.
func (_m *GroupMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipHistoryPaginateOption,
) (*GroupMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupMembershipHistoryConnection{Edges: []*GroupMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupMembershipHistoryOrderFieldHistoryTime orders GroupMembershipHistory by history_time.
	GroupMembershipHistoryOrderFieldHistoryTime = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: groupmembershiphistory.FieldHistoryTime,
		toTerm: groupmembershiphistory.ByHistoryTime,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldCreatedAt orders GroupMembershipHistory by created_at.
	GroupMembershipHistoryOrderFieldCreatedAt = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupmembershiphistory.FieldCreatedAt,
		toTerm: groupmembershiphistory.ByCreatedAt,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldUpdatedAt orders GroupMembershipHistory by updated_at.
	GroupMembershipHistoryOrderFieldUpdatedAt = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupmembershiphistory.FieldUpdatedAt,
		toTerm: groupmembershiphistory.ByUpdatedAt,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupMembershipHistoryOrderFieldRole orders GroupMembershipHistory by role.
	GroupMembershipHistoryOrderFieldRole = &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.Role, nil
		},
		column: groupmembershiphistory.FieldRole,
		toTerm: groupmembershiphistory.ByRole,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *GroupMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid GroupMembershipHistoryOrderField", str)
	}
	return nil
}

// GroupMembershipHistoryOrderField defines the ordering field of GroupMembershipHistory.
type GroupMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupMembershipHistory.
	Value    func(*GroupMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembershiphistory.OrderOption
	toCursor func(*GroupMembershipHistory) Cursor
}

// GroupMembershipHistoryOrder defines the ordering of GroupMembershipHistory.
type GroupMembershipHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *GroupMembershipHistoryOrderField `json:"field"`
}

// DefaultGroupMembershipHistoryOrder is the default ordering of GroupMembershipHistory.
var DefaultGroupMembershipHistoryOrder = &GroupMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipHistoryOrderField{
		Value: func(_m *GroupMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupmembershiphistory.FieldID,
		toTerm: groupmembershiphistory.ByID,
		toCursor: func(_m *GroupMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupMembershipHistory into GroupMembershipHistoryEdge.
func (_m *GroupMembershipHistory) ToEdge(order *GroupMembershipHistoryOrder) *GroupMembershipHistoryEdge {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	return &GroupMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupSettingEdge is the edge representation of GroupSetting.
type GroupSettingEdge struct {
	Node   *GroupSetting `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupSettingConnection is the connection containing edges to GroupSetting.
type GroupSettingConnection struct {
	Edges      []*GroupSettingEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupSettingConnection) build(nodes []*GroupSetting, pager *groupsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingPaginateOption enables pagination customization.
type GroupSettingPaginateOption func(*groupsettingPager) error

// WithGroupSettingOrder configures pagination ordering.
func WithGroupSettingOrder(order []*GroupSettingOrder) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupSettingFilter configures pagination filter.
func WithGroupSettingFilter(filter func(*GroupSettingQuery) (*GroupSettingQuery, error)) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		if filter == nil {
			return errors.New("GroupSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettingPager struct {
	reverse bool
	order   []*GroupSettingOrder
	filter  func(*GroupSettingQuery) (*GroupSettingQuery, error)
}

func newGroupSettingPager(opts []GroupSettingPaginateOption, reverse bool) (*groupsettingPager, error) {
	pager := &groupsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupsettingPager) applyFilter(query *GroupSettingQuery) (*GroupSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettingPager) toCursor(_m *GroupSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *groupsettingPager) applyCursors(query *GroupSettingQuery, after, before *Cursor) (*GroupSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupsettingPager) applyOrder(query *GroupSettingQuery) *GroupSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupsettingPager) orderExpr(query *GroupSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSetting.
func (_m *GroupSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingPaginateOption,
) (*GroupSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupSettingConnection{Edges: []*GroupSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupSettingOrderFieldCreatedAt orders GroupSetting by created_at.
	GroupSettingOrderFieldCreatedAt = &GroupSettingOrderField{
		Value: func(_m *GroupSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupsetting.FieldCreatedAt,
		toTerm: groupsetting.ByCreatedAt,
		toCursor: func(_m *GroupSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupSettingOrderFieldUpdatedAt orders GroupSetting by updated_at.
	GroupSettingOrderFieldUpdatedAt = &GroupSettingOrderField{
		Value: func(_m *GroupSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupsetting.FieldUpdatedAt,
		toTerm: groupsetting.ByUpdatedAt,
		toCursor: func(_m *GroupSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupSettingOrderField) String() string {
	var str string
	switch f.column {
	case GroupSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GroupSettingOrderField", str)
	}
	return nil
}

// GroupSettingOrderField defines the ordering field of GroupSetting.
type GroupSettingOrderField struct {
	// Value extracts the ordering value from the given GroupSetting.
	Value    func(*GroupSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsetting.OrderOption
	toCursor func(*GroupSetting) Cursor
}

// GroupSettingOrder defines the ordering of GroupSetting.
type GroupSettingOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupSettingOrderField `json:"field"`
}

// DefaultGroupSettingOrder is the default ordering of GroupSetting.
var DefaultGroupSettingOrder = &GroupSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingOrderField{
		Value: func(_m *GroupSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupsetting.FieldID,
		toTerm: groupsetting.ByID,
		toCursor: func(_m *GroupSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupSetting into GroupSettingEdge.
func (_m *GroupSetting) ToEdge(order *GroupSettingOrder) *GroupSettingEdge {
	if order == nil {
		order = DefaultGroupSettingOrder
	}
	return &GroupSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupSettingHistoryEdge is the edge representation of GroupSettingHistory.
type GroupSettingHistoryEdge struct {
	Node   *GroupSettingHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// GroupSettingHistoryConnection is the connection containing edges to GroupSettingHistory.
type GroupSettingHistoryConnection struct {
	Edges      []*GroupSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *GroupSettingHistoryConnection) build(nodes []*GroupSettingHistory, pager *groupsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingHistoryPaginateOption enables pagination customization.
type GroupSettingHistoryPaginateOption func(*groupsettinghistoryPager) error

// WithGroupSettingHistoryOrder configures pagination ordering.
func WithGroupSettingHistoryOrder(order *GroupSettingHistoryOrder) GroupSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	o := *order
	return func(pager *groupsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupSettingHistoryFilter configures pagination filter.
func WithGroupSettingHistoryFilter(filter func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)) GroupSettingHistoryPaginateOption {
	return func(pager *groupsettinghistoryPager) error {
		if filter == nil {
			return errors.New("GroupSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettinghistoryPager struct {
	reverse bool
	order   *GroupSettingHistoryOrder
	filter  func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)
}

func newGroupSettingHistoryPager(opts []GroupSettingHistoryPaginateOption, reverse bool) (*groupsettinghistoryPager, error) {
	pager := &groupsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupSettingHistoryOrder
	}
	return pager, nil
}

func (p *groupsettinghistoryPager) applyFilter(query *GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) toCursor(_m *GroupSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *groupsettinghistoryPager) applyCursors(query *GroupSettingHistoryQuery, after, before *Cursor) (*GroupSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) applyOrder(query *GroupSettingHistoryQuery) *GroupSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
		query = query.Order(DefaultGroupSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupsettinghistoryPager) orderExpr(query *GroupSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSettingHistory.
func (_m *GroupSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingHistoryPaginateOption,
) (*GroupSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupSettingHistoryConnection{Edges: []*GroupSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupSettingHistoryOrderFieldHistoryTime orders GroupSettingHistory by history_time.
	GroupSettingHistoryOrderFieldHistoryTime = &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: groupsettinghistory.FieldHistoryTime,
		toTerm: groupsettinghistory.ByHistoryTime,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// GroupSettingHistoryOrderFieldCreatedAt orders GroupSettingHistory by created_at.
	GroupSettingHistoryOrderFieldCreatedAt = &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupsettinghistory.FieldCreatedAt,
		toTerm: groupsettinghistory.ByCreatedAt,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupSettingHistoryOrderFieldUpdatedAt orders GroupSettingHistory by updated_at.
	GroupSettingHistoryOrderFieldUpdatedAt = &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupsettinghistory.FieldUpdatedAt,
		toTerm: groupsettinghistory.ByUpdatedAt,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case GroupSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *GroupSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *GroupSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GroupSettingHistoryOrderField", str)
	}
	return nil
}

// GroupSettingHistoryOrderField defines the ordering field of GroupSettingHistory.
type GroupSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupSettingHistory.
	Value    func(*GroupSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsettinghistory.OrderOption
	toCursor func(*GroupSettingHistory) Cursor
}

// GroupSettingHistoryOrder defines the ordering of GroupSettingHistory.
type GroupSettingHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *GroupSettingHistoryOrderField `json:"field"`
}

// DefaultGroupSettingHistoryOrder is the default ordering of GroupSettingHistory.
var DefaultGroupSettingHistoryOrder = &GroupSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingHistoryOrderField{
		Value: func(_m *GroupSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupsettinghistory.FieldID,
		toTerm: groupsettinghistory.ByID,
		toCursor: func(_m *GroupSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupSettingHistory into GroupSettingHistoryEdge.
func (_m *GroupSettingHistory) ToEdge(order *GroupSettingHistoryOrder) *GroupSettingHistoryEdge {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	return &GroupSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// HushEdge is the edge representation of Hush.
type HushEdge struct {
	Node   *Hush  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HushConnection is the connection containing edges to Hush.
type HushConnection struct {
	Edges      []*HushEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *HushConnection) build(nodes []*Hush, pager *hushPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Hush
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Hush {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Hush {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushPaginateOption enables pagination customization.
type HushPaginateOption func(*hushPager) error

// WithHushOrder configures pagination ordering.
func WithHushOrder(order []*HushOrder) HushPaginateOption {
	return func(pager *hushPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithHushFilter configures pagination filter.
func WithHushFilter(filter func(*HushQuery) (*HushQuery, error)) HushPaginateOption {
	return func(pager *hushPager) error {
		if filter == nil {
			return errors.New("HushQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushPager struct {
	reverse bool
	order   []*HushOrder
	filter  func(*HushQuery) (*HushQuery, error)
}

func newHushPager(opts []HushPaginateOption, reverse bool) (*hushPager, error) {
	pager := &hushPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *hushPager) applyFilter(query *HushQuery) (*HushQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushPager) toCursor(_m *Hush) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *hushPager) applyCursors(query *HushQuery, after, before *Cursor) (*HushQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultHushOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *hushPager) applyOrder(query *HushQuery) *HushQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultHushOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultHushOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *hushPager) orderExpr(query *HushQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultHushOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Hush.
func (_m *HushQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushPaginateOption,
) (*HushConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &HushConnection{Edges: []*HushEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushOrderFieldCreatedAt orders Hush by created_at.
	HushOrderFieldCreatedAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: hush.FieldCreatedAt,
		toTerm: hush.ByCreatedAt,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// HushOrderFieldUpdatedAt orders Hush by updated_at.
	HushOrderFieldUpdatedAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: hush.FieldUpdatedAt,
		toTerm: hush.ByUpdatedAt,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// HushOrderFieldName orders Hush by name.
	HushOrderFieldName = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.Name, nil
		},
		column: hush.FieldName,
		toTerm: hush.ByName,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// HushOrderFieldKind orders Hush by kind.
	HushOrderFieldKind = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: hush.FieldKind,
		toTerm: hush.ByKind,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// HushOrderFieldLastUsedAt orders Hush by last_used_at.
	HushOrderFieldLastUsedAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: hush.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) hush.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hush.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *Hush) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// HushOrderFieldExpiresAt orders Hush by expires_at.
	HushOrderFieldExpiresAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: hush.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) hush.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hush.ByExpiresAt(opts...)
		},
		toCursor: func(_m *Hush) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushOrderField) String() string {
	var str string
	switch f.column {
	case HushOrderFieldCreatedAt.column:
		str = "created_at"
	case HushOrderFieldUpdatedAt.column:
		str = "updated_at"
	case HushOrderFieldName.column:
		str = "name"
	case HushOrderFieldKind.column:
		str = "kind"
	case HushOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case HushOrderFieldExpiresAt.column:
		str = "expires_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HushOrderFieldCreatedAt
	case "updated_at":
		*f = *HushOrderFieldUpdatedAt
	case "name":
		*f = *HushOrderFieldName
	case "kind":
		*f = *HushOrderFieldKind
	case "last_used_at":
		*f = *HushOrderFieldLastUsedAt
	case "expires_at":
		*f = *HushOrderFieldExpiresAt
	default:
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

// HushOrderField defines the ordering field of Hush.
type HushOrderField struct {
	// Value extracts the ordering value from the given Hush.
	Value    func(*Hush) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hush.OrderOption
	toCursor func(*Hush) Cursor
}

// HushOrder defines the ordering of Hush.
type HushOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HushOrderField `json:"field"`
}

// DefaultHushOrder is the default ordering of Hush.
var DefaultHushOrder = &HushOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.ID, nil
		},
		column: hush.FieldID,
		toTerm: hush.ByID,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Hush into HushEdge.
func (_m *Hush) ToEdge(order *HushOrder) *HushEdge {
	if order == nil {
		order = DefaultHushOrder
	}
	return &HushEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// HushHistoryEdge is the edge representation of HushHistory.
type HushHistoryEdge struct {
	Node   *HushHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// HushHistoryConnection is the connection containing edges to HushHistory.
type HushHistoryConnection struct {
	Edges      []*HushHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *HushHistoryConnection) build(nodes []*HushHistory, pager *hushhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *HushHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HushHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HushHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushHistoryPaginateOption enables pagination customization.
type HushHistoryPaginateOption func(*hushhistoryPager) error

// WithHushHistoryOrder configures pagination ordering.
func WithHushHistoryOrder(order *HushHistoryOrder) HushHistoryPaginateOption {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	o := *order
	return func(pager *hushhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHushHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHushHistoryFilter configures pagination filter.
func WithHushHistoryFilter(filter func(*HushHistoryQuery) (*HushHistoryQuery, error)) HushHistoryPaginateOption {
	return func(pager *hushhistoryPager) error {
		if filter == nil {
			return errors.New("HushHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushhistoryPager struct {
	reverse bool
	order   *HushHistoryOrder
	filter  func(*HushHistoryQuery) (*HushHistoryQuery, error)
}

func newHushHistoryPager(opts []HushHistoryPaginateOption, reverse bool) (*hushhistoryPager, error) {
	pager := &hushhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHushHistoryOrder
	}
	return pager, nil
}

func (p *hushhistoryPager) applyFilter(query *HushHistoryQuery) (*HushHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushhistoryPager) toCursor(_m *HushHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *hushhistoryPager) applyCursors(query *HushHistoryQuery, after, before *Cursor) (*HushHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHushHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hushhistoryPager) applyOrder(query *HushHistoryQuery) *HushHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHushHistoryOrder.Field {
		query = query.Order(DefaultHushHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hushhistoryPager) orderExpr(query *HushHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHushHistoryOrder.Field {
			b.Comma().Ident(DefaultHushHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HushHistory.
func (_m *HushHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushHistoryPaginateOption,
) (*HushHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &HushHistoryConnection{Edges: []*HushHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushHistoryOrderFieldHistoryTime orders HushHistory by history_time.
	HushHistoryOrderFieldHistoryTime = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: hushhistory.FieldHistoryTime,
		toTerm: hushhistory.ByHistoryTime,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// HushHistoryOrderFieldCreatedAt orders HushHistory by created_at.
	HushHistoryOrderFieldCreatedAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: hushhistory.FieldCreatedAt,
		toTerm: hushhistory.ByCreatedAt,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// HushHistoryOrderFieldUpdatedAt orders HushHistory by updated_at.
	HushHistoryOrderFieldUpdatedAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: hushhistory.FieldUpdatedAt,
		toTerm: hushhistory.ByUpdatedAt,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// HushHistoryOrderFieldName orders HushHistory by name.
	HushHistoryOrderFieldName = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: hushhistory.FieldName,
		toTerm: hushhistory.ByName,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// HushHistoryOrderFieldKind orders HushHistory by kind.
	HushHistoryOrderFieldKind = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: hushhistory.FieldKind,
		toTerm: hushhistory.ByKind,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// HushHistoryOrderFieldLastUsedAt orders HushHistory by last_used_at.
	HushHistoryOrderFieldLastUsedAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: hushhistory.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) hushhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hushhistory.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *HushHistory) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// HushHistoryOrderFieldExpiresAt orders HushHistory by expires_at.
	HushHistoryOrderFieldExpiresAt = &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: hushhistory.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) hushhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hushhistory.ByExpiresAt(opts...)
		},
		toCursor: func(_m *HushHistory) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushHistoryOrderField) String() string {
	var str string
	switch f.column {
	case HushHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case HushHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case HushHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case HushHistoryOrderFieldName.column:
		str = "name"
	case HushHistoryOrderFieldKind.column:
		str = "kind"
	case HushHistoryOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case HushHistoryOrderFieldExpiresAt.column:
		str = "expires_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *HushHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *HushHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *HushHistoryOrderFieldUpdatedAt
	case "name":
		*f = *HushHistoryOrderFieldName
	case "kind":
		*f = *HushHistoryOrderFieldKind
	case "last_used_at":
		*f = *HushHistoryOrderFieldLastUsedAt
	case "expires_at":
		*f = *HushHistoryOrderFieldExpiresAt
	default:
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

// HushHistoryOrderField defines the ordering field of HushHistory.
type HushHistoryOrderField struct {
	// Value extracts the ordering value from the given HushHistory.
	Value    func(*HushHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hushhistory.OrderOption
	toCursor func(*HushHistory) Cursor
}

// HushHistoryOrder defines the ordering of HushHistory.
type HushHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *HushHistoryOrderField `json:"field"`
}

// DefaultHushHistoryOrder is the default ordering of HushHistory.
var DefaultHushHistoryOrder = &HushHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushHistoryOrderField{
		Value: func(_m *HushHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: hushhistory.FieldID,
		toTerm: hushhistory.ByID,
		toCursor: func(_m *HushHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts HushHistory into HushHistoryEdge.
func (_m *HushHistory) ToEdge(order *HushHistoryOrder) *HushHistoryEdge {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	return &HushHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// IntegrationEdge is the edge representation of Integration.
type IntegrationEdge struct {
	Node   *Integration `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// IntegrationConnection is the connection containing edges to Integration.
type IntegrationConnection struct {
	Edges      []*IntegrationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *IntegrationConnection) build(nodes []*Integration, pager *integrationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Integration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Integration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Integration {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationPaginateOption enables pagination customization.
type IntegrationPaginateOption func(*integrationPager) error

// WithIntegrationOrder configures pagination ordering.
func WithIntegrationOrder(order []*IntegrationOrder) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithIntegrationFilter configures pagination filter.
func WithIntegrationFilter(filter func(*IntegrationQuery) (*IntegrationQuery, error)) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		if filter == nil {
			return errors.New("IntegrationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationPager struct {
	reverse bool
	order   []*IntegrationOrder
	filter  func(*IntegrationQuery) (*IntegrationQuery, error)
}

func newIntegrationPager(opts []IntegrationPaginateOption, reverse bool) (*integrationPager, error) {
	pager := &integrationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *integrationPager) applyFilter(query *IntegrationQuery) (*IntegrationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationPager) toCursor(_m *Integration) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *integrationPager) applyCursors(query *IntegrationQuery, after, before *Cursor) (*IntegrationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultIntegrationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *integrationPager) applyOrder(query *IntegrationQuery) *IntegrationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultIntegrationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultIntegrationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *integrationPager) orderExpr(query *IntegrationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultIntegrationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Integration.
func (_m *IntegrationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationPaginateOption,
) (*IntegrationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &IntegrationConnection{Edges: []*IntegrationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationOrderFieldCreatedAt orders Integration by created_at.
	IntegrationOrderFieldCreatedAt = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: integration.FieldCreatedAt,
		toTerm: integration.ByCreatedAt,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// IntegrationOrderFieldUpdatedAt orders Integration by updated_at.
	IntegrationOrderFieldUpdatedAt = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: integration.FieldUpdatedAt,
		toTerm: integration.ByUpdatedAt,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// IntegrationOrderFieldName orders Integration by name.
	IntegrationOrderFieldName = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.Name, nil
		},
		column: integration.FieldName,
		toTerm: integration.ByName,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// IntegrationOrderFieldKind orders Integration by kind.
	IntegrationOrderFieldKind = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: integration.FieldKind,
		toTerm: integration.ByKind,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// IntegrationOrderFieldIntegrationType orders Integration by integration_type.
	IntegrationOrderFieldIntegrationType = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.IntegrationType, nil
		},
		column: integration.FieldIntegrationType,
		toTerm: integration.ByIntegrationType,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IntegrationType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationOrderFieldCreatedAt.column:
		str = "created_at"
	case IntegrationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IntegrationOrderFieldName.column:
		str = "name"
	case IntegrationOrderFieldKind.column:
		str = "kind"
	case IntegrationOrderFieldIntegrationType.column:
		str = "integration_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *IntegrationOrderFieldCreatedAt
	case "updated_at":
		*f = *IntegrationOrderFieldUpdatedAt
	case "name":
		*f = *IntegrationOrderFieldName
	case "kind":
		*f = *IntegrationOrderFieldKind
	case "integration_type":
		*f = *IntegrationOrderFieldIntegrationType
	default:
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

// IntegrationOrderField defines the ordering field of Integration.
type IntegrationOrderField struct {
	// Value extracts the ordering value from the given Integration.
	Value    func(*Integration) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integration.OrderOption
	toCursor func(*Integration) Cursor
}

// IntegrationOrder defines the ordering of Integration.
type IntegrationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *IntegrationOrderField `json:"field"`
}

// DefaultIntegrationOrder is the default ordering of Integration.
var DefaultIntegrationOrder = &IntegrationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.ID, nil
		},
		column: integration.FieldID,
		toTerm: integration.ByID,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Integration into IntegrationEdge.
func (_m *Integration) ToEdge(order *IntegrationOrder) *IntegrationEdge {
	if order == nil {
		order = DefaultIntegrationOrder
	}
	return &IntegrationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// IntegrationHistoryEdge is the edge representation of IntegrationHistory.
type IntegrationHistoryEdge struct {
	Node   *IntegrationHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// IntegrationHistoryConnection is the connection containing edges to IntegrationHistory.
type IntegrationHistoryConnection struct {
	Edges      []*IntegrationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *IntegrationHistoryConnection) build(nodes []*IntegrationHistory, pager *integrationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *IntegrationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationHistoryPaginateOption enables pagination customization.
type IntegrationHistoryPaginateOption func(*integrationhistoryPager) error

// WithIntegrationHistoryOrder configures pagination ordering.
func WithIntegrationHistoryOrder(order *IntegrationHistoryOrder) IntegrationHistoryPaginateOption {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	o := *order
	return func(pager *integrationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIntegrationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIntegrationHistoryFilter configures pagination filter.
func WithIntegrationHistoryFilter(filter func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)) IntegrationHistoryPaginateOption {
	return func(pager *integrationhistoryPager) error {
		if filter == nil {
			return errors.New("IntegrationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationhistoryPager struct {
	reverse bool
	order   *IntegrationHistoryOrder
	filter  func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)
}

func newIntegrationHistoryPager(opts []IntegrationHistoryPaginateOption, reverse bool) (*integrationhistoryPager, error) {
	pager := &integrationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIntegrationHistoryOrder
	}
	return pager, nil
}

func (p *integrationhistoryPager) applyFilter(query *IntegrationHistoryQuery) (*IntegrationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationhistoryPager) toCursor(_m *IntegrationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *integrationhistoryPager) applyCursors(query *IntegrationHistoryQuery, after, before *Cursor) (*IntegrationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIntegrationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *integrationhistoryPager) applyOrder(query *IntegrationHistoryQuery) *IntegrationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIntegrationHistoryOrder.Field {
		query = query.Order(DefaultIntegrationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *integrationhistoryPager) orderExpr(query *IntegrationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIntegrationHistoryOrder.Field {
			b.Comma().Ident(DefaultIntegrationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IntegrationHistory.
func (_m *IntegrationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationHistoryPaginateOption,
) (*IntegrationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &IntegrationHistoryConnection{Edges: []*IntegrationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationHistoryOrderFieldHistoryTime orders IntegrationHistory by history_time.
	IntegrationHistoryOrderFieldHistoryTime = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: integrationhistory.FieldHistoryTime,
		toTerm: integrationhistory.ByHistoryTime,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// IntegrationHistoryOrderFieldCreatedAt orders IntegrationHistory by created_at.
	IntegrationHistoryOrderFieldCreatedAt = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: integrationhistory.FieldCreatedAt,
		toTerm: integrationhistory.ByCreatedAt,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// IntegrationHistoryOrderFieldUpdatedAt orders IntegrationHistory by updated_at.
	IntegrationHistoryOrderFieldUpdatedAt = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: integrationhistory.FieldUpdatedAt,
		toTerm: integrationhistory.ByUpdatedAt,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// IntegrationHistoryOrderFieldName orders IntegrationHistory by name.
	IntegrationHistoryOrderFieldName = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: integrationhistory.FieldName,
		toTerm: integrationhistory.ByName,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// IntegrationHistoryOrderFieldKind orders IntegrationHistory by kind.
	IntegrationHistoryOrderFieldKind = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: integrationhistory.FieldKind,
		toTerm: integrationhistory.ByKind,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// IntegrationHistoryOrderFieldIntegrationType orders IntegrationHistory by integration_type.
	IntegrationHistoryOrderFieldIntegrationType = &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.IntegrationType, nil
		},
		column: integrationhistory.FieldIntegrationType,
		toTerm: integrationhistory.ByIntegrationType,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IntegrationType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case IntegrationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case IntegrationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IntegrationHistoryOrderFieldName.column:
		str = "name"
	case IntegrationHistoryOrderFieldKind.column:
		str = "kind"
	case IntegrationHistoryOrderFieldIntegrationType.column:
		str = "integration_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *IntegrationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *IntegrationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *IntegrationHistoryOrderFieldUpdatedAt
	case "name":
		*f = *IntegrationHistoryOrderFieldName
	case "kind":
		*f = *IntegrationHistoryOrderFieldKind
	case "integration_type":
		*f = *IntegrationHistoryOrderFieldIntegrationType
	default:
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

// IntegrationHistoryOrderField defines the ordering field of IntegrationHistory.
type IntegrationHistoryOrderField struct {
	// Value extracts the ordering value from the given IntegrationHistory.
	Value    func(*IntegrationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integrationhistory.OrderOption
	toCursor func(*IntegrationHistory) Cursor
}

// IntegrationHistoryOrder defines the ordering of IntegrationHistory.
type IntegrationHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *IntegrationHistoryOrderField `json:"field"`
}

// DefaultIntegrationHistoryOrder is the default ordering of IntegrationHistory.
var DefaultIntegrationHistoryOrder = &IntegrationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationHistoryOrderField{
		Value: func(_m *IntegrationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: integrationhistory.FieldID,
		toTerm: integrationhistory.ByID,
		toCursor: func(_m *IntegrationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts IntegrationHistory into IntegrationHistoryEdge.
func (_m *IntegrationHistory) ToEdge(order *IntegrationHistoryOrder) *IntegrationHistoryEdge {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	return &IntegrationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// InternalPolicyEdge is the edge representation of InternalPolicy.
type InternalPolicyEdge struct {
	Node   *InternalPolicy `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// InternalPolicyConnection is the connection containing edges to InternalPolicy.
type InternalPolicyConnection struct {
	Edges      []*InternalPolicyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *InternalPolicyConnection) build(nodes []*InternalPolicy, pager *internalpolicyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *InternalPolicy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicy {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyPaginateOption enables pagination customization.
type InternalPolicyPaginateOption func(*internalpolicyPager) error

// WithInternalPolicyOrder configures pagination ordering.
func WithInternalPolicyOrder(order []*InternalPolicyOrder) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInternalPolicyFilter configures pagination filter.
func WithInternalPolicyFilter(filter func(*InternalPolicyQuery) (*InternalPolicyQuery, error)) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		if filter == nil {
			return errors.New("InternalPolicyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyPager struct {
	reverse bool
	order   []*InternalPolicyOrder
	filter  func(*InternalPolicyQuery) (*InternalPolicyQuery, error)
}

func newInternalPolicyPager(opts []InternalPolicyPaginateOption, reverse bool) (*internalpolicyPager, error) {
	pager := &internalpolicyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *internalpolicyPager) applyFilter(query *InternalPolicyQuery) (*InternalPolicyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyPager) toCursor(_m *InternalPolicy) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *internalpolicyPager) applyCursors(query *InternalPolicyQuery, after, before *Cursor) (*InternalPolicyQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInternalPolicyOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *internalpolicyPager) applyOrder(query *InternalPolicyQuery) *InternalPolicyQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInternalPolicyOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInternalPolicyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *internalpolicyPager) orderExpr(query *InternalPolicyQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInternalPolicyOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicy.
func (_m *InternalPolicyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyPaginateOption,
) (*InternalPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &InternalPolicyConnection{Edges: []*InternalPolicyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InternalPolicyOrderFieldCreatedAt orders InternalPolicy by created_at.
	InternalPolicyOrderFieldCreatedAt = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: internalpolicy.FieldCreatedAt,
		toTerm: internalpolicy.ByCreatedAt,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// InternalPolicyOrderFieldUpdatedAt orders InternalPolicy by updated_at.
	InternalPolicyOrderFieldUpdatedAt = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: internalpolicy.FieldUpdatedAt,
		toTerm: internalpolicy.ByUpdatedAt,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// InternalPolicyOrderFieldRevision orders InternalPolicy by revision.
	InternalPolicyOrderFieldRevision = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: internalpolicy.FieldRevision,
		toTerm: internalpolicy.ByRevision,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// InternalPolicyOrderFieldName orders InternalPolicy by name.
	InternalPolicyOrderFieldName = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.Name, nil
		},
		column: internalpolicy.FieldName,
		toTerm: internalpolicy.ByName,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// InternalPolicyOrderFieldStatus orders InternalPolicy by status.
	InternalPolicyOrderFieldStatus = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.Status, nil
		},
		column: internalpolicy.FieldStatus,
		toTerm: internalpolicy.ByStatus,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// InternalPolicyOrderFieldReviewDue orders InternalPolicy by review_due.
	InternalPolicyOrderFieldReviewDue = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: internalpolicy.FieldReviewDue,
		toTerm: internalpolicy.ByReviewDue,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// InternalPolicyOrderFieldReviewFrequency orders InternalPolicy by review_frequency.
	InternalPolicyOrderFieldReviewFrequency = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: internalpolicy.FieldReviewFrequency,
		toTerm: internalpolicy.ByReviewFrequency,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InternalPolicyOrderField) String() string {
	var str string
	switch f.column {
	case InternalPolicyOrderFieldCreatedAt.column:
		str = "created_at"
	case InternalPolicyOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InternalPolicyOrderFieldRevision.column:
		str = "revision"
	case InternalPolicyOrderFieldName.column:
		str = "name"
	case InternalPolicyOrderFieldStatus.column:
		str = "STATUS"
	case InternalPolicyOrderFieldReviewDue.column:
		str = "review_due"
	case InternalPolicyOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InternalPolicyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InternalPolicyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InternalPolicyOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *InternalPolicyOrderFieldCreatedAt
	case "updated_at":
		*f = *InternalPolicyOrderFieldUpdatedAt
	case "revision":
		*f = *InternalPolicyOrderFieldRevision
	case "name":
		*f = *InternalPolicyOrderFieldName
	case "STATUS":
		*f = *InternalPolicyOrderFieldStatus
	case "review_due":
		*f = *InternalPolicyOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *InternalPolicyOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid InternalPolicyOrderField", str)
	}
	return nil
}

// InternalPolicyOrderField defines the ordering field of InternalPolicy.
type InternalPolicyOrderField struct {
	// Value extracts the ordering value from the given InternalPolicy.
	Value    func(*InternalPolicy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicy.OrderOption
	toCursor func(*InternalPolicy) Cursor
}

// InternalPolicyOrder defines the ordering of InternalPolicy.
type InternalPolicyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *InternalPolicyOrderField `json:"field"`
}

// DefaultInternalPolicyOrder is the default ordering of InternalPolicy.
var DefaultInternalPolicyOrder = &InternalPolicyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.ID, nil
		},
		column: internalpolicy.FieldID,
		toTerm: internalpolicy.ByID,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts InternalPolicy into InternalPolicyEdge.
func (_m *InternalPolicy) ToEdge(order *InternalPolicyOrder) *InternalPolicyEdge {
	if order == nil {
		order = DefaultInternalPolicyOrder
	}
	return &InternalPolicyEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// InternalPolicyHistoryEdge is the edge representation of InternalPolicyHistory.
type InternalPolicyHistoryEdge struct {
	Node   *InternalPolicyHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// InternalPolicyHistoryConnection is the connection containing edges to InternalPolicyHistory.
type InternalPolicyHistoryConnection struct {
	Edges      []*InternalPolicyHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *InternalPolicyHistoryConnection) build(nodes []*InternalPolicyHistory, pager *internalpolicyhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *InternalPolicyHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyHistoryPaginateOption enables pagination customization.
type InternalPolicyHistoryPaginateOption func(*internalpolicyhistoryPager) error

// WithInternalPolicyHistoryOrder configures pagination ordering.
func WithInternalPolicyHistoryOrder(order *InternalPolicyHistoryOrder) InternalPolicyHistoryPaginateOption {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	o := *order
	return func(pager *internalpolicyhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInternalPolicyHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInternalPolicyHistoryFilter configures pagination filter.
func WithInternalPolicyHistoryFilter(filter func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)) InternalPolicyHistoryPaginateOption {
	return func(pager *internalpolicyhistoryPager) error {
		if filter == nil {
			return errors.New("InternalPolicyHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyhistoryPager struct {
	reverse bool
	order   *InternalPolicyHistoryOrder
	filter  func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)
}

func newInternalPolicyHistoryPager(opts []InternalPolicyHistoryPaginateOption, reverse bool) (*internalpolicyhistoryPager, error) {
	pager := &internalpolicyhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInternalPolicyHistoryOrder
	}
	return pager, nil
}

func (p *internalpolicyhistoryPager) applyFilter(query *InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) toCursor(_m *InternalPolicyHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *internalpolicyhistoryPager) applyCursors(query *InternalPolicyHistoryQuery, after, before *Cursor) (*InternalPolicyHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInternalPolicyHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) applyOrder(query *InternalPolicyHistoryQuery) *InternalPolicyHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
		query = query.Order(DefaultInternalPolicyHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *internalpolicyhistoryPager) orderExpr(query *InternalPolicyHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
			b.Comma().Ident(DefaultInternalPolicyHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicyHistory.
func (_m *InternalPolicyHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyHistoryPaginateOption,
) (*InternalPolicyHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &InternalPolicyHistoryConnection{Edges: []*InternalPolicyHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InternalPolicyHistoryOrderFieldHistoryTime orders InternalPolicyHistory by history_time.
	InternalPolicyHistoryOrderFieldHistoryTime = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: internalpolicyhistory.FieldHistoryTime,
		toTerm: internalpolicyhistory.ByHistoryTime,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldCreatedAt orders InternalPolicyHistory by created_at.
	InternalPolicyHistoryOrderFieldCreatedAt = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: internalpolicyhistory.FieldCreatedAt,
		toTerm: internalpolicyhistory.ByCreatedAt,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldUpdatedAt orders InternalPolicyHistory by updated_at.
	InternalPolicyHistoryOrderFieldUpdatedAt = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: internalpolicyhistory.FieldUpdatedAt,
		toTerm: internalpolicyhistory.ByUpdatedAt,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldRevision orders InternalPolicyHistory by revision.
	InternalPolicyHistoryOrderFieldRevision = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: internalpolicyhistory.FieldRevision,
		toTerm: internalpolicyhistory.ByRevision,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldName orders InternalPolicyHistory by name.
	InternalPolicyHistoryOrderFieldName = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: internalpolicyhistory.FieldName,
		toTerm: internalpolicyhistory.ByName,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldStatus orders InternalPolicyHistory by status.
	InternalPolicyHistoryOrderFieldStatus = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: internalpolicyhistory.FieldStatus,
		toTerm: internalpolicyhistory.ByStatus,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldReviewDue orders InternalPolicyHistory by review_due.
	InternalPolicyHistoryOrderFieldReviewDue = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: internalpolicyhistory.FieldReviewDue,
		toTerm: internalpolicyhistory.ByReviewDue,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// InternalPolicyHistoryOrderFieldReviewFrequency orders InternalPolicyHistory by review_frequency.
	InternalPolicyHistoryOrderFieldReviewFrequency = &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: internalpolicyhistory.FieldReviewFrequency,
		toTerm: internalpolicyhistory.ByReviewFrequency,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InternalPolicyHistoryOrderField) String() string {
	var str string
	switch f.column {
	case InternalPolicyHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case InternalPolicyHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case InternalPolicyHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InternalPolicyHistoryOrderFieldRevision.column:
		str = "revision"
	case InternalPolicyHistoryOrderFieldName.column:
		str = "name"
	case InternalPolicyHistoryOrderFieldStatus.column:
		str = "STATUS"
	case InternalPolicyHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case InternalPolicyHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InternalPolicyHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InternalPolicyHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InternalPolicyHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *InternalPolicyHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *InternalPolicyHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *InternalPolicyHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *InternalPolicyHistoryOrderFieldRevision
	case "name":
		*f = *InternalPolicyHistoryOrderFieldName
	case "STATUS":
		*f = *InternalPolicyHistoryOrderFieldStatus
	case "review_due":
		*f = *InternalPolicyHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *InternalPolicyHistoryOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid InternalPolicyHistoryOrderField", str)
	}
	return nil
}

// InternalPolicyHistoryOrderField defines the ordering field of InternalPolicyHistory.
type InternalPolicyHistoryOrderField struct {
	// Value extracts the ordering value from the given InternalPolicyHistory.
	Value    func(*InternalPolicyHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicyhistory.OrderOption
	toCursor func(*InternalPolicyHistory) Cursor
}

// InternalPolicyHistoryOrder defines the ordering of InternalPolicyHistory.
type InternalPolicyHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *InternalPolicyHistoryOrderField `json:"field"`
}

// DefaultInternalPolicyHistoryOrder is the default ordering of InternalPolicyHistory.
var DefaultInternalPolicyHistoryOrder = &InternalPolicyHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyHistoryOrderField{
		Value: func(_m *InternalPolicyHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: internalpolicyhistory.FieldID,
		toTerm: internalpolicyhistory.ByID,
		toCursor: func(_m *InternalPolicyHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts InternalPolicyHistory into InternalPolicyHistoryEdge.
func (_m *InternalPolicyHistory) ToEdge(order *InternalPolicyHistoryOrder) *InternalPolicyHistoryEdge {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	return &InternalPolicyHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// InviteEdge is the edge representation of Invite.
type InviteEdge struct {
	Node   *Invite `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// InviteConnection is the connection containing edges to Invite.
type InviteConnection struct {
	Edges      []*InviteEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *InviteConnection) build(nodes []*Invite, pager *invitePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Invite
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Invite {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Invite {
			return nodes[i]
		}
	}
	c.Edges = make([]*InviteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InviteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InvitePaginateOption enables pagination customization.
type InvitePaginateOption func(*invitePager) error

// WithInviteOrder configures pagination ordering.
func WithInviteOrder(order []*InviteOrder) InvitePaginateOption {
	return func(pager *invitePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInviteFilter configures pagination filter.
func WithInviteFilter(filter func(*InviteQuery) (*InviteQuery, error)) InvitePaginateOption {
	return func(pager *invitePager) error {
		if filter == nil {
			return errors.New("InviteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type invitePager struct {
	reverse bool
	order   []*InviteOrder
	filter  func(*InviteQuery) (*InviteQuery, error)
}

func newInvitePager(opts []InvitePaginateOption, reverse bool) (*invitePager, error) {
	pager := &invitePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *invitePager) applyFilter(query *InviteQuery) (*InviteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *invitePager) toCursor(_m *Invite) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *invitePager) applyCursors(query *InviteQuery, after, before *Cursor) (*InviteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInviteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *invitePager) applyOrder(query *InviteQuery) *InviteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInviteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInviteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *invitePager) orderExpr(query *InviteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInviteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Invite.
func (_m *InviteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InvitePaginateOption,
) (*InviteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInvitePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &InviteConnection{Edges: []*InviteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InviteOrderFieldCreatedAt orders Invite by created_at.
	InviteOrderFieldCreatedAt = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: invite.FieldCreatedAt,
		toTerm: invite.ByCreatedAt,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// InviteOrderFieldUpdatedAt orders Invite by updated_at.
	InviteOrderFieldUpdatedAt = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: invite.FieldUpdatedAt,
		toTerm: invite.ByUpdatedAt,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// InviteOrderFieldExpires orders Invite by expires.
	InviteOrderFieldExpires = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.Expires, nil
		},
		column: invite.FieldExpires,
		toTerm: invite.ByExpires,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Expires,
			}
		},
	}
	// InviteOrderFieldStatus orders Invite by status.
	InviteOrderFieldStatus = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.Status, nil
		},
		column: invite.FieldStatus,
		toTerm: invite.ByStatus,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// InviteOrderFieldSendAttempts orders Invite by send_attempts.
	InviteOrderFieldSendAttempts = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: invite.FieldSendAttempts,
		toTerm: invite.BySendAttempts,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InviteOrderField) String() string {
	var str string
	switch f.column {
	case InviteOrderFieldCreatedAt.column:
		str = "created_at"
	case InviteOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InviteOrderFieldExpires.column:
		str = "expires"
	case InviteOrderFieldStatus.column:
		str = "STATUS"
	case InviteOrderFieldSendAttempts.column:
		str = "send_attempts"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InviteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InviteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InviteOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *InviteOrderFieldCreatedAt
	case "updated_at":
		*f = *InviteOrderFieldUpdatedAt
	case "expires":
		*f = *InviteOrderFieldExpires
	case "STATUS":
		*f = *InviteOrderFieldStatus
	case "send_attempts":
		*f = *InviteOrderFieldSendAttempts
	default:
		return fmt.Errorf("%s is not a valid InviteOrderField", str)
	}
	return nil
}

// InviteOrderField defines the ordering field of Invite.
type InviteOrderField struct {
	// Value extracts the ordering value from the given Invite.
	Value    func(*Invite) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) invite.OrderOption
	toCursor func(*Invite) Cursor
}

// InviteOrder defines the ordering of Invite.
type InviteOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *InviteOrderField `json:"field"`
}

// DefaultInviteOrder is the default ordering of Invite.
var DefaultInviteOrder = &InviteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.ID, nil
		},
		column: invite.FieldID,
		toTerm: invite.ByID,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Invite into InviteEdge.
func (_m *Invite) ToEdge(order *InviteOrder) *InviteEdge {
	if order == nil {
		order = DefaultInviteOrder
	}
	return &InviteEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobResultEdge is the edge representation of JobResult.
type JobResultEdge struct {
	Node   *JobResult `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobResultConnection is the connection containing edges to JobResult.
type JobResultConnection struct {
	Edges      []*JobResultEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobResultConnection) build(nodes []*JobResult, pager *jobresultPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobResult
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobResult {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobResult {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobResultEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobResultEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobResultPaginateOption enables pagination customization.
type JobResultPaginateOption func(*jobresultPager) error

// WithJobResultOrder configures pagination ordering.
func WithJobResultOrder(order []*JobResultOrder) JobResultPaginateOption {
	return func(pager *jobresultPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobResultFilter configures pagination filter.
func WithJobResultFilter(filter func(*JobResultQuery) (*JobResultQuery, error)) JobResultPaginateOption {
	return func(pager *jobresultPager) error {
		if filter == nil {
			return errors.New("JobResultQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobresultPager struct {
	reverse bool
	order   []*JobResultOrder
	filter  func(*JobResultQuery) (*JobResultQuery, error)
}

func newJobResultPager(opts []JobResultPaginateOption, reverse bool) (*jobresultPager, error) {
	pager := &jobresultPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobresultPager) applyFilter(query *JobResultQuery) (*JobResultQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobresultPager) toCursor(_m *JobResult) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobresultPager) applyCursors(query *JobResultQuery, after, before *Cursor) (*JobResultQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobResultOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobresultPager) applyOrder(query *JobResultQuery) *JobResultQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobResultOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobResultOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobresultPager) orderExpr(query *JobResultQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobResultOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobResult.
func (_m *JobResultQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobResultPaginateOption,
) (*JobResultConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobResultPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobResultConnection{Edges: []*JobResultEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobResultOrderFieldCreatedAt orders JobResult by created_at.
	JobResultOrderFieldCreatedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobresult.FieldCreatedAt,
		toTerm: jobresult.ByCreatedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobResultOrderFieldUpdatedAt orders JobResult by updated_at.
	JobResultOrderFieldUpdatedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobresult.FieldUpdatedAt,
		toTerm: jobresult.ByUpdatedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobResultOrderFieldStatus orders JobResult by status.
	JobResultOrderFieldStatus = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.Status, nil
		},
		column: jobresult.FieldStatus,
		toTerm: jobresult.ByStatus,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// JobResultOrderFieldExitCode orders JobResult by exit_code.
	JobResultOrderFieldExitCode = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExitCode == nil {
				return nil, nil
			}
			return _m.ExitCode, nil
		},
		column: jobresult.FieldExitCode,
		toTerm: func(opts ...sql.OrderTermOption) jobresult.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobresult.ByExitCode(opts...)
		},
		toCursor: func(_m *JobResult) Cursor {
			if _m.ExitCode == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExitCode,
			}
		},
	}
	// JobResultOrderFieldFinishedAt orders JobResult by finished_at.
	JobResultOrderFieldFinishedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.FinishedAt, nil
		},
		column: jobresult.FieldFinishedAt,
		toTerm: jobresult.ByFinishedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FinishedAt,
			}
		},
	}
	// JobResultOrderFieldStartedAt orders JobResult by started_at.
	JobResultOrderFieldStartedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: jobresult.FieldStartedAt,
		toTerm: jobresult.ByStartedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobResultOrderField) String() string {
	var str string
	switch f.column {
	case JobResultOrderFieldCreatedAt.column:
		str = "created_at"
	case JobResultOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobResultOrderFieldStatus.column:
		str = "STATUS"
	case JobResultOrderFieldExitCode.column:
		str = "exit_code"
	case JobResultOrderFieldFinishedAt.column:
		str = "finished_at"
	case JobResultOrderFieldStartedAt.column:
		str = "started_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobResultOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobResultOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobResultOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobResultOrderFieldCreatedAt
	case "updated_at":
		*f = *JobResultOrderFieldUpdatedAt
	case "STATUS":
		*f = *JobResultOrderFieldStatus
	case "exit_code":
		*f = *JobResultOrderFieldExitCode
	case "finished_at":
		*f = *JobResultOrderFieldFinishedAt
	case "started_at":
		*f = *JobResultOrderFieldStartedAt
	default:
		return fmt.Errorf("%s is not a valid JobResultOrderField", str)
	}
	return nil
}

// JobResultOrderField defines the ordering field of JobResult.
type JobResultOrderField struct {
	// Value extracts the ordering value from the given JobResult.
	Value    func(*JobResult) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobresult.OrderOption
	toCursor func(*JobResult) Cursor
}

// JobResultOrder defines the ordering of JobResult.
type JobResultOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobResultOrderField `json:"field"`
}

// DefaultJobResultOrder is the default ordering of JobResult.
var DefaultJobResultOrder = &JobResultOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobresult.FieldID,
		toTerm: jobresult.ByID,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobResult into JobResultEdge.
func (_m *JobResult) ToEdge(order *JobResultOrder) *JobResultEdge {
	if order == nil {
		order = DefaultJobResultOrder
	}
	return &JobResultEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRunnerEdge is the edge representation of JobRunner.
type JobRunnerEdge struct {
	Node   *JobRunner `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobRunnerConnection is the connection containing edges to JobRunner.
type JobRunnerConnection struct {
	Edges      []*JobRunnerEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobRunnerConnection) build(nodes []*JobRunner, pager *jobrunnerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunner {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerPaginateOption enables pagination customization.
type JobRunnerPaginateOption func(*jobrunnerPager) error

// WithJobRunnerOrder configures pagination ordering.
func WithJobRunnerOrder(order []*JobRunnerOrder) JobRunnerPaginateOption {
	return func(pager *jobrunnerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerFilter configures pagination filter.
func WithJobRunnerFilter(filter func(*JobRunnerQuery) (*JobRunnerQuery, error)) JobRunnerPaginateOption {
	return func(pager *jobrunnerPager) error {
		if filter == nil {
			return errors.New("JobRunnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnerPager struct {
	reverse bool
	order   []*JobRunnerOrder
	filter  func(*JobRunnerQuery) (*JobRunnerQuery, error)
}

func newJobRunnerPager(opts []JobRunnerPaginateOption, reverse bool) (*jobrunnerPager, error) {
	pager := &jobrunnerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnerPager) applyFilter(query *JobRunnerQuery) (*JobRunnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnerPager) toCursor(_m *JobRunner) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobrunnerPager) applyCursors(query *JobRunnerQuery, after, before *Cursor) (*JobRunnerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnerPager) applyOrder(query *JobRunnerQuery) *JobRunnerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnerPager) orderExpr(query *JobRunnerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunner.
func (_m *JobRunnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerPaginateOption,
) (*JobRunnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRunnerConnection{Edges: []*JobRunnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerOrderFieldCreatedAt orders JobRunner by created_at.
	JobRunnerOrderFieldCreatedAt = &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobrunner.FieldCreatedAt,
		toTerm: jobrunner.ByCreatedAt,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobRunnerOrderFieldUpdatedAt orders JobRunner by updated_at.
	JobRunnerOrderFieldUpdatedAt = &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobrunner.FieldUpdatedAt,
		toTerm: jobrunner.ByUpdatedAt,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobRunnerOrderFieldName orders JobRunner by name.
	JobRunnerOrderFieldName = &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.Name, nil
		},
		column: jobrunner.FieldName,
		toTerm: jobrunner.ByName,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerOrderFieldUpdatedAt
	case "name":
		*f = *JobRunnerOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid JobRunnerOrderField", str)
	}
	return nil
}

// JobRunnerOrderField defines the ordering field of JobRunner.
type JobRunnerOrderField struct {
	// Value extracts the ordering value from the given JobRunner.
	Value    func(*JobRunner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunner.OrderOption
	toCursor func(*JobRunner) Cursor
}

// JobRunnerOrder defines the ordering of JobRunner.
type JobRunnerOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobRunnerOrderField `json:"field"`
}

// DefaultJobRunnerOrder is the default ordering of JobRunner.
var DefaultJobRunnerOrder = &JobRunnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrunner.FieldID,
		toTerm: jobrunner.ByID,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRunner into JobRunnerEdge.
func (_m *JobRunner) ToEdge(order *JobRunnerOrder) *JobRunnerEdge {
	if order == nil {
		order = DefaultJobRunnerOrder
	}
	return &JobRunnerEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRunnerRegistrationTokenEdge is the edge representation of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenEdge struct {
	Node   *JobRunnerRegistrationToken `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// JobRunnerRegistrationTokenConnection is the connection containing edges to JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenConnection struct {
	Edges      []*JobRunnerRegistrationTokenEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *JobRunnerRegistrationTokenConnection) build(nodes []*JobRunnerRegistrationToken, pager *jobrunnerregistrationtokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunnerRegistrationToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunnerRegistrationToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunnerRegistrationToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerRegistrationTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerRegistrationTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerRegistrationTokenPaginateOption enables pagination customization.
type JobRunnerRegistrationTokenPaginateOption func(*jobrunnerregistrationtokenPager) error

// WithJobRunnerRegistrationTokenOrder configures pagination ordering.
func WithJobRunnerRegistrationTokenOrder(order []*JobRunnerRegistrationTokenOrder) JobRunnerRegistrationTokenPaginateOption {
	return func(pager *jobrunnerregistrationtokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerRegistrationTokenFilter configures pagination filter.
func WithJobRunnerRegistrationTokenFilter(filter func(*JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error)) JobRunnerRegistrationTokenPaginateOption {
	return func(pager *jobrunnerregistrationtokenPager) error {
		if filter == nil {
			return errors.New("JobRunnerRegistrationTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnerregistrationtokenPager struct {
	reverse bool
	order   []*JobRunnerRegistrationTokenOrder
	filter  func(*JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error)
}

func newJobRunnerRegistrationTokenPager(opts []JobRunnerRegistrationTokenPaginateOption, reverse bool) (*jobrunnerregistrationtokenPager, error) {
	pager := &jobrunnerregistrationtokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnerregistrationtokenPager) applyFilter(query *JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnerregistrationtokenPager) toCursor(_m *JobRunnerRegistrationToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobrunnerregistrationtokenPager) applyCursors(query *JobRunnerRegistrationTokenQuery, after, before *Cursor) (*JobRunnerRegistrationTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerRegistrationTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnerregistrationtokenPager) applyOrder(query *JobRunnerRegistrationTokenQuery) *JobRunnerRegistrationTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerRegistrationTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerRegistrationTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnerregistrationtokenPager) orderExpr(query *JobRunnerRegistrationTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerRegistrationTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunnerRegistrationToken.
func (_m *JobRunnerRegistrationTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerRegistrationTokenPaginateOption,
) (*JobRunnerRegistrationTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerRegistrationTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRunnerRegistrationTokenConnection{Edges: []*JobRunnerRegistrationTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerRegistrationTokenOrderFieldCreatedAt orders JobRunnerRegistrationToken by created_at.
	JobRunnerRegistrationTokenOrderFieldCreatedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldCreatedAt,
		toTerm: jobrunnerregistrationtoken.ByCreatedAt,
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobRunnerRegistrationTokenOrderFieldUpdatedAt orders JobRunnerRegistrationToken by updated_at.
	JobRunnerRegistrationTokenOrderFieldUpdatedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldUpdatedAt,
		toTerm: jobrunnerregistrationtoken.ByUpdatedAt,
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobRunnerRegistrationTokenOrderFieldLastUsedAt orders JobRunnerRegistrationToken by last_used_at.
	JobRunnerRegistrationTokenOrderFieldLastUsedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnerregistrationtoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnerregistrationtoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerRegistrationTokenOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerRegistrationTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerRegistrationTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerRegistrationTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerRegistrationTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerRegistrationTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerRegistrationTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerRegistrationTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerRegistrationTokenOrderFieldUpdatedAt
	case "last_used_at":
		*f = *JobRunnerRegistrationTokenOrderFieldLastUsedAt
	default:
		return fmt.Errorf("%s is not a valid JobRunnerRegistrationTokenOrderField", str)
	}
	return nil
}

// JobRunnerRegistrationTokenOrderField defines the ordering field of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenOrderField struct {
	// Value extracts the ordering value from the given JobRunnerRegistrationToken.
	Value    func(*JobRunnerRegistrationToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunnerregistrationtoken.OrderOption
	toCursor func(*JobRunnerRegistrationToken) Cursor
}

// JobRunnerRegistrationTokenOrder defines the ordering of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *JobRunnerRegistrationTokenOrderField `json:"field"`
}

// DefaultJobRunnerRegistrationTokenOrder is the default ordering of JobRunnerRegistrationToken.
var DefaultJobRunnerRegistrationTokenOrder = &JobRunnerRegistrationTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrunnerregistrationtoken.FieldID,
		toTerm: jobrunnerregistrationtoken.ByID,
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRunnerRegistrationToken into JobRunnerRegistrationTokenEdge.
func (_m *JobRunnerRegistrationToken) ToEdge(order *JobRunnerRegistrationTokenOrder) *JobRunnerRegistrationTokenEdge {
	if order == nil {
		order = DefaultJobRunnerRegistrationTokenOrder
	}
	return &JobRunnerRegistrationTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRunnerTokenEdge is the edge representation of JobRunnerToken.
type JobRunnerTokenEdge struct {
	Node   *JobRunnerToken `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// JobRunnerTokenConnection is the connection containing edges to JobRunnerToken.
type JobRunnerTokenConnection struct {
	Edges      []*JobRunnerTokenEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *JobRunnerTokenConnection) build(nodes []*JobRunnerToken, pager *jobrunnertokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunnerToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunnerToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunnerToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerTokenPaginateOption enables pagination customization.
type JobRunnerTokenPaginateOption func(*jobrunnertokenPager) error

// WithJobRunnerTokenOrder configures pagination ordering.
func WithJobRunnerTokenOrder(order []*JobRunnerTokenOrder) JobRunnerTokenPaginateOption {
	return func(pager *jobrunnertokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerTokenFilter configures pagination filter.
func WithJobRunnerTokenFilter(filter func(*JobRunnerTokenQuery) (*JobRunnerTokenQuery, error)) JobRunnerTokenPaginateOption {
	return func(pager *jobrunnertokenPager) error {
		if filter == nil {
			return errors.New("JobRunnerTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnertokenPager struct {
	reverse bool
	order   []*JobRunnerTokenOrder
	filter  func(*JobRunnerTokenQuery) (*JobRunnerTokenQuery, error)
}

func newJobRunnerTokenPager(opts []JobRunnerTokenPaginateOption, reverse bool) (*jobrunnertokenPager, error) {
	pager := &jobrunnertokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnertokenPager) applyFilter(query *JobRunnerTokenQuery) (*JobRunnerTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnertokenPager) toCursor(_m *JobRunnerToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobrunnertokenPager) applyCursors(query *JobRunnerTokenQuery, after, before *Cursor) (*JobRunnerTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnertokenPager) applyOrder(query *JobRunnerTokenQuery) *JobRunnerTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnertokenPager) orderExpr(query *JobRunnerTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunnerToken.
func (_m *JobRunnerTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerTokenPaginateOption,
) (*JobRunnerTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRunnerTokenConnection{Edges: []*JobRunnerTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerTokenOrderFieldCreatedAt orders JobRunnerToken by created_at.
	JobRunnerTokenOrderFieldCreatedAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobrunnertoken.FieldCreatedAt,
		toTerm: jobrunnertoken.ByCreatedAt,
		toCursor: func(_m *JobRunnerToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldUpdatedAt orders JobRunnerToken by updated_at.
	JobRunnerTokenOrderFieldUpdatedAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobrunnertoken.FieldUpdatedAt,
		toTerm: jobrunnertoken.ByUpdatedAt,
		toCursor: func(_m *JobRunnerToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldExpiresAt orders JobRunnerToken by expires_at.
	JobRunnerTokenOrderFieldExpiresAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: jobrunnertoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnertoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnertoken.ByExpiresAt(opts...)
		},
		toCursor: func(_m *JobRunnerToken) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldLastUsedAt orders JobRunnerToken by last_used_at.
	JobRunnerTokenOrderFieldLastUsedAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: jobrunnertoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnertoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnertoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *JobRunnerToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerTokenOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerTokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case JobRunnerTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerTokenOrderFieldUpdatedAt
	case "expires_at":
		*f = *JobRunnerTokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *JobRunnerTokenOrderFieldLastUsedAt
	default:
		return fmt.Errorf("%s is not a valid JobRunnerTokenOrderField", str)
	}
	return nil
}

// JobRunnerTokenOrderField defines the ordering field of JobRunnerToken.
type JobRunnerTokenOrderField struct {
	// Value extracts the ordering value from the given JobRunnerToken.
	Value    func(*JobRunnerToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunnertoken.OrderOption
	toCursor func(*JobRunnerToken) Cursor
}

// JobRunnerTokenOrder defines the ordering of JobRunnerToken.
type JobRunnerTokenOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *JobRunnerTokenOrderField `json:"field"`
}

// DefaultJobRunnerTokenOrder is the default ordering of JobRunnerToken.
var DefaultJobRunnerTokenOrder = &JobRunnerTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrunnertoken.FieldID,
		toTerm: jobrunnertoken.ByID,
		toCursor: func(_m *JobRunnerToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRunnerToken into JobRunnerTokenEdge.
func (_m *JobRunnerToken) ToEdge(order *JobRunnerTokenOrder) *JobRunnerTokenEdge {
	if order == nil {
		order = DefaultJobRunnerTokenOrder
	}
	return &JobRunnerTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobTemplateEdge is the edge representation of JobTemplate.
type JobTemplateEdge struct {
	Node   *JobTemplate `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobTemplateConnection is the connection containing edges to JobTemplate.
type JobTemplateConnection struct {
	Edges      []*JobTemplateEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobTemplateConnection) build(nodes []*JobTemplate, pager *jobtemplatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobTemplate {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobTemplatePaginateOption enables pagination customization.
type JobTemplatePaginateOption func(*jobtemplatePager) error

// WithJobTemplateOrder configures pagination ordering.
func WithJobTemplateOrder(order []*JobTemplateOrder) JobTemplatePaginateOption {
	return func(pager *jobtemplatePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobTemplateFilter configures pagination filter.
func WithJobTemplateFilter(filter func(*JobTemplateQuery) (*JobTemplateQuery, error)) JobTemplatePaginateOption {
	return func(pager *jobtemplatePager) error {
		if filter == nil {
			return errors.New("JobTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobtemplatePager struct {
	reverse bool
	order   []*JobTemplateOrder
	filter  func(*JobTemplateQuery) (*JobTemplateQuery, error)
}

func newJobTemplatePager(opts []JobTemplatePaginateOption, reverse bool) (*jobtemplatePager, error) {
	pager := &jobtemplatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobtemplatePager) applyFilter(query *JobTemplateQuery) (*JobTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobtemplatePager) toCursor(_m *JobTemplate) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobtemplatePager) applyCursors(query *JobTemplateQuery, after, before *Cursor) (*JobTemplateQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobTemplateOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobtemplatePager) applyOrder(query *JobTemplateQuery) *JobTemplateQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobTemplateOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobtemplatePager) orderExpr(query *JobTemplateQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobTemplateOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobTemplate.
func (_m *JobTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobTemplatePaginateOption,
) (*JobTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobTemplateConnection{Edges: []*JobTemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobTemplateOrderFieldCreatedAt orders JobTemplate by created_at.
	JobTemplateOrderFieldCreatedAt = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobtemplate.FieldCreatedAt,
		toTerm: jobtemplate.ByCreatedAt,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobTemplateOrderFieldUpdatedAt orders JobTemplate by updated_at.
	JobTemplateOrderFieldUpdatedAt = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobtemplate.FieldUpdatedAt,
		toTerm: jobtemplate.ByUpdatedAt,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobTemplateOrderFieldTitle orders JobTemplate by title.
	JobTemplateOrderFieldTitle = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.Title, nil
		},
		column: jobtemplate.FieldTitle,
		toTerm: jobtemplate.ByTitle,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// JobTemplateOrderFieldPlatform orders JobTemplate by platform.
	JobTemplateOrderFieldPlatform = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.Platform, nil
		},
		column: jobtemplate.FieldPlatform,
		toTerm: jobtemplate.ByPlatform,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Platform,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobTemplateOrderField) String() string {
	var str string
	switch f.column {
	case JobTemplateOrderFieldCreatedAt.column:
		str = "created_at"
	case JobTemplateOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobTemplateOrderFieldTitle.column:
		str = "title"
	case JobTemplateOrderFieldPlatform.column:
		str = "PLATFORM"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobTemplateOrderFieldCreatedAt
	case "updated_at":
		*f = *JobTemplateOrderFieldUpdatedAt
	case "title":
		*f = *JobTemplateOrderFieldTitle
	case "PLATFORM":
		*f = *JobTemplateOrderFieldPlatform
	default:
		return fmt.Errorf("%s is not a valid JobTemplateOrderField", str)
	}
	return nil
}

// JobTemplateOrderField defines the ordering field of JobTemplate.
type JobTemplateOrderField struct {
	// Value extracts the ordering value from the given JobTemplate.
	Value    func(*JobTemplate) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobtemplate.OrderOption
	toCursor func(*JobTemplate) Cursor
}

// JobTemplateOrder defines the ordering of JobTemplate.
type JobTemplateOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobTemplateOrderField `json:"field"`
}

// DefaultJobTemplateOrder is the default ordering of JobTemplate.
var DefaultJobTemplateOrder = &JobTemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobtemplate.FieldID,
		toTerm: jobtemplate.ByID,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobTemplate into JobTemplateEdge.
func (_m *JobTemplate) ToEdge(order *JobTemplateOrder) *JobTemplateEdge {
	if order == nil {
		order = DefaultJobTemplateOrder
	}
	return &JobTemplateEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobTemplateHistoryEdge is the edge representation of JobTemplateHistory.
type JobTemplateHistoryEdge struct {
	Node   *JobTemplateHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// JobTemplateHistoryConnection is the connection containing edges to JobTemplateHistory.
type JobTemplateHistoryConnection struct {
	Edges      []*JobTemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *JobTemplateHistoryConnection) build(nodes []*JobTemplateHistory, pager *jobtemplatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobTemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobTemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobTemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobTemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobTemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobTemplateHistoryPaginateOption enables pagination customization.
type JobTemplateHistoryPaginateOption func(*jobtemplatehistoryPager) error

// WithJobTemplateHistoryOrder configures pagination ordering.
func WithJobTemplateHistoryOrder(order *JobTemplateHistoryOrder) JobTemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultJobTemplateHistoryOrder
	}
	o := *order
	return func(pager *jobtemplatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobTemplateHistoryFilter configures pagination filter.
func WithJobTemplateHistoryFilter(filter func(*JobTemplateHistoryQuery) (*JobTemplateHistoryQuery, error)) JobTemplateHistoryPaginateOption {
	return func(pager *jobtemplatehistoryPager) error {
		if filter == nil {
			return errors.New("JobTemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobtemplatehistoryPager struct {
	reverse bool
	order   *JobTemplateHistoryOrder
	filter  func(*JobTemplateHistoryQuery) (*JobTemplateHistoryQuery, error)
}

func newJobTemplateHistoryPager(opts []JobTemplateHistoryPaginateOption, reverse bool) (*jobtemplatehistoryPager, error) {
	pager := &jobtemplatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobTemplateHistoryOrder
	}
	return pager, nil
}

func (p *jobtemplatehistoryPager) applyFilter(query *JobTemplateHistoryQuery) (*JobTemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobtemplatehistoryPager) toCursor(_m *JobTemplateHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobtemplatehistoryPager) applyCursors(query *JobTemplateHistoryQuery, after, before *Cursor) (*JobTemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobtemplatehistoryPager) applyOrder(query *JobTemplateHistoryQuery) *JobTemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobTemplateHistoryOrder.Field {
		query = query.Order(DefaultJobTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobtemplatehistoryPager) orderExpr(query *JobTemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultJobTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobTemplateHistory.
func (_m *JobTemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobTemplateHistoryPaginateOption,
) (*JobTemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobTemplateHistoryConnection{Edges: []*JobTemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobTemplateHistoryOrderFieldHistoryTime orders JobTemplateHistory by history_time.
	JobTemplateHistoryOrderFieldHistoryTime = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: jobtemplatehistory.FieldHistoryTime,
		toTerm: jobtemplatehistory.ByHistoryTime,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// JobTemplateHistoryOrderFieldCreatedAt orders JobTemplateHistory by created_at.
	JobTemplateHistoryOrderFieldCreatedAt = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobtemplatehistory.FieldCreatedAt,
		toTerm: jobtemplatehistory.ByCreatedAt,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobTemplateHistoryOrderFieldUpdatedAt orders JobTemplateHistory by updated_at.
	JobTemplateHistoryOrderFieldUpdatedAt = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobtemplatehistory.FieldUpdatedAt,
		toTerm: jobtemplatehistory.ByUpdatedAt,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobTemplateHistoryOrderFieldTitle orders JobTemplateHistory by title.
	JobTemplateHistoryOrderFieldTitle = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: jobtemplatehistory.FieldTitle,
		toTerm: jobtemplatehistory.ByTitle,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// JobTemplateHistoryOrderFieldPlatform orders JobTemplateHistory by platform.
	JobTemplateHistoryOrderFieldPlatform = &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.Platform, nil
		},
		column: jobtemplatehistory.FieldPlatform,
		toTerm: jobtemplatehistory.ByPlatform,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Platform,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobTemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case JobTemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case JobTemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case JobTemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobTemplateHistoryOrderFieldTitle.column:
		str = "title"
	case JobTemplateHistoryOrderFieldPlatform.column:
		str = "PLATFORM"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobTemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobTemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobTemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *JobTemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *JobTemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *JobTemplateHistoryOrderFieldUpdatedAt
	case "title":
		*f = *JobTemplateHistoryOrderFieldTitle
	case "PLATFORM":
		*f = *JobTemplateHistoryOrderFieldPlatform
	default:
		return fmt.Errorf("%s is not a valid JobTemplateHistoryOrderField", str)
	}
	return nil
}

// JobTemplateHistoryOrderField defines the ordering field of JobTemplateHistory.
type JobTemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given JobTemplateHistory.
	Value    func(*JobTemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobtemplatehistory.OrderOption
	toCursor func(*JobTemplateHistory) Cursor
}

// JobTemplateHistoryOrder defines the ordering of JobTemplateHistory.
type JobTemplateHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *JobTemplateHistoryOrderField `json:"field"`
}

// DefaultJobTemplateHistoryOrder is the default ordering of JobTemplateHistory.
var DefaultJobTemplateHistoryOrder = &JobTemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobTemplateHistoryOrderField{
		Value: func(_m *JobTemplateHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobtemplatehistory.FieldID,
		toTerm: jobtemplatehistory.ByID,
		toCursor: func(_m *JobTemplateHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobTemplateHistory into JobTemplateHistoryEdge.
func (_m *JobTemplateHistory) ToEdge(order *JobTemplateHistoryOrder) *JobTemplateHistoryEdge {
	if order == nil {
		order = DefaultJobTemplateHistoryOrder
	}
	return &JobTemplateHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappableDomainEdge is the edge representation of MappableDomain.
type MappableDomainEdge struct {
	Node   *MappableDomain `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// MappableDomainConnection is the connection containing edges to MappableDomain.
type MappableDomainConnection struct {
	Edges      []*MappableDomainEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *MappableDomainConnection) build(nodes []*MappableDomain, pager *mappabledomainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappableDomain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappableDomain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappableDomain {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappableDomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappableDomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappableDomainPaginateOption enables pagination customization.
type MappableDomainPaginateOption func(*mappabledomainPager) error

// WithMappableDomainOrder configures pagination ordering.
func WithMappableDomainOrder(order []*MappableDomainOrder) MappableDomainPaginateOption {
	return func(pager *mappabledomainPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMappableDomainFilter configures pagination filter.
func WithMappableDomainFilter(filter func(*MappableDomainQuery) (*MappableDomainQuery, error)) MappableDomainPaginateOption {
	return func(pager *mappabledomainPager) error {
		if filter == nil {
			return errors.New("MappableDomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappabledomainPager struct {
	reverse bool
	order   []*MappableDomainOrder
	filter  func(*MappableDomainQuery) (*MappableDomainQuery, error)
}

func newMappableDomainPager(opts []MappableDomainPaginateOption, reverse bool) (*mappabledomainPager, error) {
	pager := &mappabledomainPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mappabledomainPager) applyFilter(query *MappableDomainQuery) (*MappableDomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappabledomainPager) toCursor(_m *MappableDomain) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *mappabledomainPager) applyCursors(query *MappableDomainQuery, after, before *Cursor) (*MappableDomainQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMappableDomainOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *mappabledomainPager) applyOrder(query *MappableDomainQuery) *MappableDomainQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMappableDomainOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMappableDomainOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mappabledomainPager) orderExpr(query *MappableDomainQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMappableDomainOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappableDomain.
func (_m *MappableDomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappableDomainPaginateOption,
) (*MappableDomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappableDomainPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappableDomainConnection{Edges: []*MappableDomainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappableDomainOrderFieldCreatedAt orders MappableDomain by created_at.
	MappableDomainOrderFieldCreatedAt = &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappabledomain.FieldCreatedAt,
		toTerm: mappabledomain.ByCreatedAt,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappableDomainOrderFieldUpdatedAt orders MappableDomain by updated_at.
	MappableDomainOrderFieldUpdatedAt = &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappabledomain.FieldUpdatedAt,
		toTerm: mappabledomain.ByUpdatedAt,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappableDomainOrderFieldName orders MappableDomain by name.
	MappableDomainOrderFieldName = &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.Name, nil
		},
		column: mappabledomain.FieldName,
		toTerm: mappabledomain.ByName,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappableDomainOrderField) String() string {
	var str string
	switch f.column {
	case MappableDomainOrderFieldCreatedAt.column:
		str = "created_at"
	case MappableDomainOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappableDomainOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappableDomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappableDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappableDomainOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *MappableDomainOrderFieldCreatedAt
	case "updated_at":
		*f = *MappableDomainOrderFieldUpdatedAt
	case "name":
		*f = *MappableDomainOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid MappableDomainOrderField", str)
	}
	return nil
}

// MappableDomainOrderField defines the ordering field of MappableDomain.
type MappableDomainOrderField struct {
	// Value extracts the ordering value from the given MappableDomain.
	Value    func(*MappableDomain) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappabledomain.OrderOption
	toCursor func(*MappableDomain) Cursor
}

// MappableDomainOrder defines the ordering of MappableDomain.
type MappableDomainOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *MappableDomainOrderField `json:"field"`
}

// DefaultMappableDomainOrder is the default ordering of MappableDomain.
var DefaultMappableDomainOrder = &MappableDomainOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappabledomain.FieldID,
		toTerm: mappabledomain.ByID,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappableDomain into MappableDomainEdge.
func (_m *MappableDomain) ToEdge(order *MappableDomainOrder) *MappableDomainEdge {
	if order == nil {
		order = DefaultMappableDomainOrder
	}
	return &MappableDomainEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappableDomainHistoryEdge is the edge representation of MappableDomainHistory.
type MappableDomainHistoryEdge struct {
	Node   *MappableDomainHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// MappableDomainHistoryConnection is the connection containing edges to MappableDomainHistory.
type MappableDomainHistoryConnection struct {
	Edges      []*MappableDomainHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *MappableDomainHistoryConnection) build(nodes []*MappableDomainHistory, pager *mappabledomainhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappableDomainHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappableDomainHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappableDomainHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappableDomainHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappableDomainHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappableDomainHistoryPaginateOption enables pagination customization.
type MappableDomainHistoryPaginateOption func(*mappabledomainhistoryPager) error

// WithMappableDomainHistoryOrder configures pagination ordering.
func WithMappableDomainHistoryOrder(order *MappableDomainHistoryOrder) MappableDomainHistoryPaginateOption {
	if order == nil {
		order = DefaultMappableDomainHistoryOrder
	}
	o := *order
	return func(pager *mappabledomainhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMappableDomainHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMappableDomainHistoryFilter configures pagination filter.
func WithMappableDomainHistoryFilter(filter func(*MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error)) MappableDomainHistoryPaginateOption {
	return func(pager *mappabledomainhistoryPager) error {
		if filter == nil {
			return errors.New("MappableDomainHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappabledomainhistoryPager struct {
	reverse bool
	order   *MappableDomainHistoryOrder
	filter  func(*MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error)
}

func newMappableDomainHistoryPager(opts []MappableDomainHistoryPaginateOption, reverse bool) (*mappabledomainhistoryPager, error) {
	pager := &mappabledomainhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMappableDomainHistoryOrder
	}
	return pager, nil
}

func (p *mappabledomainhistoryPager) applyFilter(query *MappableDomainHistoryQuery) (*MappableDomainHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappabledomainhistoryPager) toCursor(_m *MappableDomainHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *mappabledomainhistoryPager) applyCursors(query *MappableDomainHistoryQuery, after, before *Cursor) (*MappableDomainHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMappableDomainHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mappabledomainhistoryPager) applyOrder(query *MappableDomainHistoryQuery) *MappableDomainHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMappableDomainHistoryOrder.Field {
		query = query.Order(DefaultMappableDomainHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mappabledomainhistoryPager) orderExpr(query *MappableDomainHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMappableDomainHistoryOrder.Field {
			b.Comma().Ident(DefaultMappableDomainHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappableDomainHistory.
func (_m *MappableDomainHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappableDomainHistoryPaginateOption,
) (*MappableDomainHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappableDomainHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappableDomainHistoryConnection{Edges: []*MappableDomainHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappableDomainHistoryOrderFieldHistoryTime orders MappableDomainHistory by history_time.
	MappableDomainHistoryOrderFieldHistoryTime = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: mappabledomainhistory.FieldHistoryTime,
		toTerm: mappabledomainhistory.ByHistoryTime,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// MappableDomainHistoryOrderFieldCreatedAt orders MappableDomainHistory by created_at.
	MappableDomainHistoryOrderFieldCreatedAt = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappabledomainhistory.FieldCreatedAt,
		toTerm: mappabledomainhistory.ByCreatedAt,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappableDomainHistoryOrderFieldUpdatedAt orders MappableDomainHistory by updated_at.
	MappableDomainHistoryOrderFieldUpdatedAt = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappabledomainhistory.FieldUpdatedAt,
		toTerm: mappabledomainhistory.ByUpdatedAt,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappableDomainHistoryOrderFieldName orders MappableDomainHistory by name.
	MappableDomainHistoryOrderFieldName = &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: mappabledomainhistory.FieldName,
		toTerm: mappabledomainhistory.ByName,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappableDomainHistoryOrderField) String() string {
	var str string
	switch f.column {
	case MappableDomainHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case MappableDomainHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case MappableDomainHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappableDomainHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappableDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappableDomainHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappableDomainHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *MappableDomainHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *MappableDomainHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *MappableDomainHistoryOrderFieldUpdatedAt
	case "name":
		*f = *MappableDomainHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid MappableDomainHistoryOrderField", str)
	}
	return nil
}

// MappableDomainHistoryOrderField defines the ordering field of MappableDomainHistory.
type MappableDomainHistoryOrderField struct {
	// Value extracts the ordering value from the given MappableDomainHistory.
	Value    func(*MappableDomainHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappabledomainhistory.OrderOption
	toCursor func(*MappableDomainHistory) Cursor
}

// MappableDomainHistoryOrder defines the ordering of MappableDomainHistory.
type MappableDomainHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *MappableDomainHistoryOrderField `json:"field"`
}

// DefaultMappableDomainHistoryOrder is the default ordering of MappableDomainHistory.
var DefaultMappableDomainHistoryOrder = &MappableDomainHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappableDomainHistoryOrderField{
		Value: func(_m *MappableDomainHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappabledomainhistory.FieldID,
		toTerm: mappabledomainhistory.ByID,
		toCursor: func(_m *MappableDomainHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappableDomainHistory into MappableDomainHistoryEdge.
func (_m *MappableDomainHistory) ToEdge(order *MappableDomainHistoryOrder) *MappableDomainHistoryEdge {
	if order == nil {
		order = DefaultMappableDomainHistoryOrder
	}
	return &MappableDomainHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappedControlEdge is the edge representation of MappedControl.
type MappedControlEdge struct {
	Node   *MappedControl `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// MappedControlConnection is the connection containing edges to MappedControl.
type MappedControlConnection struct {
	Edges      []*MappedControlEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *MappedControlConnection) build(nodes []*MappedControl, pager *mappedcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappedControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappedControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappedControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappedControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappedControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappedControlPaginateOption enables pagination customization.
type MappedControlPaginateOption func(*mappedcontrolPager) error

// WithMappedControlOrder configures pagination ordering.
func WithMappedControlOrder(order []*MappedControlOrder) MappedControlPaginateOption {
	return func(pager *mappedcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMappedControlFilter configures pagination filter.
func WithMappedControlFilter(filter func(*MappedControlQuery) (*MappedControlQuery, error)) MappedControlPaginateOption {
	return func(pager *mappedcontrolPager) error {
		if filter == nil {
			return errors.New("MappedControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappedcontrolPager struct {
	reverse bool
	order   []*MappedControlOrder
	filter  func(*MappedControlQuery) (*MappedControlQuery, error)
}

func newMappedControlPager(opts []MappedControlPaginateOption, reverse bool) (*mappedcontrolPager, error) {
	pager := &mappedcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mappedcontrolPager) applyFilter(query *MappedControlQuery) (*MappedControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappedcontrolPager) toCursor(_m *MappedControl) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *mappedcontrolPager) applyCursors(query *MappedControlQuery, after, before *Cursor) (*MappedControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMappedControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *mappedcontrolPager) applyOrder(query *MappedControlQuery) *MappedControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMappedControlOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMappedControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mappedcontrolPager) orderExpr(query *MappedControlQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMappedControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappedControl.
func (_m *MappedControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappedControlPaginateOption,
) (*MappedControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappedControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappedControlConnection{Edges: []*MappedControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappedControlOrderFieldCreatedAt orders MappedControl by created_at.
	MappedControlOrderFieldCreatedAt = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappedcontrol.FieldCreatedAt,
		toTerm: mappedcontrol.ByCreatedAt,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappedControlOrderFieldUpdatedAt orders MappedControl by updated_at.
	MappedControlOrderFieldUpdatedAt = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappedcontrol.FieldUpdatedAt,
		toTerm: mappedcontrol.ByUpdatedAt,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappedControlOrderFieldMappingType orders MappedControl by mapping_type.
	MappedControlOrderFieldMappingType = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.MappingType, nil
		},
		column: mappedcontrol.FieldMappingType,
		toTerm: mappedcontrol.ByMappingType,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.MappingType,
			}
		},
	}
	// MappedControlOrderFieldSource orders MappedControl by source.
	MappedControlOrderFieldSource = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.Source, nil
		},
		column: mappedcontrol.FieldSource,
		toTerm: mappedcontrol.BySource,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappedControlOrderField) String() string {
	var str string
	switch f.column {
	case MappedControlOrderFieldCreatedAt.column:
		str = "created_at"
	case MappedControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappedControlOrderFieldMappingType.column:
		str = "MAPPING_TYPE"
	case MappedControlOrderFieldSource.column:
		str = "SOURCE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappedControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappedControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappedControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *MappedControlOrderFieldCreatedAt
	case "updated_at":
		*f = *MappedControlOrderFieldUpdatedAt
	case "MAPPING_TYPE":
		*f = *MappedControlOrderFieldMappingType
	case "SOURCE":
		*f = *MappedControlOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid MappedControlOrderField", str)
	}
	return nil
}

// MappedControlOrderField defines the ordering field of MappedControl.
type MappedControlOrderField struct {
	// Value extracts the ordering value from the given MappedControl.
	Value    func(*MappedControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappedcontrol.OrderOption
	toCursor func(*MappedControl) Cursor
}

// MappedControlOrder defines the ordering of MappedControl.
type MappedControlOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *MappedControlOrderField `json:"field"`
}

// DefaultMappedControlOrder is the default ordering of MappedControl.
var DefaultMappedControlOrder = &MappedControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappedcontrol.FieldID,
		toTerm: mappedcontrol.ByID,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappedControl into MappedControlEdge.
func (_m *MappedControl) ToEdge(order *MappedControlOrder) *MappedControlEdge {
	if order == nil {
		order = DefaultMappedControlOrder
	}
	return &MappedControlEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappedControlHistoryEdge is the edge representation of MappedControlHistory.
type MappedControlHistoryEdge struct {
	Node   *MappedControlHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// MappedControlHistoryConnection is the connection containing edges to MappedControlHistory.
type MappedControlHistoryConnection struct {
	Edges      []*MappedControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *MappedControlHistoryConnection) build(nodes []*MappedControlHistory, pager *mappedcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappedControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappedControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappedControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappedControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappedControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappedControlHistoryPaginateOption enables pagination customization.
type MappedControlHistoryPaginateOption func(*mappedcontrolhistoryPager) error

// WithMappedControlHistoryOrder configures pagination ordering.
func WithMappedControlHistoryOrder(order *MappedControlHistoryOrder) MappedControlHistoryPaginateOption {
	if order == nil {
		order = DefaultMappedControlHistoryOrder
	}
	o := *order
	return func(pager *mappedcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMappedControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMappedControlHistoryFilter configures pagination filter.
func WithMappedControlHistoryFilter(filter func(*MappedControlHistoryQuery) (*MappedControlHistoryQuery, error)) MappedControlHistoryPaginateOption {
	return func(pager *mappedcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("MappedControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappedcontrolhistoryPager struct {
	reverse bool
	order   *MappedControlHistoryOrder
	filter  func(*MappedControlHistoryQuery) (*MappedControlHistoryQuery, error)
}

func newMappedControlHistoryPager(opts []MappedControlHistoryPaginateOption, reverse bool) (*mappedcontrolhistoryPager, error) {
	pager := &mappedcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMappedControlHistoryOrder
	}
	return pager, nil
}

func (p *mappedcontrolhistoryPager) applyFilter(query *MappedControlHistoryQuery) (*MappedControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappedcontrolhistoryPager) toCursor(_m *MappedControlHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *mappedcontrolhistoryPager) applyCursors(query *MappedControlHistoryQuery, after, before *Cursor) (*MappedControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMappedControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mappedcontrolhistoryPager) applyOrder(query *MappedControlHistoryQuery) *MappedControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMappedControlHistoryOrder.Field {
		query = query.Order(DefaultMappedControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mappedcontrolhistoryPager) orderExpr(query *MappedControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMappedControlHistoryOrder.Field {
			b.Comma().Ident(DefaultMappedControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappedControlHistory.
func (_m *MappedControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappedControlHistoryPaginateOption,
) (*MappedControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappedControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappedControlHistoryConnection{Edges: []*MappedControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappedControlHistoryOrderFieldHistoryTime orders MappedControlHistory by history_time.
	MappedControlHistoryOrderFieldHistoryTime = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: mappedcontrolhistory.FieldHistoryTime,
		toTerm: mappedcontrolhistory.ByHistoryTime,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// MappedControlHistoryOrderFieldCreatedAt orders MappedControlHistory by created_at.
	MappedControlHistoryOrderFieldCreatedAt = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappedcontrolhistory.FieldCreatedAt,
		toTerm: mappedcontrolhistory.ByCreatedAt,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappedControlHistoryOrderFieldUpdatedAt orders MappedControlHistory by updated_at.
	MappedControlHistoryOrderFieldUpdatedAt = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappedcontrolhistory.FieldUpdatedAt,
		toTerm: mappedcontrolhistory.ByUpdatedAt,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappedControlHistoryOrderFieldMappingType orders MappedControlHistory by mapping_type.
	MappedControlHistoryOrderFieldMappingType = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.MappingType, nil
		},
		column: mappedcontrolhistory.FieldMappingType,
		toTerm: mappedcontrolhistory.ByMappingType,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.MappingType,
			}
		},
	}
	// MappedControlHistoryOrderFieldSource orders MappedControlHistory by source.
	MappedControlHistoryOrderFieldSource = &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: mappedcontrolhistory.FieldSource,
		toTerm: mappedcontrolhistory.BySource,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappedControlHistoryOrderField) String() string {
	var str string
	switch f.column {
	case MappedControlHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case MappedControlHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case MappedControlHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappedControlHistoryOrderFieldMappingType.column:
		str = "MAPPING_TYPE"
	case MappedControlHistoryOrderFieldSource.column:
		str = "SOURCE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappedControlHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappedControlHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappedControlHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *MappedControlHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *MappedControlHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *MappedControlHistoryOrderFieldUpdatedAt
	case "MAPPING_TYPE":
		*f = *MappedControlHistoryOrderFieldMappingType
	case "SOURCE":
		*f = *MappedControlHistoryOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid MappedControlHistoryOrderField", str)
	}
	return nil
}

// MappedControlHistoryOrderField defines the ordering field of MappedControlHistory.
type MappedControlHistoryOrderField struct {
	// Value extracts the ordering value from the given MappedControlHistory.
	Value    func(*MappedControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappedcontrolhistory.OrderOption
	toCursor func(*MappedControlHistory) Cursor
}

// MappedControlHistoryOrder defines the ordering of MappedControlHistory.
type MappedControlHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *MappedControlHistoryOrderField `json:"field"`
}

// DefaultMappedControlHistoryOrder is the default ordering of MappedControlHistory.
var DefaultMappedControlHistoryOrder = &MappedControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappedControlHistoryOrderField{
		Value: func(_m *MappedControlHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappedcontrolhistory.FieldID,
		toTerm: mappedcontrolhistory.ByID,
		toCursor: func(_m *MappedControlHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappedControlHistory into MappedControlHistoryEdge.
func (_m *MappedControlHistory) ToEdge(order *MappedControlHistoryOrder) *MappedControlHistoryEdge {
	if order == nil {
		order = DefaultMappedControlHistoryOrder
	}
	return &MappedControlHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NarrativeEdge is the edge representation of Narrative.
type NarrativeEdge struct {
	Node   *Narrative `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// NarrativeConnection is the connection containing edges to Narrative.
type NarrativeConnection struct {
	Edges      []*NarrativeEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *NarrativeConnection) build(nodes []*Narrative, pager *narrativePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Narrative
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Narrative {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Narrative {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativePaginateOption enables pagination customization.
type NarrativePaginateOption func(*narrativePager) error

// WithNarrativeOrder configures pagination ordering.
func WithNarrativeOrder(order []*NarrativeOrder) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNarrativeFilter configures pagination filter.
func WithNarrativeFilter(filter func(*NarrativeQuery) (*NarrativeQuery, error)) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		if filter == nil {
			return errors.New("NarrativeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativePager struct {
	reverse bool
	order   []*NarrativeOrder
	filter  func(*NarrativeQuery) (*NarrativeQuery, error)
}

func newNarrativePager(opts []NarrativePaginateOption, reverse bool) (*narrativePager, error) {
	pager := &narrativePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *narrativePager) applyFilter(query *NarrativeQuery) (*NarrativeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativePager) toCursor(_m *Narrative) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *narrativePager) applyCursors(query *NarrativeQuery, after, before *Cursor) (*NarrativeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNarrativeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *narrativePager) applyOrder(query *NarrativeQuery) *NarrativeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNarrativeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNarrativeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *narrativePager) orderExpr(query *NarrativeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNarrativeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Narrative.
func (_m *NarrativeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativePaginateOption,
) (*NarrativeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NarrativeConnection{Edges: []*NarrativeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NarrativeOrderFieldCreatedAt orders Narrative by created_at.
	NarrativeOrderFieldCreatedAt = &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: narrative.FieldCreatedAt,
		toTerm: narrative.ByCreatedAt,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NarrativeOrderFieldUpdatedAt orders Narrative by updated_at.
	NarrativeOrderFieldUpdatedAt = &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: narrative.FieldUpdatedAt,
		toTerm: narrative.ByUpdatedAt,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// NarrativeOrderFieldName orders Narrative by name.
	NarrativeOrderFieldName = &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.Name, nil
		},
		column: narrative.FieldName,
		toTerm: narrative.ByName,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NarrativeOrderField) String() string {
	var str string
	switch f.column {
	case NarrativeOrderFieldCreatedAt.column:
		str = "created_at"
	case NarrativeOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NarrativeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NarrativeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NarrativeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NarrativeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NarrativeOrderFieldCreatedAt
	case "updated_at":
		*f = *NarrativeOrderFieldUpdatedAt
	case "name":
		*f = *NarrativeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NarrativeOrderField", str)
	}
	return nil
}

// NarrativeOrderField defines the ordering field of Narrative.
type NarrativeOrderField struct {
	// Value extracts the ordering value from the given Narrative.
	Value    func(*Narrative) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrative.OrderOption
	toCursor func(*Narrative) Cursor
}

// NarrativeOrder defines the ordering of Narrative.
type NarrativeOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *NarrativeOrderField `json:"field"`
}

// DefaultNarrativeOrder is the default ordering of Narrative.
var DefaultNarrativeOrder = &NarrativeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.ID, nil
		},
		column: narrative.FieldID,
		toTerm: narrative.ByID,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Narrative into NarrativeEdge.
func (_m *Narrative) ToEdge(order *NarrativeOrder) *NarrativeEdge {
	if order == nil {
		order = DefaultNarrativeOrder
	}
	return &NarrativeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NarrativeHistoryEdge is the edge representation of NarrativeHistory.
type NarrativeHistoryEdge struct {
	Node   *NarrativeHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// NarrativeHistoryConnection is the connection containing edges to NarrativeHistory.
type NarrativeHistoryConnection struct {
	Edges      []*NarrativeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *NarrativeHistoryConnection) build(nodes []*NarrativeHistory, pager *narrativehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NarrativeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativeHistoryPaginateOption enables pagination customization.
type NarrativeHistoryPaginateOption func(*narrativehistoryPager) error

// WithNarrativeHistoryOrder configures pagination ordering.
func WithNarrativeHistoryOrder(order *NarrativeHistoryOrder) NarrativeHistoryPaginateOption {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	o := *order
	return func(pager *narrativehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNarrativeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNarrativeHistoryFilter configures pagination filter.
func WithNarrativeHistoryFilter(filter func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)) NarrativeHistoryPaginateOption {
	return func(pager *narrativehistoryPager) error {
		if filter == nil {
			return errors.New("NarrativeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativehistoryPager struct {
	reverse bool
	order   *NarrativeHistoryOrder
	filter  func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)
}

func newNarrativeHistoryPager(opts []NarrativeHistoryPaginateOption, reverse bool) (*narrativehistoryPager, error) {
	pager := &narrativehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNarrativeHistoryOrder
	}
	return pager, nil
}

func (p *narrativehistoryPager) applyFilter(query *NarrativeHistoryQuery) (*NarrativeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativehistoryPager) toCursor(_m *NarrativeHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *narrativehistoryPager) applyCursors(query *NarrativeHistoryQuery, after, before *Cursor) (*NarrativeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNarrativeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *narrativehistoryPager) applyOrder(query *NarrativeHistoryQuery) *NarrativeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNarrativeHistoryOrder.Field {
		query = query.Order(DefaultNarrativeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *narrativehistoryPager) orderExpr(query *NarrativeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNarrativeHistoryOrder.Field {
			b.Comma().Ident(DefaultNarrativeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NarrativeHistory.
func (_m *NarrativeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativeHistoryPaginateOption,
) (*NarrativeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NarrativeHistoryConnection{Edges: []*NarrativeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NarrativeHistoryOrderFieldHistoryTime orders NarrativeHistory by history_time.
	NarrativeHistoryOrderFieldHistoryTime = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: narrativehistory.FieldHistoryTime,
		toTerm: narrativehistory.ByHistoryTime,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// NarrativeHistoryOrderFieldCreatedAt orders NarrativeHistory by created_at.
	NarrativeHistoryOrderFieldCreatedAt = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: narrativehistory.FieldCreatedAt,
		toTerm: narrativehistory.ByCreatedAt,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NarrativeHistoryOrderFieldUpdatedAt orders NarrativeHistory by updated_at.
	NarrativeHistoryOrderFieldUpdatedAt = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: narrativehistory.FieldUpdatedAt,
		toTerm: narrativehistory.ByUpdatedAt,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// NarrativeHistoryOrderFieldName orders NarrativeHistory by name.
	NarrativeHistoryOrderFieldName = &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: narrativehistory.FieldName,
		toTerm: narrativehistory.ByName,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NarrativeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NarrativeHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NarrativeHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NarrativeHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NarrativeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NarrativeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NarrativeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NarrativeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NarrativeHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NarrativeHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NarrativeHistoryOrderFieldUpdatedAt
	case "name":
		*f = *NarrativeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NarrativeHistoryOrderField", str)
	}
	return nil
}

// NarrativeHistoryOrderField defines the ordering field of NarrativeHistory.
type NarrativeHistoryOrderField struct {
	// Value extracts the ordering value from the given NarrativeHistory.
	Value    func(*NarrativeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrativehistory.OrderOption
	toCursor func(*NarrativeHistory) Cursor
}

// NarrativeHistoryOrder defines the ordering of NarrativeHistory.
type NarrativeHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *NarrativeHistoryOrderField `json:"field"`
}

// DefaultNarrativeHistoryOrder is the default ordering of NarrativeHistory.
var DefaultNarrativeHistoryOrder = &NarrativeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeHistoryOrderField{
		Value: func(_m *NarrativeHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: narrativehistory.FieldID,
		toTerm: narrativehistory.ByID,
		toCursor: func(_m *NarrativeHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts NarrativeHistory into NarrativeHistoryEdge.
func (_m *NarrativeHistory) ToEdge(order *NarrativeHistoryOrder) *NarrativeHistoryEdge {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	return &NarrativeHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NoteEdge is the edge representation of Note.
type NoteEdge struct {
	Node   *Note  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// NoteConnection is the connection containing edges to Note.
type NoteConnection struct {
	Edges      []*NoteEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *NoteConnection) build(nodes []*Note, pager *notePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Note
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Note {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Note {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotePaginateOption enables pagination customization.
type NotePaginateOption func(*notePager) error

// WithNoteOrder configures pagination ordering.
func WithNoteOrder(order []*NoteOrder) NotePaginateOption {
	return func(pager *notePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNoteFilter configures pagination filter.
func WithNoteFilter(filter func(*NoteQuery) (*NoteQuery, error)) NotePaginateOption {
	return func(pager *notePager) error {
		if filter == nil {
			return errors.New("NoteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notePager struct {
	reverse bool
	order   []*NoteOrder
	filter  func(*NoteQuery) (*NoteQuery, error)
}

func newNotePager(opts []NotePaginateOption, reverse bool) (*notePager, error) {
	pager := &notePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *notePager) applyFilter(query *NoteQuery) (*NoteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notePager) toCursor(_m *Note) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *notePager) applyCursors(query *NoteQuery, after, before *Cursor) (*NoteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNoteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *notePager) applyOrder(query *NoteQuery) *NoteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNoteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNoteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *notePager) orderExpr(query *NoteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNoteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Note.
func (_m *NoteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotePaginateOption,
) (*NoteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NoteConnection{Edges: []*NoteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NoteOrderFieldCreatedAt orders Note by created_at.
	NoteOrderFieldCreatedAt = &NoteOrderField{
		Value: func(_m *Note) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: note.FieldCreatedAt,
		toTerm: note.ByCreatedAt,
		toCursor: func(_m *Note) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NoteOrderFieldUpdatedAt orders Note by updated_at.
	NoteOrderFieldUpdatedAt = &NoteOrderField{
		Value: func(_m *Note) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: note.FieldUpdatedAt,
		toTerm: note.ByUpdatedAt,
		toCursor: func(_m *Note) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NoteOrderField) String() string {
	var str string
	switch f.column {
	case NoteOrderFieldCreatedAt.column:
		str = "created_at"
	case NoteOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NoteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NoteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NoteOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NoteOrderFieldCreatedAt
	case "updated_at":
		*f = *NoteOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NoteOrderField", str)
	}
	return nil
}

// NoteOrderField defines the ordering field of Note.
type NoteOrderField struct {
	// Value extracts the ordering value from the given Note.
	Value    func(*Note) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) note.OrderOption
	toCursor func(*Note) Cursor
}

// NoteOrder defines the ordering of Note.
type NoteOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *NoteOrderField `json:"field"`
}

// DefaultNoteOrder is the default ordering of Note.
var DefaultNoteOrder = &NoteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteOrderField{
		Value: func(_m *Note) (ent.Value, error) {
			return _m.ID, nil
		},
		column: note.FieldID,
		toTerm: note.ByID,
		toCursor: func(_m *Note) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Note into NoteEdge.
func (_m *Note) ToEdge(order *NoteOrder) *NoteEdge {
	if order == nil {
		order = DefaultNoteOrder
	}
	return &NoteEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NoteHistoryEdge is the edge representation of NoteHistory.
type NoteHistoryEdge struct {
	Node   *NoteHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// NoteHistoryConnection is the connection containing edges to NoteHistory.
type NoteHistoryConnection struct {
	Edges      []*NoteHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *NoteHistoryConnection) build(nodes []*NoteHistory, pager *notehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *NoteHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NoteHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NoteHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NoteHistoryPaginateOption enables pagination customization.
type NoteHistoryPaginateOption func(*notehistoryPager) error

// WithNoteHistoryOrder configures pagination ordering.
func WithNoteHistoryOrder(order *NoteHistoryOrder) NoteHistoryPaginateOption {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	o := *order
	return func(pager *notehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNoteHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNoteHistoryFilter configures pagination filter.
func WithNoteHistoryFilter(filter func(*NoteHistoryQuery) (*NoteHistoryQuery, error)) NoteHistoryPaginateOption {
	return func(pager *notehistoryPager) error {
		if filter == nil {
			return errors.New("NoteHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notehistoryPager struct {
	reverse bool
	order   *NoteHistoryOrder
	filter  func(*NoteHistoryQuery) (*NoteHistoryQuery, error)
}

func newNoteHistoryPager(opts []NoteHistoryPaginateOption, reverse bool) (*notehistoryPager, error) {
	pager := &notehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNoteHistoryOrder
	}
	return pager, nil
}

func (p *notehistoryPager) applyFilter(query *NoteHistoryQuery) (*NoteHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notehistoryPager) toCursor(_m *NoteHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *notehistoryPager) applyCursors(query *NoteHistoryQuery, after, before *Cursor) (*NoteHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNoteHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notehistoryPager) applyOrder(query *NoteHistoryQuery) *NoteHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNoteHistoryOrder.Field {
		query = query.Order(DefaultNoteHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notehistoryPager) orderExpr(query *NoteHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNoteHistoryOrder.Field {
			b.Comma().Ident(DefaultNoteHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NoteHistory.
func (_m *NoteHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NoteHistoryPaginateOption,
) (*NoteHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNoteHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NoteHistoryConnection{Edges: []*NoteHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NoteHistoryOrderFieldHistoryTime orders NoteHistory by history_time.
	NoteHistoryOrderFieldHistoryTime = &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: notehistory.FieldHistoryTime,
		toTerm: notehistory.ByHistoryTime,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// NoteHistoryOrderFieldCreatedAt orders NoteHistory by created_at.
	NoteHistoryOrderFieldCreatedAt = &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: notehistory.FieldCreatedAt,
		toTerm: notehistory.ByCreatedAt,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NoteHistoryOrderFieldUpdatedAt orders NoteHistory by updated_at.
	NoteHistoryOrderFieldUpdatedAt = &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: notehistory.FieldUpdatedAt,
		toTerm: notehistory.ByUpdatedAt,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NoteHistoryOrderField) String() string {
	var str string
	switch f.column {
	case NoteHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case NoteHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case NoteHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NoteHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NoteHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NoteHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *NoteHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *NoteHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *NoteHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NoteHistoryOrderField", str)
	}
	return nil
}

// NoteHistoryOrderField defines the ordering field of NoteHistory.
type NoteHistoryOrderField struct {
	// Value extracts the ordering value from the given NoteHistory.
	Value    func(*NoteHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notehistory.OrderOption
	toCursor func(*NoteHistory) Cursor
}

// NoteHistoryOrder defines the ordering of NoteHistory.
type NoteHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *NoteHistoryOrderField `json:"field"`
}

// DefaultNoteHistoryOrder is the default ordering of NoteHistory.
var DefaultNoteHistoryOrder = &NoteHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteHistoryOrderField{
		Value: func(_m *NoteHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: notehistory.FieldID,
		toTerm: notehistory.ByID,
		toCursor: func(_m *NoteHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts NoteHistory into NoteHistoryEdge.
func (_m *NoteHistory) ToEdge(order *NoteHistoryOrder) *NoteHistoryEdge {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	return &NoteHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NotificationEdge is the edge representation of Notification.
type NotificationEdge struct {
	Node   *Notification `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// NotificationConnection is the connection containing edges to Notification.
type NotificationConnection struct {
	Edges      []*NotificationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *NotificationConnection) build(nodes []*Notification, pager *notificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Notification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Notification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Notification {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationPaginateOption enables pagination customization.
type NotificationPaginateOption func(*notificationPager) error

// WithNotificationOrder configures pagination ordering.
func WithNotificationOrder(order *NotificationOrder) NotificationPaginateOption {
	if order == nil {
		order = DefaultNotificationOrder
	}
	o := *order
	return func(pager *notificationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotificationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotificationFilter configures pagination filter.
func WithNotificationFilter(filter func(*NotificationQuery) (*NotificationQuery, error)) NotificationPaginateOption {
	return func(pager *notificationPager) error {
		if filter == nil {
			return errors.New("NotificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationPager struct {
	reverse bool
	order   *NotificationOrder
	filter  func(*NotificationQuery) (*NotificationQuery, error)
}

func newNotificationPager(opts []NotificationPaginateOption, reverse bool) (*notificationPager, error) {
	pager := &notificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotificationOrder
	}
	return pager, nil
}

func (p *notificationPager) applyFilter(query *NotificationQuery) (*NotificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationPager) toCursor(_m *Notification) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *notificationPager) applyCursors(query *NotificationQuery, after, before *Cursor) (*NotificationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNotificationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notificationPager) applyOrder(query *NotificationQuery) *NotificationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNotificationOrder.Field {
		query = query.Order(DefaultNotificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notificationPager) orderExpr(query *NotificationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotificationOrder.Field {
			b.Comma().Ident(DefaultNotificationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Notification.
func (_m *NotificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationPaginateOption,
) (*NotificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NotificationConnection{Edges: []*NotificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotificationOrderFieldCreatedAt orders Notification by created_at.
	NotificationOrderFieldCreatedAt = &NotificationOrderField{
		Value: func(_m *Notification) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: notification.FieldCreatedAt,
		toTerm: notification.ByCreatedAt,
		toCursor: func(_m *Notification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NotificationOrderFieldUpdatedAt orders Notification by updated_at.
	NotificationOrderFieldUpdatedAt = &NotificationOrderField{
		Value: func(_m *Notification) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: notification.FieldUpdatedAt,
		toTerm: notification.ByUpdatedAt,
		toCursor: func(_m *Notification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotificationOrderField) String() string {
	var str string
	switch f.column {
	case NotificationOrderFieldCreatedAt.column:
		str = "created_at"
	case NotificationOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotificationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NotificationOrderFieldCreatedAt
	case "updated_at":
		*f = *NotificationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NotificationOrderField", str)
	}
	return nil
}

// NotificationOrderField defines the ordering field of Notification.
type NotificationOrderField struct {
	// Value extracts the ordering value from the given Notification.
	Value    func(*Notification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notification.OrderOption
	toCursor func(*Notification) Cursor
}

// NotificationOrder defines the ordering of Notification.
type NotificationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *NotificationOrderField `json:"field"`
}

// DefaultNotificationOrder is the default ordering of Notification.
var DefaultNotificationOrder = &NotificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotificationOrderField{
		Value: func(_m *Notification) (ent.Value, error) {
			return _m.ID, nil
		},
		column: notification.FieldID,
		toTerm: notification.ByID,
		toCursor: func(_m *Notification) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Notification into NotificationEdge.
func (_m *Notification) ToEdge(order *NotificationOrder) *NotificationEdge {
	if order == nil {
		order = DefaultNotificationOrder
	}
	return &NotificationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OnboardingEdge is the edge representation of Onboarding.
type OnboardingEdge struct {
	Node   *Onboarding `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// OnboardingConnection is the connection containing edges to Onboarding.
type OnboardingConnection struct {
	Edges      []*OnboardingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *OnboardingConnection) build(nodes []*Onboarding, pager *onboardingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Onboarding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Onboarding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Onboarding {
			return nodes[i]
		}
	}
	c.Edges = make([]*OnboardingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OnboardingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OnboardingPaginateOption enables pagination customization.
type OnboardingPaginateOption func(*onboardingPager) error

// WithOnboardingOrder configures pagination ordering.
func WithOnboardingOrder(order *OnboardingOrder) OnboardingPaginateOption {
	if order == nil {
		order = DefaultOnboardingOrder
	}
	o := *order
	return func(pager *onboardingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOnboardingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOnboardingFilter configures pagination filter.
func WithOnboardingFilter(filter func(*OnboardingQuery) (*OnboardingQuery, error)) OnboardingPaginateOption {
	return func(pager *onboardingPager) error {
		if filter == nil {
			return errors.New("OnboardingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type onboardingPager struct {
	reverse bool
	order   *OnboardingOrder
	filter  func(*OnboardingQuery) (*OnboardingQuery, error)
}

func newOnboardingPager(opts []OnboardingPaginateOption, reverse bool) (*onboardingPager, error) {
	pager := &onboardingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOnboardingOrder
	}
	return pager, nil
}

func (p *onboardingPager) applyFilter(query *OnboardingQuery) (*OnboardingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *onboardingPager) toCursor(_m *Onboarding) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *onboardingPager) applyCursors(query *OnboardingQuery, after, before *Cursor) (*OnboardingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOnboardingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *onboardingPager) applyOrder(query *OnboardingQuery) *OnboardingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOnboardingOrder.Field {
		query = query.Order(DefaultOnboardingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *onboardingPager) orderExpr(query *OnboardingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOnboardingOrder.Field {
			b.Comma().Ident(DefaultOnboardingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Onboarding.
func (_m *OnboardingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OnboardingPaginateOption,
) (*OnboardingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOnboardingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OnboardingConnection{Edges: []*OnboardingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OnboardingOrderField defines the ordering field of Onboarding.
type OnboardingOrderField struct {
	// Value extracts the ordering value from the given Onboarding.
	Value    func(*Onboarding) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) onboarding.OrderOption
	toCursor func(*Onboarding) Cursor
}

// OnboardingOrder defines the ordering of Onboarding.
type OnboardingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *OnboardingOrderField `json:"field"`
}

// DefaultOnboardingOrder is the default ordering of Onboarding.
var DefaultOnboardingOrder = &OnboardingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OnboardingOrderField{
		Value: func(_m *Onboarding) (ent.Value, error) {
			return _m.ID, nil
		},
		column: onboarding.FieldID,
		toTerm: onboarding.ByID,
		toCursor: func(_m *Onboarding) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Onboarding into OnboardingEdge.
func (_m *Onboarding) ToEdge(order *OnboardingOrder) *OnboardingEdge {
	if order == nil {
		order = DefaultOnboardingOrder
	}
	return &OnboardingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgMembershipEdge is the edge representation of OrgMembership.
type OrgMembershipEdge struct {
	Node   *OrgMembership `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// OrgMembershipConnection is the connection containing edges to OrgMembership.
type OrgMembershipConnection struct {
	Edges      []*OrgMembershipEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *OrgMembershipConnection) build(nodes []*OrgMembership, pager *orgmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipPaginateOption enables pagination customization.
type OrgMembershipPaginateOption func(*orgmembershipPager) error

// WithOrgMembershipOrder configures pagination ordering.
func WithOrgMembershipOrder(order []*OrgMembershipOrder) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrgMembershipFilter configures pagination filter.
func WithOrgMembershipFilter(filter func(*OrgMembershipQuery) (*OrgMembershipQuery, error)) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		if filter == nil {
			return errors.New("OrgMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershipPager struct {
	reverse bool
	order   []*OrgMembershipOrder
	filter  func(*OrgMembershipQuery) (*OrgMembershipQuery, error)
}

func newOrgMembershipPager(opts []OrgMembershipPaginateOption, reverse bool) (*orgmembershipPager, error) {
	pager := &orgmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *orgmembershipPager) applyFilter(query *OrgMembershipQuery) (*OrgMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershipPager) toCursor(_m *OrgMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *orgmembershipPager) applyCursors(query *OrgMembershipQuery, after, before *Cursor) (*OrgMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrgMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *orgmembershipPager) applyOrder(query *OrgMembershipQuery) *OrgMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrgMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrgMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *orgmembershipPager) orderExpr(query *OrgMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrgMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembership.
func (_m *OrgMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipPaginateOption,
) (*OrgMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgMembershipConnection{Edges: []*OrgMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgMembershipOrderFieldCreatedAt orders OrgMembership by created_at.
	OrgMembershipOrderFieldCreatedAt = &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgmembership.FieldCreatedAt,
		toTerm: orgmembership.ByCreatedAt,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgMembershipOrderFieldUpdatedAt orders OrgMembership by updated_at.
	OrgMembershipOrderFieldUpdatedAt = &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgmembership.FieldUpdatedAt,
		toTerm: orgmembership.ByUpdatedAt,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgMembershipOrderFieldRole orders OrgMembership by role.
	OrgMembershipOrderFieldRole = &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.Role, nil
		},
		column: orgmembership.FieldRole,
		toTerm: orgmembership.ByRole,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgMembershipOrderField) String() string {
	var str string
	switch f.column {
	case OrgMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrgMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *OrgMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid OrgMembershipOrderField", str)
	}
	return nil
}

// OrgMembershipOrderField defines the ordering field of OrgMembership.
type OrgMembershipOrderField struct {
	// Value extracts the ordering value from the given OrgMembership.
	Value    func(*OrgMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembership.OrderOption
	toCursor func(*OrgMembership) Cursor
}

// OrgMembershipOrder defines the ordering of OrgMembership.
type OrgMembershipOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *OrgMembershipOrderField `json:"field"`
}

// DefaultOrgMembershipOrder is the default ordering of OrgMembership.
var DefaultOrgMembershipOrder = &OrgMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgmembership.FieldID,
		toTerm: orgmembership.ByID,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgMembership into OrgMembershipEdge.
func (_m *OrgMembership) ToEdge(order *OrgMembershipOrder) *OrgMembershipEdge {
	if order == nil {
		order = DefaultOrgMembershipOrder
	}
	return &OrgMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgMembershipHistoryEdge is the edge representation of OrgMembershipHistory.
type OrgMembershipHistoryEdge struct {
	Node   *OrgMembershipHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// OrgMembershipHistoryConnection is the connection containing edges to OrgMembershipHistory.
type OrgMembershipHistoryConnection struct {
	Edges      []*OrgMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *OrgMembershipHistoryConnection) build(nodes []*OrgMembershipHistory, pager *orgmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipHistoryPaginateOption enables pagination customization.
type OrgMembershipHistoryPaginateOption func(*orgmembershiphistoryPager) error

// WithOrgMembershipHistoryOrder configures pagination ordering.
func WithOrgMembershipHistoryOrder(order *OrgMembershipHistoryOrder) OrgMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	o := *order
	return func(pager *orgmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgMembershipHistoryFilter configures pagination filter.
func WithOrgMembershipHistoryFilter(filter func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)) OrgMembershipHistoryPaginateOption {
	return func(pager *orgmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("OrgMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershiphistoryPager struct {
	reverse bool
	order   *OrgMembershipHistoryOrder
	filter  func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)
}

func newOrgMembershipHistoryPager(opts []OrgMembershipHistoryPaginateOption, reverse bool) (*orgmembershiphistoryPager, error) {
	pager := &orgmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgMembershipHistoryOrder
	}
	return pager, nil
}

func (p *orgmembershiphistoryPager) applyFilter(query *OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) toCursor(_m *OrgMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *orgmembershiphistoryPager) applyCursors(query *OrgMembershipHistoryQuery, after, before *Cursor) (*OrgMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) applyOrder(query *OrgMembershipHistoryQuery) *OrgMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
		query = query.Order(DefaultOrgMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgmembershiphistoryPager) orderExpr(query *OrgMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembershipHistory.
func (_m *OrgMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipHistoryPaginateOption,
) (*OrgMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgMembershipHistoryConnection{Edges: []*OrgMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgMembershipHistoryOrderFieldHistoryTime orders OrgMembershipHistory by history_time.
	OrgMembershipHistoryOrderFieldHistoryTime = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: orgmembershiphistory.FieldHistoryTime,
		toTerm: orgmembershiphistory.ByHistoryTime,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldCreatedAt orders OrgMembershipHistory by created_at.
	OrgMembershipHistoryOrderFieldCreatedAt = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgmembershiphistory.FieldCreatedAt,
		toTerm: orgmembershiphistory.ByCreatedAt,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldUpdatedAt orders OrgMembershipHistory by updated_at.
	OrgMembershipHistoryOrderFieldUpdatedAt = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgmembershiphistory.FieldUpdatedAt,
		toTerm: orgmembershiphistory.ByUpdatedAt,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgMembershipHistoryOrderFieldRole orders OrgMembershipHistory by role.
	OrgMembershipHistoryOrderFieldRole = &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.Role, nil
		},
		column: orgmembershiphistory.FieldRole,
		toTerm: orgmembershiphistory.ByRole,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrgMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrgMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrgMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrgMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *OrgMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid OrgMembershipHistoryOrderField", str)
	}
	return nil
}

// OrgMembershipHistoryOrderField defines the ordering field of OrgMembershipHistory.
type OrgMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgMembershipHistory.
	Value    func(*OrgMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembershiphistory.OrderOption
	toCursor func(*OrgMembershipHistory) Cursor
}

// OrgMembershipHistoryOrder defines the ordering of OrgMembershipHistory.
type OrgMembershipHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *OrgMembershipHistoryOrderField `json:"field"`
}

// DefaultOrgMembershipHistoryOrder is the default ordering of OrgMembershipHistory.
var DefaultOrgMembershipHistoryOrder = &OrgMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipHistoryOrderField{
		Value: func(_m *OrgMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgmembershiphistory.FieldID,
		toTerm: orgmembershiphistory.ByID,
		toCursor: func(_m *OrgMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgMembershipHistory into OrgMembershipHistoryEdge.
func (_m *OrgMembershipHistory) ToEdge(order *OrgMembershipHistoryOrder) *OrgMembershipHistoryEdge {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	return &OrgMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgSubscriptionEdge is the edge representation of OrgSubscription.
type OrgSubscriptionEdge struct {
	Node   *OrgSubscription `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// OrgSubscriptionConnection is the connection containing edges to OrgSubscription.
type OrgSubscriptionConnection struct {
	Edges      []*OrgSubscriptionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *OrgSubscriptionConnection) build(nodes []*OrgSubscription, pager *orgsubscriptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgSubscription
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgSubscription {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgSubscription {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgSubscriptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgSubscriptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgSubscriptionPaginateOption enables pagination customization.
type OrgSubscriptionPaginateOption func(*orgsubscriptionPager) error

// WithOrgSubscriptionOrder configures pagination ordering.
func WithOrgSubscriptionOrder(order *OrgSubscriptionOrder) OrgSubscriptionPaginateOption {
	if order == nil {
		order = DefaultOrgSubscriptionOrder
	}
	o := *order
	return func(pager *orgsubscriptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgSubscriptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgSubscriptionFilter configures pagination filter.
func WithOrgSubscriptionFilter(filter func(*OrgSubscriptionQuery) (*OrgSubscriptionQuery, error)) OrgSubscriptionPaginateOption {
	return func(pager *orgsubscriptionPager) error {
		if filter == nil {
			return errors.New("OrgSubscriptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgsubscriptionPager struct {
	reverse bool
	order   *OrgSubscriptionOrder
	filter  func(*OrgSubscriptionQuery) (*OrgSubscriptionQuery, error)
}

func newOrgSubscriptionPager(opts []OrgSubscriptionPaginateOption, reverse bool) (*orgsubscriptionPager, error) {
	pager := &orgsubscriptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgSubscriptionOrder
	}
	return pager, nil
}

func (p *orgsubscriptionPager) applyFilter(query *OrgSubscriptionQuery) (*OrgSubscriptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgsubscriptionPager) toCursor(_m *OrgSubscription) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *orgsubscriptionPager) applyCursors(query *OrgSubscriptionQuery, after, before *Cursor) (*OrgSubscriptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgSubscriptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgsubscriptionPager) applyOrder(query *OrgSubscriptionQuery) *OrgSubscriptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgSubscriptionOrder.Field {
		query = query.Order(DefaultOrgSubscriptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgsubscriptionPager) orderExpr(query *OrgSubscriptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgSubscriptionOrder.Field {
			b.Comma().Ident(DefaultOrgSubscriptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgSubscription.
func (_m *OrgSubscriptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgSubscriptionPaginateOption,
) (*OrgSubscriptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgSubscriptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgSubscriptionConnection{Edges: []*OrgSubscriptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgSubscriptionOrderFieldCreatedAt orders OrgSubscription by created_at.
	OrgSubscriptionOrderFieldCreatedAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgsubscription.FieldCreatedAt,
		toTerm: orgsubscription.ByCreatedAt,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldUpdatedAt orders OrgSubscription by updated_at.
	OrgSubscriptionOrderFieldUpdatedAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgsubscription.FieldUpdatedAt,
		toTerm: orgsubscription.ByUpdatedAt,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldStripeSubscriptionStatus orders OrgSubscription by stripe_subscription_status.
	OrgSubscriptionOrderFieldStripeSubscriptionStatus = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.StripeSubscriptionStatus, nil
		},
		column: orgsubscription.FieldStripeSubscriptionStatus,
		toTerm: orgsubscription.ByStripeSubscriptionStatus,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StripeSubscriptionStatus,
			}
		},
	}
	// OrgSubscriptionOrderFieldActive orders OrgSubscription by active.
	OrgSubscriptionOrderFieldActive = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.Active, nil
		},
		column: orgsubscription.FieldActive,
		toTerm: orgsubscription.ByActive,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// OrgSubscriptionOrderFieldExpiresAt orders OrgSubscription by expires_at.
	OrgSubscriptionOrderFieldExpiresAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: orgsubscription.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscription) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldTrialExpiresAt orders OrgSubscription by trial_expires_at.
	OrgSubscriptionOrderFieldTrialExpiresAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if _m.TrialExpiresAt == nil {
				return nil, nil
			}
			return _m.TrialExpiresAt, nil
		},
		column: orgsubscription.FieldTrialExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByTrialExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscription) Cursor {
			if _m.TrialExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.TrialExpiresAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldDaysUntilDue orders OrgSubscription by days_until_due.
	OrgSubscriptionOrderFieldDaysUntilDue = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if _m.DaysUntilDue == nil {
				return nil, nil
			}
			return _m.DaysUntilDue, nil
		},
		column: orgsubscription.FieldDaysUntilDue,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByDaysUntilDue(opts...)
		},
		toCursor: func(_m *OrgSubscription) Cursor {
			if _m.DaysUntilDue == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.DaysUntilDue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgSubscriptionOrderField) String() string {
	var str string
	switch f.column {
	case OrgSubscriptionOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgSubscriptionOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgSubscriptionOrderFieldStripeSubscriptionStatus.column:
		str = "stripe_subscription_status"
	case OrgSubscriptionOrderFieldActive.column:
		str = "active"
	case OrgSubscriptionOrderFieldExpiresAt.column:
		str = "expires_at"
	case OrgSubscriptionOrderFieldTrialExpiresAt.column:
		str = "trial_expires_at"
	case OrgSubscriptionOrderFieldDaysUntilDue.column:
		str = "days_until_due"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgSubscriptionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgSubscriptionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgSubscriptionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrgSubscriptionOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgSubscriptionOrderFieldUpdatedAt
	case "stripe_subscription_status":
		*f = *OrgSubscriptionOrderFieldStripeSubscriptionStatus
	case "active":
		*f = *OrgSubscriptionOrderFieldActive
	case "expires_at":
		*f = *OrgSubscriptionOrderFieldExpiresAt
	case "trial_expires_at":
		*f = *OrgSubscriptionOrderFieldTrialExpiresAt
	case "days_until_due":
		*f = *OrgSubscriptionOrderFieldDaysUntilDue
	default:
		return fmt.Errorf("%s is not a valid OrgSubscriptionOrderField", str)
	}
	return nil
}

// OrgSubscriptionOrderField defines the ordering field of OrgSubscription.
type OrgSubscriptionOrderField struct {
	// Value extracts the ordering value from the given OrgSubscription.
	Value    func(*OrgSubscription) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgsubscription.OrderOption
	toCursor func(*OrgSubscription) Cursor
}

// OrgSubscriptionOrder defines the ordering of OrgSubscription.
type OrgSubscriptionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *OrgSubscriptionOrderField `json:"field"`
}

// DefaultOrgSubscriptionOrder is the default ordering of OrgSubscription.
var DefaultOrgSubscriptionOrder = &OrgSubscriptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgsubscription.FieldID,
		toTerm: orgsubscription.ByID,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgSubscription into OrgSubscriptionEdge.
func (_m *OrgSubscription) ToEdge(order *OrgSubscriptionOrder) *OrgSubscriptionEdge {
	if order == nil {
		order = DefaultOrgSubscriptionOrder
	}
	return &OrgSubscriptionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgSubscriptionHistoryEdge is the edge representation of OrgSubscriptionHistory.
type OrgSubscriptionHistoryEdge struct {
	Node   *OrgSubscriptionHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// OrgSubscriptionHistoryConnection is the connection containing edges to OrgSubscriptionHistory.
type OrgSubscriptionHistoryConnection struct {
	Edges      []*OrgSubscriptionHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *OrgSubscriptionHistoryConnection) build(nodes []*OrgSubscriptionHistory, pager *orgsubscriptionhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgSubscriptionHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgSubscriptionHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgSubscriptionHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgSubscriptionHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgSubscriptionHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgSubscriptionHistoryPaginateOption enables pagination customization.
type OrgSubscriptionHistoryPaginateOption func(*orgsubscriptionhistoryPager) error

// WithOrgSubscriptionHistoryOrder configures pagination ordering.
func WithOrgSubscriptionHistoryOrder(order *OrgSubscriptionHistoryOrder) OrgSubscriptionHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgSubscriptionHistoryOrder
	}
	o := *order
	return func(pager *orgsubscriptionhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgSubscriptionHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgSubscriptionHistoryFilter configures pagination filter.
func WithOrgSubscriptionHistoryFilter(filter func(*OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error)) OrgSubscriptionHistoryPaginateOption {
	return func(pager *orgsubscriptionhistoryPager) error {
		if filter == nil {
			return errors.New("OrgSubscriptionHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgsubscriptionhistoryPager struct {
	reverse bool
	order   *OrgSubscriptionHistoryOrder
	filter  func(*OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error)
}

func newOrgSubscriptionHistoryPager(opts []OrgSubscriptionHistoryPaginateOption, reverse bool) (*orgsubscriptionhistoryPager, error) {
	pager := &orgsubscriptionhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgSubscriptionHistoryOrder
	}
	return pager, nil
}

func (p *orgsubscriptionhistoryPager) applyFilter(query *OrgSubscriptionHistoryQuery) (*OrgSubscriptionHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgsubscriptionhistoryPager) toCursor(_m *OrgSubscriptionHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *orgsubscriptionhistoryPager) applyCursors(query *OrgSubscriptionHistoryQuery, after, before *Cursor) (*OrgSubscriptionHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgSubscriptionHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgsubscriptionhistoryPager) applyOrder(query *OrgSubscriptionHistoryQuery) *OrgSubscriptionHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgSubscriptionHistoryOrder.Field {
		query = query.Order(DefaultOrgSubscriptionHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgsubscriptionhistoryPager) orderExpr(query *OrgSubscriptionHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgSubscriptionHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgSubscriptionHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgSubscriptionHistory.
func (_m *OrgSubscriptionHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgSubscriptionHistoryPaginateOption,
) (*OrgSubscriptionHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgSubscriptionHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgSubscriptionHistoryConnection{Edges: []*OrgSubscriptionHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgSubscriptionHistoryOrderFieldHistoryTime orders OrgSubscriptionHistory by history_time.
	OrgSubscriptionHistoryOrderFieldHistoryTime = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: orgsubscriptionhistory.FieldHistoryTime,
		toTerm: orgsubscriptionhistory.ByHistoryTime,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldCreatedAt orders OrgSubscriptionHistory by created_at.
	OrgSubscriptionHistoryOrderFieldCreatedAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgsubscriptionhistory.FieldCreatedAt,
		toTerm: orgsubscriptionhistory.ByCreatedAt,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldUpdatedAt orders OrgSubscriptionHistory by updated_at.
	OrgSubscriptionHistoryOrderFieldUpdatedAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgsubscriptionhistory.FieldUpdatedAt,
		toTerm: orgsubscriptionhistory.ByUpdatedAt,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus orders OrgSubscriptionHistory by stripe_subscription_status.
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.StripeSubscriptionStatus, nil
		},
		column: orgsubscriptionhistory.FieldStripeSubscriptionStatus,
		toTerm: orgsubscriptionhistory.ByStripeSubscriptionStatus,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StripeSubscriptionStatus,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldActive orders OrgSubscriptionHistory by active.
	OrgSubscriptionHistoryOrderFieldActive = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.Active, nil
		},
		column: orgsubscriptionhistory.FieldActive,
		toTerm: orgsubscriptionhistory.ByActive,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldExpiresAt orders OrgSubscriptionHistory by expires_at.
	OrgSubscriptionHistoryOrderFieldExpiresAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: orgsubscriptionhistory.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldTrialExpiresAt orders OrgSubscriptionHistory by trial_expires_at.
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.TrialExpiresAt == nil {
				return nil, nil
			}
			return _m.TrialExpiresAt, nil
		},
		column: orgsubscriptionhistory.FieldTrialExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByTrialExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			if _m.TrialExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.TrialExpiresAt,
			}
		},
	}
	// OrgSubscriptionHistoryOrderFieldDaysUntilDue orders OrgSubscriptionHistory by days_until_due.
	OrgSubscriptionHistoryOrderFieldDaysUntilDue = &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.DaysUntilDue == nil {
				return nil, nil
			}
			return _m.DaysUntilDue, nil
		},
		column: orgsubscriptionhistory.FieldDaysUntilDue,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscriptionhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscriptionhistory.ByDaysUntilDue(opts...)
		},
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			if _m.DaysUntilDue == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.DaysUntilDue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgSubscriptionHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrgSubscriptionHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrgSubscriptionHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgSubscriptionHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus.column:
		str = "stripe_subscription_status"
	case OrgSubscriptionHistoryOrderFieldActive.column:
		str = "active"
	case OrgSubscriptionHistoryOrderFieldExpiresAt.column:
		str = "expires_at"
	case OrgSubscriptionHistoryOrderFieldTrialExpiresAt.column:
		str = "trial_expires_at"
	case OrgSubscriptionHistoryOrderFieldDaysUntilDue.column:
		str = "days_until_due"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgSubscriptionHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgSubscriptionHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgSubscriptionHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrgSubscriptionHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrgSubscriptionHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgSubscriptionHistoryOrderFieldUpdatedAt
	case "stripe_subscription_status":
		*f = *OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus
	case "active":
		*f = *OrgSubscriptionHistoryOrderFieldActive
	case "expires_at":
		*f = *OrgSubscriptionHistoryOrderFieldExpiresAt
	case "trial_expires_at":
		*f = *OrgSubscriptionHistoryOrderFieldTrialExpiresAt
	case "days_until_due":
		*f = *OrgSubscriptionHistoryOrderFieldDaysUntilDue
	default:
		return fmt.Errorf("%s is not a valid OrgSubscriptionHistoryOrderField", str)
	}
	return nil
}

// OrgSubscriptionHistoryOrderField defines the ordering field of OrgSubscriptionHistory.
type OrgSubscriptionHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgSubscriptionHistory.
	Value    func(*OrgSubscriptionHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgsubscriptionhistory.OrderOption
	toCursor func(*OrgSubscriptionHistory) Cursor
}

// OrgSubscriptionHistoryOrder defines the ordering of OrgSubscriptionHistory.
type OrgSubscriptionHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *OrgSubscriptionHistoryOrderField `json:"field"`
}

// DefaultOrgSubscriptionHistoryOrder is the default ordering of OrgSubscriptionHistory.
var DefaultOrgSubscriptionHistoryOrder = &OrgSubscriptionHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgSubscriptionHistoryOrderField{
		Value: func(_m *OrgSubscriptionHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgsubscriptionhistory.FieldID,
		toTerm: orgsubscriptionhistory.ByID,
		toCursor: func(_m *OrgSubscriptionHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgSubscriptionHistory into OrgSubscriptionHistoryEdge.
func (_m *OrgSubscriptionHistory) ToEdge(order *OrgSubscriptionHistoryOrder) *OrgSubscriptionHistoryEdge {
	if order == nil {
		order = DefaultOrgSubscriptionHistoryOrder
	}
	return &OrgSubscriptionHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order []*OrganizationOrder) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   []*OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(_m *Organization) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (_m *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationOrderFieldCreatedAt orders Organization by created_at.
	OrganizationOrderFieldCreatedAt = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organization.FieldCreatedAt,
		toTerm: organization.ByCreatedAt,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationOrderFieldUpdatedAt orders Organization by updated_at.
	OrganizationOrderFieldUpdatedAt = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organization.FieldUpdatedAt,
		toTerm: organization.ByUpdatedAt,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrganizationOrderFieldName orders Organization by name.
	OrganizationOrderFieldName = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.Name, nil
		},
		column: organization.FieldName,
		toTerm: organization.ByName,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// OrganizationOrderFieldDisplayName orders Organization by display_name.
	OrganizationOrderFieldDisplayName = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: organization.FieldDisplayName,
		toTerm: organization.ByDisplayName,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrganizationOrderFieldName.column:
		str = "name"
	case OrganizationOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrganizationOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationOrderFieldUpdatedAt
	case "name":
		*f = *OrganizationOrderFieldName
	case "display_name":
		*f = *OrganizationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (_m *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationHistoryEdge is the edge representation of OrganizationHistory.
type OrganizationHistoryEdge struct {
	Node   *OrganizationHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationHistoryConnection is the connection containing edges to OrganizationHistory.
type OrganizationHistoryConnection struct {
	Edges      []*OrganizationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationHistoryConnection) build(nodes []*OrganizationHistory, pager *organizationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationHistoryPaginateOption enables pagination customization.
type OrganizationHistoryPaginateOption func(*organizationhistoryPager) error

// WithOrganizationHistoryOrder configures pagination ordering.
func WithOrganizationHistoryOrder(order *OrganizationHistoryOrder) OrganizationHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	o := *order
	return func(pager *organizationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationHistoryFilter configures pagination filter.
func WithOrganizationHistoryFilter(filter func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)) OrganizationHistoryPaginateOption {
	return func(pager *organizationhistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationhistoryPager struct {
	reverse bool
	order   *OrganizationHistoryOrder
	filter  func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)
}

func newOrganizationHistoryPager(opts []OrganizationHistoryPaginateOption, reverse bool) (*organizationhistoryPager, error) {
	pager := &organizationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationHistoryOrder
	}
	return pager, nil
}

func (p *organizationhistoryPager) applyFilter(query *OrganizationHistoryQuery) (*OrganizationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationhistoryPager) toCursor(_m *OrganizationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *organizationhistoryPager) applyCursors(query *OrganizationHistoryQuery, after, before *Cursor) (*OrganizationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationhistoryPager) applyOrder(query *OrganizationHistoryQuery) *OrganizationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationHistoryOrder.Field {
		query = query.Order(DefaultOrganizationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationhistoryPager) orderExpr(query *OrganizationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationHistory.
func (_m *OrganizationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationHistoryPaginateOption,
) (*OrganizationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationHistoryConnection{Edges: []*OrganizationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationHistoryOrderFieldHistoryTime orders OrganizationHistory by history_time.
	OrganizationHistoryOrderFieldHistoryTime = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: organizationhistory.FieldHistoryTime,
		toTerm: organizationhistory.ByHistoryTime,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrganizationHistoryOrderFieldCreatedAt orders OrganizationHistory by created_at.
	OrganizationHistoryOrderFieldCreatedAt = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organizationhistory.FieldCreatedAt,
		toTerm: organizationhistory.ByCreatedAt,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationHistoryOrderFieldUpdatedAt orders OrganizationHistory by updated_at.
	OrganizationHistoryOrderFieldUpdatedAt = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organizationhistory.FieldUpdatedAt,
		toTerm: organizationhistory.ByUpdatedAt,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrganizationHistoryOrderFieldName orders OrganizationHistory by name.
	OrganizationHistoryOrderFieldName = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: organizationhistory.FieldName,
		toTerm: organizationhistory.ByName,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// OrganizationHistoryOrderFieldDisplayName orders OrganizationHistory by display_name.
	OrganizationHistoryOrderFieldDisplayName = &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: organizationhistory.FieldDisplayName,
		toTerm: organizationhistory.ByDisplayName,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrganizationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrganizationHistoryOrderFieldName.column:
		str = "name"
	case OrganizationHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrganizationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrganizationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationHistoryOrderFieldUpdatedAt
	case "name":
		*f = *OrganizationHistoryOrderFieldName
	case "display_name":
		*f = *OrganizationHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

// OrganizationHistoryOrderField defines the ordering field of OrganizationHistory.
type OrganizationHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationHistory.
	Value    func(*OrganizationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationhistory.OrderOption
	toCursor func(*OrganizationHistory) Cursor
}

// OrganizationHistoryOrder defines the ordering of OrganizationHistory.
type OrganizationHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationHistoryOrderField `json:"field"`
}

// DefaultOrganizationHistoryOrder is the default ordering of OrganizationHistory.
var DefaultOrganizationHistoryOrder = &OrganizationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationHistoryOrderField{
		Value: func(_m *OrganizationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organizationhistory.FieldID,
		toTerm: organizationhistory.ByID,
		toCursor: func(_m *OrganizationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrganizationHistory into OrganizationHistoryEdge.
func (_m *OrganizationHistory) ToEdge(order *OrganizationHistoryOrder) *OrganizationHistoryEdge {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	return &OrganizationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationSettingEdge is the edge representation of OrganizationSetting.
type OrganizationSettingEdge struct {
	Node   *OrganizationSetting `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationSettingConnection is the connection containing edges to OrganizationSetting.
type OrganizationSettingConnection struct {
	Edges      []*OrganizationSettingEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationSettingConnection) build(nodes []*OrganizationSetting, pager *organizationsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingPaginateOption enables pagination customization.
type OrganizationSettingPaginateOption func(*organizationsettingPager) error

// WithOrganizationSettingOrder configures pagination ordering.
func WithOrganizationSettingOrder(order []*OrganizationSettingOrder) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationSettingFilter configures pagination filter.
func WithOrganizationSettingFilter(filter func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettingPager struct {
	reverse bool
	order   []*OrganizationSettingOrder
	filter  func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)
}

func newOrganizationSettingPager(opts []OrganizationSettingPaginateOption, reverse bool) (*organizationsettingPager, error) {
	pager := &organizationsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationsettingPager) applyFilter(query *OrganizationSettingQuery) (*OrganizationSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettingPager) toCursor(_m *OrganizationSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *organizationsettingPager) applyCursors(query *OrganizationSettingQuery, after, before *Cursor) (*OrganizationSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *organizationsettingPager) applyOrder(query *OrganizationSettingQuery) *OrganizationSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationsettingPager) orderExpr(query *OrganizationSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSetting.
func (_m *OrganizationSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingPaginateOption,
) (*OrganizationSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingConnection{Edges: []*OrganizationSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationSettingOrderFieldCreatedAt orders OrganizationSetting by created_at.
	OrganizationSettingOrderFieldCreatedAt = &OrganizationSettingOrderField{
		Value: func(_m *OrganizationSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organizationsetting.FieldCreatedAt,
		toTerm: organizationsetting.ByCreatedAt,
		toCursor: func(_m *OrganizationSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationSettingOrderFieldUpdatedAt orders OrganizationSetting by updated_at.
	OrganizationSettingOrderFieldUpdatedAt = &OrganizationSettingOrderField{
		Value: func(_m *OrganizationSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organizationsetting.FieldUpdatedAt,
		toTerm: organizationsetting.ByUpdatedAt,
		toCursor: func(_m *OrganizationSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationSettingOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrganizationSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OrganizationSettingOrderField", str)
	}
	return nil
}

// OrganizationSettingOrderField defines the ordering field of OrganizationSetting.
type OrganizationSettingOrderField struct {
	// Value extracts the ordering value from the given OrganizationSetting.
	Value    func(*OrganizationSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsetting.OrderOption
	toCursor func(*OrganizationSetting) Cursor
}

// OrganizationSettingOrder defines the ordering of OrganizationSetting.
type OrganizationSettingOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationSettingOrderField `json:"field"`
}

// DefaultOrganizationSettingOrder is the default ordering of OrganizationSetting.
var DefaultOrganizationSettingOrder = &OrganizationSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingOrderField{
		Value: func(_m *OrganizationSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organizationsetting.FieldID,
		toTerm: organizationsetting.ByID,
		toCursor: func(_m *OrganizationSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrganizationSetting into OrganizationSettingEdge.
func (_m *OrganizationSetting) ToEdge(order *OrganizationSettingOrder) *OrganizationSettingEdge {
	if order == nil {
		order = DefaultOrganizationSettingOrder
	}
	return &OrganizationSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationSettingHistoryEdge is the edge representation of OrganizationSettingHistory.
type OrganizationSettingHistoryEdge struct {
	Node   *OrganizationSettingHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// OrganizationSettingHistoryConnection is the connection containing edges to OrganizationSettingHistory.
type OrganizationSettingHistoryConnection struct {
	Edges      []*OrganizationSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *OrganizationSettingHistoryConnection) build(nodes []*OrganizationSettingHistory, pager *organizationsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingHistoryPaginateOption enables pagination customization.
type OrganizationSettingHistoryPaginateOption func(*organizationsettinghistoryPager) error

// WithOrganizationSettingHistoryOrder configures pagination ordering.
func WithOrganizationSettingHistoryOrder(order *OrganizationSettingHistoryOrder) OrganizationSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	o := *order
	return func(pager *organizationsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationSettingHistoryFilter configures pagination filter.
func WithOrganizationSettingHistoryFilter(filter func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)) OrganizationSettingHistoryPaginateOption {
	return func(pager *organizationsettinghistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettinghistoryPager struct {
	reverse bool
	order   *OrganizationSettingHistoryOrder
	filter  func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)
}

func newOrganizationSettingHistoryPager(opts []OrganizationSettingHistoryPaginateOption, reverse bool) (*organizationsettinghistoryPager, error) {
	pager := &organizationsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationSettingHistoryOrder
	}
	return pager, nil
}

func (p *organizationsettinghistoryPager) applyFilter(query *OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) toCursor(_m *OrganizationSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *organizationsettinghistoryPager) applyCursors(query *OrganizationSettingHistoryQuery, after, before *Cursor) (*OrganizationSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) applyOrder(query *OrganizationSettingHistoryQuery) *OrganizationSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
		query = query.Order(DefaultOrganizationSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationsettinghistoryPager) orderExpr(query *OrganizationSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSettingHistory.
func (_m *OrganizationSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingHistoryPaginateOption,
) (*OrganizationSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingHistoryConnection{Edges: []*OrganizationSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationSettingHistoryOrderFieldHistoryTime orders OrganizationSettingHistory by history_time.
	OrganizationSettingHistoryOrderFieldHistoryTime = &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: organizationsettinghistory.FieldHistoryTime,
		toTerm: organizationsettinghistory.ByHistoryTime,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// OrganizationSettingHistoryOrderFieldCreatedAt orders OrganizationSettingHistory by created_at.
	OrganizationSettingHistoryOrderFieldCreatedAt = &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organizationsettinghistory.FieldCreatedAt,
		toTerm: organizationsettinghistory.ByCreatedAt,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationSettingHistoryOrderFieldUpdatedAt orders OrganizationSettingHistory by updated_at.
	OrganizationSettingHistoryOrderFieldUpdatedAt = &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organizationsettinghistory.FieldUpdatedAt,
		toTerm: organizationsettinghistory.ByUpdatedAt,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case OrganizationSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *OrganizationSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *OrganizationSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OrganizationSettingHistoryOrderField", str)
	}
	return nil
}

// OrganizationSettingHistoryOrderField defines the ordering field of OrganizationSettingHistory.
type OrganizationSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationSettingHistory.
	Value    func(*OrganizationSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsettinghistory.OrderOption
	toCursor func(*OrganizationSettingHistory) Cursor
}

// OrganizationSettingHistoryOrder defines the ordering of OrganizationSettingHistory.
type OrganizationSettingHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *OrganizationSettingHistoryOrderField `json:"field"`
}

// DefaultOrganizationSettingHistoryOrder is the default ordering of OrganizationSettingHistory.
var DefaultOrganizationSettingHistoryOrder = &OrganizationSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingHistoryOrderField{
		Value: func(_m *OrganizationSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organizationsettinghistory.FieldID,
		toTerm: organizationsettinghistory.ByID,
		toCursor: func(_m *OrganizationSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrganizationSettingHistory into OrganizationSettingHistoryEdge.
func (_m *OrganizationSettingHistory) ToEdge(order *OrganizationSettingHistoryOrder) *OrganizationSettingHistoryEdge {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	return &OrganizationSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// PersonalAccessTokenEdge is the edge representation of PersonalAccessToken.
type PersonalAccessTokenEdge struct {
	Node   *PersonalAccessToken `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// PersonalAccessTokenConnection is the connection containing edges to PersonalAccessToken.
type PersonalAccessTokenConnection struct {
	Edges      []*PersonalAccessTokenEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *PersonalAccessTokenConnection) build(nodes []*PersonalAccessToken, pager *personalaccesstokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *PersonalAccessToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonalAccessTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonalAccessTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonalAccessTokenPaginateOption enables pagination customization.
type PersonalAccessTokenPaginateOption func(*personalaccesstokenPager) error

// WithPersonalAccessTokenOrder configures pagination ordering.
func WithPersonalAccessTokenOrder(order []*PersonalAccessTokenOrder) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonalAccessTokenFilter configures pagination filter.
func WithPersonalAccessTokenFilter(filter func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		if filter == nil {
			return errors.New("PersonalAccessTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personalaccesstokenPager struct {
	reverse bool
	order   []*PersonalAccessTokenOrder
	filter  func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)
}

func newPersonalAccessTokenPager(opts []PersonalAccessTokenPaginateOption, reverse bool) (*personalaccesstokenPager, error) {
	pager := &personalaccesstokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personalaccesstokenPager) applyFilter(query *PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personalaccesstokenPager) toCursor(_m *PersonalAccessToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *personalaccesstokenPager) applyCursors(query *PersonalAccessTokenQuery, after, before *Cursor) (*PersonalAccessTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonalAccessTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *personalaccesstokenPager) applyOrder(query *PersonalAccessTokenQuery) *PersonalAccessTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonalAccessTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonalAccessTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personalaccesstokenPager) orderExpr(query *PersonalAccessTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonalAccessTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PersonalAccessToken.
func (_m *PersonalAccessTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PersonalAccessTokenPaginateOption,
) (*PersonalAccessTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonalAccessTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &PersonalAccessTokenConnection{Edges: []*PersonalAccessTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonalAccessTokenOrderFieldCreatedAt orders PersonalAccessToken by created_at.
	PersonalAccessTokenOrderFieldCreatedAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: personalaccesstoken.FieldCreatedAt,
		toTerm: personalaccesstoken.ByCreatedAt,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldUpdatedAt orders PersonalAccessToken by updated_at.
	PersonalAccessTokenOrderFieldUpdatedAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: personalaccesstoken.FieldUpdatedAt,
		toTerm: personalaccesstoken.ByUpdatedAt,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldName orders PersonalAccessToken by name.
	PersonalAccessTokenOrderFieldName = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.Name, nil
		},
		column: personalaccesstoken.FieldName,
		toTerm: personalaccesstoken.ByName,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// PersonalAccessTokenOrderFieldExpiresAt orders PersonalAccessToken by expires_at.
	PersonalAccessTokenOrderFieldExpiresAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: personalaccesstoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) personalaccesstoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return personalaccesstoken.ByExpiresAt(opts...)
		},
		toCursor: func(_m *PersonalAccessToken) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldLastUsedAt orders PersonalAccessToken by last_used_at.
	PersonalAccessTokenOrderFieldLastUsedAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: personalaccesstoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) personalaccesstoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return personalaccesstoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *PersonalAccessToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldIsActive orders PersonalAccessToken by is_active.
	PersonalAccessTokenOrderFieldIsActive = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.IsActive, nil
		},
		column: personalaccesstoken.FieldIsActive,
		toTerm: personalaccesstoken.ByIsActive,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsActive,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonalAccessTokenOrderField) String() string {
	var str string
	switch f.column {
	case PersonalAccessTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case PersonalAccessTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case PersonalAccessTokenOrderFieldName.column:
		str = "name"
	case PersonalAccessTokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case PersonalAccessTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case PersonalAccessTokenOrderFieldIsActive.column:
		str = "is_active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonalAccessTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonalAccessTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonalAccessTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *PersonalAccessTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *PersonalAccessTokenOrderFieldUpdatedAt
	case "name":
		*f = *PersonalAccessTokenOrderFieldName
	case "expires_at":
		*f = *PersonalAccessTokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *PersonalAccessTokenOrderFieldLastUsedAt
	case "is_active":
		*f = *PersonalAccessTokenOrderFieldIsActive
	default:
		return fmt.Errorf("%s is not a valid PersonalAccessTokenOrderField", str)
	}
	return nil
}

// PersonalAccessTokenOrderField defines the ordering field of PersonalAccessToken.
type PersonalAccessTokenOrderField struct {
	// Value extracts the ordering value from the given PersonalAccessToken.
	Value    func(*PersonalAccessToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) personalaccesstoken.OrderOption
	toCursor func(*PersonalAccessToken) Cursor
}

// PersonalAccessTokenOrder defines the ordering of PersonalAccessToken.
type PersonalAccessTokenOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *PersonalAccessTokenOrderField `json:"field"`
}

// DefaultPersonalAccessTokenOrder is the default ordering of PersonalAccessToken.
var DefaultPersonalAccessTokenOrder = &PersonalAccessTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: personalaccesstoken.FieldID,
		toTerm: personalaccesstoken.ByID,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts PersonalAccessToken into PersonalAccessTokenEdge.
func (_m *PersonalAccessToken) ToEdge(order *PersonalAccessTokenOrder) *PersonalAccessTokenEdge {
	if order == nil {
		order = DefaultPersonalAccessTokenOrder
	}
	return &PersonalAccessTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProcedureEdge is the edge representation of Procedure.
type ProcedureEdge struct {
	Node   *Procedure `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ProcedureConnection is the connection containing edges to Procedure.
type ProcedureConnection struct {
	Edges      []*ProcedureEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ProcedureConnection) build(nodes []*Procedure, pager *procedurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Procedure
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Procedure {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Procedure {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedurePaginateOption enables pagination customization.
type ProcedurePaginateOption func(*procedurePager) error

// WithProcedureOrder configures pagination ordering.
func WithProcedureOrder(order []*ProcedureOrder) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProcedureFilter configures pagination filter.
func WithProcedureFilter(filter func(*ProcedureQuery) (*ProcedureQuery, error)) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		if filter == nil {
			return errors.New("ProcedureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurePager struct {
	reverse bool
	order   []*ProcedureOrder
	filter  func(*ProcedureQuery) (*ProcedureQuery, error)
}

func newProcedurePager(opts []ProcedurePaginateOption, reverse bool) (*procedurePager, error) {
	pager := &procedurePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *procedurePager) applyFilter(query *ProcedureQuery) (*ProcedureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurePager) toCursor(_m *Procedure) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *procedurePager) applyCursors(query *ProcedureQuery, after, before *Cursor) (*ProcedureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProcedureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *procedurePager) applyOrder(query *ProcedureQuery) *ProcedureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProcedureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProcedureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *procedurePager) orderExpr(query *ProcedureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProcedureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Procedure.
func (_m *ProcedureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedurePaginateOption,
) (*ProcedureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedurePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProcedureConnection{Edges: []*ProcedureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcedureOrderFieldCreatedAt orders Procedure by created_at.
	ProcedureOrderFieldCreatedAt = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: procedure.FieldCreatedAt,
		toTerm: procedure.ByCreatedAt,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProcedureOrderFieldUpdatedAt orders Procedure by updated_at.
	ProcedureOrderFieldUpdatedAt = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: procedure.FieldUpdatedAt,
		toTerm: procedure.ByUpdatedAt,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProcedureOrderFieldRevision orders Procedure by revision.
	ProcedureOrderFieldRevision = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: procedure.FieldRevision,
		toTerm: procedure.ByRevision,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ProcedureOrderFieldName orders Procedure by name.
	ProcedureOrderFieldName = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.Name, nil
		},
		column: procedure.FieldName,
		toTerm: procedure.ByName,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProcedureOrderFieldStatus orders Procedure by status.
	ProcedureOrderFieldStatus = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.Status, nil
		},
		column: procedure.FieldStatus,
		toTerm: procedure.ByStatus,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProcedureOrderFieldReviewDue orders Procedure by review_due.
	ProcedureOrderFieldReviewDue = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: procedure.FieldReviewDue,
		toTerm: procedure.ByReviewDue,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ProcedureOrderFieldReviewFrequency orders Procedure by review_frequency.
	ProcedureOrderFieldReviewFrequency = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: procedure.FieldReviewFrequency,
		toTerm: procedure.ByReviewFrequency,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcedureOrderField) String() string {
	var str string
	switch f.column {
	case ProcedureOrderFieldCreatedAt.column:
		str = "created_at"
	case ProcedureOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProcedureOrderFieldRevision.column:
		str = "revision"
	case ProcedureOrderFieldName.column:
		str = "name"
	case ProcedureOrderFieldStatus.column:
		str = "STATUS"
	case ProcedureOrderFieldReviewDue.column:
		str = "review_due"
	case ProcedureOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcedureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcedureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcedureOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProcedureOrderFieldCreatedAt
	case "updated_at":
		*f = *ProcedureOrderFieldUpdatedAt
	case "revision":
		*f = *ProcedureOrderFieldRevision
	case "name":
		*f = *ProcedureOrderFieldName
	case "STATUS":
		*f = *ProcedureOrderFieldStatus
	case "review_due":
		*f = *ProcedureOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ProcedureOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid ProcedureOrderField", str)
	}
	return nil
}

// ProcedureOrderField defines the ordering field of Procedure.
type ProcedureOrderField struct {
	// Value extracts the ordering value from the given Procedure.
	Value    func(*Procedure) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedure.OrderOption
	toCursor func(*Procedure) Cursor
}

// ProcedureOrder defines the ordering of Procedure.
type ProcedureOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ProcedureOrderField `json:"field"`
}

// DefaultProcedureOrder is the default ordering of Procedure.
var DefaultProcedureOrder = &ProcedureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.ID, nil
		},
		column: procedure.FieldID,
		toTerm: procedure.ByID,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Procedure into ProcedureEdge.
func (_m *Procedure) ToEdge(order *ProcedureOrder) *ProcedureEdge {
	if order == nil {
		order = DefaultProcedureOrder
	}
	return &ProcedureEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProcedureHistoryEdge is the edge representation of ProcedureHistory.
type ProcedureHistoryEdge struct {
	Node   *ProcedureHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProcedureHistoryConnection is the connection containing edges to ProcedureHistory.
type ProcedureHistoryConnection struct {
	Edges      []*ProcedureHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProcedureHistoryConnection) build(nodes []*ProcedureHistory, pager *procedurehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProcedureHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedureHistoryPaginateOption enables pagination customization.
type ProcedureHistoryPaginateOption func(*procedurehistoryPager) error

// WithProcedureHistoryOrder configures pagination ordering.
func WithProcedureHistoryOrder(order *ProcedureHistoryOrder) ProcedureHistoryPaginateOption {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	o := *order
	return func(pager *procedurehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcedureHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcedureHistoryFilter configures pagination filter.
func WithProcedureHistoryFilter(filter func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)) ProcedureHistoryPaginateOption {
	return func(pager *procedurehistoryPager) error {
		if filter == nil {
			return errors.New("ProcedureHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurehistoryPager struct {
	reverse bool
	order   *ProcedureHistoryOrder
	filter  func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)
}

func newProcedureHistoryPager(opts []ProcedureHistoryPaginateOption, reverse bool) (*procedurehistoryPager, error) {
	pager := &procedurehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcedureHistoryOrder
	}
	return pager, nil
}

func (p *procedurehistoryPager) applyFilter(query *ProcedureHistoryQuery) (*ProcedureHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurehistoryPager) toCursor(_m *ProcedureHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *procedurehistoryPager) applyCursors(query *ProcedureHistoryQuery, after, before *Cursor) (*ProcedureHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcedureHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procedurehistoryPager) applyOrder(query *ProcedureHistoryQuery) *ProcedureHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcedureHistoryOrder.Field {
		query = query.Order(DefaultProcedureHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procedurehistoryPager) orderExpr(query *ProcedureHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcedureHistoryOrder.Field {
			b.Comma().Ident(DefaultProcedureHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProcedureHistory.
func (_m *ProcedureHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedureHistoryPaginateOption,
) (*ProcedureHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedureHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProcedureHistoryConnection{Edges: []*ProcedureHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcedureHistoryOrderFieldHistoryTime orders ProcedureHistory by history_time.
	ProcedureHistoryOrderFieldHistoryTime = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: procedurehistory.FieldHistoryTime,
		toTerm: procedurehistory.ByHistoryTime,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ProcedureHistoryOrderFieldCreatedAt orders ProcedureHistory by created_at.
	ProcedureHistoryOrderFieldCreatedAt = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: procedurehistory.FieldCreatedAt,
		toTerm: procedurehistory.ByCreatedAt,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProcedureHistoryOrderFieldUpdatedAt orders ProcedureHistory by updated_at.
	ProcedureHistoryOrderFieldUpdatedAt = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: procedurehistory.FieldUpdatedAt,
		toTerm: procedurehistory.ByUpdatedAt,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProcedureHistoryOrderFieldRevision orders ProcedureHistory by revision.
	ProcedureHistoryOrderFieldRevision = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: procedurehistory.FieldRevision,
		toTerm: procedurehistory.ByRevision,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ProcedureHistoryOrderFieldName orders ProcedureHistory by name.
	ProcedureHistoryOrderFieldName = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: procedurehistory.FieldName,
		toTerm: procedurehistory.ByName,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProcedureHistoryOrderFieldStatus orders ProcedureHistory by status.
	ProcedureHistoryOrderFieldStatus = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: procedurehistory.FieldStatus,
		toTerm: procedurehistory.ByStatus,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProcedureHistoryOrderFieldReviewDue orders ProcedureHistory by review_due.
	ProcedureHistoryOrderFieldReviewDue = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: procedurehistory.FieldReviewDue,
		toTerm: procedurehistory.ByReviewDue,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ProcedureHistoryOrderFieldReviewFrequency orders ProcedureHistory by review_frequency.
	ProcedureHistoryOrderFieldReviewFrequency = &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: procedurehistory.FieldReviewFrequency,
		toTerm: procedurehistory.ByReviewFrequency,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcedureHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProcedureHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProcedureHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProcedureHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProcedureHistoryOrderFieldRevision.column:
		str = "revision"
	case ProcedureHistoryOrderFieldName.column:
		str = "name"
	case ProcedureHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ProcedureHistoryOrderFieldReviewDue.column:
		str = "review_due"
	case ProcedureHistoryOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcedureHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcedureHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcedureHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProcedureHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProcedureHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProcedureHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *ProcedureHistoryOrderFieldRevision
	case "name":
		*f = *ProcedureHistoryOrderFieldName
	case "STATUS":
		*f = *ProcedureHistoryOrderFieldStatus
	case "review_due":
		*f = *ProcedureHistoryOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ProcedureHistoryOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid ProcedureHistoryOrderField", str)
	}
	return nil
}

// ProcedureHistoryOrderField defines the ordering field of ProcedureHistory.
type ProcedureHistoryOrderField struct {
	// Value extracts the ordering value from the given ProcedureHistory.
	Value    func(*ProcedureHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedurehistory.OrderOption
	toCursor func(*ProcedureHistory) Cursor
}

// ProcedureHistoryOrder defines the ordering of ProcedureHistory.
type ProcedureHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProcedureHistoryOrderField `json:"field"`
}

// DefaultProcedureHistoryOrder is the default ordering of ProcedureHistory.
var DefaultProcedureHistoryOrder = &ProcedureHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureHistoryOrderField{
		Value: func(_m *ProcedureHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: procedurehistory.FieldID,
		toTerm: procedurehistory.ByID,
		toCursor: func(_m *ProcedureHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProcedureHistory into ProcedureHistoryEdge.
func (_m *ProcedureHistory) ToEdge(order *ProcedureHistoryOrder) *ProcedureHistoryEdge {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	return &ProcedureHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramEdge is the edge representation of Program.
type ProgramEdge struct {
	Node   *Program `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProgramConnection is the connection containing edges to Program.
type ProgramConnection struct {
	Edges      []*ProgramEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProgramConnection) build(nodes []*Program, pager *programPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Program
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Program {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Program {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramPaginateOption enables pagination customization.
type ProgramPaginateOption func(*programPager) error

// WithProgramOrder configures pagination ordering.
func WithProgramOrder(order []*ProgramOrder) ProgramPaginateOption {
	return func(pager *programPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProgramFilter configures pagination filter.
func WithProgramFilter(filter func(*ProgramQuery) (*ProgramQuery, error)) ProgramPaginateOption {
	return func(pager *programPager) error {
		if filter == nil {
			return errors.New("ProgramQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programPager struct {
	reverse bool
	order   []*ProgramOrder
	filter  func(*ProgramQuery) (*ProgramQuery, error)
}

func newProgramPager(opts []ProgramPaginateOption, reverse bool) (*programPager, error) {
	pager := &programPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *programPager) applyFilter(query *ProgramQuery) (*ProgramQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programPager) toCursor(_m *Program) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *programPager) applyCursors(query *ProgramQuery, after, before *Cursor) (*ProgramQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProgramOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *programPager) applyOrder(query *ProgramQuery) *ProgramQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProgramOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProgramOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *programPager) orderExpr(query *ProgramQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProgramOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Program.
func (_m *ProgramQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramPaginateOption,
) (*ProgramConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramConnection{Edges: []*ProgramEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramOrderFieldCreatedAt orders Program by created_at.
	ProgramOrderFieldCreatedAt = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: program.FieldCreatedAt,
		toTerm: program.ByCreatedAt,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramOrderFieldUpdatedAt orders Program by updated_at.
	ProgramOrderFieldUpdatedAt = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: program.FieldUpdatedAt,
		toTerm: program.ByUpdatedAt,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramOrderFieldName orders Program by name.
	ProgramOrderFieldName = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.Name, nil
		},
		column: program.FieldName,
		toTerm: program.ByName,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProgramOrderFieldStatus orders Program by status.
	ProgramOrderFieldStatus = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.Status, nil
		},
		column: program.FieldStatus,
		toTerm: program.ByStatus,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProgramOrderFieldProgramType orders Program by program_type.
	ProgramOrderFieldProgramType = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.ProgramType, nil
		},
		column: program.FieldProgramType,
		toTerm: program.ByProgramType,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ProgramType,
			}
		},
	}
	// ProgramOrderFieldFrameworkName orders Program by framework_name.
	ProgramOrderFieldFrameworkName = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.FrameworkName, nil
		},
		column: program.FieldFrameworkName,
		toTerm: program.ByFrameworkName,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FrameworkName,
			}
		},
	}
	// ProgramOrderFieldStartDate orders Program by start_date.
	ProgramOrderFieldStartDate = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.StartDate, nil
		},
		column: program.FieldStartDate,
		toTerm: program.ByStartDate,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartDate,
			}
		},
	}
	// ProgramOrderFieldEndDate orders Program by end_date.
	ProgramOrderFieldEndDate = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.EndDate, nil
		},
		column: program.FieldEndDate,
		toTerm: program.ByEndDate,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramOrderField) String() string {
	var str string
	switch f.column {
	case ProgramOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramOrderFieldName.column:
		str = "name"
	case ProgramOrderFieldStatus.column:
		str = "STATUS"
	case ProgramOrderFieldProgramType.column:
		str = "PROGRAM_TYPE"
	case ProgramOrderFieldFrameworkName.column:
		str = "framework"
	case ProgramOrderFieldStartDate.column:
		str = "start_date"
	case ProgramOrderFieldEndDate.column:
		str = "end_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProgramOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramOrderFieldUpdatedAt
	case "name":
		*f = *ProgramOrderFieldName
	case "STATUS":
		*f = *ProgramOrderFieldStatus
	case "PROGRAM_TYPE":
		*f = *ProgramOrderFieldProgramType
	case "framework":
		*f = *ProgramOrderFieldFrameworkName
	case "start_date":
		*f = *ProgramOrderFieldStartDate
	case "end_date":
		*f = *ProgramOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid ProgramOrderField", str)
	}
	return nil
}

// ProgramOrderField defines the ordering field of Program.
type ProgramOrderField struct {
	// Value extracts the ordering value from the given Program.
	Value    func(*Program) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) program.OrderOption
	toCursor func(*Program) Cursor
}

// ProgramOrder defines the ordering of Program.
type ProgramOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProgramOrderField `json:"field"`
}

// DefaultProgramOrder is the default ordering of Program.
var DefaultProgramOrder = &ProgramOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.ID, nil
		},
		column: program.FieldID,
		toTerm: program.ByID,
		toCursor: func(_m *Program) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Program into ProgramEdge.
func (_m *Program) ToEdge(order *ProgramOrder) *ProgramEdge {
	if order == nil {
		order = DefaultProgramOrder
	}
	return &ProgramEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramHistoryEdge is the edge representation of ProgramHistory.
type ProgramHistoryEdge struct {
	Node   *ProgramHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ProgramHistoryConnection is the connection containing edges to ProgramHistory.
type ProgramHistoryConnection struct {
	Edges      []*ProgramHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ProgramHistoryConnection) build(nodes []*ProgramHistory, pager *programhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramHistoryPaginateOption enables pagination customization.
type ProgramHistoryPaginateOption func(*programhistoryPager) error

// WithProgramHistoryOrder configures pagination ordering.
func WithProgramHistoryOrder(order *ProgramHistoryOrder) ProgramHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	o := *order
	return func(pager *programhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramHistoryFilter configures pagination filter.
func WithProgramHistoryFilter(filter func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)) ProgramHistoryPaginateOption {
	return func(pager *programhistoryPager) error {
		if filter == nil {
			return errors.New("ProgramHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programhistoryPager struct {
	reverse bool
	order   *ProgramHistoryOrder
	filter  func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)
}

func newProgramHistoryPager(opts []ProgramHistoryPaginateOption, reverse bool) (*programhistoryPager, error) {
	pager := &programhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramHistoryOrder
	}
	return pager, nil
}

func (p *programhistoryPager) applyFilter(query *ProgramHistoryQuery) (*ProgramHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programhistoryPager) toCursor(_m *ProgramHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *programhistoryPager) applyCursors(query *ProgramHistoryQuery, after, before *Cursor) (*ProgramHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programhistoryPager) applyOrder(query *ProgramHistoryQuery) *ProgramHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramHistoryOrder.Field {
		query = query.Order(DefaultProgramHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programhistoryPager) orderExpr(query *ProgramHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramHistory.
func (_m *ProgramHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramHistoryPaginateOption,
) (*ProgramHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramHistoryConnection{Edges: []*ProgramHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramHistoryOrderFieldHistoryTime orders ProgramHistory by history_time.
	ProgramHistoryOrderFieldHistoryTime = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: programhistory.FieldHistoryTime,
		toTerm: programhistory.ByHistoryTime,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ProgramHistoryOrderFieldCreatedAt orders ProgramHistory by created_at.
	ProgramHistoryOrderFieldCreatedAt = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: programhistory.FieldCreatedAt,
		toTerm: programhistory.ByCreatedAt,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramHistoryOrderFieldUpdatedAt orders ProgramHistory by updated_at.
	ProgramHistoryOrderFieldUpdatedAt = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: programhistory.FieldUpdatedAt,
		toTerm: programhistory.ByUpdatedAt,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramHistoryOrderFieldName orders ProgramHistory by name.
	ProgramHistoryOrderFieldName = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: programhistory.FieldName,
		toTerm: programhistory.ByName,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProgramHistoryOrderFieldStatus orders ProgramHistory by status.
	ProgramHistoryOrderFieldStatus = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: programhistory.FieldStatus,
		toTerm: programhistory.ByStatus,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProgramHistoryOrderFieldProgramType orders ProgramHistory by program_type.
	ProgramHistoryOrderFieldProgramType = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.ProgramType, nil
		},
		column: programhistory.FieldProgramType,
		toTerm: programhistory.ByProgramType,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ProgramType,
			}
		},
	}
	// ProgramHistoryOrderFieldFrameworkName orders ProgramHistory by framework_name.
	ProgramHistoryOrderFieldFrameworkName = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.FrameworkName, nil
		},
		column: programhistory.FieldFrameworkName,
		toTerm: programhistory.ByFrameworkName,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FrameworkName,
			}
		},
	}
	// ProgramHistoryOrderFieldStartDate orders ProgramHistory by start_date.
	ProgramHistoryOrderFieldStartDate = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.StartDate, nil
		},
		column: programhistory.FieldStartDate,
		toTerm: programhistory.ByStartDate,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartDate,
			}
		},
	}
	// ProgramHistoryOrderFieldEndDate orders ProgramHistory by end_date.
	ProgramHistoryOrderFieldEndDate = &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.EndDate, nil
		},
		column: programhistory.FieldEndDate,
		toTerm: programhistory.ByEndDate,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProgramHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProgramHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramHistoryOrderFieldName.column:
		str = "name"
	case ProgramHistoryOrderFieldStatus.column:
		str = "STATUS"
	case ProgramHistoryOrderFieldProgramType.column:
		str = "PROGRAM_TYPE"
	case ProgramHistoryOrderFieldFrameworkName.column:
		str = "framework"
	case ProgramHistoryOrderFieldStartDate.column:
		str = "start_date"
	case ProgramHistoryOrderFieldEndDate.column:
		str = "end_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProgramHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProgramHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramHistoryOrderFieldUpdatedAt
	case "name":
		*f = *ProgramHistoryOrderFieldName
	case "STATUS":
		*f = *ProgramHistoryOrderFieldStatus
	case "PROGRAM_TYPE":
		*f = *ProgramHistoryOrderFieldProgramType
	case "framework":
		*f = *ProgramHistoryOrderFieldFrameworkName
	case "start_date":
		*f = *ProgramHistoryOrderFieldStartDate
	case "end_date":
		*f = *ProgramHistoryOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid ProgramHistoryOrderField", str)
	}
	return nil
}

// ProgramHistoryOrderField defines the ordering field of ProgramHistory.
type ProgramHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramHistory.
	Value    func(*ProgramHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programhistory.OrderOption
	toCursor func(*ProgramHistory) Cursor
}

// ProgramHistoryOrder defines the ordering of ProgramHistory.
type ProgramHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ProgramHistoryOrderField `json:"field"`
}

// DefaultProgramHistoryOrder is the default ordering of ProgramHistory.
var DefaultProgramHistoryOrder = &ProgramHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramHistoryOrderField{
		Value: func(_m *ProgramHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: programhistory.FieldID,
		toTerm: programhistory.ByID,
		toCursor: func(_m *ProgramHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProgramHistory into ProgramHistoryEdge.
func (_m *ProgramHistory) ToEdge(order *ProgramHistoryOrder) *ProgramHistoryEdge {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	return &ProgramHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramMembershipEdge is the edge representation of ProgramMembership.
type ProgramMembershipEdge struct {
	Node   *ProgramMembership `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ProgramMembershipConnection is the connection containing edges to ProgramMembership.
type ProgramMembershipConnection struct {
	Edges      []*ProgramMembershipEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ProgramMembershipConnection) build(nodes []*ProgramMembership, pager *programmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipPaginateOption enables pagination customization.
type ProgramMembershipPaginateOption func(*programmembershipPager) error

// WithProgramMembershipOrder configures pagination ordering.
func WithProgramMembershipOrder(order []*ProgramMembershipOrder) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProgramMembershipFilter configures pagination filter.
func WithProgramMembershipFilter(filter func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershipPager struct {
	reverse bool
	order   []*ProgramMembershipOrder
	filter  func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)
}

func newProgramMembershipPager(opts []ProgramMembershipPaginateOption, reverse bool) (*programmembershipPager, error) {
	pager := &programmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *programmembershipPager) applyFilter(query *ProgramMembershipQuery) (*ProgramMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershipPager) toCursor(_m *ProgramMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *programmembershipPager) applyCursors(query *ProgramMembershipQuery, after, before *Cursor) (*ProgramMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProgramMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *programmembershipPager) applyOrder(query *ProgramMembershipQuery) *ProgramMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProgramMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProgramMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *programmembershipPager) orderExpr(query *ProgramMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProgramMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembership.
func (_m *ProgramMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipPaginateOption,
) (*ProgramMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipConnection{Edges: []*ProgramMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramMembershipOrderFieldCreatedAt orders ProgramMembership by created_at.
	ProgramMembershipOrderFieldCreatedAt = &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: programmembership.FieldCreatedAt,
		toTerm: programmembership.ByCreatedAt,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramMembershipOrderFieldUpdatedAt orders ProgramMembership by updated_at.
	ProgramMembershipOrderFieldUpdatedAt = &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: programmembership.FieldUpdatedAt,
		toTerm: programmembership.ByUpdatedAt,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramMembershipOrderFieldRole orders ProgramMembership by role.
	ProgramMembershipOrderFieldRole = &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.Role, nil
		},
		column: programmembership.FieldRole,
		toTerm: programmembership.ByRole,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramMembershipOrderField) String() string {
	var str string
	switch f.column {
	case ProgramMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProgramMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *ProgramMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid ProgramMembershipOrderField", str)
	}
	return nil
}

// ProgramMembershipOrderField defines the ordering field of ProgramMembership.
type ProgramMembershipOrderField struct {
	// Value extracts the ordering value from the given ProgramMembership.
	Value    func(*ProgramMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembership.OrderOption
	toCursor func(*ProgramMembership) Cursor
}

// ProgramMembershipOrder defines the ordering of ProgramMembership.
type ProgramMembershipOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ProgramMembershipOrderField `json:"field"`
}

// DefaultProgramMembershipOrder is the default ordering of ProgramMembership.
var DefaultProgramMembershipOrder = &ProgramMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: programmembership.FieldID,
		toTerm: programmembership.ByID,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProgramMembership into ProgramMembershipEdge.
func (_m *ProgramMembership) ToEdge(order *ProgramMembershipOrder) *ProgramMembershipEdge {
	if order == nil {
		order = DefaultProgramMembershipOrder
	}
	return &ProgramMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramMembershipHistoryEdge is the edge representation of ProgramMembershipHistory.
type ProgramMembershipHistoryEdge struct {
	Node   *ProgramMembershipHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// ProgramMembershipHistoryConnection is the connection containing edges to ProgramMembershipHistory.
type ProgramMembershipHistoryConnection struct {
	Edges      []*ProgramMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *ProgramMembershipHistoryConnection) build(nodes []*ProgramMembershipHistory, pager *programmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipHistoryPaginateOption enables pagination customization.
type ProgramMembershipHistoryPaginateOption func(*programmembershiphistoryPager) error

// WithProgramMembershipHistoryOrder configures pagination ordering.
func WithProgramMembershipHistoryOrder(order *ProgramMembershipHistoryOrder) ProgramMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	o := *order
	return func(pager *programmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramMembershipHistoryFilter configures pagination filter.
func WithProgramMembershipHistoryFilter(filter func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)) ProgramMembershipHistoryPaginateOption {
	return func(pager *programmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershiphistoryPager struct {
	reverse bool
	order   *ProgramMembershipHistoryOrder
	filter  func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)
}

func newProgramMembershipHistoryPager(opts []ProgramMembershipHistoryPaginateOption, reverse bool) (*programmembershiphistoryPager, error) {
	pager := &programmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramMembershipHistoryOrder
	}
	return pager, nil
}

func (p *programmembershiphistoryPager) applyFilter(query *ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) toCursor(_m *ProgramMembershipHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *programmembershiphistoryPager) applyCursors(query *ProgramMembershipHistoryQuery, after, before *Cursor) (*ProgramMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) applyOrder(query *ProgramMembershipHistoryQuery) *ProgramMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
		query = query.Order(DefaultProgramMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programmembershiphistoryPager) orderExpr(query *ProgramMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembershipHistory.
func (_m *ProgramMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipHistoryPaginateOption,
) (*ProgramMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipHistoryConnection{Edges: []*ProgramMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramMembershipHistoryOrderFieldHistoryTime orders ProgramMembershipHistory by history_time.
	ProgramMembershipHistoryOrderFieldHistoryTime = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: programmembershiphistory.FieldHistoryTime,
		toTerm: programmembershiphistory.ByHistoryTime,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldCreatedAt orders ProgramMembershipHistory by created_at.
	ProgramMembershipHistoryOrderFieldCreatedAt = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: programmembershiphistory.FieldCreatedAt,
		toTerm: programmembershiphistory.ByCreatedAt,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldUpdatedAt orders ProgramMembershipHistory by updated_at.
	ProgramMembershipHistoryOrderFieldUpdatedAt = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: programmembershiphistory.FieldUpdatedAt,
		toTerm: programmembershiphistory.ByUpdatedAt,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramMembershipHistoryOrderFieldRole orders ProgramMembershipHistory by role.
	ProgramMembershipHistoryOrderFieldRole = &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.Role, nil
		},
		column: programmembershiphistory.FieldRole,
		toTerm: programmembershiphistory.ByRole,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramMembershipHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ProgramMembershipHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ProgramMembershipHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramMembershipHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramMembershipHistoryOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramMembershipHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramMembershipHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ProgramMembershipHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ProgramMembershipHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramMembershipHistoryOrderFieldUpdatedAt
	case "ROLE":
		*f = *ProgramMembershipHistoryOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid ProgramMembershipHistoryOrderField", str)
	}
	return nil
}

// ProgramMembershipHistoryOrderField defines the ordering field of ProgramMembershipHistory.
type ProgramMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramMembershipHistory.
	Value    func(*ProgramMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembershiphistory.OrderOption
	toCursor func(*ProgramMembershipHistory) Cursor
}

// ProgramMembershipHistoryOrder defines the ordering of ProgramMembershipHistory.
type ProgramMembershipHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *ProgramMembershipHistoryOrderField `json:"field"`
}

// DefaultProgramMembershipHistoryOrder is the default ordering of ProgramMembershipHistory.
var DefaultProgramMembershipHistoryOrder = &ProgramMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipHistoryOrderField{
		Value: func(_m *ProgramMembershipHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: programmembershiphistory.FieldID,
		toTerm: programmembershiphistory.ByID,
		toCursor: func(_m *ProgramMembershipHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProgramMembershipHistory into ProgramMembershipHistoryEdge.
func (_m *ProgramMembershipHistory) ToEdge(order *ProgramMembershipHistoryOrder) *ProgramMembershipHistoryEdge {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	return &ProgramMembershipHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RemediationEdge is the edge representation of Remediation.
type RemediationEdge struct {
	Node   *Remediation `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// RemediationConnection is the connection containing edges to Remediation.
type RemediationConnection struct {
	Edges      []*RemediationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *RemediationConnection) build(nodes []*Remediation, pager *remediationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Remediation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Remediation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Remediation {
			return nodes[i]
		}
	}
	c.Edges = make([]*RemediationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RemediationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RemediationPaginateOption enables pagination customization.
type RemediationPaginateOption func(*remediationPager) error

// WithRemediationOrder configures pagination ordering.
func WithRemediationOrder(order []*RemediationOrder) RemediationPaginateOption {
	return func(pager *remediationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRemediationFilter configures pagination filter.
func WithRemediationFilter(filter func(*RemediationQuery) (*RemediationQuery, error)) RemediationPaginateOption {
	return func(pager *remediationPager) error {
		if filter == nil {
			return errors.New("RemediationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type remediationPager struct {
	reverse bool
	order   []*RemediationOrder
	filter  func(*RemediationQuery) (*RemediationQuery, error)
}

func newRemediationPager(opts []RemediationPaginateOption, reverse bool) (*remediationPager, error) {
	pager := &remediationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *remediationPager) applyFilter(query *RemediationQuery) (*RemediationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *remediationPager) toCursor(_m *Remediation) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *remediationPager) applyCursors(query *RemediationQuery, after, before *Cursor) (*RemediationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRemediationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *remediationPager) applyOrder(query *RemediationQuery) *RemediationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRemediationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRemediationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *remediationPager) orderExpr(query *RemediationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRemediationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Remediation.
func (_m *RemediationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RemediationPaginateOption,
) (*RemediationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRemediationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RemediationConnection{Edges: []*RemediationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RemediationOrderFieldCreatedAt orders Remediation by created_at.
	RemediationOrderFieldCreatedAt = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: remediation.FieldCreatedAt,
		toTerm: remediation.ByCreatedAt,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RemediationOrderFieldUpdatedAt orders Remediation by updated_at.
	RemediationOrderFieldUpdatedAt = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: remediation.FieldUpdatedAt,
		toTerm: remediation.ByUpdatedAt,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RemediationOrderFieldExternalID orders Remediation by external_id.
	RemediationOrderFieldExternalID = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: remediation.FieldExternalID,
		toTerm: remediation.ByExternalID,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// RemediationOrderFieldExternalOwnerID orders Remediation by external_owner_id.
	RemediationOrderFieldExternalOwnerID = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: remediation.FieldExternalOwnerID,
		toTerm: remediation.ByExternalOwnerID,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// RemediationOrderFieldTitle orders Remediation by title.
	RemediationOrderFieldTitle = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.Title, nil
		},
		column: remediation.FieldTitle,
		toTerm: remediation.ByTitle,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// RemediationOrderFieldState orders Remediation by state.
	RemediationOrderFieldState = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.State, nil
		},
		column: remediation.FieldState,
		toTerm: remediation.ByState,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RemediationOrderField) String() string {
	var str string
	switch f.column {
	case RemediationOrderFieldCreatedAt.column:
		str = "created_at"
	case RemediationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RemediationOrderFieldExternalID.column:
		str = "external_id"
	case RemediationOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case RemediationOrderFieldTitle.column:
		str = "title"
	case RemediationOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RemediationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RemediationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RemediationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RemediationOrderFieldCreatedAt
	case "updated_at":
		*f = *RemediationOrderFieldUpdatedAt
	case "external_id":
		*f = *RemediationOrderFieldExternalID
	case "external_owner_id":
		*f = *RemediationOrderFieldExternalOwnerID
	case "title":
		*f = *RemediationOrderFieldTitle
	case "state":
		*f = *RemediationOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid RemediationOrderField", str)
	}
	return nil
}

// RemediationOrderField defines the ordering field of Remediation.
type RemediationOrderField struct {
	// Value extracts the ordering value from the given Remediation.
	Value    func(*Remediation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) remediation.OrderOption
	toCursor func(*Remediation) Cursor
}

// RemediationOrder defines the ordering of Remediation.
type RemediationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *RemediationOrderField `json:"field"`
}

// DefaultRemediationOrder is the default ordering of Remediation.
var DefaultRemediationOrder = &RemediationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.ID, nil
		},
		column: remediation.FieldID,
		toTerm: remediation.ByID,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Remediation into RemediationEdge.
func (_m *Remediation) ToEdge(order *RemediationOrder) *RemediationEdge {
	if order == nil {
		order = DefaultRemediationOrder
	}
	return &RemediationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RemediationHistoryEdge is the edge representation of RemediationHistory.
type RemediationHistoryEdge struct {
	Node   *RemediationHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// RemediationHistoryConnection is the connection containing edges to RemediationHistory.
type RemediationHistoryConnection struct {
	Edges      []*RemediationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *RemediationHistoryConnection) build(nodes []*RemediationHistory, pager *remediationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *RemediationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RemediationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RemediationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*RemediationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RemediationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RemediationHistoryPaginateOption enables pagination customization.
type RemediationHistoryPaginateOption func(*remediationhistoryPager) error

// WithRemediationHistoryOrder configures pagination ordering.
func WithRemediationHistoryOrder(order *RemediationHistoryOrder) RemediationHistoryPaginateOption {
	if order == nil {
		order = DefaultRemediationHistoryOrder
	}
	o := *order
	return func(pager *remediationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRemediationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRemediationHistoryFilter configures pagination filter.
func WithRemediationHistoryFilter(filter func(*RemediationHistoryQuery) (*RemediationHistoryQuery, error)) RemediationHistoryPaginateOption {
	return func(pager *remediationhistoryPager) error {
		if filter == nil {
			return errors.New("RemediationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type remediationhistoryPager struct {
	reverse bool
	order   *RemediationHistoryOrder
	filter  func(*RemediationHistoryQuery) (*RemediationHistoryQuery, error)
}

func newRemediationHistoryPager(opts []RemediationHistoryPaginateOption, reverse bool) (*remediationhistoryPager, error) {
	pager := &remediationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRemediationHistoryOrder
	}
	return pager, nil
}

func (p *remediationhistoryPager) applyFilter(query *RemediationHistoryQuery) (*RemediationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *remediationhistoryPager) toCursor(_m *RemediationHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *remediationhistoryPager) applyCursors(query *RemediationHistoryQuery, after, before *Cursor) (*RemediationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRemediationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *remediationhistoryPager) applyOrder(query *RemediationHistoryQuery) *RemediationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRemediationHistoryOrder.Field {
		query = query.Order(DefaultRemediationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *remediationhistoryPager) orderExpr(query *RemediationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRemediationHistoryOrder.Field {
			b.Comma().Ident(DefaultRemediationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RemediationHistory.
func (_m *RemediationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RemediationHistoryPaginateOption,
) (*RemediationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRemediationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RemediationHistoryConnection{Edges: []*RemediationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RemediationHistoryOrderFieldHistoryTime orders RemediationHistory by history_time.
	RemediationHistoryOrderFieldHistoryTime = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: remediationhistory.FieldHistoryTime,
		toTerm: remediationhistory.ByHistoryTime,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// RemediationHistoryOrderFieldCreatedAt orders RemediationHistory by created_at.
	RemediationHistoryOrderFieldCreatedAt = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: remediationhistory.FieldCreatedAt,
		toTerm: remediationhistory.ByCreatedAt,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RemediationHistoryOrderFieldUpdatedAt orders RemediationHistory by updated_at.
	RemediationHistoryOrderFieldUpdatedAt = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: remediationhistory.FieldUpdatedAt,
		toTerm: remediationhistory.ByUpdatedAt,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RemediationHistoryOrderFieldExternalID orders RemediationHistory by external_id.
	RemediationHistoryOrderFieldExternalID = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: remediationhistory.FieldExternalID,
		toTerm: remediationhistory.ByExternalID,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// RemediationHistoryOrderFieldExternalOwnerID orders RemediationHistory by external_owner_id.
	RemediationHistoryOrderFieldExternalOwnerID = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: remediationhistory.FieldExternalOwnerID,
		toTerm: remediationhistory.ByExternalOwnerID,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// RemediationHistoryOrderFieldTitle orders RemediationHistory by title.
	RemediationHistoryOrderFieldTitle = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: remediationhistory.FieldTitle,
		toTerm: remediationhistory.ByTitle,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// RemediationHistoryOrderFieldState orders RemediationHistory by state.
	RemediationHistoryOrderFieldState = &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.State, nil
		},
		column: remediationhistory.FieldState,
		toTerm: remediationhistory.ByState,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RemediationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case RemediationHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case RemediationHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case RemediationHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RemediationHistoryOrderFieldExternalID.column:
		str = "external_id"
	case RemediationHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case RemediationHistoryOrderFieldTitle.column:
		str = "title"
	case RemediationHistoryOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RemediationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RemediationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RemediationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *RemediationHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *RemediationHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *RemediationHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *RemediationHistoryOrderFieldExternalID
	case "external_owner_id":
		*f = *RemediationHistoryOrderFieldExternalOwnerID
	case "title":
		*f = *RemediationHistoryOrderFieldTitle
	case "state":
		*f = *RemediationHistoryOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid RemediationHistoryOrderField", str)
	}
	return nil
}

// RemediationHistoryOrderField defines the ordering field of RemediationHistory.
type RemediationHistoryOrderField struct {
	// Value extracts the ordering value from the given RemediationHistory.
	Value    func(*RemediationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) remediationhistory.OrderOption
	toCursor func(*RemediationHistory) Cursor
}

// RemediationHistoryOrder defines the ordering of RemediationHistory.
type RemediationHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *RemediationHistoryOrderField `json:"field"`
}

// DefaultRemediationHistoryOrder is the default ordering of RemediationHistory.
var DefaultRemediationHistoryOrder = &RemediationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RemediationHistoryOrderField{
		Value: func(_m *RemediationHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: remediationhistory.FieldID,
		toTerm: remediationhistory.ByID,
		toCursor: func(_m *RemediationHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts RemediationHistory into RemediationHistoryEdge.
func (_m *RemediationHistory) ToEdge(order *RemediationHistoryOrder) *RemediationHistoryEdge {
	if order == nil {
		order = DefaultRemediationHistoryOrder
	}
	return &RemediationHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ReviewEdge is the edge representation of Review.
type ReviewEdge struct {
	Node   *Review `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ReviewConnection is the connection containing edges to Review.
type ReviewConnection struct {
	Edges      []*ReviewEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ReviewConnection) build(nodes []*Review, pager *reviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Review
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Review {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Review {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReviewPaginateOption enables pagination customization.
type ReviewPaginateOption func(*reviewPager) error

// WithReviewOrder configures pagination ordering.
func WithReviewOrder(order []*ReviewOrder) ReviewPaginateOption {
	return func(pager *reviewPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithReviewFilter configures pagination filter.
func WithReviewFilter(filter func(*ReviewQuery) (*ReviewQuery, error)) ReviewPaginateOption {
	return func(pager *reviewPager) error {
		if filter == nil {
			return errors.New("ReviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reviewPager struct {
	reverse bool
	order   []*ReviewOrder
	filter  func(*ReviewQuery) (*ReviewQuery, error)
}

func newReviewPager(opts []ReviewPaginateOption, reverse bool) (*reviewPager, error) {
	pager := &reviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *reviewPager) applyFilter(query *ReviewQuery) (*ReviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reviewPager) toCursor(_m *Review) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *reviewPager) applyCursors(query *ReviewQuery, after, before *Cursor) (*ReviewQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultReviewOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *reviewPager) applyOrder(query *ReviewQuery) *ReviewQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultReviewOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultReviewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *reviewPager) orderExpr(query *ReviewQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultReviewOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Review.
func (_m *ReviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReviewPaginateOption,
) (*ReviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReviewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ReviewConnection{Edges: []*ReviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReviewOrderFieldCreatedAt orders Review by created_at.
	ReviewOrderFieldCreatedAt = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: review.FieldCreatedAt,
		toTerm: review.ByCreatedAt,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ReviewOrderFieldUpdatedAt orders Review by updated_at.
	ReviewOrderFieldUpdatedAt = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: review.FieldUpdatedAt,
		toTerm: review.ByUpdatedAt,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ReviewOrderFieldExternalID orders Review by external_id.
	ReviewOrderFieldExternalID = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: review.FieldExternalID,
		toTerm: review.ByExternalID,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// ReviewOrderFieldExternalOwnerID orders Review by external_owner_id.
	ReviewOrderFieldExternalOwnerID = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: review.FieldExternalOwnerID,
		toTerm: review.ByExternalOwnerID,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// ReviewOrderFieldTitle orders Review by title.
	ReviewOrderFieldTitle = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.Title, nil
		},
		column: review.FieldTitle,
		toTerm: review.ByTitle,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ReviewOrderFieldState orders Review by state.
	ReviewOrderFieldState = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.State, nil
		},
		column: review.FieldState,
		toTerm: review.ByState,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReviewOrderField) String() string {
	var str string
	switch f.column {
	case ReviewOrderFieldCreatedAt.column:
		str = "created_at"
	case ReviewOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ReviewOrderFieldExternalID.column:
		str = "external_id"
	case ReviewOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case ReviewOrderFieldTitle.column:
		str = "title"
	case ReviewOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReviewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReviewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReviewOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ReviewOrderFieldCreatedAt
	case "updated_at":
		*f = *ReviewOrderFieldUpdatedAt
	case "external_id":
		*f = *ReviewOrderFieldExternalID
	case "external_owner_id":
		*f = *ReviewOrderFieldExternalOwnerID
	case "title":
		*f = *ReviewOrderFieldTitle
	case "state":
		*f = *ReviewOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid ReviewOrderField", str)
	}
	return nil
}

// ReviewOrderField defines the ordering field of Review.
type ReviewOrderField struct {
	// Value extracts the ordering value from the given Review.
	Value    func(*Review) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) review.OrderOption
	toCursor func(*Review) Cursor
}

// ReviewOrder defines the ordering of Review.
type ReviewOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ReviewOrderField `json:"field"`
}

// DefaultReviewOrder is the default ordering of Review.
var DefaultReviewOrder = &ReviewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.ID, nil
		},
		column: review.FieldID,
		toTerm: review.ByID,
		toCursor: func(_m *Review) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Review into ReviewEdge.
func (_m *Review) ToEdge(order *ReviewOrder) *ReviewEdge {
	if order == nil {
		order = DefaultReviewOrder
	}
	return &ReviewEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ReviewHistoryEdge is the edge representation of ReviewHistory.
type ReviewHistoryEdge struct {
	Node   *ReviewHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ReviewHistoryConnection is the connection containing edges to ReviewHistory.
type ReviewHistoryConnection struct {
	Edges      []*ReviewHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ReviewHistoryConnection) build(nodes []*ReviewHistory, pager *reviewhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ReviewHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReviewHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReviewHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReviewHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReviewHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReviewHistoryPaginateOption enables pagination customization.
type ReviewHistoryPaginateOption func(*reviewhistoryPager) error

// WithReviewHistoryOrder configures pagination ordering.
func WithReviewHistoryOrder(order *ReviewHistoryOrder) ReviewHistoryPaginateOption {
	if order == nil {
		order = DefaultReviewHistoryOrder
	}
	o := *order
	return func(pager *reviewhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReviewHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReviewHistoryFilter configures pagination filter.
func WithReviewHistoryFilter(filter func(*ReviewHistoryQuery) (*ReviewHistoryQuery, error)) ReviewHistoryPaginateOption {
	return func(pager *reviewhistoryPager) error {
		if filter == nil {
			return errors.New("ReviewHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reviewhistoryPager struct {
	reverse bool
	order   *ReviewHistoryOrder
	filter  func(*ReviewHistoryQuery) (*ReviewHistoryQuery, error)
}

func newReviewHistoryPager(opts []ReviewHistoryPaginateOption, reverse bool) (*reviewhistoryPager, error) {
	pager := &reviewhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReviewHistoryOrder
	}
	return pager, nil
}

func (p *reviewhistoryPager) applyFilter(query *ReviewHistoryQuery) (*ReviewHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reviewhistoryPager) toCursor(_m *ReviewHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *reviewhistoryPager) applyCursors(query *ReviewHistoryQuery, after, before *Cursor) (*ReviewHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReviewHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *reviewhistoryPager) applyOrder(query *ReviewHistoryQuery) *ReviewHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReviewHistoryOrder.Field {
		query = query.Order(DefaultReviewHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *reviewhistoryPager) orderExpr(query *ReviewHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReviewHistoryOrder.Field {
			b.Comma().Ident(DefaultReviewHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReviewHistory.
func (_m *ReviewHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReviewHistoryPaginateOption,
) (*ReviewHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReviewHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ReviewHistoryConnection{Edges: []*ReviewHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReviewHistoryOrderFieldHistoryTime orders ReviewHistory by history_time.
	ReviewHistoryOrderFieldHistoryTime = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: reviewhistory.FieldHistoryTime,
		toTerm: reviewhistory.ByHistoryTime,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ReviewHistoryOrderFieldCreatedAt orders ReviewHistory by created_at.
	ReviewHistoryOrderFieldCreatedAt = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: reviewhistory.FieldCreatedAt,
		toTerm: reviewhistory.ByCreatedAt,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ReviewHistoryOrderFieldUpdatedAt orders ReviewHistory by updated_at.
	ReviewHistoryOrderFieldUpdatedAt = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: reviewhistory.FieldUpdatedAt,
		toTerm: reviewhistory.ByUpdatedAt,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ReviewHistoryOrderFieldExternalID orders ReviewHistory by external_id.
	ReviewHistoryOrderFieldExternalID = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: reviewhistory.FieldExternalID,
		toTerm: reviewhistory.ByExternalID,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// ReviewHistoryOrderFieldExternalOwnerID orders ReviewHistory by external_owner_id.
	ReviewHistoryOrderFieldExternalOwnerID = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: reviewhistory.FieldExternalOwnerID,
		toTerm: reviewhistory.ByExternalOwnerID,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// ReviewHistoryOrderFieldTitle orders ReviewHistory by title.
	ReviewHistoryOrderFieldTitle = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: reviewhistory.FieldTitle,
		toTerm: reviewhistory.ByTitle,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ReviewHistoryOrderFieldState orders ReviewHistory by state.
	ReviewHistoryOrderFieldState = &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.State, nil
		},
		column: reviewhistory.FieldState,
		toTerm: reviewhistory.ByState,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReviewHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ReviewHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ReviewHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ReviewHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ReviewHistoryOrderFieldExternalID.column:
		str = "external_id"
	case ReviewHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case ReviewHistoryOrderFieldTitle.column:
		str = "title"
	case ReviewHistoryOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReviewHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReviewHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReviewHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ReviewHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ReviewHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ReviewHistoryOrderFieldUpdatedAt
	case "external_id":
		*f = *ReviewHistoryOrderFieldExternalID
	case "external_owner_id":
		*f = *ReviewHistoryOrderFieldExternalOwnerID
	case "title":
		*f = *ReviewHistoryOrderFieldTitle
	case "state":
		*f = *ReviewHistoryOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid ReviewHistoryOrderField", str)
	}
	return nil
}

// ReviewHistoryOrderField defines the ordering field of ReviewHistory.
type ReviewHistoryOrderField struct {
	// Value extracts the ordering value from the given ReviewHistory.
	Value    func(*ReviewHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) reviewhistory.OrderOption
	toCursor func(*ReviewHistory) Cursor
}

// ReviewHistoryOrder defines the ordering of ReviewHistory.
type ReviewHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ReviewHistoryOrderField `json:"field"`
}

// DefaultReviewHistoryOrder is the default ordering of ReviewHistory.
var DefaultReviewHistoryOrder = &ReviewHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReviewHistoryOrderField{
		Value: func(_m *ReviewHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: reviewhistory.FieldID,
		toTerm: reviewhistory.ByID,
		toCursor: func(_m *ReviewHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ReviewHistory into ReviewHistoryEdge.
func (_m *ReviewHistory) ToEdge(order *ReviewHistoryOrder) *ReviewHistoryEdge {
	if order == nil {
		order = DefaultReviewHistoryOrder
	}
	return &ReviewHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RiskEdge is the edge representation of Risk.
type RiskEdge struct {
	Node   *Risk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RiskConnection is the connection containing edges to Risk.
type RiskConnection struct {
	Edges      []*RiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *RiskConnection) build(nodes []*Risk, pager *riskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Risk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Risk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Risk {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskPaginateOption enables pagination customization.
type RiskPaginateOption func(*riskPager) error

// WithRiskOrder configures pagination ordering.
func WithRiskOrder(order []*RiskOrder) RiskPaginateOption {
	return func(pager *riskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRiskFilter configures pagination filter.
func WithRiskFilter(filter func(*RiskQuery) (*RiskQuery, error)) RiskPaginateOption {
	return func(pager *riskPager) error {
		if filter == nil {
			return errors.New("RiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskPager struct {
	reverse bool
	order   []*RiskOrder
	filter  func(*RiskQuery) (*RiskQuery, error)
}

func newRiskPager(opts []RiskPaginateOption, reverse bool) (*riskPager, error) {
	pager := &riskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *riskPager) applyFilter(query *RiskQuery) (*RiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskPager) toCursor(_m *Risk) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *riskPager) applyCursors(query *RiskQuery, after, before *Cursor) (*RiskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRiskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *riskPager) applyOrder(query *RiskQuery) *RiskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRiskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRiskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *riskPager) orderExpr(query *RiskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRiskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Risk.
func (_m *RiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskPaginateOption,
) (*RiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RiskConnection{Edges: []*RiskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RiskOrderFieldCreatedAt orders Risk by created_at.
	RiskOrderFieldCreatedAt = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: risk.FieldCreatedAt,
		toTerm: risk.ByCreatedAt,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RiskOrderFieldUpdatedAt orders Risk by updated_at.
	RiskOrderFieldUpdatedAt = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: risk.FieldUpdatedAt,
		toTerm: risk.ByUpdatedAt,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RiskOrderFieldName orders Risk by name.
	RiskOrderFieldName = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Name, nil
		},
		column: risk.FieldName,
		toTerm: risk.ByName,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// RiskOrderFieldStatus orders Risk by status.
	RiskOrderFieldStatus = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Status, nil
		},
		column: risk.FieldStatus,
		toTerm: risk.ByStatus,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// RiskOrderFieldRiskType orders Risk by risk_type.
	RiskOrderFieldRiskType = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.RiskType, nil
		},
		column: risk.FieldRiskType,
		toTerm: risk.ByRiskType,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RiskType,
			}
		},
	}
	// RiskOrderFieldCategory orders Risk by category.
	RiskOrderFieldCategory = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Category, nil
		},
		column: risk.FieldCategory,
		toTerm: risk.ByCategory,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// RiskOrderFieldImpact orders Risk by impact.
	RiskOrderFieldImpact = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Impact, nil
		},
		column: risk.FieldImpact,
		toTerm: risk.ByImpact,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Impact,
			}
		},
	}
	// RiskOrderFieldLikelihood orders Risk by likelihood.
	RiskOrderFieldLikelihood = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Likelihood, nil
		},
		column: risk.FieldLikelihood,
		toTerm: risk.ByLikelihood,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Likelihood,
			}
		},
	}
	// RiskOrderFieldScore orders Risk by score.
	RiskOrderFieldScore = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Score, nil
		},
		column: risk.FieldScore,
		toTerm: risk.ByScore,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Score,
			}
		},
	}
	// RiskOrderFieldBusinessCosts orders Risk by business_costs.
	RiskOrderFieldBusinessCosts = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.BusinessCosts, nil
		},
		column: risk.FieldBusinessCosts,
		toTerm: risk.ByBusinessCosts,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BusinessCosts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RiskOrderField) String() string {
	var str string
	switch f.column {
	case RiskOrderFieldCreatedAt.column:
		str = "created_at"
	case RiskOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RiskOrderFieldName.column:
		str = "name"
	case RiskOrderFieldStatus.column:
		str = "STATUS"
	case RiskOrderFieldRiskType.column:
		str = "risk_type"
	case RiskOrderFieldCategory.column:
		str = "category"
	case RiskOrderFieldImpact.column:
		str = "IMPACT"
	case RiskOrderFieldLikelihood.column:
		str = "LIKELIHOOD"
	case RiskOrderFieldScore.column:
		str = "score"
	case RiskOrderFieldBusinessCosts.column:
		str = "business_costs"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RiskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RiskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RiskOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RiskOrderFieldCreatedAt
	case "updated_at":
		*f = *RiskOrderFieldUpdatedAt
	case "name":
		*f = *RiskOrderFieldName
	case "STATUS":
		*f = *RiskOrderFieldStatus
	case "risk_type":
		*f = *RiskOrderFieldRiskType
	case "category":
		*f = *RiskOrderFieldCategory
	case "IMPACT":
		*f = *RiskOrderFieldImpact
	case "LIKELIHOOD":
		*f = *RiskOrderFieldLikelihood
	case "score":
		*f = *RiskOrderFieldScore
	case "business_costs":
		*f = *RiskOrderFieldBusinessCosts
	default:
		return fmt.Errorf("%s is not a valid RiskOrderField", str)
	}
	return nil
}

// RiskOrderField defines the ordering field of Risk.
type RiskOrderField struct {
	// Value extracts the ordering value from the given Risk.
	Value    func(*Risk) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) risk.OrderOption
	toCursor func(*Risk) Cursor
}

// RiskOrder defines the ordering of Risk.
type RiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RiskOrderField `json:"field"`
}

// DefaultRiskOrder is the default ordering of Risk.
var DefaultRiskOrder = &RiskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.ID, nil
		},
		column: risk.FieldID,
		toTerm: risk.ByID,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Risk into RiskEdge.
func (_m *Risk) ToEdge(order *RiskOrder) *RiskEdge {
	if order == nil {
		order = DefaultRiskOrder
	}
	return &RiskEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RiskHistoryEdge is the edge representation of RiskHistory.
type RiskHistoryEdge struct {
	Node   *RiskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// RiskHistoryConnection is the connection containing edges to RiskHistory.
type RiskHistoryConnection struct {
	Edges      []*RiskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *RiskHistoryConnection) build(nodes []*RiskHistory, pager *riskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *RiskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RiskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RiskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskHistoryPaginateOption enables pagination customization.
type RiskHistoryPaginateOption func(*riskhistoryPager) error

// WithRiskHistoryOrder configures pagination ordering.
func WithRiskHistoryOrder(order *RiskHistoryOrder) RiskHistoryPaginateOption {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	o := *order
	return func(pager *riskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRiskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRiskHistoryFilter configures pagination filter.
func WithRiskHistoryFilter(filter func(*RiskHistoryQuery) (*RiskHistoryQuery, error)) RiskHistoryPaginateOption {
	return func(pager *riskhistoryPager) error {
		if filter == nil {
			return errors.New("RiskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskhistoryPager struct {
	reverse bool
	order   *RiskHistoryOrder
	filter  func(*RiskHistoryQuery) (*RiskHistoryQuery, error)
}

func newRiskHistoryPager(opts []RiskHistoryPaginateOption, reverse bool) (*riskhistoryPager, error) {
	pager := &riskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRiskHistoryOrder
	}
	return pager, nil
}

func (p *riskhistoryPager) applyFilter(query *RiskHistoryQuery) (*RiskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskhistoryPager) toCursor(_m *RiskHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *riskhistoryPager) applyCursors(query *RiskHistoryQuery, after, before *Cursor) (*RiskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRiskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *riskhistoryPager) applyOrder(query *RiskHistoryQuery) *RiskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRiskHistoryOrder.Field {
		query = query.Order(DefaultRiskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *riskhistoryPager) orderExpr(query *RiskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRiskHistoryOrder.Field {
			b.Comma().Ident(DefaultRiskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RiskHistory.
func (_m *RiskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskHistoryPaginateOption,
) (*RiskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RiskHistoryConnection{Edges: []*RiskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RiskHistoryOrderFieldHistoryTime orders RiskHistory by history_time.
	RiskHistoryOrderFieldHistoryTime = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: riskhistory.FieldHistoryTime,
		toTerm: riskhistory.ByHistoryTime,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// RiskHistoryOrderFieldCreatedAt orders RiskHistory by created_at.
	RiskHistoryOrderFieldCreatedAt = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: riskhistory.FieldCreatedAt,
		toTerm: riskhistory.ByCreatedAt,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RiskHistoryOrderFieldUpdatedAt orders RiskHistory by updated_at.
	RiskHistoryOrderFieldUpdatedAt = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: riskhistory.FieldUpdatedAt,
		toTerm: riskhistory.ByUpdatedAt,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RiskHistoryOrderFieldName orders RiskHistory by name.
	RiskHistoryOrderFieldName = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: riskhistory.FieldName,
		toTerm: riskhistory.ByName,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// RiskHistoryOrderFieldStatus orders RiskHistory by status.
	RiskHistoryOrderFieldStatus = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: riskhistory.FieldStatus,
		toTerm: riskhistory.ByStatus,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// RiskHistoryOrderFieldRiskType orders RiskHistory by risk_type.
	RiskHistoryOrderFieldRiskType = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.RiskType, nil
		},
		column: riskhistory.FieldRiskType,
		toTerm: riskhistory.ByRiskType,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RiskType,
			}
		},
	}
	// RiskHistoryOrderFieldCategory orders RiskHistory by category.
	RiskHistoryOrderFieldCategory = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: riskhistory.FieldCategory,
		toTerm: riskhistory.ByCategory,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// RiskHistoryOrderFieldImpact orders RiskHistory by impact.
	RiskHistoryOrderFieldImpact = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Impact, nil
		},
		column: riskhistory.FieldImpact,
		toTerm: riskhistory.ByImpact,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Impact,
			}
		},
	}
	// RiskHistoryOrderFieldLikelihood orders RiskHistory by likelihood.
	RiskHistoryOrderFieldLikelihood = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Likelihood, nil
		},
		column: riskhistory.FieldLikelihood,
		toTerm: riskhistory.ByLikelihood,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Likelihood,
			}
		},
	}
	// RiskHistoryOrderFieldScore orders RiskHistory by score.
	RiskHistoryOrderFieldScore = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.Score, nil
		},
		column: riskhistory.FieldScore,
		toTerm: riskhistory.ByScore,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Score,
			}
		},
	}
	// RiskHistoryOrderFieldBusinessCosts orders RiskHistory by business_costs.
	RiskHistoryOrderFieldBusinessCosts = &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.BusinessCosts, nil
		},
		column: riskhistory.FieldBusinessCosts,
		toTerm: riskhistory.ByBusinessCosts,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BusinessCosts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RiskHistoryOrderField) String() string {
	var str string
	switch f.column {
	case RiskHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case RiskHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case RiskHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RiskHistoryOrderFieldName.column:
		str = "name"
	case RiskHistoryOrderFieldStatus.column:
		str = "STATUS"
	case RiskHistoryOrderFieldRiskType.column:
		str = "risk_type"
	case RiskHistoryOrderFieldCategory.column:
		str = "category"
	case RiskHistoryOrderFieldImpact.column:
		str = "IMPACT"
	case RiskHistoryOrderFieldLikelihood.column:
		str = "LIKELIHOOD"
	case RiskHistoryOrderFieldScore.column:
		str = "score"
	case RiskHistoryOrderFieldBusinessCosts.column:
		str = "business_costs"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RiskHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RiskHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RiskHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *RiskHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *RiskHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *RiskHistoryOrderFieldUpdatedAt
	case "name":
		*f = *RiskHistoryOrderFieldName
	case "STATUS":
		*f = *RiskHistoryOrderFieldStatus
	case "risk_type":
		*f = *RiskHistoryOrderFieldRiskType
	case "category":
		*f = *RiskHistoryOrderFieldCategory
	case "IMPACT":
		*f = *RiskHistoryOrderFieldImpact
	case "LIKELIHOOD":
		*f = *RiskHistoryOrderFieldLikelihood
	case "score":
		*f = *RiskHistoryOrderFieldScore
	case "business_costs":
		*f = *RiskHistoryOrderFieldBusinessCosts
	default:
		return fmt.Errorf("%s is not a valid RiskHistoryOrderField", str)
	}
	return nil
}

// RiskHistoryOrderField defines the ordering field of RiskHistory.
type RiskHistoryOrderField struct {
	// Value extracts the ordering value from the given RiskHistory.
	Value    func(*RiskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) riskhistory.OrderOption
	toCursor func(*RiskHistory) Cursor
}

// RiskHistoryOrder defines the ordering of RiskHistory.
type RiskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *RiskHistoryOrderField `json:"field"`
}

// DefaultRiskHistoryOrder is the default ordering of RiskHistory.
var DefaultRiskHistoryOrder = &RiskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskHistoryOrderField{
		Value: func(_m *RiskHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: riskhistory.FieldID,
		toTerm: riskhistory.ByID,
		toCursor: func(_m *RiskHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts RiskHistory into RiskHistoryEdge.
func (_m *RiskHistory) ToEdge(order *RiskHistoryOrder) *RiskHistoryEdge {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	return &RiskHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScanEdge is the edge representation of Scan.
type ScanEdge struct {
	Node   *Scan  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ScanConnection is the connection containing edges to Scan.
type ScanConnection struct {
	Edges      []*ScanEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *ScanConnection) build(nodes []*Scan, pager *scanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Scan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Scan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Scan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScanPaginateOption enables pagination customization.
type ScanPaginateOption func(*scanPager) error

// WithScanOrder configures pagination ordering.
func WithScanOrder(order []*ScanOrder) ScanPaginateOption {
	return func(pager *scanPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScanFilter configures pagination filter.
func WithScanFilter(filter func(*ScanQuery) (*ScanQuery, error)) ScanPaginateOption {
	return func(pager *scanPager) error {
		if filter == nil {
			return errors.New("ScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scanPager struct {
	reverse bool
	order   []*ScanOrder
	filter  func(*ScanQuery) (*ScanQuery, error)
}

func newScanPager(opts []ScanPaginateOption, reverse bool) (*scanPager, error) {
	pager := &scanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scanPager) applyFilter(query *ScanQuery) (*ScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scanPager) toCursor(_m *Scan) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *scanPager) applyCursors(query *ScanQuery, after, before *Cursor) (*ScanQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScanOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scanPager) applyOrder(query *ScanQuery) *ScanQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScanOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scanPager) orderExpr(query *ScanQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScanOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Scan.
func (_m *ScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScanPaginateOption,
) (*ScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScanConnection{Edges: []*ScanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScanOrderFieldCreatedAt orders Scan by created_at.
	ScanOrderFieldCreatedAt = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scan.FieldCreatedAt,
		toTerm: scan.ByCreatedAt,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScanOrderFieldUpdatedAt orders Scan by updated_at.
	ScanOrderFieldUpdatedAt = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scan.FieldUpdatedAt,
		toTerm: scan.ByUpdatedAt,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ScanOrderFieldScanType orders Scan by scan_type.
	ScanOrderFieldScanType = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.ScanType, nil
		},
		column: scan.FieldScanType,
		toTerm: scan.ByScanType,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ScanType,
			}
		},
	}
	// ScanOrderFieldStatus orders Scan by status.
	ScanOrderFieldStatus = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.Status, nil
		},
		column: scan.FieldStatus,
		toTerm: scan.ByStatus,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScanOrderField) String() string {
	var str string
	switch f.column {
	case ScanOrderFieldCreatedAt.column:
		str = "created_at"
	case ScanOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScanOrderFieldScanType.column:
		str = "SCAN_TYPE"
	case ScanOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScanOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScanOrderFieldCreatedAt
	case "updated_at":
		*f = *ScanOrderFieldUpdatedAt
	case "SCAN_TYPE":
		*f = *ScanOrderFieldScanType
	case "STATUS":
		*f = *ScanOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ScanOrderField", str)
	}
	return nil
}

// ScanOrderField defines the ordering field of Scan.
type ScanOrderField struct {
	// Value extracts the ordering value from the given Scan.
	Value    func(*Scan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scan.OrderOption
	toCursor func(*Scan) Cursor
}

// ScanOrder defines the ordering of Scan.
type ScanOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ScanOrderField `json:"field"`
}

// DefaultScanOrder is the default ordering of Scan.
var DefaultScanOrder = &ScanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scan.FieldID,
		toTerm: scan.ByID,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Scan into ScanEdge.
func (_m *Scan) ToEdge(order *ScanOrder) *ScanEdge {
	if order == nil {
		order = DefaultScanOrder
	}
	return &ScanEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScanHistoryEdge is the edge representation of ScanHistory.
type ScanHistoryEdge struct {
	Node   *ScanHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ScanHistoryConnection is the connection containing edges to ScanHistory.
type ScanHistoryConnection struct {
	Edges      []*ScanHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ScanHistoryConnection) build(nodes []*ScanHistory, pager *scanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScanHistoryPaginateOption enables pagination customization.
type ScanHistoryPaginateOption func(*scanhistoryPager) error

// WithScanHistoryOrder configures pagination ordering.
func WithScanHistoryOrder(order *ScanHistoryOrder) ScanHistoryPaginateOption {
	if order == nil {
		order = DefaultScanHistoryOrder
	}
	o := *order
	return func(pager *scanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScanHistoryFilter configures pagination filter.
func WithScanHistoryFilter(filter func(*ScanHistoryQuery) (*ScanHistoryQuery, error)) ScanHistoryPaginateOption {
	return func(pager *scanhistoryPager) error {
		if filter == nil {
			return errors.New("ScanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scanhistoryPager struct {
	reverse bool
	order   *ScanHistoryOrder
	filter  func(*ScanHistoryQuery) (*ScanHistoryQuery, error)
}

func newScanHistoryPager(opts []ScanHistoryPaginateOption, reverse bool) (*scanhistoryPager, error) {
	pager := &scanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScanHistoryOrder
	}
	return pager, nil
}

func (p *scanhistoryPager) applyFilter(query *ScanHistoryQuery) (*ScanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scanhistoryPager) toCursor(_m *ScanHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *scanhistoryPager) applyCursors(query *ScanHistoryQuery, after, before *Cursor) (*ScanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scanhistoryPager) applyOrder(query *ScanHistoryQuery) *ScanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScanHistoryOrder.Field {
		query = query.Order(DefaultScanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scanhistoryPager) orderExpr(query *ScanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScanHistoryOrder.Field {
			b.Comma().Ident(DefaultScanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScanHistory.
func (_m *ScanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScanHistoryPaginateOption,
) (*ScanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScanHistoryConnection{Edges: []*ScanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScanHistoryOrderFieldHistoryTime orders ScanHistory by history_time.
	ScanHistoryOrderFieldHistoryTime = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: scanhistory.FieldHistoryTime,
		toTerm: scanhistory.ByHistoryTime,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ScanHistoryOrderFieldCreatedAt orders ScanHistory by created_at.
	ScanHistoryOrderFieldCreatedAt = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scanhistory.FieldCreatedAt,
		toTerm: scanhistory.ByCreatedAt,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScanHistoryOrderFieldUpdatedAt orders ScanHistory by updated_at.
	ScanHistoryOrderFieldUpdatedAt = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scanhistory.FieldUpdatedAt,
		toTerm: scanhistory.ByUpdatedAt,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ScanHistoryOrderFieldScanType orders ScanHistory by scan_type.
	ScanHistoryOrderFieldScanType = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.ScanType, nil
		},
		column: scanhistory.FieldScanType,
		toTerm: scanhistory.ByScanType,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ScanType,
			}
		},
	}
	// ScanHistoryOrderFieldStatus orders ScanHistory by status.
	ScanHistoryOrderFieldStatus = &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: scanhistory.FieldStatus,
		toTerm: scanhistory.ByStatus,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScanHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ScanHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ScanHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ScanHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScanHistoryOrderFieldScanType.column:
		str = "SCAN_TYPE"
	case ScanHistoryOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScanHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScanHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScanHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ScanHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ScanHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ScanHistoryOrderFieldUpdatedAt
	case "SCAN_TYPE":
		*f = *ScanHistoryOrderFieldScanType
	case "STATUS":
		*f = *ScanHistoryOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ScanHistoryOrderField", str)
	}
	return nil
}

// ScanHistoryOrderField defines the ordering field of ScanHistory.
type ScanHistoryOrderField struct {
	// Value extracts the ordering value from the given ScanHistory.
	Value    func(*ScanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scanhistory.OrderOption
	toCursor func(*ScanHistory) Cursor
}

// ScanHistoryOrder defines the ordering of ScanHistory.
type ScanHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ScanHistoryOrderField `json:"field"`
}

// DefaultScanHistoryOrder is the default ordering of ScanHistory.
var DefaultScanHistoryOrder = &ScanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScanHistoryOrderField{
		Value: func(_m *ScanHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scanhistory.FieldID,
		toTerm: scanhistory.ByID,
		toCursor: func(_m *ScanHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScanHistory into ScanHistoryEdge.
func (_m *ScanHistory) ToEdge(order *ScanHistoryOrder) *ScanHistoryEdge {
	if order == nil {
		order = DefaultScanHistoryOrder
	}
	return &ScanHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScheduledJobEdge is the edge representation of ScheduledJob.
type ScheduledJobEdge struct {
	Node   *ScheduledJob `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ScheduledJobConnection is the connection containing edges to ScheduledJob.
type ScheduledJobConnection struct {
	Edges      []*ScheduledJobEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ScheduledJobConnection) build(nodes []*ScheduledJob, pager *scheduledjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobPaginateOption enables pagination customization.
type ScheduledJobPaginateOption func(*scheduledjobPager) error

// WithScheduledJobOrder configures pagination ordering.
func WithScheduledJobOrder(order []*ScheduledJobOrder) ScheduledJobPaginateOption {
	return func(pager *scheduledjobPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScheduledJobFilter configures pagination filter.
func WithScheduledJobFilter(filter func(*ScheduledJobQuery) (*ScheduledJobQuery, error)) ScheduledJobPaginateOption {
	return func(pager *scheduledjobPager) error {
		if filter == nil {
			return errors.New("ScheduledJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobPager struct {
	reverse bool
	order   []*ScheduledJobOrder
	filter  func(*ScheduledJobQuery) (*ScheduledJobQuery, error)
}

func newScheduledJobPager(opts []ScheduledJobPaginateOption, reverse bool) (*scheduledjobPager, error) {
	pager := &scheduledjobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scheduledjobPager) applyFilter(query *ScheduledJobQuery) (*ScheduledJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobPager) toCursor(_m *ScheduledJob) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *scheduledjobPager) applyCursors(query *ScheduledJobQuery, after, before *Cursor) (*ScheduledJobQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScheduledJobOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scheduledjobPager) applyOrder(query *ScheduledJobQuery) *ScheduledJobQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScheduledJobOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScheduledJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scheduledjobPager) orderExpr(query *ScheduledJobQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScheduledJobOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJob.
func (_m *ScheduledJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobPaginateOption,
) (*ScheduledJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScheduledJobConnection{Edges: []*ScheduledJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobOrderFieldCreatedAt orders ScheduledJob by created_at.
	ScheduledJobOrderFieldCreatedAt = &ScheduledJobOrderField{
		Value: func(_m *ScheduledJob) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scheduledjob.FieldCreatedAt,
		toTerm: scheduledjob.ByCreatedAt,
		toCursor: func(_m *ScheduledJob) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScheduledJobOrderFieldUpdatedAt orders ScheduledJob by updated_at.
	ScheduledJobOrderFieldUpdatedAt = &ScheduledJobOrderField{
		Value: func(_m *ScheduledJob) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scheduledjob.FieldUpdatedAt,
		toTerm: scheduledjob.ByUpdatedAt,
		toCursor: func(_m *ScheduledJob) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScheduledJobOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobOrderField", str)
	}
	return nil
}

// ScheduledJobOrderField defines the ordering field of ScheduledJob.
type ScheduledJobOrderField struct {
	// Value extracts the ordering value from the given ScheduledJob.
	Value    func(*ScheduledJob) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjob.OrderOption
	toCursor func(*ScheduledJob) Cursor
}

// ScheduledJobOrder defines the ordering of ScheduledJob.
type ScheduledJobOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ScheduledJobOrderField `json:"field"`
}

// DefaultScheduledJobOrder is the default ordering of ScheduledJob.
var DefaultScheduledJobOrder = &ScheduledJobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobOrderField{
		Value: func(_m *ScheduledJob) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scheduledjob.FieldID,
		toTerm: scheduledjob.ByID,
		toCursor: func(_m *ScheduledJob) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScheduledJob into ScheduledJobEdge.
func (_m *ScheduledJob) ToEdge(order *ScheduledJobOrder) *ScheduledJobEdge {
	if order == nil {
		order = DefaultScheduledJobOrder
	}
	return &ScheduledJobEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScheduledJobHistoryEdge is the edge representation of ScheduledJobHistory.
type ScheduledJobHistoryEdge struct {
	Node   *ScheduledJobHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// ScheduledJobHistoryConnection is the connection containing edges to ScheduledJobHistory.
type ScheduledJobHistoryConnection struct {
	Edges      []*ScheduledJobHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *ScheduledJobHistoryConnection) build(nodes []*ScheduledJobHistory, pager *scheduledjobhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJobHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJobHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJobHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobHistoryPaginateOption enables pagination customization.
type ScheduledJobHistoryPaginateOption func(*scheduledjobhistoryPager) error

// WithScheduledJobHistoryOrder configures pagination ordering.
func WithScheduledJobHistoryOrder(order *ScheduledJobHistoryOrder) ScheduledJobHistoryPaginateOption {
	if order == nil {
		order = DefaultScheduledJobHistoryOrder
	}
	o := *order
	return func(pager *scheduledjobhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScheduledJobHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScheduledJobHistoryFilter configures pagination filter.
func WithScheduledJobHistoryFilter(filter func(*ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error)) ScheduledJobHistoryPaginateOption {
	return func(pager *scheduledjobhistoryPager) error {
		if filter == nil {
			return errors.New("ScheduledJobHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobhistoryPager struct {
	reverse bool
	order   *ScheduledJobHistoryOrder
	filter  func(*ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error)
}

func newScheduledJobHistoryPager(opts []ScheduledJobHistoryPaginateOption, reverse bool) (*scheduledjobhistoryPager, error) {
	pager := &scheduledjobhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScheduledJobHistoryOrder
	}
	return pager, nil
}

func (p *scheduledjobhistoryPager) applyFilter(query *ScheduledJobHistoryQuery) (*ScheduledJobHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobhistoryPager) toCursor(_m *ScheduledJobHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *scheduledjobhistoryPager) applyCursors(query *ScheduledJobHistoryQuery, after, before *Cursor) (*ScheduledJobHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScheduledJobHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scheduledjobhistoryPager) applyOrder(query *ScheduledJobHistoryQuery) *ScheduledJobHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScheduledJobHistoryOrder.Field {
		query = query.Order(DefaultScheduledJobHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scheduledjobhistoryPager) orderExpr(query *ScheduledJobHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScheduledJobHistoryOrder.Field {
			b.Comma().Ident(DefaultScheduledJobHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJobHistory.
func (_m *ScheduledJobHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobHistoryPaginateOption,
) (*ScheduledJobHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScheduledJobHistoryConnection{Edges: []*ScheduledJobHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobHistoryOrderFieldHistoryTime orders ScheduledJobHistory by history_time.
	ScheduledJobHistoryOrderFieldHistoryTime = &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: scheduledjobhistory.FieldHistoryTime,
		toTerm: scheduledjobhistory.ByHistoryTime,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldCreatedAt orders ScheduledJobHistory by created_at.
	ScheduledJobHistoryOrderFieldCreatedAt = &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scheduledjobhistory.FieldCreatedAt,
		toTerm: scheduledjobhistory.ByCreatedAt,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScheduledJobHistoryOrderFieldUpdatedAt orders ScheduledJobHistory by updated_at.
	ScheduledJobHistoryOrderFieldUpdatedAt = &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scheduledjobhistory.FieldUpdatedAt,
		toTerm: scheduledjobhistory.ByUpdatedAt,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case ScheduledJobHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *ScheduledJobHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *ScheduledJobHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobHistoryOrderField", str)
	}
	return nil
}

// ScheduledJobHistoryOrderField defines the ordering field of ScheduledJobHistory.
type ScheduledJobHistoryOrderField struct {
	// Value extracts the ordering value from the given ScheduledJobHistory.
	Value    func(*ScheduledJobHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjobhistory.OrderOption
	toCursor func(*ScheduledJobHistory) Cursor
}

// ScheduledJobHistoryOrder defines the ordering of ScheduledJobHistory.
type ScheduledJobHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *ScheduledJobHistoryOrderField `json:"field"`
}

// DefaultScheduledJobHistoryOrder is the default ordering of ScheduledJobHistory.
var DefaultScheduledJobHistoryOrder = &ScheduledJobHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobHistoryOrderField{
		Value: func(_m *ScheduledJobHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scheduledjobhistory.FieldID,
		toTerm: scheduledjobhistory.ByID,
		toCursor: func(_m *ScheduledJobHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScheduledJobHistory into ScheduledJobHistoryEdge.
func (_m *ScheduledJobHistory) ToEdge(order *ScheduledJobHistoryOrder) *ScheduledJobHistoryEdge {
	if order == nil {
		order = DefaultScheduledJobHistoryOrder
	}
	return &ScheduledJobHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScheduledJobRunEdge is the edge representation of ScheduledJobRun.
type ScheduledJobRunEdge struct {
	Node   *ScheduledJobRun `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ScheduledJobRunConnection is the connection containing edges to ScheduledJobRun.
type ScheduledJobRunConnection struct {
	Edges      []*ScheduledJobRunEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ScheduledJobRunConnection) build(nodes []*ScheduledJobRun, pager *scheduledjobrunPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJobRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJobRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJobRun {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobRunPaginateOption enables pagination customization.
type ScheduledJobRunPaginateOption func(*scheduledjobrunPager) error

// WithScheduledJobRunOrder configures pagination ordering.
func WithScheduledJobRunOrder(order []*ScheduledJobRunOrder) ScheduledJobRunPaginateOption {
	return func(pager *scheduledjobrunPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScheduledJobRunFilter configures pagination filter.
func WithScheduledJobRunFilter(filter func(*ScheduledJobRunQuery) (*ScheduledJobRunQuery, error)) ScheduledJobRunPaginateOption {
	return func(pager *scheduledjobrunPager) error {
		if filter == nil {
			return errors.New("ScheduledJobRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobrunPager struct {
	reverse bool
	order   []*ScheduledJobRunOrder
	filter  func(*ScheduledJobRunQuery) (*ScheduledJobRunQuery, error)
}

func newScheduledJobRunPager(opts []ScheduledJobRunPaginateOption, reverse bool) (*scheduledjobrunPager, error) {
	pager := &scheduledjobrunPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scheduledjobrunPager) applyFilter(query *ScheduledJobRunQuery) (*ScheduledJobRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobrunPager) toCursor(_m *ScheduledJobRun) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *scheduledjobrunPager) applyCursors(query *ScheduledJobRunQuery, after, before *Cursor) (*ScheduledJobRunQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScheduledJobRunOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scheduledjobrunPager) applyOrder(query *ScheduledJobRunQuery) *ScheduledJobRunQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScheduledJobRunOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScheduledJobRunOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scheduledjobrunPager) orderExpr(query *ScheduledJobRunQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScheduledJobRunOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJobRun.
func (_m *ScheduledJobRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobRunPaginateOption,
) (*ScheduledJobRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobRunPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScheduledJobRunConnection{Edges: []*ScheduledJobRunEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobRunOrderFieldCreatedAt orders ScheduledJobRun by created_at.
	ScheduledJobRunOrderFieldCreatedAt = &ScheduledJobRunOrderField{
		Value: func(_m *ScheduledJobRun) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scheduledjobrun.FieldCreatedAt,
		toTerm: scheduledjobrun.ByCreatedAt,
		toCursor: func(_m *ScheduledJobRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScheduledJobRunOrderFieldUpdatedAt orders ScheduledJobRun by updated_at.
	ScheduledJobRunOrderFieldUpdatedAt = &ScheduledJobRunOrderField{
		Value: func(_m *ScheduledJobRun) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scheduledjobrun.FieldUpdatedAt,
		toTerm: scheduledjobrun.ByUpdatedAt,
		toCursor: func(_m *ScheduledJobRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobRunOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobRunOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobRunOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobRunOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScheduledJobRunOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobRunOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobRunOrderField", str)
	}
	return nil
}

// ScheduledJobRunOrderField defines the ordering field of ScheduledJobRun.
type ScheduledJobRunOrderField struct {
	// Value extracts the ordering value from the given ScheduledJobRun.
	Value    func(*ScheduledJobRun) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjobrun.OrderOption
	toCursor func(*ScheduledJobRun) Cursor
}

// ScheduledJobRunOrder defines the ordering of ScheduledJobRun.
type ScheduledJobRunOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ScheduledJobRunOrderField `json:"field"`
}

// DefaultScheduledJobRunOrder is the default ordering of ScheduledJobRun.
var DefaultScheduledJobRunOrder = &ScheduledJobRunOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobRunOrderField{
		Value: func(_m *ScheduledJobRun) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scheduledjobrun.FieldID,
		toTerm: scheduledjobrun.ByID,
		toCursor: func(_m *ScheduledJobRun) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScheduledJobRun into ScheduledJobRunEdge.
func (_m *ScheduledJobRun) ToEdge(order *ScheduledJobRunOrder) *ScheduledJobRunEdge {
	if order == nil {
		order = DefaultScheduledJobRunOrder
	}
	return &ScheduledJobRunEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// StandardEdge is the edge representation of Standard.
type StandardEdge struct {
	Node   *Standard `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// StandardConnection is the connection containing edges to Standard.
type StandardConnection struct {
	Edges      []*StandardEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *StandardConnection) build(nodes []*Standard, pager *standardPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Standard
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Standard {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Standard {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardPaginateOption enables pagination customization.
type StandardPaginateOption func(*standardPager) error

// WithStandardOrder configures pagination ordering.
func WithStandardOrder(order []*StandardOrder) StandardPaginateOption {
	return func(pager *standardPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithStandardFilter configures pagination filter.
func WithStandardFilter(filter func(*StandardQuery) (*StandardQuery, error)) StandardPaginateOption {
	return func(pager *standardPager) error {
		if filter == nil {
			return errors.New("StandardQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardPager struct {
	reverse bool
	order   []*StandardOrder
	filter  func(*StandardQuery) (*StandardQuery, error)
}

func newStandardPager(opts []StandardPaginateOption, reverse bool) (*standardPager, error) {
	pager := &standardPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *standardPager) applyFilter(query *StandardQuery) (*StandardQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardPager) toCursor(_m *Standard) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *standardPager) applyCursors(query *StandardQuery, after, before *Cursor) (*StandardQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultStandardOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *standardPager) applyOrder(query *StandardQuery) *StandardQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultStandardOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultStandardOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *standardPager) orderExpr(query *StandardQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultStandardOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Standard.
func (_m *StandardQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardPaginateOption,
) (*StandardConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &StandardConnection{Edges: []*StandardEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StandardOrderFieldCreatedAt orders Standard by created_at.
	StandardOrderFieldCreatedAt = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: standard.FieldCreatedAt,
		toTerm: standard.ByCreatedAt,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// StandardOrderFieldUpdatedAt orders Standard by updated_at.
	StandardOrderFieldUpdatedAt = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: standard.FieldUpdatedAt,
		toTerm: standard.ByUpdatedAt,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// StandardOrderFieldRevision orders Standard by revision.
	StandardOrderFieldRevision = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: standard.FieldRevision,
		toTerm: standard.ByRevision,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// StandardOrderFieldName orders Standard by name.
	StandardOrderFieldName = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Name, nil
		},
		column: standard.FieldName,
		toTerm: standard.ByName,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// StandardOrderFieldShortName orders Standard by short_name.
	StandardOrderFieldShortName = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.ShortName, nil
		},
		column: standard.FieldShortName,
		toTerm: standard.ByShortName,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ShortName,
			}
		},
	}
	// StandardOrderFieldFramework orders Standard by framework.
	StandardOrderFieldFramework = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Framework, nil
		},
		column: standard.FieldFramework,
		toTerm: standard.ByFramework,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Framework,
			}
		},
	}
	// StandardOrderFieldGoverningBody orders Standard by governing_body.
	StandardOrderFieldGoverningBody = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.GoverningBody, nil
		},
		column: standard.FieldGoverningBody,
		toTerm: standard.ByGoverningBody,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.GoverningBody,
			}
		},
	}
	// StandardOrderFieldStatus orders Standard by status.
	StandardOrderFieldStatus = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Status, nil
		},
		column: standard.FieldStatus,
		toTerm: standard.ByStatus,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// StandardOrderFieldStandardType orders Standard by standard_type.
	StandardOrderFieldStandardType = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.StandardType, nil
		},
		column: standard.FieldStandardType,
		toTerm: standard.ByStandardType,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StandardType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StandardOrderField) String() string {
	var str string
	switch f.column {
	case StandardOrderFieldCreatedAt.column:
		str = "created_at"
	case StandardOrderFieldUpdatedAt.column:
		str = "updated_at"
	case StandardOrderFieldRevision.column:
		str = "revision"
	case StandardOrderFieldName.column:
		str = "name"
	case StandardOrderFieldShortName.column:
		str = "short_name"
	case StandardOrderFieldFramework.column:
		str = "framework"
	case StandardOrderFieldGoverningBody.column:
		str = "governing_body"
	case StandardOrderFieldStatus.column:
		str = "STATUS"
	case StandardOrderFieldStandardType.column:
		str = "standard_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StandardOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StandardOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StandardOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *StandardOrderFieldCreatedAt
	case "updated_at":
		*f = *StandardOrderFieldUpdatedAt
	case "revision":
		*f = *StandardOrderFieldRevision
	case "name":
		*f = *StandardOrderFieldName
	case "short_name":
		*f = *StandardOrderFieldShortName
	case "framework":
		*f = *StandardOrderFieldFramework
	case "governing_body":
		*f = *StandardOrderFieldGoverningBody
	case "STATUS":
		*f = *StandardOrderFieldStatus
	case "standard_type":
		*f = *StandardOrderFieldStandardType
	default:
		return fmt.Errorf("%s is not a valid StandardOrderField", str)
	}
	return nil
}

// StandardOrderField defines the ordering field of Standard.
type StandardOrderField struct {
	// Value extracts the ordering value from the given Standard.
	Value    func(*Standard) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standard.OrderOption
	toCursor func(*Standard) Cursor
}

// StandardOrder defines the ordering of Standard.
type StandardOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *StandardOrderField `json:"field"`
}

// DefaultStandardOrder is the default ordering of Standard.
var DefaultStandardOrder = &StandardOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.ID, nil
		},
		column: standard.FieldID,
		toTerm: standard.ByID,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Standard into StandardEdge.
func (_m *Standard) ToEdge(order *StandardOrder) *StandardEdge {
	if order == nil {
		order = DefaultStandardOrder
	}
	return &StandardEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// StandardHistoryEdge is the edge representation of StandardHistory.
type StandardHistoryEdge struct {
	Node   *StandardHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// StandardHistoryConnection is the connection containing edges to StandardHistory.
type StandardHistoryConnection struct {
	Edges      []*StandardHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *StandardHistoryConnection) build(nodes []*StandardHistory, pager *standardhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *StandardHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *StandardHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *StandardHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardHistoryPaginateOption enables pagination customization.
type StandardHistoryPaginateOption func(*standardhistoryPager) error

// WithStandardHistoryOrder configures pagination ordering.
func WithStandardHistoryOrder(order *StandardHistoryOrder) StandardHistoryPaginateOption {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	o := *order
	return func(pager *standardhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStandardHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStandardHistoryFilter configures pagination filter.
func WithStandardHistoryFilter(filter func(*StandardHistoryQuery) (*StandardHistoryQuery, error)) StandardHistoryPaginateOption {
	return func(pager *standardhistoryPager) error {
		if filter == nil {
			return errors.New("StandardHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardhistoryPager struct {
	reverse bool
	order   *StandardHistoryOrder
	filter  func(*StandardHistoryQuery) (*StandardHistoryQuery, error)
}

func newStandardHistoryPager(opts []StandardHistoryPaginateOption, reverse bool) (*standardhistoryPager, error) {
	pager := &standardhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStandardHistoryOrder
	}
	return pager, nil
}

func (p *standardhistoryPager) applyFilter(query *StandardHistoryQuery) (*StandardHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardhistoryPager) toCursor(_m *StandardHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *standardhistoryPager) applyCursors(query *StandardHistoryQuery, after, before *Cursor) (*StandardHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStandardHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *standardhistoryPager) applyOrder(query *StandardHistoryQuery) *StandardHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStandardHistoryOrder.Field {
		query = query.Order(DefaultStandardHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *standardhistoryPager) orderExpr(query *StandardHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStandardHistoryOrder.Field {
			b.Comma().Ident(DefaultStandardHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to StandardHistory.
func (_m *StandardHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardHistoryPaginateOption,
) (*StandardHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &StandardHistoryConnection{Edges: []*StandardHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StandardHistoryOrderFieldHistoryTime orders StandardHistory by history_time.
	StandardHistoryOrderFieldHistoryTime = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: standardhistory.FieldHistoryTime,
		toTerm: standardhistory.ByHistoryTime,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// StandardHistoryOrderFieldCreatedAt orders StandardHistory by created_at.
	StandardHistoryOrderFieldCreatedAt = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: standardhistory.FieldCreatedAt,
		toTerm: standardhistory.ByCreatedAt,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// StandardHistoryOrderFieldUpdatedAt orders StandardHistory by updated_at.
	StandardHistoryOrderFieldUpdatedAt = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: standardhistory.FieldUpdatedAt,
		toTerm: standardhistory.ByUpdatedAt,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// StandardHistoryOrderFieldRevision orders StandardHistory by revision.
	StandardHistoryOrderFieldRevision = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: standardhistory.FieldRevision,
		toTerm: standardhistory.ByRevision,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// StandardHistoryOrderFieldName orders StandardHistory by name.
	StandardHistoryOrderFieldName = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: standardhistory.FieldName,
		toTerm: standardhistory.ByName,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// StandardHistoryOrderFieldShortName orders StandardHistory by short_name.
	StandardHistoryOrderFieldShortName = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.ShortName, nil
		},
		column: standardhistory.FieldShortName,
		toTerm: standardhistory.ByShortName,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ShortName,
			}
		},
	}
	// StandardHistoryOrderFieldFramework orders StandardHistory by framework.
	StandardHistoryOrderFieldFramework = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Framework, nil
		},
		column: standardhistory.FieldFramework,
		toTerm: standardhistory.ByFramework,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Framework,
			}
		},
	}
	// StandardHistoryOrderFieldGoverningBody orders StandardHistory by governing_body.
	StandardHistoryOrderFieldGoverningBody = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.GoverningBody, nil
		},
		column: standardhistory.FieldGoverningBody,
		toTerm: standardhistory.ByGoverningBody,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.GoverningBody,
			}
		},
	}
	// StandardHistoryOrderFieldStatus orders StandardHistory by status.
	StandardHistoryOrderFieldStatus = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: standardhistory.FieldStatus,
		toTerm: standardhistory.ByStatus,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// StandardHistoryOrderFieldStandardType orders StandardHistory by standard_type.
	StandardHistoryOrderFieldStandardType = &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.StandardType, nil
		},
		column: standardhistory.FieldStandardType,
		toTerm: standardhistory.ByStandardType,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StandardType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StandardHistoryOrderField) String() string {
	var str string
	switch f.column {
	case StandardHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case StandardHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case StandardHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case StandardHistoryOrderFieldRevision.column:
		str = "revision"
	case StandardHistoryOrderFieldName.column:
		str = "name"
	case StandardHistoryOrderFieldShortName.column:
		str = "short_name"
	case StandardHistoryOrderFieldFramework.column:
		str = "framework"
	case StandardHistoryOrderFieldGoverningBody.column:
		str = "governing_body"
	case StandardHistoryOrderFieldStatus.column:
		str = "STATUS"
	case StandardHistoryOrderFieldStandardType.column:
		str = "standard_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StandardHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StandardHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StandardHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *StandardHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *StandardHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *StandardHistoryOrderFieldUpdatedAt
	case "revision":
		*f = *StandardHistoryOrderFieldRevision
	case "name":
		*f = *StandardHistoryOrderFieldName
	case "short_name":
		*f = *StandardHistoryOrderFieldShortName
	case "framework":
		*f = *StandardHistoryOrderFieldFramework
	case "governing_body":
		*f = *StandardHistoryOrderFieldGoverningBody
	case "STATUS":
		*f = *StandardHistoryOrderFieldStatus
	case "standard_type":
		*f = *StandardHistoryOrderFieldStandardType
	default:
		return fmt.Errorf("%s is not a valid StandardHistoryOrderField", str)
	}
	return nil
}

// StandardHistoryOrderField defines the ordering field of StandardHistory.
type StandardHistoryOrderField struct {
	// Value extracts the ordering value from the given StandardHistory.
	Value    func(*StandardHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standardhistory.OrderOption
	toCursor func(*StandardHistory) Cursor
}

// StandardHistoryOrder defines the ordering of StandardHistory.
type StandardHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *StandardHistoryOrderField `json:"field"`
}

// DefaultStandardHistoryOrder is the default ordering of StandardHistory.
var DefaultStandardHistoryOrder = &StandardHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardHistoryOrderField{
		Value: func(_m *StandardHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: standardhistory.FieldID,
		toTerm: standardhistory.ByID,
		toCursor: func(_m *StandardHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts StandardHistory into StandardHistoryEdge.
func (_m *StandardHistory) ToEdge(order *StandardHistoryOrder) *StandardHistoryEdge {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	return &StandardHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubcontrolEdge is the edge representation of Subcontrol.
type SubcontrolEdge struct {
	Node   *Subcontrol `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubcontrolConnection is the connection containing edges to Subcontrol.
type SubcontrolConnection struct {
	Edges      []*SubcontrolEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubcontrolConnection) build(nodes []*Subcontrol, pager *subcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subcontrol
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subcontrol {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subcontrol {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolPaginateOption enables pagination customization.
type SubcontrolPaginateOption func(*subcontrolPager) error

// WithSubcontrolOrder configures pagination ordering.
func WithSubcontrolOrder(order []*SubcontrolOrder) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubcontrolFilter configures pagination filter.
func WithSubcontrolFilter(filter func(*SubcontrolQuery) (*SubcontrolQuery, error)) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		if filter == nil {
			return errors.New("SubcontrolQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolPager struct {
	reverse bool
	order   []*SubcontrolOrder
	filter  func(*SubcontrolQuery) (*SubcontrolQuery, error)
}

func newSubcontrolPager(opts []SubcontrolPaginateOption, reverse bool) (*subcontrolPager, error) {
	pager := &subcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subcontrolPager) applyFilter(query *SubcontrolQuery) (*SubcontrolQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolPager) toCursor(_m *Subcontrol) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *subcontrolPager) applyCursors(query *SubcontrolQuery, after, before *Cursor) (*SubcontrolQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubcontrolOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subcontrolPager) applyOrder(query *SubcontrolQuery) *SubcontrolQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubcontrolOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case SubcontrolOrderFieldControlOwnerName.column, SubcontrolOrderFieldDelegateName.column, SubcontrolOrderFieldResponsiblePartyName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubcontrolOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subcontrolPager) orderExpr(query *SubcontrolQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case SubcontrolOrderFieldControlOwnerName.column, SubcontrolOrderFieldDelegateName.column, SubcontrolOrderFieldResponsiblePartyName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubcontrolOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subcontrol.
func (_m *SubcontrolQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolPaginateOption,
) (*SubcontrolConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubcontrolConnection{Edges: []*SubcontrolEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubcontrolOrderFieldCreatedAt orders Subcontrol by created_at.
	SubcontrolOrderFieldCreatedAt = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subcontrol.FieldCreatedAt,
		toTerm: subcontrol.ByCreatedAt,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubcontrolOrderFieldUpdatedAt orders Subcontrol by updated_at.
	SubcontrolOrderFieldUpdatedAt = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subcontrol.FieldUpdatedAt,
		toTerm: subcontrol.ByUpdatedAt,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubcontrolOrderFieldTitle orders Subcontrol by title.
	SubcontrolOrderFieldTitle = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Title, nil
		},
		column: subcontrol.FieldTitle,
		toTerm: subcontrol.ByTitle,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// SubcontrolOrderFieldStatus orders Subcontrol by status.
	SubcontrolOrderFieldStatus = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Status, nil
		},
		column: subcontrol.FieldStatus,
		toTerm: subcontrol.ByStatus,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// SubcontrolOrderFieldSource orders Subcontrol by source.
	SubcontrolOrderFieldSource = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Source, nil
		},
		column: subcontrol.FieldSource,
		toTerm: subcontrol.BySource,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// SubcontrolOrderFieldReferenceFramework orders Subcontrol by reference_framework.
	SubcontrolOrderFieldReferenceFramework = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: subcontrol.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return subcontrol.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// SubcontrolOrderFieldControlType orders Subcontrol by control_type.
	SubcontrolOrderFieldControlType = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.ControlType, nil
		},
		column: subcontrol.FieldControlType,
		toTerm: subcontrol.ByControlType,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlType,
			}
		},
	}
	// SubcontrolOrderFieldCategory orders Subcontrol by category.
	SubcontrolOrderFieldCategory = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Category, nil
		},
		column: subcontrol.FieldCategory,
		toTerm: subcontrol.ByCategory,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// SubcontrolOrderFieldSubcategory orders Subcontrol by subcategory.
	SubcontrolOrderFieldSubcategory = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: subcontrol.FieldSubcategory,
		toTerm: subcontrol.BySubcategory,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// SubcontrolOrderFieldRefCode orders Subcontrol by ref_code.
	SubcontrolOrderFieldRefCode = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: subcontrol.FieldRefCode,
		toTerm: subcontrol.ByRefCode,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
	// SubcontrolOrderFieldControlOwnerName orders by CONTROL_OWNER_name.
	SubcontrolOrderFieldControlOwnerName = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Value("control_owner_name")
		},
		column: "control_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByControlOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("control_owner_name"))...,
			)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			cv, _ := _m.Value("control_owner_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// SubcontrolOrderFieldDelegateName orders by DELEGATE_name.
	SubcontrolOrderFieldDelegateName = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Value("delegate_name")
		},
		column: "delegate_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByDelegateField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("delegate_name"))...,
			)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			cv, _ := _m.Value("delegate_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// SubcontrolOrderFieldResponsiblePartyName orders by RESPONSIBLE_PARTY_name.
	SubcontrolOrderFieldResponsiblePartyName = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Value("responsible_party_name")
		},
		column: "responsible_party_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByResponsiblePartyField(
				entity.FieldName,
				append(opts, sql.OrderSelectAs("responsible_party_name"))...,
			)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			cv, _ := _m.Value("responsible_party_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubcontrolOrderField) String() string {
	var str string
	switch f.column {
	case SubcontrolOrderFieldCreatedAt.column:
		str = "created_at"
	case SubcontrolOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubcontrolOrderFieldTitle.column:
		str = "title"
	case SubcontrolOrderFieldStatus.column:
		str = "STATUS"
	case SubcontrolOrderFieldSource.column:
		str = "SOURCE"
	case SubcontrolOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case SubcontrolOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case SubcontrolOrderFieldCategory.column:
		str = "category"
	case SubcontrolOrderFieldSubcategory.column:
		str = "subcategory"
	case SubcontrolOrderFieldRefCode.column:
		str = "ref_code"
	case SubcontrolOrderFieldControlOwnerName.column:
		str = "CONTROL_OWNER_name"
	case SubcontrolOrderFieldDelegateName.column:
		str = "DELEGATE_name"
	case SubcontrolOrderFieldResponsiblePartyName.column:
		str = "RESPONSIBLE_PARTY_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubcontrolOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubcontrolOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubcontrolOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubcontrolOrderFieldCreatedAt
	case "updated_at":
		*f = *SubcontrolOrderFieldUpdatedAt
	case "title":
		*f = *SubcontrolOrderFieldTitle
	case "STATUS":
		*f = *SubcontrolOrderFieldStatus
	case "SOURCE":
		*f = *SubcontrolOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *SubcontrolOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *SubcontrolOrderFieldControlType
	case "category":
		*f = *SubcontrolOrderFieldCategory
	case "subcategory":
		*f = *SubcontrolOrderFieldSubcategory
	case "ref_code":
		*f = *SubcontrolOrderFieldRefCode
	case "CONTROL_OWNER_name":
		*f = *SubcontrolOrderFieldControlOwnerName
	case "DELEGATE_name":
		*f = *SubcontrolOrderFieldDelegateName
	case "RESPONSIBLE_PARTY_name":
		*f = *SubcontrolOrderFieldResponsiblePartyName
	default:
		return fmt.Errorf("%s is not a valid SubcontrolOrderField", str)
	}
	return nil
}

// SubcontrolOrderField defines the ordering field of Subcontrol.
type SubcontrolOrderField struct {
	// Value extracts the ordering value from the given Subcontrol.
	Value    func(*Subcontrol) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrol.OrderOption
	toCursor func(*Subcontrol) Cursor
}

// SubcontrolOrder defines the ordering of Subcontrol.
type SubcontrolOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubcontrolOrderField `json:"field"`
}

// DefaultSubcontrolOrder is the default ordering of Subcontrol.
var DefaultSubcontrolOrder = &SubcontrolOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subcontrol.FieldID,
		toTerm: subcontrol.ByID,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Subcontrol into SubcontrolEdge.
func (_m *Subcontrol) ToEdge(order *SubcontrolOrder) *SubcontrolEdge {
	if order == nil {
		order = DefaultSubcontrolOrder
	}
	return &SubcontrolEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubcontrolHistoryEdge is the edge representation of SubcontrolHistory.
type SubcontrolHistoryEdge struct {
	Node   *SubcontrolHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// SubcontrolHistoryConnection is the connection containing edges to SubcontrolHistory.
type SubcontrolHistoryConnection struct {
	Edges      []*SubcontrolHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *SubcontrolHistoryConnection) build(nodes []*SubcontrolHistory, pager *subcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *SubcontrolHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolHistoryPaginateOption enables pagination customization.
type SubcontrolHistoryPaginateOption func(*subcontrolhistoryPager) error

// WithSubcontrolHistoryOrder configures pagination ordering.
func WithSubcontrolHistoryOrder(order *SubcontrolHistoryOrder) SubcontrolHistoryPaginateOption {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	o := *order
	return func(pager *subcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubcontrolHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubcontrolHistoryFilter configures pagination filter.
func WithSubcontrolHistoryFilter(filter func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)) SubcontrolHistoryPaginateOption {
	return func(pager *subcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("SubcontrolHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolhistoryPager struct {
	reverse bool
	order   *SubcontrolHistoryOrder
	filter  func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)
}

func newSubcontrolHistoryPager(opts []SubcontrolHistoryPaginateOption, reverse bool) (*subcontrolhistoryPager, error) {
	pager := &subcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubcontrolHistoryOrder
	}
	return pager, nil
}

func (p *subcontrolhistoryPager) applyFilter(query *SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) toCursor(_m *SubcontrolHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *subcontrolhistoryPager) applyCursors(query *SubcontrolHistoryQuery, after, before *Cursor) (*SubcontrolHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubcontrolHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) applyOrder(query *SubcontrolHistoryQuery) *SubcontrolHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
		query = query.Order(DefaultSubcontrolHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subcontrolhistoryPager) orderExpr(query *SubcontrolHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
			b.Comma().Ident(DefaultSubcontrolHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubcontrolHistory.
func (_m *SubcontrolHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolHistoryPaginateOption,
) (*SubcontrolHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubcontrolHistoryConnection{Edges: []*SubcontrolHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubcontrolHistoryOrderFieldHistoryTime orders SubcontrolHistory by history_time.
	SubcontrolHistoryOrderFieldHistoryTime = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: subcontrolhistory.FieldHistoryTime,
		toTerm: subcontrolhistory.ByHistoryTime,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// SubcontrolHistoryOrderFieldCreatedAt orders SubcontrolHistory by created_at.
	SubcontrolHistoryOrderFieldCreatedAt = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subcontrolhistory.FieldCreatedAt,
		toTerm: subcontrolhistory.ByCreatedAt,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubcontrolHistoryOrderFieldUpdatedAt orders SubcontrolHistory by updated_at.
	SubcontrolHistoryOrderFieldUpdatedAt = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subcontrolhistory.FieldUpdatedAt,
		toTerm: subcontrolhistory.ByUpdatedAt,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubcontrolHistoryOrderFieldTitle orders SubcontrolHistory by title.
	SubcontrolHistoryOrderFieldTitle = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: subcontrolhistory.FieldTitle,
		toTerm: subcontrolhistory.ByTitle,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// SubcontrolHistoryOrderFieldStatus orders SubcontrolHistory by status.
	SubcontrolHistoryOrderFieldStatus = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: subcontrolhistory.FieldStatus,
		toTerm: subcontrolhistory.ByStatus,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// SubcontrolHistoryOrderFieldSource orders SubcontrolHistory by source.
	SubcontrolHistoryOrderFieldSource = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Source, nil
		},
		column: subcontrolhistory.FieldSource,
		toTerm: subcontrolhistory.BySource,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// SubcontrolHistoryOrderFieldReferenceFramework orders SubcontrolHistory by reference_framework.
	SubcontrolHistoryOrderFieldReferenceFramework = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: subcontrolhistory.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) subcontrolhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return subcontrolhistory.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *SubcontrolHistory) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// SubcontrolHistoryOrderFieldControlType orders SubcontrolHistory by control_type.
	SubcontrolHistoryOrderFieldControlType = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.ControlType, nil
		},
		column: subcontrolhistory.FieldControlType,
		toTerm: subcontrolhistory.ByControlType,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlType,
			}
		},
	}
	// SubcontrolHistoryOrderFieldCategory orders SubcontrolHistory by category.
	SubcontrolHistoryOrderFieldCategory = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: subcontrolhistory.FieldCategory,
		toTerm: subcontrolhistory.ByCategory,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// SubcontrolHistoryOrderFieldSubcategory orders SubcontrolHistory by subcategory.
	SubcontrolHistoryOrderFieldSubcategory = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: subcontrolhistory.FieldSubcategory,
		toTerm: subcontrolhistory.BySubcategory,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// SubcontrolHistoryOrderFieldRefCode orders SubcontrolHistory by ref_code.
	SubcontrolHistoryOrderFieldRefCode = &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: subcontrolhistory.FieldRefCode,
		toTerm: subcontrolhistory.ByRefCode,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubcontrolHistoryOrderField) String() string {
	var str string
	switch f.column {
	case SubcontrolHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case SubcontrolHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case SubcontrolHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubcontrolHistoryOrderFieldTitle.column:
		str = "title"
	case SubcontrolHistoryOrderFieldStatus.column:
		str = "STATUS"
	case SubcontrolHistoryOrderFieldSource.column:
		str = "SOURCE"
	case SubcontrolHistoryOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case SubcontrolHistoryOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case SubcontrolHistoryOrderFieldCategory.column:
		str = "category"
	case SubcontrolHistoryOrderFieldSubcategory.column:
		str = "subcategory"
	case SubcontrolHistoryOrderFieldRefCode.column:
		str = "ref_code"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubcontrolHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubcontrolHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubcontrolHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *SubcontrolHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *SubcontrolHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *SubcontrolHistoryOrderFieldUpdatedAt
	case "title":
		*f = *SubcontrolHistoryOrderFieldTitle
	case "STATUS":
		*f = *SubcontrolHistoryOrderFieldStatus
	case "SOURCE":
		*f = *SubcontrolHistoryOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *SubcontrolHistoryOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *SubcontrolHistoryOrderFieldControlType
	case "category":
		*f = *SubcontrolHistoryOrderFieldCategory
	case "subcategory":
		*f = *SubcontrolHistoryOrderFieldSubcategory
	case "ref_code":
		*f = *SubcontrolHistoryOrderFieldRefCode
	default:
		return fmt.Errorf("%s is not a valid SubcontrolHistoryOrderField", str)
	}
	return nil
}

// SubcontrolHistoryOrderField defines the ordering field of SubcontrolHistory.
type SubcontrolHistoryOrderField struct {
	// Value extracts the ordering value from the given SubcontrolHistory.
	Value    func(*SubcontrolHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrolhistory.OrderOption
	toCursor func(*SubcontrolHistory) Cursor
}

// SubcontrolHistoryOrder defines the ordering of SubcontrolHistory.
type SubcontrolHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *SubcontrolHistoryOrderField `json:"field"`
}

// DefaultSubcontrolHistoryOrder is the default ordering of SubcontrolHistory.
var DefaultSubcontrolHistoryOrder = &SubcontrolHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolHistoryOrderField{
		Value: func(_m *SubcontrolHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subcontrolhistory.FieldID,
		toTerm: subcontrolhistory.ByID,
		toCursor: func(_m *SubcontrolHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts SubcontrolHistory into SubcontrolHistoryEdge.
func (_m *SubcontrolHistory) ToEdge(order *SubcontrolHistoryOrder) *SubcontrolHistoryEdge {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	return &SubcontrolHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubprocessorEdge is the edge representation of Subprocessor.
type SubprocessorEdge struct {
	Node   *Subprocessor `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// SubprocessorConnection is the connection containing edges to Subprocessor.
type SubprocessorConnection struct {
	Edges      []*SubprocessorEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *SubprocessorConnection) build(nodes []*Subprocessor, pager *subprocessorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subprocessor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subprocessor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subprocessor {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubprocessorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubprocessorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubprocessorPaginateOption enables pagination customization.
type SubprocessorPaginateOption func(*subprocessorPager) error

// WithSubprocessorOrder configures pagination ordering.
func WithSubprocessorOrder(order []*SubprocessorOrder) SubprocessorPaginateOption {
	return func(pager *subprocessorPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubprocessorFilter configures pagination filter.
func WithSubprocessorFilter(filter func(*SubprocessorQuery) (*SubprocessorQuery, error)) SubprocessorPaginateOption {
	return func(pager *subprocessorPager) error {
		if filter == nil {
			return errors.New("SubprocessorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subprocessorPager struct {
	reverse bool
	order   []*SubprocessorOrder
	filter  func(*SubprocessorQuery) (*SubprocessorQuery, error)
}

func newSubprocessorPager(opts []SubprocessorPaginateOption, reverse bool) (*subprocessorPager, error) {
	pager := &subprocessorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subprocessorPager) applyFilter(query *SubprocessorQuery) (*SubprocessorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subprocessorPager) toCursor(_m *Subprocessor) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *subprocessorPager) applyCursors(query *SubprocessorQuery, after, before *Cursor) (*SubprocessorQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubprocessorOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subprocessorPager) applyOrder(query *SubprocessorQuery) *SubprocessorQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubprocessorOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubprocessorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subprocessorPager) orderExpr(query *SubprocessorQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubprocessorOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subprocessor.
func (_m *SubprocessorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubprocessorPaginateOption,
) (*SubprocessorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubprocessorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubprocessorConnection{Edges: []*SubprocessorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubprocessorOrderFieldCreatedAt orders Subprocessor by created_at.
	SubprocessorOrderFieldCreatedAt = &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subprocessor.FieldCreatedAt,
		toTerm: subprocessor.ByCreatedAt,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubprocessorOrderFieldUpdatedAt orders Subprocessor by updated_at.
	SubprocessorOrderFieldUpdatedAt = &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subprocessor.FieldUpdatedAt,
		toTerm: subprocessor.ByUpdatedAt,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubprocessorOrderFieldName orders Subprocessor by name.
	SubprocessorOrderFieldName = &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.Name, nil
		},
		column: subprocessor.FieldName,
		toTerm: subprocessor.ByName,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubprocessorOrderField) String() string {
	var str string
	switch f.column {
	case SubprocessorOrderFieldCreatedAt.column:
		str = "created_at"
	case SubprocessorOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubprocessorOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubprocessorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubprocessorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubprocessorOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubprocessorOrderFieldCreatedAt
	case "updated_at":
		*f = *SubprocessorOrderFieldUpdatedAt
	case "name":
		*f = *SubprocessorOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid SubprocessorOrderField", str)
	}
	return nil
}

// SubprocessorOrderField defines the ordering field of Subprocessor.
type SubprocessorOrderField struct {
	// Value extracts the ordering value from the given Subprocessor.
	Value    func(*Subprocessor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subprocessor.OrderOption
	toCursor func(*Subprocessor) Cursor
}

// SubprocessorOrder defines the ordering of Subprocessor.
type SubprocessorOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *SubprocessorOrderField `json:"field"`
}

// DefaultSubprocessorOrder is the default ordering of Subprocessor.
var DefaultSubprocessorOrder = &SubprocessorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subprocessor.FieldID,
		toTerm: subprocessor.ByID,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Subprocessor into SubprocessorEdge.
func (_m *Subprocessor) ToEdge(order *SubprocessorOrder) *SubprocessorEdge {
	if order == nil {
		order = DefaultSubprocessorOrder
	}
	return &SubprocessorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubprocessorHistoryEdge is the edge representation of SubprocessorHistory.
type SubprocessorHistoryEdge struct {
	Node   *SubprocessorHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// SubprocessorHistoryConnection is the connection containing edges to SubprocessorHistory.
type SubprocessorHistoryConnection struct {
	Edges      []*SubprocessorHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *SubprocessorHistoryConnection) build(nodes []*SubprocessorHistory, pager *subprocessorhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *SubprocessorHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubprocessorHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubprocessorHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubprocessorHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubprocessorHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubprocessorHistoryPaginateOption enables pagination customization.
type SubprocessorHistoryPaginateOption func(*subprocessorhistoryPager) error

// WithSubprocessorHistoryOrder configures pagination ordering.
func WithSubprocessorHistoryOrder(order *SubprocessorHistoryOrder) SubprocessorHistoryPaginateOption {
	if order == nil {
		order = DefaultSubprocessorHistoryOrder
	}
	o := *order
	return func(pager *subprocessorhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubprocessorHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubprocessorHistoryFilter configures pagination filter.
func WithSubprocessorHistoryFilter(filter func(*SubprocessorHistoryQuery) (*SubprocessorHistoryQuery, error)) SubprocessorHistoryPaginateOption {
	return func(pager *subprocessorhistoryPager) error {
		if filter == nil {
			return errors.New("SubprocessorHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subprocessorhistoryPager struct {
	reverse bool
	order   *SubprocessorHistoryOrder
	filter  func(*SubprocessorHistoryQuery) (*SubprocessorHistoryQuery, error)
}

func newSubprocessorHistoryPager(opts []SubprocessorHistoryPaginateOption, reverse bool) (*subprocessorhistoryPager, error) {
	pager := &subprocessorhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubprocessorHistoryOrder
	}
	return pager, nil
}

func (p *subprocessorhistoryPager) applyFilter(query *SubprocessorHistoryQuery) (*SubprocessorHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subprocessorhistoryPager) toCursor(_m *SubprocessorHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *subprocessorhistoryPager) applyCursors(query *SubprocessorHistoryQuery, after, before *Cursor) (*SubprocessorHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubprocessorHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subprocessorhistoryPager) applyOrder(query *SubprocessorHistoryQuery) *SubprocessorHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubprocessorHistoryOrder.Field {
		query = query.Order(DefaultSubprocessorHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subprocessorhistoryPager) orderExpr(query *SubprocessorHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubprocessorHistoryOrder.Field {
			b.Comma().Ident(DefaultSubprocessorHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubprocessorHistory.
func (_m *SubprocessorHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubprocessorHistoryPaginateOption,
) (*SubprocessorHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubprocessorHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubprocessorHistoryConnection{Edges: []*SubprocessorHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubprocessorHistoryOrderFieldHistoryTime orders SubprocessorHistory by history_time.
	SubprocessorHistoryOrderFieldHistoryTime = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: subprocessorhistory.FieldHistoryTime,
		toTerm: subprocessorhistory.ByHistoryTime,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// SubprocessorHistoryOrderFieldCreatedAt orders SubprocessorHistory by created_at.
	SubprocessorHistoryOrderFieldCreatedAt = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subprocessorhistory.FieldCreatedAt,
		toTerm: subprocessorhistory.ByCreatedAt,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubprocessorHistoryOrderFieldUpdatedAt orders SubprocessorHistory by updated_at.
	SubprocessorHistoryOrderFieldUpdatedAt = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subprocessorhistory.FieldUpdatedAt,
		toTerm: subprocessorhistory.ByUpdatedAt,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubprocessorHistoryOrderFieldName orders SubprocessorHistory by name.
	SubprocessorHistoryOrderFieldName = &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: subprocessorhistory.FieldName,
		toTerm: subprocessorhistory.ByName,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubprocessorHistoryOrderField) String() string {
	var str string
	switch f.column {
	case SubprocessorHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case SubprocessorHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case SubprocessorHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubprocessorHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubprocessorHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubprocessorHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubprocessorHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *SubprocessorHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *SubprocessorHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *SubprocessorHistoryOrderFieldUpdatedAt
	case "name":
		*f = *SubprocessorHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid SubprocessorHistoryOrderField", str)
	}
	return nil
}

// SubprocessorHistoryOrderField defines the ordering field of SubprocessorHistory.
type SubprocessorHistoryOrderField struct {
	// Value extracts the ordering value from the given SubprocessorHistory.
	Value    func(*SubprocessorHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subprocessorhistory.OrderOption
	toCursor func(*SubprocessorHistory) Cursor
}

// SubprocessorHistoryOrder defines the ordering of SubprocessorHistory.
type SubprocessorHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *SubprocessorHistoryOrderField `json:"field"`
}

// DefaultSubprocessorHistoryOrder is the default ordering of SubprocessorHistory.
var DefaultSubprocessorHistoryOrder = &SubprocessorHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubprocessorHistoryOrderField{
		Value: func(_m *SubprocessorHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subprocessorhistory.FieldID,
		toTerm: subprocessorhistory.ByID,
		toCursor: func(_m *SubprocessorHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts SubprocessorHistory into SubprocessorHistoryEdge.
func (_m *SubprocessorHistory) ToEdge(order *SubprocessorHistoryOrder) *SubprocessorHistoryEdge {
	if order == nil {
		order = DefaultSubprocessorHistoryOrder
	}
	return &SubprocessorHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubscriberEdge is the edge representation of Subscriber.
type SubscriberEdge struct {
	Node   *Subscriber `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubscriberConnection is the connection containing edges to Subscriber.
type SubscriberConnection struct {
	Edges      []*SubscriberEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubscriberConnection) build(nodes []*Subscriber, pager *subscriberPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subscriber
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subscriber {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subscriber {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubscriberEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubscriberEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubscriberPaginateOption enables pagination customization.
type SubscriberPaginateOption func(*subscriberPager) error

// WithSubscriberOrder configures pagination ordering.
func WithSubscriberOrder(order []*SubscriberOrder) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubscriberFilter configures pagination filter.
func WithSubscriberFilter(filter func(*SubscriberQuery) (*SubscriberQuery, error)) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		if filter == nil {
			return errors.New("SubscriberQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subscriberPager struct {
	reverse bool
	order   []*SubscriberOrder
	filter  func(*SubscriberQuery) (*SubscriberQuery, error)
}

func newSubscriberPager(opts []SubscriberPaginateOption, reverse bool) (*subscriberPager, error) {
	pager := &subscriberPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subscriberPager) applyFilter(query *SubscriberQuery) (*SubscriberQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subscriberPager) toCursor(_m *Subscriber) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *subscriberPager) applyCursors(query *SubscriberQuery, after, before *Cursor) (*SubscriberQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubscriberOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subscriberPager) applyOrder(query *SubscriberQuery) *SubscriberQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubscriberOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubscriberOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subscriberPager) orderExpr(query *SubscriberQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubscriberOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subscriber.
func (_m *SubscriberQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubscriberPaginateOption,
) (*SubscriberConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubscriberPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubscriberConnection{Edges: []*SubscriberEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubscriberOrderFieldCreatedAt orders Subscriber by created_at.
	SubscriberOrderFieldCreatedAt = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subscriber.FieldCreatedAt,
		toTerm: subscriber.ByCreatedAt,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubscriberOrderFieldUpdatedAt orders Subscriber by updated_at.
	SubscriberOrderFieldUpdatedAt = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subscriber.FieldUpdatedAt,
		toTerm: subscriber.ByUpdatedAt,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubscriberOrderFieldEmail orders Subscriber by email.
	SubscriberOrderFieldEmail = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.Email, nil
		},
		column: subscriber.FieldEmail,
		toTerm: subscriber.ByEmail,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// SubscriberOrderFieldActive orders Subscriber by active.
	SubscriberOrderFieldActive = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.Active, nil
		},
		column: subscriber.FieldActive,
		toTerm: subscriber.ByActive,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// SubscriberOrderFieldUnsubscribed orders Subscriber by unsubscribed.
	SubscriberOrderFieldUnsubscribed = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.Unsubscribed, nil
		},
		column: subscriber.FieldUnsubscribed,
		toTerm: subscriber.ByUnsubscribed,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Unsubscribed,
			}
		},
	}
	// SubscriberOrderFieldSendAttempts orders Subscriber by send_attempts.
	SubscriberOrderFieldSendAttempts = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: subscriber.FieldSendAttempts,
		toTerm: subscriber.BySendAttempts,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubscriberOrderField) String() string {
	var str string
	switch f.column {
	case SubscriberOrderFieldCreatedAt.column:
		str = "created_at"
	case SubscriberOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubscriberOrderFieldEmail.column:
		str = "email"
	case SubscriberOrderFieldActive.column:
		str = "active"
	case SubscriberOrderFieldUnsubscribed.column:
		str = "unsubscribed"
	case SubscriberOrderFieldSendAttempts.column:
		str = "send_attempts"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubscriberOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubscriberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubscriberOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubscriberOrderFieldCreatedAt
	case "updated_at":
		*f = *SubscriberOrderFieldUpdatedAt
	case "email":
		*f = *SubscriberOrderFieldEmail
	case "active":
		*f = *SubscriberOrderFieldActive
	case "unsubscribed":
		*f = *SubscriberOrderFieldUnsubscribed
	case "send_attempts":
		*f = *SubscriberOrderFieldSendAttempts
	default:
		return fmt.Errorf("%s is not a valid SubscriberOrderField", str)
	}
	return nil
}

// SubscriberOrderField defines the ordering field of Subscriber.
type SubscriberOrderField struct {
	// Value extracts the ordering value from the given Subscriber.
	Value    func(*Subscriber) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subscriber.OrderOption
	toCursor func(*Subscriber) Cursor
}

// SubscriberOrder defines the ordering of Subscriber.
type SubscriberOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubscriberOrderField `json:"field"`
}

// DefaultSubscriberOrder is the default ordering of Subscriber.
var DefaultSubscriberOrder = &SubscriberOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subscriber.FieldID,
		toTerm: subscriber.ByID,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Subscriber into SubscriberEdge.
func (_m *Subscriber) ToEdge(order *SubscriberOrder) *SubscriberEdge {
	if order == nil {
		order = DefaultSubscriberOrder
	}
	return &SubscriberEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TFASettingEdge is the edge representation of TFASetting.
type TFASettingEdge struct {
	Node   *TFASetting `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// TFASettingConnection is the connection containing edges to TFASetting.
type TFASettingConnection struct {
	Edges      []*TFASettingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *TFASettingConnection) build(nodes []*TFASetting, pager *tfasettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TFASetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TFASetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TFASetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TFASettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TFASettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TFASettingPaginateOption enables pagination customization.
type TFASettingPaginateOption func(*tfasettingPager) error

// WithTFASettingOrder configures pagination ordering.
func WithTFASettingOrder(order []*TFASettingOrder) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTFASettingFilter configures pagination filter.
func WithTFASettingFilter(filter func(*TFASettingQuery) (*TFASettingQuery, error)) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		if filter == nil {
			return errors.New("TFASettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tfasettingPager struct {
	reverse bool
	order   []*TFASettingOrder
	filter  func(*TFASettingQuery) (*TFASettingQuery, error)
}

func newTFASettingPager(opts []TFASettingPaginateOption, reverse bool) (*tfasettingPager, error) {
	pager := &tfasettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tfasettingPager) applyFilter(query *TFASettingQuery) (*TFASettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tfasettingPager) toCursor(_m *TFASetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *tfasettingPager) applyCursors(query *TFASettingQuery, after, before *Cursor) (*TFASettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTFASettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *tfasettingPager) applyOrder(query *TFASettingQuery) *TFASettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTFASettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTFASettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tfasettingPager) orderExpr(query *TFASettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTFASettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TFASetting.
func (_m *TFASettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TFASettingPaginateOption,
) (*TFASettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTFASettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TFASettingConnection{Edges: []*TFASettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TFASettingOrderFieldCreatedAt orders TFASetting by created_at.
	TFASettingOrderFieldCreatedAt = &TFASettingOrderField{
		Value: func(_m *TFASetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: tfasetting.FieldCreatedAt,
		toTerm: tfasetting.ByCreatedAt,
		toCursor: func(_m *TFASetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TFASettingOrderFieldUpdatedAt orders TFASetting by updated_at.
	TFASettingOrderFieldUpdatedAt = &TFASettingOrderField{
		Value: func(_m *TFASetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: tfasetting.FieldUpdatedAt,
		toTerm: tfasetting.ByUpdatedAt,
		toCursor: func(_m *TFASetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TFASettingOrderField) String() string {
	var str string
	switch f.column {
	case TFASettingOrderFieldCreatedAt.column:
		str = "created_at"
	case TFASettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TFASettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TFASettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TFASettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TFASettingOrderFieldCreatedAt
	case "updated_at":
		*f = *TFASettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TFASettingOrderField", str)
	}
	return nil
}

// TFASettingOrderField defines the ordering field of TFASetting.
type TFASettingOrderField struct {
	// Value extracts the ordering value from the given TFASetting.
	Value    func(*TFASetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tfasetting.OrderOption
	toCursor func(*TFASetting) Cursor
}

// TFASettingOrder defines the ordering of TFASetting.
type TFASettingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *TFASettingOrderField `json:"field"`
}

// DefaultTFASettingOrder is the default ordering of TFASetting.
var DefaultTFASettingOrder = &TFASettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TFASettingOrderField{
		Value: func(_m *TFASetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: tfasetting.FieldID,
		toTerm: tfasetting.ByID,
		toCursor: func(_m *TFASetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TFASetting into TFASettingEdge.
func (_m *TFASetting) ToEdge(order *TFASettingOrder) *TFASettingEdge {
	if order == nil {
		order = DefaultTFASettingOrder
	}
	return &TFASettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TagDefinitionEdge is the edge representation of TagDefinition.
type TagDefinitionEdge struct {
	Node   *TagDefinition `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// TagDefinitionConnection is the connection containing edges to TagDefinition.
type TagDefinitionConnection struct {
	Edges      []*TagDefinitionEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *TagDefinitionConnection) build(nodes []*TagDefinition, pager *tagdefinitionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TagDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TagDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TagDefinition {
			return nodes[i]
		}
	}
	c.Edges = make([]*TagDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TagDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TagDefinitionPaginateOption enables pagination customization.
type TagDefinitionPaginateOption func(*tagdefinitionPager) error

// WithTagDefinitionOrder configures pagination ordering.
func WithTagDefinitionOrder(order []*TagDefinitionOrder) TagDefinitionPaginateOption {
	return func(pager *tagdefinitionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTagDefinitionFilter configures pagination filter.
func WithTagDefinitionFilter(filter func(*TagDefinitionQuery) (*TagDefinitionQuery, error)) TagDefinitionPaginateOption {
	return func(pager *tagdefinitionPager) error {
		if filter == nil {
			return errors.New("TagDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagdefinitionPager struct {
	reverse bool
	order   []*TagDefinitionOrder
	filter  func(*TagDefinitionQuery) (*TagDefinitionQuery, error)
}

func newTagDefinitionPager(opts []TagDefinitionPaginateOption, reverse bool) (*tagdefinitionPager, error) {
	pager := &tagdefinitionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tagdefinitionPager) applyFilter(query *TagDefinitionQuery) (*TagDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagdefinitionPager) toCursor(_m *TagDefinition) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *tagdefinitionPager) applyCursors(query *TagDefinitionQuery, after, before *Cursor) (*TagDefinitionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTagDefinitionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *tagdefinitionPager) applyOrder(query *TagDefinitionQuery) *TagDefinitionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTagDefinitionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTagDefinitionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tagdefinitionPager) orderExpr(query *TagDefinitionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTagDefinitionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TagDefinition.
func (_m *TagDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagDefinitionPaginateOption,
) (*TagDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagDefinitionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TagDefinitionConnection{Edges: []*TagDefinitionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TagDefinitionOrderFieldCreatedAt orders TagDefinition by created_at.
	TagDefinitionOrderFieldCreatedAt = &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: tagdefinition.FieldCreatedAt,
		toTerm: tagdefinition.ByCreatedAt,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TagDefinitionOrderFieldUpdatedAt orders TagDefinition by updated_at.
	TagDefinitionOrderFieldUpdatedAt = &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: tagdefinition.FieldUpdatedAt,
		toTerm: tagdefinition.ByUpdatedAt,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TagDefinitionOrderField) String() string {
	var str string
	switch f.column {
	case TagDefinitionOrderFieldCreatedAt.column:
		str = "created_at"
	case TagDefinitionOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TagDefinitionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TagDefinitionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TagDefinitionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TagDefinitionOrderFieldCreatedAt
	case "updated_at":
		*f = *TagDefinitionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TagDefinitionOrderField", str)
	}
	return nil
}

// TagDefinitionOrderField defines the ordering field of TagDefinition.
type TagDefinitionOrderField struct {
	// Value extracts the ordering value from the given TagDefinition.
	Value    func(*TagDefinition) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tagdefinition.OrderOption
	toCursor func(*TagDefinition) Cursor
}

// TagDefinitionOrder defines the ordering of TagDefinition.
type TagDefinitionOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *TagDefinitionOrderField `json:"field"`
}

// DefaultTagDefinitionOrder is the default ordering of TagDefinition.
var DefaultTagDefinitionOrder = &TagDefinitionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.ID, nil
		},
		column: tagdefinition.FieldID,
		toTerm: tagdefinition.ByID,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TagDefinition into TagDefinitionEdge.
func (_m *TagDefinition) ToEdge(order *TagDefinitionOrder) *TagDefinitionEdge {
	if order == nil {
		order = DefaultTagDefinitionOrder
	}
	return &TagDefinitionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order []*TaskOrder) TaskPaginateOption {
	return func(pager *taskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   []*TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(_m *Task) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTaskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTaskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (_m *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskOrderFieldCreatedAt orders Task by created_at.
	TaskOrderFieldCreatedAt = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: task.FieldCreatedAt,
		toTerm: task.ByCreatedAt,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TaskOrderFieldUpdatedAt orders Task by updated_at.
	TaskOrderFieldUpdatedAt = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: task.FieldUpdatedAt,
		toTerm: task.ByUpdatedAt,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TaskOrderFieldTitle orders Task by title.
	TaskOrderFieldTitle = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.Title, nil
		},
		column: task.FieldTitle,
		toTerm: task.ByTitle,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// TaskOrderFieldStatus orders Task by status.
	TaskOrderFieldStatus = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.Status, nil
		},
		column: task.FieldStatus,
		toTerm: task.ByStatus,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// TaskOrderFieldCategory orders Task by category.
	TaskOrderFieldCategory = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.Category, nil
		},
		column: task.FieldCategory,
		toTerm: task.ByCategory,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// TaskOrderFieldDue orders Task by due.
	TaskOrderFieldDue = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Due == nil {
				return nil, nil
			}
			return _m.Due, nil
		},
		column: task.FieldDue,
		toTerm: func(opts ...sql.OrderTermOption) task.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return task.ByDue(opts...)
		},
		toCursor: func(_m *Task) Cursor {
			if _m.Due == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Due,
			}
		},
	}
	// TaskOrderFieldCompleted orders Task by completed.
	TaskOrderFieldCompleted = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Completed == nil {
				return nil, nil
			}
			return _m.Completed, nil
		},
		column: task.FieldCompleted,
		toTerm: func(opts ...sql.OrderTermOption) task.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return task.ByCompleted(opts...)
		},
		toCursor: func(_m *Task) Cursor {
			if _m.Completed == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Completed,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskOrderField) String() string {
	var str string
	switch f.column {
	case TaskOrderFieldCreatedAt.column:
		str = "created_at"
	case TaskOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TaskOrderFieldTitle.column:
		str = "title"
	case TaskOrderFieldStatus.column:
		str = "STATUS"
	case TaskOrderFieldCategory.column:
		str = "category"
	case TaskOrderFieldDue.column:
		str = "due"
	case TaskOrderFieldCompleted.column:
		str = "completed"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TaskOrderFieldCreatedAt
	case "updated_at":
		*f = *TaskOrderFieldUpdatedAt
	case "title":
		*f = *TaskOrderFieldTitle
	case "STATUS":
		*f = *TaskOrderFieldStatus
	case "category":
		*f = *TaskOrderFieldCategory
	case "due":
		*f = *TaskOrderFieldDue
	case "completed":
		*f = *TaskOrderFieldCompleted
	default:
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(_m *Task) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (_m *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TaskHistoryEdge is the edge representation of TaskHistory.
type TaskHistoryEdge struct {
	Node   *TaskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TaskHistoryConnection is the connection containing edges to TaskHistory.
type TaskHistoryConnection struct {
	Edges      []*TaskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TaskHistoryConnection) build(nodes []*TaskHistory, pager *taskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TaskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TaskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TaskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskHistoryPaginateOption enables pagination customization.
type TaskHistoryPaginateOption func(*taskhistoryPager) error

// WithTaskHistoryOrder configures pagination ordering.
func WithTaskHistoryOrder(order *TaskHistoryOrder) TaskHistoryPaginateOption {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	o := *order
	return func(pager *taskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskHistoryFilter configures pagination filter.
func WithTaskHistoryFilter(filter func(*TaskHistoryQuery) (*TaskHistoryQuery, error)) TaskHistoryPaginateOption {
	return func(pager *taskhistoryPager) error {
		if filter == nil {
			return errors.New("TaskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskhistoryPager struct {
	reverse bool
	order   *TaskHistoryOrder
	filter  func(*TaskHistoryQuery) (*TaskHistoryQuery, error)
}

func newTaskHistoryPager(opts []TaskHistoryPaginateOption, reverse bool) (*taskhistoryPager, error) {
	pager := &taskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskHistoryOrder
	}
	return pager, nil
}

func (p *taskhistoryPager) applyFilter(query *TaskHistoryQuery) (*TaskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskhistoryPager) toCursor(_m *TaskHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *taskhistoryPager) applyCursors(query *TaskHistoryQuery, after, before *Cursor) (*TaskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTaskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskhistoryPager) applyOrder(query *TaskHistoryQuery) *TaskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTaskHistoryOrder.Field {
		query = query.Order(DefaultTaskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *taskhistoryPager) orderExpr(query *TaskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTaskHistoryOrder.Field {
			b.Comma().Ident(DefaultTaskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TaskHistory.
func (_m *TaskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskHistoryPaginateOption,
) (*TaskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TaskHistoryConnection{Edges: []*TaskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskHistoryOrderFieldHistoryTime orders TaskHistory by history_time.
	TaskHistoryOrderFieldHistoryTime = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: taskhistory.FieldHistoryTime,
		toTerm: taskhistory.ByHistoryTime,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TaskHistoryOrderFieldCreatedAt orders TaskHistory by created_at.
	TaskHistoryOrderFieldCreatedAt = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: taskhistory.FieldCreatedAt,
		toTerm: taskhistory.ByCreatedAt,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TaskHistoryOrderFieldUpdatedAt orders TaskHistory by updated_at.
	TaskHistoryOrderFieldUpdatedAt = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: taskhistory.FieldUpdatedAt,
		toTerm: taskhistory.ByUpdatedAt,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TaskHistoryOrderFieldTitle orders TaskHistory by title.
	TaskHistoryOrderFieldTitle = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.Title, nil
		},
		column: taskhistory.FieldTitle,
		toTerm: taskhistory.ByTitle,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// TaskHistoryOrderFieldStatus orders TaskHistory by status.
	TaskHistoryOrderFieldStatus = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.Status, nil
		},
		column: taskhistory.FieldStatus,
		toTerm: taskhistory.ByStatus,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// TaskHistoryOrderFieldCategory orders TaskHistory by category.
	TaskHistoryOrderFieldCategory = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: taskhistory.FieldCategory,
		toTerm: taskhistory.ByCategory,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// TaskHistoryOrderFieldDue orders TaskHistory by due.
	TaskHistoryOrderFieldDue = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Due == nil {
				return nil, nil
			}
			return _m.Due, nil
		},
		column: taskhistory.FieldDue,
		toTerm: func(opts ...sql.OrderTermOption) taskhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return taskhistory.ByDue(opts...)
		},
		toCursor: func(_m *TaskHistory) Cursor {
			if _m.Due == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Due,
			}
		},
	}
	// TaskHistoryOrderFieldCompleted orders TaskHistory by completed.
	TaskHistoryOrderFieldCompleted = &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Completed == nil {
				return nil, nil
			}
			return _m.Completed, nil
		},
		column: taskhistory.FieldCompleted,
		toTerm: func(opts ...sql.OrderTermOption) taskhistory.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return taskhistory.ByCompleted(opts...)
		},
		toCursor: func(_m *TaskHistory) Cursor {
			if _m.Completed == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Completed,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TaskHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TaskHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TaskHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TaskHistoryOrderFieldTitle.column:
		str = "title"
	case TaskHistoryOrderFieldStatus.column:
		str = "STATUS"
	case TaskHistoryOrderFieldCategory.column:
		str = "category"
	case TaskHistoryOrderFieldDue.column:
		str = "due"
	case TaskHistoryOrderFieldCompleted.column:
		str = "completed"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TaskHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TaskHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TaskHistoryOrderFieldUpdatedAt
	case "title":
		*f = *TaskHistoryOrderFieldTitle
	case "STATUS":
		*f = *TaskHistoryOrderFieldStatus
	case "category":
		*f = *TaskHistoryOrderFieldCategory
	case "due":
		*f = *TaskHistoryOrderFieldDue
	case "completed":
		*f = *TaskHistoryOrderFieldCompleted
	default:
		return fmt.Errorf("%s is not a valid TaskHistoryOrderField", str)
	}
	return nil
}

// TaskHistoryOrderField defines the ordering field of TaskHistory.
type TaskHistoryOrderField struct {
	// Value extracts the ordering value from the given TaskHistory.
	Value    func(*TaskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) taskhistory.OrderOption
	toCursor func(*TaskHistory) Cursor
}

// TaskHistoryOrder defines the ordering of TaskHistory.
type TaskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TaskHistoryOrderField `json:"field"`
}

// DefaultTaskHistoryOrder is the default ordering of TaskHistory.
var DefaultTaskHistoryOrder = &TaskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskHistoryOrderField{
		Value: func(_m *TaskHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: taskhistory.FieldID,
		toTerm: taskhistory.ByID,
		toCursor: func(_m *TaskHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TaskHistory into TaskHistoryEdge.
func (_m *TaskHistory) ToEdge(order *TaskHistoryOrder) *TaskHistoryEdge {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	return &TaskHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TemplateEdge is the edge representation of Template.
type TemplateEdge struct {
	Node   *Template `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TemplateConnection is the connection containing edges to Template.
type TemplateConnection struct {
	Edges      []*TemplateEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *TemplateConnection) build(nodes []*Template, pager *templatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Template
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Template {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Template {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplatePaginateOption enables pagination customization.
type TemplatePaginateOption func(*templatePager) error

// WithTemplateOrder configures pagination ordering.
func WithTemplateOrder(order []*TemplateOrder) TemplatePaginateOption {
	return func(pager *templatePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTemplateFilter configures pagination filter.
func WithTemplateFilter(filter func(*TemplateQuery) (*TemplateQuery, error)) TemplatePaginateOption {
	return func(pager *templatePager) error {
		if filter == nil {
			return errors.New("TemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatePager struct {
	reverse bool
	order   []*TemplateOrder
	filter  func(*TemplateQuery) (*TemplateQuery, error)
}

func newTemplatePager(opts []TemplatePaginateOption, reverse bool) (*templatePager, error) {
	pager := &templatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *templatePager) applyFilter(query *TemplateQuery) (*TemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatePager) toCursor(_m *Template) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *templatePager) applyCursors(query *TemplateQuery, after, before *Cursor) (*TemplateQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTemplateOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *templatePager) applyOrder(query *TemplateQuery) *TemplateQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTemplateOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *templatePager) orderExpr(query *TemplateQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTemplateOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Template.
func (_m *TemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplatePaginateOption,
) (*TemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TemplateConnection{Edges: []*TemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateOrderFieldCreatedAt orders Template by created_at.
	TemplateOrderFieldCreatedAt = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: template.FieldCreatedAt,
		toTerm: template.ByCreatedAt,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TemplateOrderFieldUpdatedAt orders Template by updated_at.
	TemplateOrderFieldUpdatedAt = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: template.FieldUpdatedAt,
		toTerm: template.ByUpdatedAt,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TemplateOrderFieldName orders Template by name.
	TemplateOrderFieldName = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.Name, nil
		},
		column: template.FieldName,
		toTerm: template.ByName,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// TemplateOrderFieldTemplateType orders Template by template_type.
	TemplateOrderFieldTemplateType = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.TemplateType, nil
		},
		column: template.FieldTemplateType,
		toTerm: template.ByTemplateType,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TemplateType,
			}
		},
	}
	// TemplateOrderFieldKind orders Template by kind.
	TemplateOrderFieldKind = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: template.FieldKind,
		toTerm: template.ByKind,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateOrderField) String() string {
	var str string
	switch f.column {
	case TemplateOrderFieldCreatedAt.column:
		str = "created_at"
	case TemplateOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TemplateOrderFieldName.column:
		str = "name"
	case TemplateOrderFieldTemplateType.column:
		str = "TEMPLATE_TYPE"
	case TemplateOrderFieldKind.column:
		str = "KIND"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TemplateOrderFieldCreatedAt
	case "updated_at":
		*f = *TemplateOrderFieldUpdatedAt
	case "name":
		*f = *TemplateOrderFieldName
	case "TEMPLATE_TYPE":
		*f = *TemplateOrderFieldTemplateType
	case "KIND":
		*f = *TemplateOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

// TemplateOrderField defines the ordering field of Template.
type TemplateOrderField struct {
	// Value extracts the ordering value from the given Template.
	Value    func(*Template) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) template.OrderOption
	toCursor func(*Template) Cursor
}

// TemplateOrder defines the ordering of Template.
type TemplateOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TemplateOrderField `json:"field"`
}

// DefaultTemplateOrder is the default ordering of Template.
var DefaultTemplateOrder = &TemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.ID, nil
		},
		column: template.FieldID,
		toTerm: template.ByID,
		toCursor: func(_m *Template) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Template into TemplateEdge.
func (_m *Template) ToEdge(order *TemplateOrder) *TemplateEdge {
	if order == nil {
		order = DefaultTemplateOrder
	}
	return &TemplateEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TemplateHistoryEdge is the edge representation of TemplateHistory.
type TemplateHistoryEdge struct {
	Node   *TemplateHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TemplateHistoryConnection is the connection containing edges to TemplateHistory.
type TemplateHistoryConnection struct {
	Edges      []*TemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TemplateHistoryConnection) build(nodes []*TemplateHistory, pager *templatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplateHistoryPaginateOption enables pagination customization.
type TemplateHistoryPaginateOption func(*templatehistoryPager) error

// WithTemplateHistoryOrder configures pagination ordering.
func WithTemplateHistoryOrder(order *TemplateHistoryOrder) TemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	o := *order
	return func(pager *templatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateHistoryFilter configures pagination filter.
func WithTemplateHistoryFilter(filter func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)) TemplateHistoryPaginateOption {
	return func(pager *templatehistoryPager) error {
		if filter == nil {
			return errors.New("TemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatehistoryPager struct {
	reverse bool
	order   *TemplateHistoryOrder
	filter  func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)
}

func newTemplateHistoryPager(opts []TemplateHistoryPaginateOption, reverse bool) (*templatehistoryPager, error) {
	pager := &templatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateHistoryOrder
	}
	return pager, nil
}

func (p *templatehistoryPager) applyFilter(query *TemplateHistoryQuery) (*TemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatehistoryPager) toCursor(_m *TemplateHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *templatehistoryPager) applyCursors(query *TemplateHistoryQuery, after, before *Cursor) (*TemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *templatehistoryPager) applyOrder(query *TemplateHistoryQuery) *TemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTemplateHistoryOrder.Field {
		query = query.Order(DefaultTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *templatehistoryPager) orderExpr(query *TemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TemplateHistory.
func (_m *TemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplateHistoryPaginateOption,
) (*TemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TemplateHistoryConnection{Edges: []*TemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateHistoryOrderFieldHistoryTime orders TemplateHistory by history_time.
	TemplateHistoryOrderFieldHistoryTime = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: templatehistory.FieldHistoryTime,
		toTerm: templatehistory.ByHistoryTime,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TemplateHistoryOrderFieldCreatedAt orders TemplateHistory by created_at.
	TemplateHistoryOrderFieldCreatedAt = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: templatehistory.FieldCreatedAt,
		toTerm: templatehistory.ByCreatedAt,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TemplateHistoryOrderFieldUpdatedAt orders TemplateHistory by updated_at.
	TemplateHistoryOrderFieldUpdatedAt = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: templatehistory.FieldUpdatedAt,
		toTerm: templatehistory.ByUpdatedAt,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TemplateHistoryOrderFieldName orders TemplateHistory by name.
	TemplateHistoryOrderFieldName = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: templatehistory.FieldName,
		toTerm: templatehistory.ByName,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// TemplateHistoryOrderFieldTemplateType orders TemplateHistory by template_type.
	TemplateHistoryOrderFieldTemplateType = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.TemplateType, nil
		},
		column: templatehistory.FieldTemplateType,
		toTerm: templatehistory.ByTemplateType,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TemplateType,
			}
		},
	}
	// TemplateHistoryOrderFieldKind orders TemplateHistory by kind.
	TemplateHistoryOrderFieldKind = &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: templatehistory.FieldKind,
		toTerm: templatehistory.ByKind,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TemplateHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TemplateHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TemplateHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TemplateHistoryOrderFieldName.column:
		str = "name"
	case TemplateHistoryOrderFieldTemplateType.column:
		str = "TEMPLATE_TYPE"
	case TemplateHistoryOrderFieldKind.column:
		str = "KIND"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TemplateHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TemplateHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TemplateHistoryOrderFieldUpdatedAt
	case "name":
		*f = *TemplateHistoryOrderFieldName
	case "TEMPLATE_TYPE":
		*f = *TemplateHistoryOrderFieldTemplateType
	case "KIND":
		*f = *TemplateHistoryOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

// TemplateHistoryOrderField defines the ordering field of TemplateHistory.
type TemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given TemplateHistory.
	Value    func(*TemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) templatehistory.OrderOption
	toCursor func(*TemplateHistory) Cursor
}

// TemplateHistoryOrder defines the ordering of TemplateHistory.
type TemplateHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TemplateHistoryOrderField `json:"field"`
}

// DefaultTemplateHistoryOrder is the default ordering of TemplateHistory.
var DefaultTemplateHistoryOrder = &TemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateHistoryOrderField{
		Value: func(_m *TemplateHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: templatehistory.FieldID,
		toTerm: templatehistory.ByID,
		toCursor: func(_m *TemplateHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TemplateHistory into TemplateHistoryEdge.
func (_m *TemplateHistory) ToEdge(order *TemplateHistoryOrder) *TemplateHistoryEdge {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	return &TemplateHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterEdge is the edge representation of TrustCenter.
type TrustCenterEdge struct {
	Node   *TrustCenter `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TrustCenterConnection is the connection containing edges to TrustCenter.
type TrustCenterConnection struct {
	Edges      []*TrustCenterEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TrustCenterConnection) build(nodes []*TrustCenter, pager *trustcenterPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenter {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterPaginateOption enables pagination customization.
type TrustCenterPaginateOption func(*trustcenterPager) error

// WithTrustCenterOrder configures pagination ordering.
func WithTrustCenterOrder(order []*TrustCenterOrder) TrustCenterPaginateOption {
	return func(pager *trustcenterPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterFilter configures pagination filter.
func WithTrustCenterFilter(filter func(*TrustCenterQuery) (*TrustCenterQuery, error)) TrustCenterPaginateOption {
	return func(pager *trustcenterPager) error {
		if filter == nil {
			return errors.New("TrustCenterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterPager struct {
	reverse bool
	order   []*TrustCenterOrder
	filter  func(*TrustCenterQuery) (*TrustCenterQuery, error)
}

func newTrustCenterPager(opts []TrustCenterPaginateOption, reverse bool) (*trustcenterPager, error) {
	pager := &trustcenterPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterPager) applyFilter(query *TrustCenterQuery) (*TrustCenterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterPager) toCursor(_m *TrustCenter) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterPager) applyCursors(query *TrustCenterQuery, after, before *Cursor) (*TrustCenterQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterPager) applyOrder(query *TrustCenterQuery) *TrustCenterQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterPager) orderExpr(query *TrustCenterQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenter.
func (_m *TrustCenterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterPaginateOption,
) (*TrustCenterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterConnection{Edges: []*TrustCenterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterOrderFieldCreatedAt orders TrustCenter by created_at.
	TrustCenterOrderFieldCreatedAt = &TrustCenterOrderField{
		Value: func(_m *TrustCenter) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenter.FieldCreatedAt,
		toTerm: trustcenter.ByCreatedAt,
		toCursor: func(_m *TrustCenter) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterOrderFieldUpdatedAt orders TrustCenter by updated_at.
	TrustCenterOrderFieldUpdatedAt = &TrustCenterOrderField{
		Value: func(_m *TrustCenter) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenter.FieldUpdatedAt,
		toTerm: trustcenter.ByUpdatedAt,
		toCursor: func(_m *TrustCenter) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterOrderField", str)
	}
	return nil
}

// TrustCenterOrderField defines the ordering field of TrustCenter.
type TrustCenterOrderField struct {
	// Value extracts the ordering value from the given TrustCenter.
	Value    func(*TrustCenter) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenter.OrderOption
	toCursor func(*TrustCenter) Cursor
}

// TrustCenterOrder defines the ordering of TrustCenter.
type TrustCenterOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TrustCenterOrderField `json:"field"`
}

// DefaultTrustCenterOrder is the default ordering of TrustCenter.
var DefaultTrustCenterOrder = &TrustCenterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterOrderField{
		Value: func(_m *TrustCenter) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenter.FieldID,
		toTerm: trustcenter.ByID,
		toCursor: func(_m *TrustCenter) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenter into TrustCenterEdge.
func (_m *TrustCenter) ToEdge(order *TrustCenterOrder) *TrustCenterEdge {
	if order == nil {
		order = DefaultTrustCenterOrder
	}
	return &TrustCenterEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterComplianceEdge is the edge representation of TrustCenterCompliance.
type TrustCenterComplianceEdge struct {
	Node   *TrustCenterCompliance `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// TrustCenterComplianceConnection is the connection containing edges to TrustCenterCompliance.
type TrustCenterComplianceConnection struct {
	Edges      []*TrustCenterComplianceEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *TrustCenterComplianceConnection) build(nodes []*TrustCenterCompliance, pager *trustcentercompliancePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterCompliance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterCompliance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterCompliance {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterComplianceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterComplianceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterCompliancePaginateOption enables pagination customization.
type TrustCenterCompliancePaginateOption func(*trustcentercompliancePager) error

// WithTrustCenterComplianceOrder configures pagination ordering.
func WithTrustCenterComplianceOrder(order []*TrustCenterComplianceOrder) TrustCenterCompliancePaginateOption {
	return func(pager *trustcentercompliancePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterComplianceFilter configures pagination filter.
func WithTrustCenterComplianceFilter(filter func(*TrustCenterComplianceQuery) (*TrustCenterComplianceQuery, error)) TrustCenterCompliancePaginateOption {
	return func(pager *trustcentercompliancePager) error {
		if filter == nil {
			return errors.New("TrustCenterComplianceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentercompliancePager struct {
	reverse bool
	order   []*TrustCenterComplianceOrder
	filter  func(*TrustCenterComplianceQuery) (*TrustCenterComplianceQuery, error)
}

func newTrustCenterCompliancePager(opts []TrustCenterCompliancePaginateOption, reverse bool) (*trustcentercompliancePager, error) {
	pager := &trustcentercompliancePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentercompliancePager) applyFilter(query *TrustCenterComplianceQuery) (*TrustCenterComplianceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentercompliancePager) toCursor(_m *TrustCenterCompliance) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcentercompliancePager) applyCursors(query *TrustCenterComplianceQuery, after, before *Cursor) (*TrustCenterComplianceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterComplianceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentercompliancePager) applyOrder(query *TrustCenterComplianceQuery) *TrustCenterComplianceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterComplianceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterComplianceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentercompliancePager) orderExpr(query *TrustCenterComplianceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterComplianceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterCompliance.
func (_m *TrustCenterComplianceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterCompliancePaginateOption,
) (*TrustCenterComplianceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterCompliancePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterComplianceConnection{Edges: []*TrustCenterComplianceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterComplianceOrderFieldCreatedAt orders TrustCenterCompliance by created_at.
	TrustCenterComplianceOrderFieldCreatedAt = &TrustCenterComplianceOrderField{
		Value: func(_m *TrustCenterCompliance) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentercompliance.FieldCreatedAt,
		toTerm: trustcentercompliance.ByCreatedAt,
		toCursor: func(_m *TrustCenterCompliance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterComplianceOrderFieldUpdatedAt orders TrustCenterCompliance by updated_at.
	TrustCenterComplianceOrderFieldUpdatedAt = &TrustCenterComplianceOrderField{
		Value: func(_m *TrustCenterCompliance) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentercompliance.FieldUpdatedAt,
		toTerm: trustcentercompliance.ByUpdatedAt,
		toCursor: func(_m *TrustCenterCompliance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterComplianceOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterComplianceOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterComplianceOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterComplianceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterComplianceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterComplianceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterComplianceOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterComplianceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterComplianceOrderField", str)
	}
	return nil
}

// TrustCenterComplianceOrderField defines the ordering field of TrustCenterCompliance.
type TrustCenterComplianceOrderField struct {
	// Value extracts the ordering value from the given TrustCenterCompliance.
	Value    func(*TrustCenterCompliance) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentercompliance.OrderOption
	toCursor func(*TrustCenterCompliance) Cursor
}

// TrustCenterComplianceOrder defines the ordering of TrustCenterCompliance.
type TrustCenterComplianceOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *TrustCenterComplianceOrderField `json:"field"`
}

// DefaultTrustCenterComplianceOrder is the default ordering of TrustCenterCompliance.
var DefaultTrustCenterComplianceOrder = &TrustCenterComplianceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterComplianceOrderField{
		Value: func(_m *TrustCenterCompliance) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentercompliance.FieldID,
		toTerm: trustcentercompliance.ByID,
		toCursor: func(_m *TrustCenterCompliance) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterCompliance into TrustCenterComplianceEdge.
func (_m *TrustCenterCompliance) ToEdge(order *TrustCenterComplianceOrder) *TrustCenterComplianceEdge {
	if order == nil {
		order = DefaultTrustCenterComplianceOrder
	}
	return &TrustCenterComplianceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterComplianceHistoryEdge is the edge representation of TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryEdge struct {
	Node   *TrustCenterComplianceHistory `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// TrustCenterComplianceHistoryConnection is the connection containing edges to TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryConnection struct {
	Edges      []*TrustCenterComplianceHistoryEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *TrustCenterComplianceHistoryConnection) build(nodes []*TrustCenterComplianceHistory, pager *trustcentercompliancehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterComplianceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterComplianceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterComplianceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterComplianceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterComplianceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterComplianceHistoryPaginateOption enables pagination customization.
type TrustCenterComplianceHistoryPaginateOption func(*trustcentercompliancehistoryPager) error

// WithTrustCenterComplianceHistoryOrder configures pagination ordering.
func WithTrustCenterComplianceHistoryOrder(order *TrustCenterComplianceHistoryOrder) TrustCenterComplianceHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterComplianceHistoryOrder
	}
	o := *order
	return func(pager *trustcentercompliancehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterComplianceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterComplianceHistoryFilter configures pagination filter.
func WithTrustCenterComplianceHistoryFilter(filter func(*TrustCenterComplianceHistoryQuery) (*TrustCenterComplianceHistoryQuery, error)) TrustCenterComplianceHistoryPaginateOption {
	return func(pager *trustcentercompliancehistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterComplianceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentercompliancehistoryPager struct {
	reverse bool
	order   *TrustCenterComplianceHistoryOrder
	filter  func(*TrustCenterComplianceHistoryQuery) (*TrustCenterComplianceHistoryQuery, error)
}

func newTrustCenterComplianceHistoryPager(opts []TrustCenterComplianceHistoryPaginateOption, reverse bool) (*trustcentercompliancehistoryPager, error) {
	pager := &trustcentercompliancehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterComplianceHistoryOrder
	}
	return pager, nil
}

func (p *trustcentercompliancehistoryPager) applyFilter(query *TrustCenterComplianceHistoryQuery) (*TrustCenterComplianceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentercompliancehistoryPager) toCursor(_m *TrustCenterComplianceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcentercompliancehistoryPager) applyCursors(query *TrustCenterComplianceHistoryQuery, after, before *Cursor) (*TrustCenterComplianceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterComplianceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentercompliancehistoryPager) applyOrder(query *TrustCenterComplianceHistoryQuery) *TrustCenterComplianceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterComplianceHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterComplianceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentercompliancehistoryPager) orderExpr(query *TrustCenterComplianceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterComplianceHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterComplianceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterComplianceHistory.
func (_m *TrustCenterComplianceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterComplianceHistoryPaginateOption,
) (*TrustCenterComplianceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterComplianceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterComplianceHistoryConnection{Edges: []*TrustCenterComplianceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterComplianceHistoryOrderFieldHistoryTime orders TrustCenterComplianceHistory by history_time.
	TrustCenterComplianceHistoryOrderFieldHistoryTime = &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcentercompliancehistory.FieldHistoryTime,
		toTerm: trustcentercompliancehistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterComplianceHistoryOrderFieldCreatedAt orders TrustCenterComplianceHistory by created_at.
	TrustCenterComplianceHistoryOrderFieldCreatedAt = &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentercompliancehistory.FieldCreatedAt,
		toTerm: trustcentercompliancehistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterComplianceHistoryOrderFieldUpdatedAt orders TrustCenterComplianceHistory by updated_at.
	TrustCenterComplianceHistoryOrderFieldUpdatedAt = &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentercompliancehistory.FieldUpdatedAt,
		toTerm: trustcentercompliancehistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterComplianceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterComplianceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterComplianceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterComplianceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterComplianceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterComplianceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterComplianceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterComplianceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterComplianceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterComplianceHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterComplianceHistoryOrderField", str)
	}
	return nil
}

// TrustCenterComplianceHistoryOrderField defines the ordering field of TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterComplianceHistory.
	Value    func(*TrustCenterComplianceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentercompliancehistory.OrderOption
	toCursor func(*TrustCenterComplianceHistory) Cursor
}

// TrustCenterComplianceHistoryOrder defines the ordering of TrustCenterComplianceHistory.
type TrustCenterComplianceHistoryOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *TrustCenterComplianceHistoryOrderField `json:"field"`
}

// DefaultTrustCenterComplianceHistoryOrder is the default ordering of TrustCenterComplianceHistory.
var DefaultTrustCenterComplianceHistoryOrder = &TrustCenterComplianceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterComplianceHistoryOrderField{
		Value: func(_m *TrustCenterComplianceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentercompliancehistory.FieldID,
		toTerm: trustcentercompliancehistory.ByID,
		toCursor: func(_m *TrustCenterComplianceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterComplianceHistory into TrustCenterComplianceHistoryEdge.
func (_m *TrustCenterComplianceHistory) ToEdge(order *TrustCenterComplianceHistoryOrder) *TrustCenterComplianceHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterComplianceHistoryOrder
	}
	return &TrustCenterComplianceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterDocEdge is the edge representation of TrustCenterDoc.
type TrustCenterDocEdge struct {
	Node   *TrustCenterDoc `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// TrustCenterDocConnection is the connection containing edges to TrustCenterDoc.
type TrustCenterDocConnection struct {
	Edges      []*TrustCenterDocEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *TrustCenterDocConnection) build(nodes []*TrustCenterDoc, pager *trustcenterdocPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterDoc
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterDoc {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterDoc {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterDocEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterDocEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterDocPaginateOption enables pagination customization.
type TrustCenterDocPaginateOption func(*trustcenterdocPager) error

// WithTrustCenterDocOrder configures pagination ordering.
func WithTrustCenterDocOrder(order []*TrustCenterDocOrder) TrustCenterDocPaginateOption {
	return func(pager *trustcenterdocPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterDocFilter configures pagination filter.
func WithTrustCenterDocFilter(filter func(*TrustCenterDocQuery) (*TrustCenterDocQuery, error)) TrustCenterDocPaginateOption {
	return func(pager *trustcenterdocPager) error {
		if filter == nil {
			return errors.New("TrustCenterDocQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterdocPager struct {
	reverse bool
	order   []*TrustCenterDocOrder
	filter  func(*TrustCenterDocQuery) (*TrustCenterDocQuery, error)
}

func newTrustCenterDocPager(opts []TrustCenterDocPaginateOption, reverse bool) (*trustcenterdocPager, error) {
	pager := &trustcenterdocPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterdocPager) applyFilter(query *TrustCenterDocQuery) (*TrustCenterDocQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterdocPager) toCursor(_m *TrustCenterDoc) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterdocPager) applyCursors(query *TrustCenterDocQuery, after, before *Cursor) (*TrustCenterDocQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterDocOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterdocPager) applyOrder(query *TrustCenterDocQuery) *TrustCenterDocQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterDocOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterDocOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterdocPager) orderExpr(query *TrustCenterDocQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterDocOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterDoc.
func (_m *TrustCenterDocQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterDocPaginateOption,
) (*TrustCenterDocConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterDocPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterDocConnection{Edges: []*TrustCenterDocEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterDocOrderFieldCreatedAt orders TrustCenterDoc by created_at.
	TrustCenterDocOrderFieldCreatedAt = &TrustCenterDocOrderField{
		Value: func(_m *TrustCenterDoc) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterdoc.FieldCreatedAt,
		toTerm: trustcenterdoc.ByCreatedAt,
		toCursor: func(_m *TrustCenterDoc) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterDocOrderFieldUpdatedAt orders TrustCenterDoc by updated_at.
	TrustCenterDocOrderFieldUpdatedAt = &TrustCenterDocOrderField{
		Value: func(_m *TrustCenterDoc) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterdoc.FieldUpdatedAt,
		toTerm: trustcenterdoc.ByUpdatedAt,
		toCursor: func(_m *TrustCenterDoc) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterDocOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterDocOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterDocOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterDocOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterDocOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterDocOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterDocOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterDocOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterDocOrderField", str)
	}
	return nil
}

// TrustCenterDocOrderField defines the ordering field of TrustCenterDoc.
type TrustCenterDocOrderField struct {
	// Value extracts the ordering value from the given TrustCenterDoc.
	Value    func(*TrustCenterDoc) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterdoc.OrderOption
	toCursor func(*TrustCenterDoc) Cursor
}

// TrustCenterDocOrder defines the ordering of TrustCenterDoc.
type TrustCenterDocOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *TrustCenterDocOrderField `json:"field"`
}

// DefaultTrustCenterDocOrder is the default ordering of TrustCenterDoc.
var DefaultTrustCenterDocOrder = &TrustCenterDocOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterDocOrderField{
		Value: func(_m *TrustCenterDoc) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterdoc.FieldID,
		toTerm: trustcenterdoc.ByID,
		toCursor: func(_m *TrustCenterDoc) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterDoc into TrustCenterDocEdge.
func (_m *TrustCenterDoc) ToEdge(order *TrustCenterDocOrder) *TrustCenterDocEdge {
	if order == nil {
		order = DefaultTrustCenterDocOrder
	}
	return &TrustCenterDocEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterDocHistoryEdge is the edge representation of TrustCenterDocHistory.
type TrustCenterDocHistoryEdge struct {
	Node   *TrustCenterDocHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// TrustCenterDocHistoryConnection is the connection containing edges to TrustCenterDocHistory.
type TrustCenterDocHistoryConnection struct {
	Edges      []*TrustCenterDocHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *TrustCenterDocHistoryConnection) build(nodes []*TrustCenterDocHistory, pager *trustcenterdochistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterDocHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterDocHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterDocHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterDocHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterDocHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterDocHistoryPaginateOption enables pagination customization.
type TrustCenterDocHistoryPaginateOption func(*trustcenterdochistoryPager) error

// WithTrustCenterDocHistoryOrder configures pagination ordering.
func WithTrustCenterDocHistoryOrder(order *TrustCenterDocHistoryOrder) TrustCenterDocHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterDocHistoryOrder
	}
	o := *order
	return func(pager *trustcenterdochistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterDocHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterDocHistoryFilter configures pagination filter.
func WithTrustCenterDocHistoryFilter(filter func(*TrustCenterDocHistoryQuery) (*TrustCenterDocHistoryQuery, error)) TrustCenterDocHistoryPaginateOption {
	return func(pager *trustcenterdochistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterDocHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterdochistoryPager struct {
	reverse bool
	order   *TrustCenterDocHistoryOrder
	filter  func(*TrustCenterDocHistoryQuery) (*TrustCenterDocHistoryQuery, error)
}

func newTrustCenterDocHistoryPager(opts []TrustCenterDocHistoryPaginateOption, reverse bool) (*trustcenterdochistoryPager, error) {
	pager := &trustcenterdochistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterDocHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterdochistoryPager) applyFilter(query *TrustCenterDocHistoryQuery) (*TrustCenterDocHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterdochistoryPager) toCursor(_m *TrustCenterDocHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterdochistoryPager) applyCursors(query *TrustCenterDocHistoryQuery, after, before *Cursor) (*TrustCenterDocHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterDocHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterdochistoryPager) applyOrder(query *TrustCenterDocHistoryQuery) *TrustCenterDocHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterDocHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterDocHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterdochistoryPager) orderExpr(query *TrustCenterDocHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterDocHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterDocHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterDocHistory.
func (_m *TrustCenterDocHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterDocHistoryPaginateOption,
) (*TrustCenterDocHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterDocHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterDocHistoryConnection{Edges: []*TrustCenterDocHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterDocHistoryOrderFieldHistoryTime orders TrustCenterDocHistory by history_time.
	TrustCenterDocHistoryOrderFieldHistoryTime = &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterdochistory.FieldHistoryTime,
		toTerm: trustcenterdochistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterDocHistoryOrderFieldCreatedAt orders TrustCenterDocHistory by created_at.
	TrustCenterDocHistoryOrderFieldCreatedAt = &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterdochistory.FieldCreatedAt,
		toTerm: trustcenterdochistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterDocHistoryOrderFieldUpdatedAt orders TrustCenterDocHistory by updated_at.
	TrustCenterDocHistoryOrderFieldUpdatedAt = &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterdochistory.FieldUpdatedAt,
		toTerm: trustcenterdochistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterDocHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterDocHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterDocHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterDocHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterDocHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterDocHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterDocHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterDocHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterDocHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterDocHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterDocHistoryOrderField", str)
	}
	return nil
}

// TrustCenterDocHistoryOrderField defines the ordering field of TrustCenterDocHistory.
type TrustCenterDocHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterDocHistory.
	Value    func(*TrustCenterDocHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterdochistory.OrderOption
	toCursor func(*TrustCenterDocHistory) Cursor
}

// TrustCenterDocHistoryOrder defines the ordering of TrustCenterDocHistory.
type TrustCenterDocHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *TrustCenterDocHistoryOrderField `json:"field"`
}

// DefaultTrustCenterDocHistoryOrder is the default ordering of TrustCenterDocHistory.
var DefaultTrustCenterDocHistoryOrder = &TrustCenterDocHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterDocHistoryOrderField{
		Value: func(_m *TrustCenterDocHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterdochistory.FieldID,
		toTerm: trustcenterdochistory.ByID,
		toCursor: func(_m *TrustCenterDocHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterDocHistory into TrustCenterDocHistoryEdge.
func (_m *TrustCenterDocHistory) ToEdge(order *TrustCenterDocHistoryOrder) *TrustCenterDocHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterDocHistoryOrder
	}
	return &TrustCenterDocHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterHistoryEdge is the edge representation of TrustCenterHistory.
type TrustCenterHistoryEdge struct {
	Node   *TrustCenterHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// TrustCenterHistoryConnection is the connection containing edges to TrustCenterHistory.
type TrustCenterHistoryConnection struct {
	Edges      []*TrustCenterHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *TrustCenterHistoryConnection) build(nodes []*TrustCenterHistory, pager *trustcenterhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterHistoryPaginateOption enables pagination customization.
type TrustCenterHistoryPaginateOption func(*trustcenterhistoryPager) error

// WithTrustCenterHistoryOrder configures pagination ordering.
func WithTrustCenterHistoryOrder(order *TrustCenterHistoryOrder) TrustCenterHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterHistoryOrder
	}
	o := *order
	return func(pager *trustcenterhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterHistoryFilter configures pagination filter.
func WithTrustCenterHistoryFilter(filter func(*TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error)) TrustCenterHistoryPaginateOption {
	return func(pager *trustcenterhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterhistoryPager struct {
	reverse bool
	order   *TrustCenterHistoryOrder
	filter  func(*TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error)
}

func newTrustCenterHistoryPager(opts []TrustCenterHistoryPaginateOption, reverse bool) (*trustcenterhistoryPager, error) {
	pager := &trustcenterhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterhistoryPager) applyFilter(query *TrustCenterHistoryQuery) (*TrustCenterHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterhistoryPager) toCursor(_m *TrustCenterHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterhistoryPager) applyCursors(query *TrustCenterHistoryQuery, after, before *Cursor) (*TrustCenterHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterhistoryPager) applyOrder(query *TrustCenterHistoryQuery) *TrustCenterHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterhistoryPager) orderExpr(query *TrustCenterHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterHistory.
func (_m *TrustCenterHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterHistoryPaginateOption,
) (*TrustCenterHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterHistoryConnection{Edges: []*TrustCenterHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterHistoryOrderFieldHistoryTime orders TrustCenterHistory by history_time.
	TrustCenterHistoryOrderFieldHistoryTime = &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterhistory.FieldHistoryTime,
		toTerm: trustcenterhistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterHistoryOrderFieldCreatedAt orders TrustCenterHistory by created_at.
	TrustCenterHistoryOrderFieldCreatedAt = &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterhistory.FieldCreatedAt,
		toTerm: trustcenterhistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterHistoryOrderFieldUpdatedAt orders TrustCenterHistory by updated_at.
	TrustCenterHistoryOrderFieldUpdatedAt = &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterhistory.FieldUpdatedAt,
		toTerm: trustcenterhistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterHistoryOrderField", str)
	}
	return nil
}

// TrustCenterHistoryOrderField defines the ordering field of TrustCenterHistory.
type TrustCenterHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterHistory.
	Value    func(*TrustCenterHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterhistory.OrderOption
	toCursor func(*TrustCenterHistory) Cursor
}

// TrustCenterHistoryOrder defines the ordering of TrustCenterHistory.
type TrustCenterHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *TrustCenterHistoryOrderField `json:"field"`
}

// DefaultTrustCenterHistoryOrder is the default ordering of TrustCenterHistory.
var DefaultTrustCenterHistoryOrder = &TrustCenterHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterHistoryOrderField{
		Value: func(_m *TrustCenterHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterhistory.FieldID,
		toTerm: trustcenterhistory.ByID,
		toCursor: func(_m *TrustCenterHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterHistory into TrustCenterHistoryEdge.
func (_m *TrustCenterHistory) ToEdge(order *TrustCenterHistoryOrder) *TrustCenterHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterHistoryOrder
	}
	return &TrustCenterHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSettingEdge is the edge representation of TrustCenterSetting.
type TrustCenterSettingEdge struct {
	Node   *TrustCenterSetting `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// TrustCenterSettingConnection is the connection containing edges to TrustCenterSetting.
type TrustCenterSettingConnection struct {
	Edges      []*TrustCenterSettingEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *TrustCenterSettingConnection) build(nodes []*TrustCenterSetting, pager *trustcentersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSettingPaginateOption enables pagination customization.
type TrustCenterSettingPaginateOption func(*trustcentersettingPager) error

// WithTrustCenterSettingOrder configures pagination ordering.
func WithTrustCenterSettingOrder(order []*TrustCenterSettingOrder) TrustCenterSettingPaginateOption {
	return func(pager *trustcentersettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterSettingFilter configures pagination filter.
func WithTrustCenterSettingFilter(filter func(*TrustCenterSettingQuery) (*TrustCenterSettingQuery, error)) TrustCenterSettingPaginateOption {
	return func(pager *trustcentersettingPager) error {
		if filter == nil {
			return errors.New("TrustCenterSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersettingPager struct {
	reverse bool
	order   []*TrustCenterSettingOrder
	filter  func(*TrustCenterSettingQuery) (*TrustCenterSettingQuery, error)
}

func newTrustCenterSettingPager(opts []TrustCenterSettingPaginateOption, reverse bool) (*trustcentersettingPager, error) {
	pager := &trustcentersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentersettingPager) applyFilter(query *TrustCenterSettingQuery) (*TrustCenterSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersettingPager) toCursor(_m *TrustCenterSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcentersettingPager) applyCursors(query *TrustCenterSettingQuery, after, before *Cursor) (*TrustCenterSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentersettingPager) applyOrder(query *TrustCenterSettingQuery) *TrustCenterSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentersettingPager) orderExpr(query *TrustCenterSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSetting.
func (_m *TrustCenterSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSettingPaginateOption,
) (*TrustCenterSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSettingConnection{Edges: []*TrustCenterSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSettingOrderFieldCreatedAt orders TrustCenterSetting by created_at.
	TrustCenterSettingOrderFieldCreatedAt = &TrustCenterSettingOrderField{
		Value: func(_m *TrustCenterSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersetting.FieldCreatedAt,
		toTerm: trustcentersetting.ByCreatedAt,
		toCursor: func(_m *TrustCenterSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSettingOrderFieldUpdatedAt orders TrustCenterSetting by updated_at.
	TrustCenterSettingOrderFieldUpdatedAt = &TrustCenterSettingOrderField{
		Value: func(_m *TrustCenterSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersetting.FieldUpdatedAt,
		toTerm: trustcentersetting.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSettingOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSettingOrderField", str)
	}
	return nil
}

// TrustCenterSettingOrderField defines the ordering field of TrustCenterSetting.
type TrustCenterSettingOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSetting.
	Value    func(*TrustCenterSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersetting.OrderOption
	toCursor func(*TrustCenterSetting) Cursor
}

// TrustCenterSettingOrder defines the ordering of TrustCenterSetting.
type TrustCenterSettingOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *TrustCenterSettingOrderField `json:"field"`
}

// DefaultTrustCenterSettingOrder is the default ordering of TrustCenterSetting.
var DefaultTrustCenterSettingOrder = &TrustCenterSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSettingOrderField{
		Value: func(_m *TrustCenterSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersetting.FieldID,
		toTerm: trustcentersetting.ByID,
		toCursor: func(_m *TrustCenterSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSetting into TrustCenterSettingEdge.
func (_m *TrustCenterSetting) ToEdge(order *TrustCenterSettingOrder) *TrustCenterSettingEdge {
	if order == nil {
		order = DefaultTrustCenterSettingOrder
	}
	return &TrustCenterSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSettingHistoryEdge is the edge representation of TrustCenterSettingHistory.
type TrustCenterSettingHistoryEdge struct {
	Node   *TrustCenterSettingHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// TrustCenterSettingHistoryConnection is the connection containing edges to TrustCenterSettingHistory.
type TrustCenterSettingHistoryConnection struct {
	Edges      []*TrustCenterSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *TrustCenterSettingHistoryConnection) build(nodes []*TrustCenterSettingHistory, pager *trustcentersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSettingHistoryPaginateOption enables pagination customization.
type TrustCenterSettingHistoryPaginateOption func(*trustcentersettinghistoryPager) error

// WithTrustCenterSettingHistoryOrder configures pagination ordering.
func WithTrustCenterSettingHistoryOrder(order *TrustCenterSettingHistoryOrder) TrustCenterSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterSettingHistoryOrder
	}
	o := *order
	return func(pager *trustcentersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterSettingHistoryFilter configures pagination filter.
func WithTrustCenterSettingHistoryFilter(filter func(*TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error)) TrustCenterSettingHistoryPaginateOption {
	return func(pager *trustcentersettinghistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersettinghistoryPager struct {
	reverse bool
	order   *TrustCenterSettingHistoryOrder
	filter  func(*TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error)
}

func newTrustCenterSettingHistoryPager(opts []TrustCenterSettingHistoryPaginateOption, reverse bool) (*trustcentersettinghistoryPager, error) {
	pager := &trustcentersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterSettingHistoryOrder
	}
	return pager, nil
}

func (p *trustcentersettinghistoryPager) applyFilter(query *TrustCenterSettingHistoryQuery) (*TrustCenterSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersettinghistoryPager) toCursor(_m *TrustCenterSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcentersettinghistoryPager) applyCursors(query *TrustCenterSettingHistoryQuery, after, before *Cursor) (*TrustCenterSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentersettinghistoryPager) applyOrder(query *TrustCenterSettingHistoryQuery) *TrustCenterSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterSettingHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentersettinghistoryPager) orderExpr(query *TrustCenterSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSettingHistory.
func (_m *TrustCenterSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSettingHistoryPaginateOption,
) (*TrustCenterSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSettingHistoryConnection{Edges: []*TrustCenterSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSettingHistoryOrderFieldHistoryTime orders TrustCenterSettingHistory by history_time.
	TrustCenterSettingHistoryOrderFieldHistoryTime = &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcentersettinghistory.FieldHistoryTime,
		toTerm: trustcentersettinghistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterSettingHistoryOrderFieldCreatedAt orders TrustCenterSettingHistory by created_at.
	TrustCenterSettingHistoryOrderFieldCreatedAt = &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersettinghistory.FieldCreatedAt,
		toTerm: trustcentersettinghistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSettingHistoryOrderFieldUpdatedAt orders TrustCenterSettingHistory by updated_at.
	TrustCenterSettingHistoryOrderFieldUpdatedAt = &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersettinghistory.FieldUpdatedAt,
		toTerm: trustcentersettinghistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSettingHistoryOrderField", str)
	}
	return nil
}

// TrustCenterSettingHistoryOrderField defines the ordering field of TrustCenterSettingHistory.
type TrustCenterSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSettingHistory.
	Value    func(*TrustCenterSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersettinghistory.OrderOption
	toCursor func(*TrustCenterSettingHistory) Cursor
}

// TrustCenterSettingHistoryOrder defines the ordering of TrustCenterSettingHistory.
type TrustCenterSettingHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *TrustCenterSettingHistoryOrderField `json:"field"`
}

// DefaultTrustCenterSettingHistoryOrder is the default ordering of TrustCenterSettingHistory.
var DefaultTrustCenterSettingHistoryOrder = &TrustCenterSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSettingHistoryOrderField{
		Value: func(_m *TrustCenterSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersettinghistory.FieldID,
		toTerm: trustcentersettinghistory.ByID,
		toCursor: func(_m *TrustCenterSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSettingHistory into TrustCenterSettingHistoryEdge.
func (_m *TrustCenterSettingHistory) ToEdge(order *TrustCenterSettingHistoryOrder) *TrustCenterSettingHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterSettingHistoryOrder
	}
	return &TrustCenterSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSubprocessorEdge is the edge representation of TrustCenterSubprocessor.
type TrustCenterSubprocessorEdge struct {
	Node   *TrustCenterSubprocessor `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// TrustCenterSubprocessorConnection is the connection containing edges to TrustCenterSubprocessor.
type TrustCenterSubprocessorConnection struct {
	Edges      []*TrustCenterSubprocessorEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *TrustCenterSubprocessorConnection) build(nodes []*TrustCenterSubprocessor, pager *trustcentersubprocessorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSubprocessor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSubprocessor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSubprocessor {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSubprocessorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSubprocessorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSubprocessorPaginateOption enables pagination customization.
type TrustCenterSubprocessorPaginateOption func(*trustcentersubprocessorPager) error

// WithTrustCenterSubprocessorOrder configures pagination ordering.
func WithTrustCenterSubprocessorOrder(order []*TrustCenterSubprocessorOrder) TrustCenterSubprocessorPaginateOption {
	return func(pager *trustcentersubprocessorPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterSubprocessorFilter configures pagination filter.
func WithTrustCenterSubprocessorFilter(filter func(*TrustCenterSubprocessorQuery) (*TrustCenterSubprocessorQuery, error)) TrustCenterSubprocessorPaginateOption {
	return func(pager *trustcentersubprocessorPager) error {
		if filter == nil {
			return errors.New("TrustCenterSubprocessorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersubprocessorPager struct {
	reverse bool
	order   []*TrustCenterSubprocessorOrder
	filter  func(*TrustCenterSubprocessorQuery) (*TrustCenterSubprocessorQuery, error)
}

func newTrustCenterSubprocessorPager(opts []TrustCenterSubprocessorPaginateOption, reverse bool) (*trustcentersubprocessorPager, error) {
	pager := &trustcentersubprocessorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentersubprocessorPager) applyFilter(query *TrustCenterSubprocessorQuery) (*TrustCenterSubprocessorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersubprocessorPager) toCursor(_m *TrustCenterSubprocessor) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcentersubprocessorPager) applyCursors(query *TrustCenterSubprocessorQuery, after, before *Cursor) (*TrustCenterSubprocessorQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterSubprocessorOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentersubprocessorPager) applyOrder(query *TrustCenterSubprocessorQuery) *TrustCenterSubprocessorQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterSubprocessorOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterSubprocessorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentersubprocessorPager) orderExpr(query *TrustCenterSubprocessorQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterSubprocessorOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSubprocessor.
func (_m *TrustCenterSubprocessorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSubprocessorPaginateOption,
) (*TrustCenterSubprocessorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSubprocessorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSubprocessorConnection{Edges: []*TrustCenterSubprocessorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSubprocessorOrderFieldCreatedAt orders TrustCenterSubprocessor by created_at.
	TrustCenterSubprocessorOrderFieldCreatedAt = &TrustCenterSubprocessorOrderField{
		Value: func(_m *TrustCenterSubprocessor) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersubprocessor.FieldCreatedAt,
		toTerm: trustcentersubprocessor.ByCreatedAt,
		toCursor: func(_m *TrustCenterSubprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSubprocessorOrderFieldUpdatedAt orders TrustCenterSubprocessor by updated_at.
	TrustCenterSubprocessorOrderFieldUpdatedAt = &TrustCenterSubprocessorOrderField{
		Value: func(_m *TrustCenterSubprocessor) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersubprocessor.FieldUpdatedAt,
		toTerm: trustcentersubprocessor.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSubprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSubprocessorOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSubprocessorOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSubprocessorOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSubprocessorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSubprocessorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSubprocessorOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterSubprocessorOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSubprocessorOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSubprocessorOrderField", str)
	}
	return nil
}

// TrustCenterSubprocessorOrderField defines the ordering field of TrustCenterSubprocessor.
type TrustCenterSubprocessorOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSubprocessor.
	Value    func(*TrustCenterSubprocessor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersubprocessor.OrderOption
	toCursor func(*TrustCenterSubprocessor) Cursor
}

// TrustCenterSubprocessorOrder defines the ordering of TrustCenterSubprocessor.
type TrustCenterSubprocessorOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *TrustCenterSubprocessorOrderField `json:"field"`
}

// DefaultTrustCenterSubprocessorOrder is the default ordering of TrustCenterSubprocessor.
var DefaultTrustCenterSubprocessorOrder = &TrustCenterSubprocessorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSubprocessorOrderField{
		Value: func(_m *TrustCenterSubprocessor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersubprocessor.FieldID,
		toTerm: trustcentersubprocessor.ByID,
		toCursor: func(_m *TrustCenterSubprocessor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSubprocessor into TrustCenterSubprocessorEdge.
func (_m *TrustCenterSubprocessor) ToEdge(order *TrustCenterSubprocessorOrder) *TrustCenterSubprocessorEdge {
	if order == nil {
		order = DefaultTrustCenterSubprocessorOrder
	}
	return &TrustCenterSubprocessorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSubprocessorHistoryEdge is the edge representation of TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryEdge struct {
	Node   *TrustCenterSubprocessorHistory `json:"node"`
	Cursor Cursor                          `json:"cursor"`
}

// TrustCenterSubprocessorHistoryConnection is the connection containing edges to TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryConnection struct {
	Edges      []*TrustCenterSubprocessorHistoryEdge `json:"edges"`
	PageInfo   PageInfo                              `json:"pageInfo"`
	TotalCount int                                   `json:"totalCount"`
}

func (c *TrustCenterSubprocessorHistoryConnection) build(nodes []*TrustCenterSubprocessorHistory, pager *trustcentersubprocessorhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSubprocessorHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSubprocessorHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSubprocessorHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSubprocessorHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSubprocessorHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSubprocessorHistoryPaginateOption enables pagination customization.
type TrustCenterSubprocessorHistoryPaginateOption func(*trustcentersubprocessorhistoryPager) error

// WithTrustCenterSubprocessorHistoryOrder configures pagination ordering.
func WithTrustCenterSubprocessorHistoryOrder(order *TrustCenterSubprocessorHistoryOrder) TrustCenterSubprocessorHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterSubprocessorHistoryOrder
	}
	o := *order
	return func(pager *trustcentersubprocessorhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterSubprocessorHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterSubprocessorHistoryFilter configures pagination filter.
func WithTrustCenterSubprocessorHistoryFilter(filter func(*TrustCenterSubprocessorHistoryQuery) (*TrustCenterSubprocessorHistoryQuery, error)) TrustCenterSubprocessorHistoryPaginateOption {
	return func(pager *trustcentersubprocessorhistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterSubprocessorHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersubprocessorhistoryPager struct {
	reverse bool
	order   *TrustCenterSubprocessorHistoryOrder
	filter  func(*TrustCenterSubprocessorHistoryQuery) (*TrustCenterSubprocessorHistoryQuery, error)
}

func newTrustCenterSubprocessorHistoryPager(opts []TrustCenterSubprocessorHistoryPaginateOption, reverse bool) (*trustcentersubprocessorhistoryPager, error) {
	pager := &trustcentersubprocessorhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterSubprocessorHistoryOrder
	}
	return pager, nil
}

func (p *trustcentersubprocessorhistoryPager) applyFilter(query *TrustCenterSubprocessorHistoryQuery) (*TrustCenterSubprocessorHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersubprocessorhistoryPager) toCursor(_m *TrustCenterSubprocessorHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcentersubprocessorhistoryPager) applyCursors(query *TrustCenterSubprocessorHistoryQuery, after, before *Cursor) (*TrustCenterSubprocessorHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterSubprocessorHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcentersubprocessorhistoryPager) applyOrder(query *TrustCenterSubprocessorHistoryQuery) *TrustCenterSubprocessorHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterSubprocessorHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterSubprocessorHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcentersubprocessorhistoryPager) orderExpr(query *TrustCenterSubprocessorHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterSubprocessorHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterSubprocessorHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSubprocessorHistory.
func (_m *TrustCenterSubprocessorHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSubprocessorHistoryPaginateOption,
) (*TrustCenterSubprocessorHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSubprocessorHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSubprocessorHistoryConnection{Edges: []*TrustCenterSubprocessorHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSubprocessorHistoryOrderFieldHistoryTime orders TrustCenterSubprocessorHistory by history_time.
	TrustCenterSubprocessorHistoryOrderFieldHistoryTime = &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcentersubprocessorhistory.FieldHistoryTime,
		toTerm: trustcentersubprocessorhistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterSubprocessorHistoryOrderFieldCreatedAt orders TrustCenterSubprocessorHistory by created_at.
	TrustCenterSubprocessorHistoryOrderFieldCreatedAt = &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersubprocessorhistory.FieldCreatedAt,
		toTerm: trustcentersubprocessorhistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSubprocessorHistoryOrderFieldUpdatedAt orders TrustCenterSubprocessorHistory by updated_at.
	TrustCenterSubprocessorHistoryOrderFieldUpdatedAt = &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersubprocessorhistory.FieldUpdatedAt,
		toTerm: trustcentersubprocessorhistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSubprocessorHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSubprocessorHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterSubprocessorHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSubprocessorHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSubprocessorHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSubprocessorHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSubprocessorHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterSubprocessorHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterSubprocessorHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSubprocessorHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSubprocessorHistoryOrderField", str)
	}
	return nil
}

// TrustCenterSubprocessorHistoryOrderField defines the ordering field of TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSubprocessorHistory.
	Value    func(*TrustCenterSubprocessorHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersubprocessorhistory.OrderOption
	toCursor func(*TrustCenterSubprocessorHistory) Cursor
}

// TrustCenterSubprocessorHistoryOrder defines the ordering of TrustCenterSubprocessorHistory.
type TrustCenterSubprocessorHistoryOrder struct {
	Direction OrderDirection                            `json:"direction"`
	Field     *TrustCenterSubprocessorHistoryOrderField `json:"field"`
}

// DefaultTrustCenterSubprocessorHistoryOrder is the default ordering of TrustCenterSubprocessorHistory.
var DefaultTrustCenterSubprocessorHistoryOrder = &TrustCenterSubprocessorHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSubprocessorHistoryOrderField{
		Value: func(_m *TrustCenterSubprocessorHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersubprocessorhistory.FieldID,
		toTerm: trustcentersubprocessorhistory.ByID,
		toCursor: func(_m *TrustCenterSubprocessorHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSubprocessorHistory into TrustCenterSubprocessorHistoryEdge.
func (_m *TrustCenterSubprocessorHistory) ToEdge(order *TrustCenterSubprocessorHistoryOrder) *TrustCenterSubprocessorHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterSubprocessorHistoryOrder
	}
	return &TrustCenterSubprocessorHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterWatermarkConfigEdge is the edge representation of TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigEdge struct {
	Node   *TrustCenterWatermarkConfig `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// TrustCenterWatermarkConfigConnection is the connection containing edges to TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigConnection struct {
	Edges      []*TrustCenterWatermarkConfigEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *TrustCenterWatermarkConfigConnection) build(nodes []*TrustCenterWatermarkConfig, pager *trustcenterwatermarkconfigPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterWatermarkConfig
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterWatermarkConfig {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterWatermarkConfig {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterWatermarkConfigEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterWatermarkConfigEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterWatermarkConfigPaginateOption enables pagination customization.
type TrustCenterWatermarkConfigPaginateOption func(*trustcenterwatermarkconfigPager) error

// WithTrustCenterWatermarkConfigOrder configures pagination ordering.
func WithTrustCenterWatermarkConfigOrder(order []*TrustCenterWatermarkConfigOrder) TrustCenterWatermarkConfigPaginateOption {
	return func(pager *trustcenterwatermarkconfigPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterWatermarkConfigFilter configures pagination filter.
func WithTrustCenterWatermarkConfigFilter(filter func(*TrustCenterWatermarkConfigQuery) (*TrustCenterWatermarkConfigQuery, error)) TrustCenterWatermarkConfigPaginateOption {
	return func(pager *trustcenterwatermarkconfigPager) error {
		if filter == nil {
			return errors.New("TrustCenterWatermarkConfigQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterwatermarkconfigPager struct {
	reverse bool
	order   []*TrustCenterWatermarkConfigOrder
	filter  func(*TrustCenterWatermarkConfigQuery) (*TrustCenterWatermarkConfigQuery, error)
}

func newTrustCenterWatermarkConfigPager(opts []TrustCenterWatermarkConfigPaginateOption, reverse bool) (*trustcenterwatermarkconfigPager, error) {
	pager := &trustcenterwatermarkconfigPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterwatermarkconfigPager) applyFilter(query *TrustCenterWatermarkConfigQuery) (*TrustCenterWatermarkConfigQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterwatermarkconfigPager) toCursor(_m *TrustCenterWatermarkConfig) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterwatermarkconfigPager) applyCursors(query *TrustCenterWatermarkConfigQuery, after, before *Cursor) (*TrustCenterWatermarkConfigQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterWatermarkConfigOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterwatermarkconfigPager) applyOrder(query *TrustCenterWatermarkConfigQuery) *TrustCenterWatermarkConfigQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterWatermarkConfigOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterWatermarkConfigOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterwatermarkconfigPager) orderExpr(query *TrustCenterWatermarkConfigQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterWatermarkConfigOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterWatermarkConfig.
func (_m *TrustCenterWatermarkConfigQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterWatermarkConfigPaginateOption,
) (*TrustCenterWatermarkConfigConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterWatermarkConfigPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterWatermarkConfigConnection{Edges: []*TrustCenterWatermarkConfigEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterWatermarkConfigOrderFieldCreatedAt orders TrustCenterWatermarkConfig by created_at.
	TrustCenterWatermarkConfigOrderFieldCreatedAt = &TrustCenterWatermarkConfigOrderField{
		Value: func(_m *TrustCenterWatermarkConfig) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterwatermarkconfig.FieldCreatedAt,
		toTerm: trustcenterwatermarkconfig.ByCreatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfig) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterWatermarkConfigOrderFieldUpdatedAt orders TrustCenterWatermarkConfig by updated_at.
	TrustCenterWatermarkConfigOrderFieldUpdatedAt = &TrustCenterWatermarkConfigOrderField{
		Value: func(_m *TrustCenterWatermarkConfig) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterwatermarkconfig.FieldUpdatedAt,
		toTerm: trustcenterwatermarkconfig.ByUpdatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfig) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterWatermarkConfigOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterWatermarkConfigOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterWatermarkConfigOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterWatermarkConfigOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterWatermarkConfigOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterWatermarkConfigOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterWatermarkConfigOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterWatermarkConfigOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterWatermarkConfigOrderField", str)
	}
	return nil
}

// TrustCenterWatermarkConfigOrderField defines the ordering field of TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigOrderField struct {
	// Value extracts the ordering value from the given TrustCenterWatermarkConfig.
	Value    func(*TrustCenterWatermarkConfig) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterwatermarkconfig.OrderOption
	toCursor func(*TrustCenterWatermarkConfig) Cursor
}

// TrustCenterWatermarkConfigOrder defines the ordering of TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *TrustCenterWatermarkConfigOrderField `json:"field"`
}

// DefaultTrustCenterWatermarkConfigOrder is the default ordering of TrustCenterWatermarkConfig.
var DefaultTrustCenterWatermarkConfigOrder = &TrustCenterWatermarkConfigOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterWatermarkConfigOrderField{
		Value: func(_m *TrustCenterWatermarkConfig) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterwatermarkconfig.FieldID,
		toTerm: trustcenterwatermarkconfig.ByID,
		toCursor: func(_m *TrustCenterWatermarkConfig) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterWatermarkConfig into TrustCenterWatermarkConfigEdge.
func (_m *TrustCenterWatermarkConfig) ToEdge(order *TrustCenterWatermarkConfigOrder) *TrustCenterWatermarkConfigEdge {
	if order == nil {
		order = DefaultTrustCenterWatermarkConfigOrder
	}
	return &TrustCenterWatermarkConfigEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterWatermarkConfigHistoryEdge is the edge representation of TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryEdge struct {
	Node   *TrustCenterWatermarkConfigHistory `json:"node"`
	Cursor Cursor                             `json:"cursor"`
}

// TrustCenterWatermarkConfigHistoryConnection is the connection containing edges to TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryConnection struct {
	Edges      []*TrustCenterWatermarkConfigHistoryEdge `json:"edges"`
	PageInfo   PageInfo                                 `json:"pageInfo"`
	TotalCount int                                      `json:"totalCount"`
}

func (c *TrustCenterWatermarkConfigHistoryConnection) build(nodes []*TrustCenterWatermarkConfigHistory, pager *trustcenterwatermarkconfighistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterWatermarkConfigHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterWatermarkConfigHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterWatermarkConfigHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterWatermarkConfigHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterWatermarkConfigHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterWatermarkConfigHistoryPaginateOption enables pagination customization.
type TrustCenterWatermarkConfigHistoryPaginateOption func(*trustcenterwatermarkconfighistoryPager) error

// WithTrustCenterWatermarkConfigHistoryOrder configures pagination ordering.
func WithTrustCenterWatermarkConfigHistoryOrder(order *TrustCenterWatermarkConfigHistoryOrder) TrustCenterWatermarkConfigHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustCenterWatermarkConfigHistoryOrder
	}
	o := *order
	return func(pager *trustcenterwatermarkconfighistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustCenterWatermarkConfigHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustCenterWatermarkConfigHistoryFilter configures pagination filter.
func WithTrustCenterWatermarkConfigHistoryFilter(filter func(*TrustCenterWatermarkConfigHistoryQuery) (*TrustCenterWatermarkConfigHistoryQuery, error)) TrustCenterWatermarkConfigHistoryPaginateOption {
	return func(pager *trustcenterwatermarkconfighistoryPager) error {
		if filter == nil {
			return errors.New("TrustCenterWatermarkConfigHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterwatermarkconfighistoryPager struct {
	reverse bool
	order   *TrustCenterWatermarkConfigHistoryOrder
	filter  func(*TrustCenterWatermarkConfigHistoryQuery) (*TrustCenterWatermarkConfigHistoryQuery, error)
}

func newTrustCenterWatermarkConfigHistoryPager(opts []TrustCenterWatermarkConfigHistoryPaginateOption, reverse bool) (*trustcenterwatermarkconfighistoryPager, error) {
	pager := &trustcenterwatermarkconfighistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustCenterWatermarkConfigHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterwatermarkconfighistoryPager) applyFilter(query *TrustCenterWatermarkConfigHistoryQuery) (*TrustCenterWatermarkConfigHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterwatermarkconfighistoryPager) toCursor(_m *TrustCenterWatermarkConfigHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterwatermarkconfighistoryPager) applyCursors(query *TrustCenterWatermarkConfigHistoryQuery, after, before *Cursor) (*TrustCenterWatermarkConfigHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustCenterWatermarkConfigHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterwatermarkconfighistoryPager) applyOrder(query *TrustCenterWatermarkConfigHistoryQuery) *TrustCenterWatermarkConfigHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustCenterWatermarkConfigHistoryOrder.Field {
		query = query.Order(DefaultTrustCenterWatermarkConfigHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterwatermarkconfighistoryPager) orderExpr(query *TrustCenterWatermarkConfigHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustCenterWatermarkConfigHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustCenterWatermarkConfigHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterWatermarkConfigHistory.
func (_m *TrustCenterWatermarkConfigHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterWatermarkConfigHistoryPaginateOption,
) (*TrustCenterWatermarkConfigHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterWatermarkConfigHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterWatermarkConfigHistoryConnection{Edges: []*TrustCenterWatermarkConfigHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime orders TrustCenterWatermarkConfigHistory by history_time.
	TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime = &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterwatermarkconfighistory.FieldHistoryTime,
		toTerm: trustcenterwatermarkconfighistory.ByHistoryTime,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt orders TrustCenterWatermarkConfigHistory by created_at.
	TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt = &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterwatermarkconfighistory.FieldCreatedAt,
		toTerm: trustcenterwatermarkconfighistory.ByCreatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt orders TrustCenterWatermarkConfigHistory by updated_at.
	TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt = &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterwatermarkconfighistory.FieldUpdatedAt,
		toTerm: trustcenterwatermarkconfighistory.ByUpdatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterWatermarkConfigHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterWatermarkConfigHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterWatermarkConfigHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterWatermarkConfigHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterWatermarkConfigHistoryOrderField", str)
	}
	return nil
}

// TrustCenterWatermarkConfigHistoryOrderField defines the ordering field of TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustCenterWatermarkConfigHistory.
	Value    func(*TrustCenterWatermarkConfigHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterwatermarkconfighistory.OrderOption
	toCursor func(*TrustCenterWatermarkConfigHistory) Cursor
}

// TrustCenterWatermarkConfigHistoryOrder defines the ordering of TrustCenterWatermarkConfigHistory.
type TrustCenterWatermarkConfigHistoryOrder struct {
	Direction OrderDirection                               `json:"direction"`
	Field     *TrustCenterWatermarkConfigHistoryOrderField `json:"field"`
}

// DefaultTrustCenterWatermarkConfigHistoryOrder is the default ordering of TrustCenterWatermarkConfigHistory.
var DefaultTrustCenterWatermarkConfigHistoryOrder = &TrustCenterWatermarkConfigHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterWatermarkConfigHistoryOrderField{
		Value: func(_m *TrustCenterWatermarkConfigHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterwatermarkconfighistory.FieldID,
		toTerm: trustcenterwatermarkconfighistory.ByID,
		toCursor: func(_m *TrustCenterWatermarkConfigHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterWatermarkConfigHistory into TrustCenterWatermarkConfigHistoryEdge.
func (_m *TrustCenterWatermarkConfigHistory) ToEdge(order *TrustCenterWatermarkConfigHistoryOrder) *TrustCenterWatermarkConfigHistoryEdge {
	if order == nil {
		order = DefaultTrustCenterWatermarkConfigHistoryOrder
	}
	return &TrustCenterWatermarkConfigHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustcenterEntityEdge is the edge representation of TrustcenterEntity.
type TrustcenterEntityEdge struct {
	Node   *TrustcenterEntity `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// TrustcenterEntityConnection is the connection containing edges to TrustcenterEntity.
type TrustcenterEntityConnection struct {
	Edges      []*TrustcenterEntityEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *TrustcenterEntityConnection) build(nodes []*TrustcenterEntity, pager *trustcenterentityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustcenterEntity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustcenterEntity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustcenterEntity {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustcenterEntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustcenterEntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustcenterEntityPaginateOption enables pagination customization.
type TrustcenterEntityPaginateOption func(*trustcenterentityPager) error

// WithTrustcenterEntityOrder configures pagination ordering.
func WithTrustcenterEntityOrder(order []*TrustcenterEntityOrder) TrustcenterEntityPaginateOption {
	return func(pager *trustcenterentityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustcenterEntityFilter configures pagination filter.
func WithTrustcenterEntityFilter(filter func(*TrustcenterEntityQuery) (*TrustcenterEntityQuery, error)) TrustcenterEntityPaginateOption {
	return func(pager *trustcenterentityPager) error {
		if filter == nil {
			return errors.New("TrustcenterEntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterentityPager struct {
	reverse bool
	order   []*TrustcenterEntityOrder
	filter  func(*TrustcenterEntityQuery) (*TrustcenterEntityQuery, error)
}

func newTrustcenterEntityPager(opts []TrustcenterEntityPaginateOption, reverse bool) (*trustcenterentityPager, error) {
	pager := &trustcenterentityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterentityPager) applyFilter(query *TrustcenterEntityQuery) (*TrustcenterEntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterentityPager) toCursor(_m *TrustcenterEntity) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterentityPager) applyCursors(query *TrustcenterEntityQuery, after, before *Cursor) (*TrustcenterEntityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustcenterEntityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterentityPager) applyOrder(query *TrustcenterEntityQuery) *TrustcenterEntityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustcenterEntityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustcenterEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterentityPager) orderExpr(query *TrustcenterEntityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustcenterEntityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustcenterEntity.
func (_m *TrustcenterEntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustcenterEntityPaginateOption,
) (*TrustcenterEntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustcenterEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustcenterEntityConnection{Edges: []*TrustcenterEntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustcenterEntityOrderFieldCreatedAt orders TrustcenterEntity by created_at.
	TrustcenterEntityOrderFieldCreatedAt = &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterentity.FieldCreatedAt,
		toTerm: trustcenterentity.ByCreatedAt,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustcenterEntityOrderFieldUpdatedAt orders TrustcenterEntity by updated_at.
	TrustcenterEntityOrderFieldUpdatedAt = &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterentity.FieldUpdatedAt,
		toTerm: trustcenterentity.ByUpdatedAt,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TrustcenterEntityOrderFieldName orders TrustcenterEntity by name.
	TrustcenterEntityOrderFieldName = &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.Name, nil
		},
		column: trustcenterentity.FieldName,
		toTerm: trustcenterentity.ByName,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustcenterEntityOrderField) String() string {
	var str string
	switch f.column {
	case TrustcenterEntityOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustcenterEntityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TrustcenterEntityOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustcenterEntityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustcenterEntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustcenterEntityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustcenterEntityOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustcenterEntityOrderFieldUpdatedAt
	case "NAME":
		*f = *TrustcenterEntityOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TrustcenterEntityOrderField", str)
	}
	return nil
}

// TrustcenterEntityOrderField defines the ordering field of TrustcenterEntity.
type TrustcenterEntityOrderField struct {
	// Value extracts the ordering value from the given TrustcenterEntity.
	Value    func(*TrustcenterEntity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterentity.OrderOption
	toCursor func(*TrustcenterEntity) Cursor
}

// TrustcenterEntityOrder defines the ordering of TrustcenterEntity.
type TrustcenterEntityOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *TrustcenterEntityOrderField `json:"field"`
}

// DefaultTrustcenterEntityOrder is the default ordering of TrustcenterEntity.
var DefaultTrustcenterEntityOrder = &TrustcenterEntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterentity.FieldID,
		toTerm: trustcenterentity.ByID,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustcenterEntity into TrustcenterEntityEdge.
func (_m *TrustcenterEntity) ToEdge(order *TrustcenterEntityOrder) *TrustcenterEntityEdge {
	if order == nil {
		order = DefaultTrustcenterEntityOrder
	}
	return &TrustcenterEntityEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustcenterEntityHistoryEdge is the edge representation of TrustcenterEntityHistory.
type TrustcenterEntityHistoryEdge struct {
	Node   *TrustcenterEntityHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// TrustcenterEntityHistoryConnection is the connection containing edges to TrustcenterEntityHistory.
type TrustcenterEntityHistoryConnection struct {
	Edges      []*TrustcenterEntityHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *TrustcenterEntityHistoryConnection) build(nodes []*TrustcenterEntityHistory, pager *trustcenterentityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustcenterEntityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustcenterEntityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustcenterEntityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustcenterEntityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustcenterEntityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustcenterEntityHistoryPaginateOption enables pagination customization.
type TrustcenterEntityHistoryPaginateOption func(*trustcenterentityhistoryPager) error

// WithTrustcenterEntityHistoryOrder configures pagination ordering.
func WithTrustcenterEntityHistoryOrder(order *TrustcenterEntityHistoryOrder) TrustcenterEntityHistoryPaginateOption {
	if order == nil {
		order = DefaultTrustcenterEntityHistoryOrder
	}
	o := *order
	return func(pager *trustcenterentityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrustcenterEntityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrustcenterEntityHistoryFilter configures pagination filter.
func WithTrustcenterEntityHistoryFilter(filter func(*TrustcenterEntityHistoryQuery) (*TrustcenterEntityHistoryQuery, error)) TrustcenterEntityHistoryPaginateOption {
	return func(pager *trustcenterentityhistoryPager) error {
		if filter == nil {
			return errors.New("TrustcenterEntityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterentityhistoryPager struct {
	reverse bool
	order   *TrustcenterEntityHistoryOrder
	filter  func(*TrustcenterEntityHistoryQuery) (*TrustcenterEntityHistoryQuery, error)
}

func newTrustcenterEntityHistoryPager(opts []TrustcenterEntityHistoryPaginateOption, reverse bool) (*trustcenterentityhistoryPager, error) {
	pager := &trustcenterentityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrustcenterEntityHistoryOrder
	}
	return pager, nil
}

func (p *trustcenterentityhistoryPager) applyFilter(query *TrustcenterEntityHistoryQuery) (*TrustcenterEntityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterentityhistoryPager) toCursor(_m *TrustcenterEntityHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *trustcenterentityhistoryPager) applyCursors(query *TrustcenterEntityHistoryQuery, after, before *Cursor) (*TrustcenterEntityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrustcenterEntityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trustcenterentityhistoryPager) applyOrder(query *TrustcenterEntityHistoryQuery) *TrustcenterEntityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrustcenterEntityHistoryOrder.Field {
		query = query.Order(DefaultTrustcenterEntityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trustcenterentityhistoryPager) orderExpr(query *TrustcenterEntityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrustcenterEntityHistoryOrder.Field {
			b.Comma().Ident(DefaultTrustcenterEntityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustcenterEntityHistory.
func (_m *TrustcenterEntityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustcenterEntityHistoryPaginateOption,
) (*TrustcenterEntityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustcenterEntityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustcenterEntityHistoryConnection{Edges: []*TrustcenterEntityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustcenterEntityHistoryOrderFieldHistoryTime orders TrustcenterEntityHistory by history_time.
	TrustcenterEntityHistoryOrderFieldHistoryTime = &TrustcenterEntityHistoryOrderField{
		Value: func(_m *TrustcenterEntityHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: trustcenterentityhistory.FieldHistoryTime,
		toTerm: trustcenterentityhistory.ByHistoryTime,
		toCursor: func(_m *TrustcenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// TrustcenterEntityHistoryOrderFieldCreatedAt orders TrustcenterEntityHistory by created_at.
	TrustcenterEntityHistoryOrderFieldCreatedAt = &TrustcenterEntityHistoryOrderField{
		Value: func(_m *TrustcenterEntityHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterentityhistory.FieldCreatedAt,
		toTerm: trustcenterentityhistory.ByCreatedAt,
		toCursor: func(_m *TrustcenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustcenterEntityHistoryOrderFieldUpdatedAt orders TrustcenterEntityHistory by updated_at.
	TrustcenterEntityHistoryOrderFieldUpdatedAt = &TrustcenterEntityHistoryOrderField{
		Value: func(_m *TrustcenterEntityHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterentityhistory.FieldUpdatedAt,
		toTerm: trustcenterentityhistory.ByUpdatedAt,
		toCursor: func(_m *TrustcenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TrustcenterEntityHistoryOrderFieldName orders TrustcenterEntityHistory by name.
	TrustcenterEntityHistoryOrderFieldName = &TrustcenterEntityHistoryOrderField{
		Value: func(_m *TrustcenterEntityHistory) (ent.Value, error) {
			return _m.Name, nil
		},
		column: trustcenterentityhistory.FieldName,
		toTerm: trustcenterentityhistory.ByName,
		toCursor: func(_m *TrustcenterEntityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustcenterEntityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TrustcenterEntityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case TrustcenterEntityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustcenterEntityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TrustcenterEntityHistoryOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustcenterEntityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustcenterEntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustcenterEntityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *TrustcenterEntityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *TrustcenterEntityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustcenterEntityHistoryOrderFieldUpdatedAt
	case "NAME":
		*f = *TrustcenterEntityHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TrustcenterEntityHistoryOrderField", str)
	}
	return nil
}

// TrustcenterEntityHistoryOrderField defines the ordering field of TrustcenterEntityHistory.
type TrustcenterEntityHistoryOrderField struct {
	// Value extracts the ordering value from the given TrustcenterEntityHistory.
	Value    func(*TrustcenterEntityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterentityhistory.OrderOption
	toCursor func(*TrustcenterEntityHistory) Cursor
}

// TrustcenterEntityHistoryOrder defines the ordering of TrustcenterEntityHistory.
type TrustcenterEntityHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *TrustcenterEntityHistoryOrderField `json:"field"`
}

// DefaultTrustcenterEntityHistoryOrder is the default ordering of TrustcenterEntityHistory.
var DefaultTrustcenterEntityHistoryOrder = &TrustcenterEntityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustcenterEntityHistoryOrderField{
		Value: func(_m *TrustcenterEntityHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterentityhistory.FieldID,
		toTerm: trustcenterentityhistory.ByID,
		toCursor: func(_m *TrustcenterEntityHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustcenterEntityHistory into TrustcenterEntityHistoryEdge.
func (_m *TrustcenterEntityHistory) ToEdge(order *TrustcenterEntityHistoryOrder) *TrustcenterEntityHistoryEdge {
	if order == nil {
		order = DefaultTrustcenterEntityHistoryOrder
	}
	return &TrustcenterEntityHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order []*UserOrder) UserPaginateOption {
	return func(pager *userPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   []*UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(_m *User) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (_m *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// UserOrderFieldFirstName orders User by first_name.
	UserOrderFieldFirstName = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.FirstName, nil
		},
		column: user.FieldFirstName,
		toTerm: user.ByFirstName,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FirstName,
			}
		},
	}
	// UserOrderFieldLastName orders User by last_name.
	UserOrderFieldLastName = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.LastName, nil
		},
		column: user.FieldLastName,
		toTerm: user.ByLastName,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastName,
			}
		},
	}
	// UserOrderFieldDisplayName orders User by display_name.
	UserOrderFieldDisplayName = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: user.FieldDisplayName,
		toTerm: user.ByDisplayName,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "created_at"
	case UserOrderFieldUpdatedAt.column:
		str = "updated_at"
	case UserOrderFieldFirstName.column:
		str = "first_name"
	case UserOrderFieldLastName.column:
		str = "last_name"
	case UserOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserOrderFieldCreatedAt
	case "updated_at":
		*f = *UserOrderFieldUpdatedAt
	case "first_name":
		*f = *UserOrderFieldFirstName
	case "last_name":
		*f = *UserOrderFieldLastName
	case "display_name":
		*f = *UserOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(_m *User) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (_m *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserHistoryEdge is the edge representation of UserHistory.
type UserHistoryEdge struct {
	Node   *UserHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserHistoryConnection is the connection containing edges to UserHistory.
type UserHistoryConnection struct {
	Edges      []*UserHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserHistoryConnection) build(nodes []*UserHistory, pager *userhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserHistoryPaginateOption enables pagination customization.
type UserHistoryPaginateOption func(*userhistoryPager) error

// WithUserHistoryOrder configures pagination ordering.
func WithUserHistoryOrder(order *UserHistoryOrder) UserHistoryPaginateOption {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	o := *order
	return func(pager *userhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserHistoryFilter configures pagination filter.
func WithUserHistoryFilter(filter func(*UserHistoryQuery) (*UserHistoryQuery, error)) UserHistoryPaginateOption {
	return func(pager *userhistoryPager) error {
		if filter == nil {
			return errors.New("UserHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userhistoryPager struct {
	reverse bool
	order   *UserHistoryOrder
	filter  func(*UserHistoryQuery) (*UserHistoryQuery, error)
}

func newUserHistoryPager(opts []UserHistoryPaginateOption, reverse bool) (*userhistoryPager, error) {
	pager := &userhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserHistoryOrder
	}
	return pager, nil
}

func (p *userhistoryPager) applyFilter(query *UserHistoryQuery) (*UserHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userhistoryPager) toCursor(_m *UserHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *userhistoryPager) applyCursors(query *UserHistoryQuery, after, before *Cursor) (*UserHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userhistoryPager) applyOrder(query *UserHistoryQuery) *UserHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserHistoryOrder.Field {
		query = query.Order(DefaultUserHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userhistoryPager) orderExpr(query *UserHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserHistoryOrder.Field {
			b.Comma().Ident(DefaultUserHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserHistory.
func (_m *UserHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserHistoryPaginateOption,
) (*UserHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserHistoryConnection{Edges: []*UserHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserHistoryOrderFieldHistoryTime orders UserHistory by history_time.
	UserHistoryOrderFieldHistoryTime = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: userhistory.FieldHistoryTime,
		toTerm: userhistory.ByHistoryTime,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// UserHistoryOrderFieldCreatedAt orders UserHistory by created_at.
	UserHistoryOrderFieldCreatedAt = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: userhistory.FieldCreatedAt,
		toTerm: userhistory.ByCreatedAt,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserHistoryOrderFieldUpdatedAt orders UserHistory by updated_at.
	UserHistoryOrderFieldUpdatedAt = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: userhistory.FieldUpdatedAt,
		toTerm: userhistory.ByUpdatedAt,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// UserHistoryOrderFieldFirstName orders UserHistory by first_name.
	UserHistoryOrderFieldFirstName = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.FirstName, nil
		},
		column: userhistory.FieldFirstName,
		toTerm: userhistory.ByFirstName,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FirstName,
			}
		},
	}
	// UserHistoryOrderFieldLastName orders UserHistory by last_name.
	UserHistoryOrderFieldLastName = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.LastName, nil
		},
		column: userhistory.FieldLastName,
		toTerm: userhistory.ByLastName,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastName,
			}
		},
	}
	// UserHistoryOrderFieldDisplayName orders UserHistory by display_name.
	UserHistoryOrderFieldDisplayName = &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: userhistory.FieldDisplayName,
		toTerm: userhistory.ByDisplayName,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case UserHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case UserHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case UserHistoryOrderFieldFirstName.column:
		str = "first_name"
	case UserHistoryOrderFieldLastName.column:
		str = "last_name"
	case UserHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *UserHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *UserHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *UserHistoryOrderFieldUpdatedAt
	case "first_name":
		*f = *UserHistoryOrderFieldFirstName
	case "last_name":
		*f = *UserHistoryOrderFieldLastName
	case "display_name":
		*f = *UserHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

// UserHistoryOrderField defines the ordering field of UserHistory.
type UserHistoryOrderField struct {
	// Value extracts the ordering value from the given UserHistory.
	Value    func(*UserHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userhistory.OrderOption
	toCursor func(*UserHistory) Cursor
}

// UserHistoryOrder defines the ordering of UserHistory.
type UserHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserHistoryOrderField `json:"field"`
}

// DefaultUserHistoryOrder is the default ordering of UserHistory.
var DefaultUserHistoryOrder = &UserHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserHistoryOrderField{
		Value: func(_m *UserHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: userhistory.FieldID,
		toTerm: userhistory.ByID,
		toCursor: func(_m *UserHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserHistory into UserHistoryEdge.
func (_m *UserHistory) ToEdge(order *UserHistoryOrder) *UserHistoryEdge {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	return &UserHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserSettingEdge is the edge representation of UserSetting.
type UserSettingEdge struct {
	Node   *UserSetting `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserSettingConnection is the connection containing edges to UserSetting.
type UserSettingConnection struct {
	Edges      []*UserSettingEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserSettingConnection) build(nodes []*UserSetting, pager *usersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingPaginateOption enables pagination customization.
type UserSettingPaginateOption func(*usersettingPager) error

// WithUserSettingOrder configures pagination ordering.
func WithUserSettingOrder(order []*UserSettingOrder) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserSettingFilter configures pagination filter.
func WithUserSettingFilter(filter func(*UserSettingQuery) (*UserSettingQuery, error)) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		if filter == nil {
			return errors.New("UserSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettingPager struct {
	reverse bool
	order   []*UserSettingOrder
	filter  func(*UserSettingQuery) (*UserSettingQuery, error)
}

func newUserSettingPager(opts []UserSettingPaginateOption, reverse bool) (*usersettingPager, error) {
	pager := &usersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *usersettingPager) applyFilter(query *UserSettingQuery) (*UserSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettingPager) toCursor(_m *UserSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *usersettingPager) applyCursors(query *UserSettingQuery, after, before *Cursor) (*UserSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *usersettingPager) applyOrder(query *UserSettingQuery) *UserSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *usersettingPager) orderExpr(query *UserSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSetting.
func (_m *UserSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingPaginateOption,
) (*UserSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserSettingConnection{Edges: []*UserSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSettingOrderFieldCreatedAt orders UserSetting by created_at.
	UserSettingOrderFieldCreatedAt = &UserSettingOrderField{
		Value: func(_m *UserSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: usersetting.FieldCreatedAt,
		toTerm: usersetting.ByCreatedAt,
		toCursor: func(_m *UserSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserSettingOrderFieldUpdatedAt orders UserSetting by updated_at.
	UserSettingOrderFieldUpdatedAt = &UserSettingOrderField{
		Value: func(_m *UserSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: usersetting.FieldUpdatedAt,
		toTerm: usersetting.ByUpdatedAt,
		toCursor: func(_m *UserSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSettingOrderField) String() string {
	var str string
	switch f.column {
	case UserSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case UserSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *UserSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSettingOrderField", str)
	}
	return nil
}

// UserSettingOrderField defines the ordering field of UserSetting.
type UserSettingOrderField struct {
	// Value extracts the ordering value from the given UserSetting.
	Value    func(*UserSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersetting.OrderOption
	toCursor func(*UserSetting) Cursor
}

// UserSettingOrder defines the ordering of UserSetting.
type UserSettingOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserSettingOrderField `json:"field"`
}

// DefaultUserSettingOrder is the default ordering of UserSetting.
var DefaultUserSettingOrder = &UserSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingOrderField{
		Value: func(_m *UserSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: usersetting.FieldID,
		toTerm: usersetting.ByID,
		toCursor: func(_m *UserSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserSetting into UserSettingEdge.
func (_m *UserSetting) ToEdge(order *UserSettingOrder) *UserSettingEdge {
	if order == nil {
		order = DefaultUserSettingOrder
	}
	return &UserSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserSettingHistoryEdge is the edge representation of UserSettingHistory.
type UserSettingHistoryEdge struct {
	Node   *UserSettingHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// UserSettingHistoryConnection is the connection containing edges to UserSettingHistory.
type UserSettingHistoryConnection struct {
	Edges      []*UserSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *UserSettingHistoryConnection) build(nodes []*UserSettingHistory, pager *usersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingHistoryPaginateOption enables pagination customization.
type UserSettingHistoryPaginateOption func(*usersettinghistoryPager) error

// WithUserSettingHistoryOrder configures pagination ordering.
func WithUserSettingHistoryOrder(order *UserSettingHistoryOrder) UserSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	o := *order
	return func(pager *usersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSettingHistoryFilter configures pagination filter.
func WithUserSettingHistoryFilter(filter func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)) UserSettingHistoryPaginateOption {
	return func(pager *usersettinghistoryPager) error {
		if filter == nil {
			return errors.New("UserSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettinghistoryPager struct {
	reverse bool
	order   *UserSettingHistoryOrder
	filter  func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)
}

func newUserSettingHistoryPager(opts []UserSettingHistoryPaginateOption, reverse bool) (*usersettinghistoryPager, error) {
	pager := &usersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSettingHistoryOrder
	}
	return pager, nil
}

func (p *usersettinghistoryPager) applyFilter(query *UserSettingHistoryQuery) (*UserSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettinghistoryPager) toCursor(_m *UserSettingHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *usersettinghistoryPager) applyCursors(query *UserSettingHistoryQuery, after, before *Cursor) (*UserSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersettinghistoryPager) applyOrder(query *UserSettingHistoryQuery) *UserSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSettingHistoryOrder.Field {
		query = query.Order(DefaultUserSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersettinghistoryPager) orderExpr(query *UserSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultUserSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSettingHistory.
func (_m *UserSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingHistoryPaginateOption,
) (*UserSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserSettingHistoryConnection{Edges: []*UserSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSettingHistoryOrderFieldHistoryTime orders UserSettingHistory by history_time.
	UserSettingHistoryOrderFieldHistoryTime = &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: usersettinghistory.FieldHistoryTime,
		toTerm: usersettinghistory.ByHistoryTime,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// UserSettingHistoryOrderFieldCreatedAt orders UserSettingHistory by created_at.
	UserSettingHistoryOrderFieldCreatedAt = &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: usersettinghistory.FieldCreatedAt,
		toTerm: usersettinghistory.ByCreatedAt,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserSettingHistoryOrderFieldUpdatedAt orders UserSettingHistory by updated_at.
	UserSettingHistoryOrderFieldUpdatedAt = &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: usersettinghistory.FieldUpdatedAt,
		toTerm: usersettinghistory.ByUpdatedAt,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSettingHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserSettingHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case UserSettingHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case UserSettingHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSettingHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSettingHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *UserSettingHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *UserSettingHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *UserSettingHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSettingHistoryOrderField", str)
	}
	return nil
}

// UserSettingHistoryOrderField defines the ordering field of UserSettingHistory.
type UserSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given UserSettingHistory.
	Value    func(*UserSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersettinghistory.OrderOption
	toCursor func(*UserSettingHistory) Cursor
}

// UserSettingHistoryOrder defines the ordering of UserSettingHistory.
type UserSettingHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *UserSettingHistoryOrderField `json:"field"`
}

// DefaultUserSettingHistoryOrder is the default ordering of UserSettingHistory.
var DefaultUserSettingHistoryOrder = &UserSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingHistoryOrderField{
		Value: func(_m *UserSettingHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: usersettinghistory.FieldID,
		toTerm: usersettinghistory.ByID,
		toCursor: func(_m *UserSettingHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserSettingHistory into UserSettingHistoryEdge.
func (_m *UserSettingHistory) ToEdge(order *UserSettingHistoryOrder) *UserSettingHistoryEdge {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	return &UserSettingHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// VulnerabilityEdge is the edge representation of Vulnerability.
type VulnerabilityEdge struct {
	Node   *Vulnerability `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// VulnerabilityConnection is the connection containing edges to Vulnerability.
type VulnerabilityConnection struct {
	Edges      []*VulnerabilityEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *VulnerabilityConnection) build(nodes []*Vulnerability, pager *vulnerabilityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Vulnerability
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vulnerability {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vulnerability {
			return nodes[i]
		}
	}
	c.Edges = make([]*VulnerabilityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VulnerabilityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VulnerabilityPaginateOption enables pagination customization.
type VulnerabilityPaginateOption func(*vulnerabilityPager) error

// WithVulnerabilityOrder configures pagination ordering.
func WithVulnerabilityOrder(order []*VulnerabilityOrder) VulnerabilityPaginateOption {
	return func(pager *vulnerabilityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithVulnerabilityFilter configures pagination filter.
func WithVulnerabilityFilter(filter func(*VulnerabilityQuery) (*VulnerabilityQuery, error)) VulnerabilityPaginateOption {
	return func(pager *vulnerabilityPager) error {
		if filter == nil {
			return errors.New("VulnerabilityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityPager struct {
	reverse bool
	order   []*VulnerabilityOrder
	filter  func(*VulnerabilityQuery) (*VulnerabilityQuery, error)
}

func newVulnerabilityPager(opts []VulnerabilityPaginateOption, reverse bool) (*vulnerabilityPager, error) {
	pager := &vulnerabilityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *vulnerabilityPager) applyFilter(query *VulnerabilityQuery) (*VulnerabilityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityPager) toCursor(_m *Vulnerability) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *vulnerabilityPager) applyCursors(query *VulnerabilityQuery, after, before *Cursor) (*VulnerabilityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultVulnerabilityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *vulnerabilityPager) applyOrder(query *VulnerabilityQuery) *VulnerabilityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultVulnerabilityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultVulnerabilityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *vulnerabilityPager) orderExpr(query *VulnerabilityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultVulnerabilityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Vulnerability.
func (_m *VulnerabilityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityPaginateOption,
) (*VulnerabilityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &VulnerabilityConnection{Edges: []*VulnerabilityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VulnerabilityOrderFieldCreatedAt orders Vulnerability by created_at.
	VulnerabilityOrderFieldCreatedAt = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: vulnerability.FieldCreatedAt,
		toTerm: vulnerability.ByCreatedAt,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// VulnerabilityOrderFieldUpdatedAt orders Vulnerability by updated_at.
	VulnerabilityOrderFieldUpdatedAt = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: vulnerability.FieldUpdatedAt,
		toTerm: vulnerability.ByUpdatedAt,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// VulnerabilityOrderFieldExternalOwnerID orders Vulnerability by external_owner_id.
	VulnerabilityOrderFieldExternalOwnerID = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: vulnerability.FieldExternalOwnerID,
		toTerm: vulnerability.ByExternalOwnerID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// VulnerabilityOrderFieldExternalID orders Vulnerability by external_id.
	VulnerabilityOrderFieldExternalID = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: vulnerability.FieldExternalID,
		toTerm: vulnerability.ByExternalID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// VulnerabilityOrderFieldCveID orders Vulnerability by cve_id.
	VulnerabilityOrderFieldCveID = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.CveID, nil
		},
		column: vulnerability.FieldCveID,
		toTerm: vulnerability.ByCveID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CveID,
			}
		},
	}
	// VulnerabilityOrderFieldCategory orders Vulnerability by category.
	VulnerabilityOrderFieldCategory = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.Category, nil
		},
		column: vulnerability.FieldCategory,
		toTerm: vulnerability.ByCategory,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// VulnerabilityOrderFieldSeverity orders Vulnerability by severity.
	VulnerabilityOrderFieldSeverity = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: vulnerability.FieldSeverity,
		toTerm: vulnerability.BySeverity,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VulnerabilityOrderField) String() string {
	var str string
	switch f.column {
	case VulnerabilityOrderFieldCreatedAt.column:
		str = "created_at"
	case VulnerabilityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case VulnerabilityOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case VulnerabilityOrderFieldExternalID.column:
		str = "external_id"
	case VulnerabilityOrderFieldCveID.column:
		str = "cve_id"
	case VulnerabilityOrderFieldCategory.column:
		str = "category"
	case VulnerabilityOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VulnerabilityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VulnerabilityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VulnerabilityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *VulnerabilityOrderFieldCreatedAt
	case "updated_at":
		*f = *VulnerabilityOrderFieldUpdatedAt
	case "external_owner_id":
		*f = *VulnerabilityOrderFieldExternalOwnerID
	case "external_id":
		*f = *VulnerabilityOrderFieldExternalID
	case "cve_id":
		*f = *VulnerabilityOrderFieldCveID
	case "category":
		*f = *VulnerabilityOrderFieldCategory
	case "severity":
		*f = *VulnerabilityOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid VulnerabilityOrderField", str)
	}
	return nil
}

// VulnerabilityOrderField defines the ordering field of Vulnerability.
type VulnerabilityOrderField struct {
	// Value extracts the ordering value from the given Vulnerability.
	Value    func(*Vulnerability) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) vulnerability.OrderOption
	toCursor func(*Vulnerability) Cursor
}

// VulnerabilityOrder defines the ordering of Vulnerability.
type VulnerabilityOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *VulnerabilityOrderField `json:"field"`
}

// DefaultVulnerabilityOrder is the default ordering of Vulnerability.
var DefaultVulnerabilityOrder = &VulnerabilityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.ID, nil
		},
		column: vulnerability.FieldID,
		toTerm: vulnerability.ByID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Vulnerability into VulnerabilityEdge.
func (_m *Vulnerability) ToEdge(order *VulnerabilityOrder) *VulnerabilityEdge {
	if order == nil {
		order = DefaultVulnerabilityOrder
	}
	return &VulnerabilityEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// VulnerabilityHistoryEdge is the edge representation of VulnerabilityHistory.
type VulnerabilityHistoryEdge struct {
	Node   *VulnerabilityHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// VulnerabilityHistoryConnection is the connection containing edges to VulnerabilityHistory.
type VulnerabilityHistoryConnection struct {
	Edges      []*VulnerabilityHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *VulnerabilityHistoryConnection) build(nodes []*VulnerabilityHistory, pager *vulnerabilityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *VulnerabilityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VulnerabilityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VulnerabilityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*VulnerabilityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VulnerabilityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VulnerabilityHistoryPaginateOption enables pagination customization.
type VulnerabilityHistoryPaginateOption func(*vulnerabilityhistoryPager) error

// WithVulnerabilityHistoryOrder configures pagination ordering.
func WithVulnerabilityHistoryOrder(order *VulnerabilityHistoryOrder) VulnerabilityHistoryPaginateOption {
	if order == nil {
		order = DefaultVulnerabilityHistoryOrder
	}
	o := *order
	return func(pager *vulnerabilityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVulnerabilityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVulnerabilityHistoryFilter configures pagination filter.
func WithVulnerabilityHistoryFilter(filter func(*VulnerabilityHistoryQuery) (*VulnerabilityHistoryQuery, error)) VulnerabilityHistoryPaginateOption {
	return func(pager *vulnerabilityhistoryPager) error {
		if filter == nil {
			return errors.New("VulnerabilityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityhistoryPager struct {
	reverse bool
	order   *VulnerabilityHistoryOrder
	filter  func(*VulnerabilityHistoryQuery) (*VulnerabilityHistoryQuery, error)
}

func newVulnerabilityHistoryPager(opts []VulnerabilityHistoryPaginateOption, reverse bool) (*vulnerabilityhistoryPager, error) {
	pager := &vulnerabilityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVulnerabilityHistoryOrder
	}
	return pager, nil
}

func (p *vulnerabilityhistoryPager) applyFilter(query *VulnerabilityHistoryQuery) (*VulnerabilityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityhistoryPager) toCursor(_m *VulnerabilityHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *vulnerabilityhistoryPager) applyCursors(query *VulnerabilityHistoryQuery, after, before *Cursor) (*VulnerabilityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultVulnerabilityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *vulnerabilityhistoryPager) applyOrder(query *VulnerabilityHistoryQuery) *VulnerabilityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultVulnerabilityHistoryOrder.Field {
		query = query.Order(DefaultVulnerabilityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *vulnerabilityhistoryPager) orderExpr(query *VulnerabilityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultVulnerabilityHistoryOrder.Field {
			b.Comma().Ident(DefaultVulnerabilityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to VulnerabilityHistory.
func (_m *VulnerabilityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityHistoryPaginateOption,
) (*VulnerabilityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &VulnerabilityHistoryConnection{Edges: []*VulnerabilityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VulnerabilityHistoryOrderFieldHistoryTime orders VulnerabilityHistory by history_time.
	VulnerabilityHistoryOrderFieldHistoryTime = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: vulnerabilityhistory.FieldHistoryTime,
		toTerm: vulnerabilityhistory.ByHistoryTime,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldCreatedAt orders VulnerabilityHistory by created_at.
	VulnerabilityHistoryOrderFieldCreatedAt = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: vulnerabilityhistory.FieldCreatedAt,
		toTerm: vulnerabilityhistory.ByCreatedAt,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldUpdatedAt orders VulnerabilityHistory by updated_at.
	VulnerabilityHistoryOrderFieldUpdatedAt = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: vulnerabilityhistory.FieldUpdatedAt,
		toTerm: vulnerabilityhistory.ByUpdatedAt,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldExternalOwnerID orders VulnerabilityHistory by external_owner_id.
	VulnerabilityHistoryOrderFieldExternalOwnerID = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: vulnerabilityhistory.FieldExternalOwnerID,
		toTerm: vulnerabilityhistory.ByExternalOwnerID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldExternalID orders VulnerabilityHistory by external_id.
	VulnerabilityHistoryOrderFieldExternalID = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: vulnerabilityhistory.FieldExternalID,
		toTerm: vulnerabilityhistory.ByExternalID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldCveID orders VulnerabilityHistory by cve_id.
	VulnerabilityHistoryOrderFieldCveID = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.CveID, nil
		},
		column: vulnerabilityhistory.FieldCveID,
		toTerm: vulnerabilityhistory.ByCveID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CveID,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldCategory orders VulnerabilityHistory by category.
	VulnerabilityHistoryOrderFieldCategory = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.Category, nil
		},
		column: vulnerabilityhistory.FieldCategory,
		toTerm: vulnerabilityhistory.ByCategory,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// VulnerabilityHistoryOrderFieldSeverity orders VulnerabilityHistory by severity.
	VulnerabilityHistoryOrderFieldSeverity = &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: vulnerabilityhistory.FieldSeverity,
		toTerm: vulnerabilityhistory.BySeverity,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VulnerabilityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case VulnerabilityHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case VulnerabilityHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case VulnerabilityHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	case VulnerabilityHistoryOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case VulnerabilityHistoryOrderFieldExternalID.column:
		str = "external_id"
	case VulnerabilityHistoryOrderFieldCveID.column:
		str = "cve_id"
	case VulnerabilityHistoryOrderFieldCategory.column:
		str = "category"
	case VulnerabilityHistoryOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VulnerabilityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VulnerabilityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VulnerabilityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *VulnerabilityHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *VulnerabilityHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *VulnerabilityHistoryOrderFieldUpdatedAt
	case "external_owner_id":
		*f = *VulnerabilityHistoryOrderFieldExternalOwnerID
	case "external_id":
		*f = *VulnerabilityHistoryOrderFieldExternalID
	case "cve_id":
		*f = *VulnerabilityHistoryOrderFieldCveID
	case "category":
		*f = *VulnerabilityHistoryOrderFieldCategory
	case "severity":
		*f = *VulnerabilityHistoryOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid VulnerabilityHistoryOrderField", str)
	}
	return nil
}

// VulnerabilityHistoryOrderField defines the ordering field of VulnerabilityHistory.
type VulnerabilityHistoryOrderField struct {
	// Value extracts the ordering value from the given VulnerabilityHistory.
	Value    func(*VulnerabilityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) vulnerabilityhistory.OrderOption
	toCursor func(*VulnerabilityHistory) Cursor
}

// VulnerabilityHistoryOrder defines the ordering of VulnerabilityHistory.
type VulnerabilityHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *VulnerabilityHistoryOrderField `json:"field"`
}

// DefaultVulnerabilityHistoryOrder is the default ordering of VulnerabilityHistory.
var DefaultVulnerabilityHistoryOrder = &VulnerabilityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &VulnerabilityHistoryOrderField{
		Value: func(_m *VulnerabilityHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: vulnerabilityhistory.FieldID,
		toTerm: vulnerabilityhistory.ByID,
		toCursor: func(_m *VulnerabilityHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts VulnerabilityHistory into VulnerabilityHistoryEdge.
func (_m *VulnerabilityHistory) ToEdge(order *VulnerabilityHistoryOrder) *VulnerabilityHistoryEdge {
	if order == nil {
		order = DefaultVulnerabilityHistoryOrder
	}
	return &VulnerabilityHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WebauthnEdge is the edge representation of Webauthn.
type WebauthnEdge struct {
	Node   *Webauthn `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// WebauthnConnection is the connection containing edges to Webauthn.
type WebauthnConnection struct {
	Edges      []*WebauthnEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *WebauthnConnection) build(nodes []*Webauthn, pager *webauthnPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Webauthn
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Webauthn {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Webauthn {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebauthnEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebauthnEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebauthnPaginateOption enables pagination customization.
type WebauthnPaginateOption func(*webauthnPager) error

// WithWebauthnOrder configures pagination ordering.
func WithWebauthnOrder(order *WebauthnOrder) WebauthnPaginateOption {
	if order == nil {
		order = DefaultWebauthnOrder
	}
	o := *order
	return func(pager *webauthnPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebauthnOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebauthnFilter configures pagination filter.
func WithWebauthnFilter(filter func(*WebauthnQuery) (*WebauthnQuery, error)) WebauthnPaginateOption {
	return func(pager *webauthnPager) error {
		if filter == nil {
			return errors.New("WebauthnQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type webauthnPager struct {
	reverse bool
	order   *WebauthnOrder
	filter  func(*WebauthnQuery) (*WebauthnQuery, error)
}

func newWebauthnPager(opts []WebauthnPaginateOption, reverse bool) (*webauthnPager, error) {
	pager := &webauthnPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebauthnOrder
	}
	return pager, nil
}

func (p *webauthnPager) applyFilter(query *WebauthnQuery) (*WebauthnQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *webauthnPager) toCursor(_m *Webauthn) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *webauthnPager) applyCursors(query *WebauthnQuery, after, before *Cursor) (*WebauthnQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWebauthnOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *webauthnPager) applyOrder(query *WebauthnQuery) *WebauthnQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWebauthnOrder.Field {
		query = query.Order(DefaultWebauthnOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *webauthnPager) orderExpr(query *WebauthnQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebauthnOrder.Field {
			b.Comma().Ident(DefaultWebauthnOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Webauthn.
func (_m *WebauthnQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebauthnPaginateOption,
) (*WebauthnConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebauthnPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WebauthnConnection{Edges: []*WebauthnEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebauthnOrderFieldCreatedAt orders Webauthn by created_at.
	WebauthnOrderFieldCreatedAt = &WebauthnOrderField{
		Value: func(_m *Webauthn) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: webauthn.FieldCreatedAt,
		toTerm: webauthn.ByCreatedAt,
		toCursor: func(_m *Webauthn) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WebauthnOrderFieldUpdatedAt orders Webauthn by updated_at.
	WebauthnOrderFieldUpdatedAt = &WebauthnOrderField{
		Value: func(_m *Webauthn) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: webauthn.FieldUpdatedAt,
		toTerm: webauthn.ByUpdatedAt,
		toCursor: func(_m *Webauthn) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebauthnOrderField) String() string {
	var str string
	switch f.column {
	case WebauthnOrderFieldCreatedAt.column:
		str = "created_at"
	case WebauthnOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebauthnOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebauthnOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebauthnOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WebauthnOrderFieldCreatedAt
	case "updated_at":
		*f = *WebauthnOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WebauthnOrderField", str)
	}
	return nil
}

// WebauthnOrderField defines the ordering field of Webauthn.
type WebauthnOrderField struct {
	// Value extracts the ordering value from the given Webauthn.
	Value    func(*Webauthn) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) webauthn.OrderOption
	toCursor func(*Webauthn) Cursor
}

// WebauthnOrder defines the ordering of Webauthn.
type WebauthnOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *WebauthnOrderField `json:"field"`
}

// DefaultWebauthnOrder is the default ordering of Webauthn.
var DefaultWebauthnOrder = &WebauthnOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WebauthnOrderField{
		Value: func(_m *Webauthn) (ent.Value, error) {
			return _m.ID, nil
		},
		column: webauthn.FieldID,
		toTerm: webauthn.ByID,
		toCursor: func(_m *Webauthn) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Webauthn into WebauthnEdge.
func (_m *Webauthn) ToEdge(order *WebauthnOrder) *WebauthnEdge {
	if order == nil {
		order = DefaultWebauthnOrder
	}
	return &WebauthnEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentEdge is the edge representation of WorkflowAssignment.
type WorkflowAssignmentEdge struct {
	Node   *WorkflowAssignment `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// WorkflowAssignmentConnection is the connection containing edges to WorkflowAssignment.
type WorkflowAssignmentConnection struct {
	Edges      []*WorkflowAssignmentEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *WorkflowAssignmentConnection) build(nodes []*WorkflowAssignment, pager *workflowassignmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignment {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentPaginateOption enables pagination customization.
type WorkflowAssignmentPaginateOption func(*workflowassignmentPager) error

// WithWorkflowAssignmentOrder configures pagination ordering.
func WithWorkflowAssignmentOrder(order []*WorkflowAssignmentOrder) WorkflowAssignmentPaginateOption {
	return func(pager *workflowassignmentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowAssignmentFilter configures pagination filter.
func WithWorkflowAssignmentFilter(filter func(*WorkflowAssignmentQuery) (*WorkflowAssignmentQuery, error)) WorkflowAssignmentPaginateOption {
	return func(pager *workflowassignmentPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmentPager struct {
	reverse bool
	order   []*WorkflowAssignmentOrder
	filter  func(*WorkflowAssignmentQuery) (*WorkflowAssignmentQuery, error)
}

func newWorkflowAssignmentPager(opts []WorkflowAssignmentPaginateOption, reverse bool) (*workflowassignmentPager, error) {
	pager := &workflowassignmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowassignmentPager) applyFilter(query *WorkflowAssignmentQuery) (*WorkflowAssignmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmentPager) toCursor(_m *WorkflowAssignment) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowassignmentPager) applyCursors(query *WorkflowAssignmentQuery, after, before *Cursor) (*WorkflowAssignmentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowAssignmentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowassignmentPager) applyOrder(query *WorkflowAssignmentQuery) *WorkflowAssignmentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowAssignmentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowAssignmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowassignmentPager) orderExpr(query *WorkflowAssignmentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowAssignmentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignment.
func (_m *WorkflowAssignmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentPaginateOption,
) (*WorkflowAssignmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentConnection{Edges: []*WorkflowAssignmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentOrderFieldCreatedAt orders WorkflowAssignment by created_at.
	WorkflowAssignmentOrderFieldCreatedAt = &WorkflowAssignmentOrderField{
		Value: func(_m *WorkflowAssignment) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignment.FieldCreatedAt,
		toTerm: workflowassignment.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentOrderFieldUpdatedAt orders WorkflowAssignment by updated_at.
	WorkflowAssignmentOrderFieldUpdatedAt = &WorkflowAssignmentOrderField{
		Value: func(_m *WorkflowAssignment) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignment.FieldUpdatedAt,
		toTerm: workflowassignment.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowAssignmentOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentOrderField", str)
	}
	return nil
}

// WorkflowAssignmentOrderField defines the ordering field of WorkflowAssignment.
type WorkflowAssignmentOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignment.
	Value    func(*WorkflowAssignment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignment.OrderOption
	toCursor func(*WorkflowAssignment) Cursor
}

// WorkflowAssignmentOrder defines the ordering of WorkflowAssignment.
type WorkflowAssignmentOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *WorkflowAssignmentOrderField `json:"field"`
}

// DefaultWorkflowAssignmentOrder is the default ordering of WorkflowAssignment.
var DefaultWorkflowAssignmentOrder = &WorkflowAssignmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentOrderField{
		Value: func(_m *WorkflowAssignment) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignment.FieldID,
		toTerm: workflowassignment.ByID,
		toCursor: func(_m *WorkflowAssignment) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignment into WorkflowAssignmentEdge.
func (_m *WorkflowAssignment) ToEdge(order *WorkflowAssignmentOrder) *WorkflowAssignmentEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentOrder
	}
	return &WorkflowAssignmentEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentHistoryEdge is the edge representation of WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryEdge struct {
	Node   *WorkflowAssignmentHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// WorkflowAssignmentHistoryConnection is the connection containing edges to WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryConnection struct {
	Edges      []*WorkflowAssignmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *WorkflowAssignmentHistoryConnection) build(nodes []*WorkflowAssignmentHistory, pager *workflowassignmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentHistoryPaginateOption enables pagination customization.
type WorkflowAssignmentHistoryPaginateOption func(*workflowassignmenthistoryPager) error

// WithWorkflowAssignmentHistoryOrder configures pagination ordering.
func WithWorkflowAssignmentHistoryOrder(order *WorkflowAssignmentHistoryOrder) WorkflowAssignmentHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowAssignmentHistoryOrder
	}
	o := *order
	return func(pager *workflowassignmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowAssignmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowAssignmentHistoryFilter configures pagination filter.
func WithWorkflowAssignmentHistoryFilter(filter func(*WorkflowAssignmentHistoryQuery) (*WorkflowAssignmentHistoryQuery, error)) WorkflowAssignmentHistoryPaginateOption {
	return func(pager *workflowassignmenthistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmenthistoryPager struct {
	reverse bool
	order   *WorkflowAssignmentHistoryOrder
	filter  func(*WorkflowAssignmentHistoryQuery) (*WorkflowAssignmentHistoryQuery, error)
}

func newWorkflowAssignmentHistoryPager(opts []WorkflowAssignmentHistoryPaginateOption, reverse bool) (*workflowassignmenthistoryPager, error) {
	pager := &workflowassignmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowAssignmentHistoryOrder
	}
	return pager, nil
}

func (p *workflowassignmenthistoryPager) applyFilter(query *WorkflowAssignmentHistoryQuery) (*WorkflowAssignmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmenthistoryPager) toCursor(_m *WorkflowAssignmentHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowassignmenthistoryPager) applyCursors(query *WorkflowAssignmentHistoryQuery, after, before *Cursor) (*WorkflowAssignmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowAssignmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowassignmenthistoryPager) applyOrder(query *WorkflowAssignmentHistoryQuery) *WorkflowAssignmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowAssignmentHistoryOrder.Field {
		query = query.Order(DefaultWorkflowAssignmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowassignmenthistoryPager) orderExpr(query *WorkflowAssignmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowAssignmentHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowAssignmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignmentHistory.
func (_m *WorkflowAssignmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentHistoryPaginateOption,
) (*WorkflowAssignmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentHistoryConnection{Edges: []*WorkflowAssignmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentHistoryOrderFieldHistoryTime orders WorkflowAssignmentHistory by history_time.
	WorkflowAssignmentHistoryOrderFieldHistoryTime = &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowassignmenthistory.FieldHistoryTime,
		toTerm: workflowassignmenthistory.ByHistoryTime,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowAssignmentHistoryOrderFieldCreatedAt orders WorkflowAssignmentHistory by created_at.
	WorkflowAssignmentHistoryOrderFieldCreatedAt = &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignmenthistory.FieldCreatedAt,
		toTerm: workflowassignmenthistory.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentHistoryOrderFieldUpdatedAt orders WorkflowAssignmentHistory by updated_at.
	WorkflowAssignmentHistoryOrderFieldUpdatedAt = &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignmenthistory.FieldUpdatedAt,
		toTerm: workflowassignmenthistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowAssignmentHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowAssignmentHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowAssignmentHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentHistoryOrderField", str)
	}
	return nil
}

// WorkflowAssignmentHistoryOrderField defines the ordering field of WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignmentHistory.
	Value    func(*WorkflowAssignmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignmenthistory.OrderOption
	toCursor func(*WorkflowAssignmentHistory) Cursor
}

// WorkflowAssignmentHistoryOrder defines the ordering of WorkflowAssignmentHistory.
type WorkflowAssignmentHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *WorkflowAssignmentHistoryOrderField `json:"field"`
}

// DefaultWorkflowAssignmentHistoryOrder is the default ordering of WorkflowAssignmentHistory.
var DefaultWorkflowAssignmentHistoryOrder = &WorkflowAssignmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentHistoryOrderField{
		Value: func(_m *WorkflowAssignmentHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignmenthistory.FieldID,
		toTerm: workflowassignmenthistory.ByID,
		toCursor: func(_m *WorkflowAssignmentHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignmentHistory into WorkflowAssignmentHistoryEdge.
func (_m *WorkflowAssignmentHistory) ToEdge(order *WorkflowAssignmentHistoryOrder) *WorkflowAssignmentHistoryEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentHistoryOrder
	}
	return &WorkflowAssignmentHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentTargetEdge is the edge representation of WorkflowAssignmentTarget.
type WorkflowAssignmentTargetEdge struct {
	Node   *WorkflowAssignmentTarget `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// WorkflowAssignmentTargetConnection is the connection containing edges to WorkflowAssignmentTarget.
type WorkflowAssignmentTargetConnection struct {
	Edges      []*WorkflowAssignmentTargetEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *WorkflowAssignmentTargetConnection) build(nodes []*WorkflowAssignmentTarget, pager *workflowassignmenttargetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignmentTarget
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignmentTarget {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignmentTarget {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentTargetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentTargetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentTargetPaginateOption enables pagination customization.
type WorkflowAssignmentTargetPaginateOption func(*workflowassignmenttargetPager) error

// WithWorkflowAssignmentTargetOrder configures pagination ordering.
func WithWorkflowAssignmentTargetOrder(order []*WorkflowAssignmentTargetOrder) WorkflowAssignmentTargetPaginateOption {
	return func(pager *workflowassignmenttargetPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowAssignmentTargetFilter configures pagination filter.
func WithWorkflowAssignmentTargetFilter(filter func(*WorkflowAssignmentTargetQuery) (*WorkflowAssignmentTargetQuery, error)) WorkflowAssignmentTargetPaginateOption {
	return func(pager *workflowassignmenttargetPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentTargetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmenttargetPager struct {
	reverse bool
	order   []*WorkflowAssignmentTargetOrder
	filter  func(*WorkflowAssignmentTargetQuery) (*WorkflowAssignmentTargetQuery, error)
}

func newWorkflowAssignmentTargetPager(opts []WorkflowAssignmentTargetPaginateOption, reverse bool) (*workflowassignmenttargetPager, error) {
	pager := &workflowassignmenttargetPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowassignmenttargetPager) applyFilter(query *WorkflowAssignmentTargetQuery) (*WorkflowAssignmentTargetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmenttargetPager) toCursor(_m *WorkflowAssignmentTarget) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowassignmenttargetPager) applyCursors(query *WorkflowAssignmentTargetQuery, after, before *Cursor) (*WorkflowAssignmentTargetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowAssignmentTargetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowassignmenttargetPager) applyOrder(query *WorkflowAssignmentTargetQuery) *WorkflowAssignmentTargetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowAssignmentTargetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowAssignmentTargetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowassignmenttargetPager) orderExpr(query *WorkflowAssignmentTargetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowAssignmentTargetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignmentTarget.
func (_m *WorkflowAssignmentTargetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentTargetPaginateOption,
) (*WorkflowAssignmentTargetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentTargetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentTargetConnection{Edges: []*WorkflowAssignmentTargetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentTargetOrderFieldCreatedAt orders WorkflowAssignmentTarget by created_at.
	WorkflowAssignmentTargetOrderFieldCreatedAt = &WorkflowAssignmentTargetOrderField{
		Value: func(_m *WorkflowAssignmentTarget) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignmenttarget.FieldCreatedAt,
		toTerm: workflowassignmenttarget.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignmentTarget) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentTargetOrderFieldUpdatedAt orders WorkflowAssignmentTarget by updated_at.
	WorkflowAssignmentTargetOrderFieldUpdatedAt = &WorkflowAssignmentTargetOrderField{
		Value: func(_m *WorkflowAssignmentTarget) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignmenttarget.FieldUpdatedAt,
		toTerm: workflowassignmenttarget.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignmentTarget) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentTargetOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentTargetOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentTargetOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentTargetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentTargetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentTargetOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowAssignmentTargetOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentTargetOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentTargetOrderField", str)
	}
	return nil
}

// WorkflowAssignmentTargetOrderField defines the ordering field of WorkflowAssignmentTarget.
type WorkflowAssignmentTargetOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignmentTarget.
	Value    func(*WorkflowAssignmentTarget) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignmenttarget.OrderOption
	toCursor func(*WorkflowAssignmentTarget) Cursor
}

// WorkflowAssignmentTargetOrder defines the ordering of WorkflowAssignmentTarget.
type WorkflowAssignmentTargetOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *WorkflowAssignmentTargetOrderField `json:"field"`
}

// DefaultWorkflowAssignmentTargetOrder is the default ordering of WorkflowAssignmentTarget.
var DefaultWorkflowAssignmentTargetOrder = &WorkflowAssignmentTargetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentTargetOrderField{
		Value: func(_m *WorkflowAssignmentTarget) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignmenttarget.FieldID,
		toTerm: workflowassignmenttarget.ByID,
		toCursor: func(_m *WorkflowAssignmentTarget) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignmentTarget into WorkflowAssignmentTargetEdge.
func (_m *WorkflowAssignmentTarget) ToEdge(order *WorkflowAssignmentTargetOrder) *WorkflowAssignmentTargetEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentTargetOrder
	}
	return &WorkflowAssignmentTargetEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentTargetHistoryEdge is the edge representation of WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryEdge struct {
	Node   *WorkflowAssignmentTargetHistory `json:"node"`
	Cursor Cursor                           `json:"cursor"`
}

// WorkflowAssignmentTargetHistoryConnection is the connection containing edges to WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryConnection struct {
	Edges      []*WorkflowAssignmentTargetHistoryEdge `json:"edges"`
	PageInfo   PageInfo                               `json:"pageInfo"`
	TotalCount int                                    `json:"totalCount"`
}

func (c *WorkflowAssignmentTargetHistoryConnection) build(nodes []*WorkflowAssignmentTargetHistory, pager *workflowassignmenttargethistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignmentTargetHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignmentTargetHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignmentTargetHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentTargetHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentTargetHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentTargetHistoryPaginateOption enables pagination customization.
type WorkflowAssignmentTargetHistoryPaginateOption func(*workflowassignmenttargethistoryPager) error

// WithWorkflowAssignmentTargetHistoryOrder configures pagination ordering.
func WithWorkflowAssignmentTargetHistoryOrder(order *WorkflowAssignmentTargetHistoryOrder) WorkflowAssignmentTargetHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowAssignmentTargetHistoryOrder
	}
	o := *order
	return func(pager *workflowassignmenttargethistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowAssignmentTargetHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowAssignmentTargetHistoryFilter configures pagination filter.
func WithWorkflowAssignmentTargetHistoryFilter(filter func(*WorkflowAssignmentTargetHistoryQuery) (*WorkflowAssignmentTargetHistoryQuery, error)) WorkflowAssignmentTargetHistoryPaginateOption {
	return func(pager *workflowassignmenttargethistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentTargetHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmenttargethistoryPager struct {
	reverse bool
	order   *WorkflowAssignmentTargetHistoryOrder
	filter  func(*WorkflowAssignmentTargetHistoryQuery) (*WorkflowAssignmentTargetHistoryQuery, error)
}

func newWorkflowAssignmentTargetHistoryPager(opts []WorkflowAssignmentTargetHistoryPaginateOption, reverse bool) (*workflowassignmenttargethistoryPager, error) {
	pager := &workflowassignmenttargethistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowAssignmentTargetHistoryOrder
	}
	return pager, nil
}

func (p *workflowassignmenttargethistoryPager) applyFilter(query *WorkflowAssignmentTargetHistoryQuery) (*WorkflowAssignmentTargetHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmenttargethistoryPager) toCursor(_m *WorkflowAssignmentTargetHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowassignmenttargethistoryPager) applyCursors(query *WorkflowAssignmentTargetHistoryQuery, after, before *Cursor) (*WorkflowAssignmentTargetHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowAssignmentTargetHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowassignmenttargethistoryPager) applyOrder(query *WorkflowAssignmentTargetHistoryQuery) *WorkflowAssignmentTargetHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowAssignmentTargetHistoryOrder.Field {
		query = query.Order(DefaultWorkflowAssignmentTargetHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowassignmenttargethistoryPager) orderExpr(query *WorkflowAssignmentTargetHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowAssignmentTargetHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowAssignmentTargetHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignmentTargetHistory.
func (_m *WorkflowAssignmentTargetHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentTargetHistoryPaginateOption,
) (*WorkflowAssignmentTargetHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentTargetHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentTargetHistoryConnection{Edges: []*WorkflowAssignmentTargetHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentTargetHistoryOrderFieldHistoryTime orders WorkflowAssignmentTargetHistory by history_time.
	WorkflowAssignmentTargetHistoryOrderFieldHistoryTime = &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowassignmenttargethistory.FieldHistoryTime,
		toTerm: workflowassignmenttargethistory.ByHistoryTime,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowAssignmentTargetHistoryOrderFieldCreatedAt orders WorkflowAssignmentTargetHistory by created_at.
	WorkflowAssignmentTargetHistoryOrderFieldCreatedAt = &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignmenttargethistory.FieldCreatedAt,
		toTerm: workflowassignmenttargethistory.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt orders WorkflowAssignmentTargetHistory by updated_at.
	WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt = &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignmenttargethistory.FieldUpdatedAt,
		toTerm: workflowassignmenttargethistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentTargetHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentTargetHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowAssignmentTargetHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentTargetHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentTargetHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentTargetHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowAssignmentTargetHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowAssignmentTargetHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentTargetHistoryOrderField", str)
	}
	return nil
}

// WorkflowAssignmentTargetHistoryOrderField defines the ordering field of WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignmentTargetHistory.
	Value    func(*WorkflowAssignmentTargetHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignmenttargethistory.OrderOption
	toCursor func(*WorkflowAssignmentTargetHistory) Cursor
}

// WorkflowAssignmentTargetHistoryOrder defines the ordering of WorkflowAssignmentTargetHistory.
type WorkflowAssignmentTargetHistoryOrder struct {
	Direction OrderDirection                             `json:"direction"`
	Field     *WorkflowAssignmentTargetHistoryOrderField `json:"field"`
}

// DefaultWorkflowAssignmentTargetHistoryOrder is the default ordering of WorkflowAssignmentTargetHistory.
var DefaultWorkflowAssignmentTargetHistoryOrder = &WorkflowAssignmentTargetHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentTargetHistoryOrderField{
		Value: func(_m *WorkflowAssignmentTargetHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignmenttargethistory.FieldID,
		toTerm: workflowassignmenttargethistory.ByID,
		toCursor: func(_m *WorkflowAssignmentTargetHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignmentTargetHistory into WorkflowAssignmentTargetHistoryEdge.
func (_m *WorkflowAssignmentTargetHistory) ToEdge(order *WorkflowAssignmentTargetHistoryOrder) *WorkflowAssignmentTargetHistoryEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentTargetHistoryOrder
	}
	return &WorkflowAssignmentTargetHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowDefinitionEdge is the edge representation of WorkflowDefinition.
type WorkflowDefinitionEdge struct {
	Node   *WorkflowDefinition `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// WorkflowDefinitionConnection is the connection containing edges to WorkflowDefinition.
type WorkflowDefinitionConnection struct {
	Edges      []*WorkflowDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *WorkflowDefinitionConnection) build(nodes []*WorkflowDefinition, pager *workflowdefinitionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowDefinition {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowDefinitionPaginateOption enables pagination customization.
type WorkflowDefinitionPaginateOption func(*workflowdefinitionPager) error

// WithWorkflowDefinitionOrder configures pagination ordering.
func WithWorkflowDefinitionOrder(order []*WorkflowDefinitionOrder) WorkflowDefinitionPaginateOption {
	return func(pager *workflowdefinitionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowDefinitionFilter configures pagination filter.
func WithWorkflowDefinitionFilter(filter func(*WorkflowDefinitionQuery) (*WorkflowDefinitionQuery, error)) WorkflowDefinitionPaginateOption {
	return func(pager *workflowdefinitionPager) error {
		if filter == nil {
			return errors.New("WorkflowDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowdefinitionPager struct {
	reverse bool
	order   []*WorkflowDefinitionOrder
	filter  func(*WorkflowDefinitionQuery) (*WorkflowDefinitionQuery, error)
}

func newWorkflowDefinitionPager(opts []WorkflowDefinitionPaginateOption, reverse bool) (*workflowdefinitionPager, error) {
	pager := &workflowdefinitionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowdefinitionPager) applyFilter(query *WorkflowDefinitionQuery) (*WorkflowDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowdefinitionPager) toCursor(_m *WorkflowDefinition) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowdefinitionPager) applyCursors(query *WorkflowDefinitionQuery, after, before *Cursor) (*WorkflowDefinitionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowDefinitionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowdefinitionPager) applyOrder(query *WorkflowDefinitionQuery) *WorkflowDefinitionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowDefinitionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowDefinitionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowdefinitionPager) orderExpr(query *WorkflowDefinitionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowDefinitionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowDefinition.
func (_m *WorkflowDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowDefinitionPaginateOption,
) (*WorkflowDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowDefinitionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowDefinitionConnection{Edges: []*WorkflowDefinitionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowDefinitionOrderFieldCreatedAt orders WorkflowDefinition by created_at.
	WorkflowDefinitionOrderFieldCreatedAt = &WorkflowDefinitionOrderField{
		Value: func(_m *WorkflowDefinition) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowdefinition.FieldCreatedAt,
		toTerm: workflowdefinition.ByCreatedAt,
		toCursor: func(_m *WorkflowDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowDefinitionOrderFieldUpdatedAt orders WorkflowDefinition by updated_at.
	WorkflowDefinitionOrderFieldUpdatedAt = &WorkflowDefinitionOrderField{
		Value: func(_m *WorkflowDefinition) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowdefinition.FieldUpdatedAt,
		toTerm: workflowdefinition.ByUpdatedAt,
		toCursor: func(_m *WorkflowDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowDefinitionOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowDefinitionOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowDefinitionOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowDefinitionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowDefinitionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowDefinitionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowDefinitionOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowDefinitionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowDefinitionOrderField", str)
	}
	return nil
}

// WorkflowDefinitionOrderField defines the ordering field of WorkflowDefinition.
type WorkflowDefinitionOrderField struct {
	// Value extracts the ordering value from the given WorkflowDefinition.
	Value    func(*WorkflowDefinition) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowdefinition.OrderOption
	toCursor func(*WorkflowDefinition) Cursor
}

// WorkflowDefinitionOrder defines the ordering of WorkflowDefinition.
type WorkflowDefinitionOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *WorkflowDefinitionOrderField `json:"field"`
}

// DefaultWorkflowDefinitionOrder is the default ordering of WorkflowDefinition.
var DefaultWorkflowDefinitionOrder = &WorkflowDefinitionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowDefinitionOrderField{
		Value: func(_m *WorkflowDefinition) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowdefinition.FieldID,
		toTerm: workflowdefinition.ByID,
		toCursor: func(_m *WorkflowDefinition) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowDefinition into WorkflowDefinitionEdge.
func (_m *WorkflowDefinition) ToEdge(order *WorkflowDefinitionOrder) *WorkflowDefinitionEdge {
	if order == nil {
		order = DefaultWorkflowDefinitionOrder
	}
	return &WorkflowDefinitionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowDefinitionHistoryEdge is the edge representation of WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryEdge struct {
	Node   *WorkflowDefinitionHistory `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// WorkflowDefinitionHistoryConnection is the connection containing edges to WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryConnection struct {
	Edges      []*WorkflowDefinitionHistoryEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

func (c *WorkflowDefinitionHistoryConnection) build(nodes []*WorkflowDefinitionHistory, pager *workflowdefinitionhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowDefinitionHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowDefinitionHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowDefinitionHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowDefinitionHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowDefinitionHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowDefinitionHistoryPaginateOption enables pagination customization.
type WorkflowDefinitionHistoryPaginateOption func(*workflowdefinitionhistoryPager) error

// WithWorkflowDefinitionHistoryOrder configures pagination ordering.
func WithWorkflowDefinitionHistoryOrder(order *WorkflowDefinitionHistoryOrder) WorkflowDefinitionHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowDefinitionHistoryOrder
	}
	o := *order
	return func(pager *workflowdefinitionhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowDefinitionHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowDefinitionHistoryFilter configures pagination filter.
func WithWorkflowDefinitionHistoryFilter(filter func(*WorkflowDefinitionHistoryQuery) (*WorkflowDefinitionHistoryQuery, error)) WorkflowDefinitionHistoryPaginateOption {
	return func(pager *workflowdefinitionhistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowDefinitionHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowdefinitionhistoryPager struct {
	reverse bool
	order   *WorkflowDefinitionHistoryOrder
	filter  func(*WorkflowDefinitionHistoryQuery) (*WorkflowDefinitionHistoryQuery, error)
}

func newWorkflowDefinitionHistoryPager(opts []WorkflowDefinitionHistoryPaginateOption, reverse bool) (*workflowdefinitionhistoryPager, error) {
	pager := &workflowdefinitionhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowDefinitionHistoryOrder
	}
	return pager, nil
}

func (p *workflowdefinitionhistoryPager) applyFilter(query *WorkflowDefinitionHistoryQuery) (*WorkflowDefinitionHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowdefinitionhistoryPager) toCursor(_m *WorkflowDefinitionHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowdefinitionhistoryPager) applyCursors(query *WorkflowDefinitionHistoryQuery, after, before *Cursor) (*WorkflowDefinitionHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowDefinitionHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowdefinitionhistoryPager) applyOrder(query *WorkflowDefinitionHistoryQuery) *WorkflowDefinitionHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowDefinitionHistoryOrder.Field {
		query = query.Order(DefaultWorkflowDefinitionHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowdefinitionhistoryPager) orderExpr(query *WorkflowDefinitionHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowDefinitionHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowDefinitionHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowDefinitionHistory.
func (_m *WorkflowDefinitionHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowDefinitionHistoryPaginateOption,
) (*WorkflowDefinitionHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowDefinitionHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowDefinitionHistoryConnection{Edges: []*WorkflowDefinitionHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowDefinitionHistoryOrderFieldHistoryTime orders WorkflowDefinitionHistory by history_time.
	WorkflowDefinitionHistoryOrderFieldHistoryTime = &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowdefinitionhistory.FieldHistoryTime,
		toTerm: workflowdefinitionhistory.ByHistoryTime,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowDefinitionHistoryOrderFieldCreatedAt orders WorkflowDefinitionHistory by created_at.
	WorkflowDefinitionHistoryOrderFieldCreatedAt = &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowdefinitionhistory.FieldCreatedAt,
		toTerm: workflowdefinitionhistory.ByCreatedAt,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowDefinitionHistoryOrderFieldUpdatedAt orders WorkflowDefinitionHistory by updated_at.
	WorkflowDefinitionHistoryOrderFieldUpdatedAt = &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowdefinitionhistory.FieldUpdatedAt,
		toTerm: workflowdefinitionhistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowDefinitionHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowDefinitionHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowDefinitionHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowDefinitionHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowDefinitionHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowDefinitionHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowDefinitionHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowDefinitionHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowDefinitionHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowDefinitionHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowDefinitionHistoryOrderField", str)
	}
	return nil
}

// WorkflowDefinitionHistoryOrderField defines the ordering field of WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowDefinitionHistory.
	Value    func(*WorkflowDefinitionHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowdefinitionhistory.OrderOption
	toCursor func(*WorkflowDefinitionHistory) Cursor
}

// WorkflowDefinitionHistoryOrder defines the ordering of WorkflowDefinitionHistory.
type WorkflowDefinitionHistoryOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *WorkflowDefinitionHistoryOrderField `json:"field"`
}

// DefaultWorkflowDefinitionHistoryOrder is the default ordering of WorkflowDefinitionHistory.
var DefaultWorkflowDefinitionHistoryOrder = &WorkflowDefinitionHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowDefinitionHistoryOrderField{
		Value: func(_m *WorkflowDefinitionHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowdefinitionhistory.FieldID,
		toTerm: workflowdefinitionhistory.ByID,
		toCursor: func(_m *WorkflowDefinitionHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowDefinitionHistory into WorkflowDefinitionHistoryEdge.
func (_m *WorkflowDefinitionHistory) ToEdge(order *WorkflowDefinitionHistoryOrder) *WorkflowDefinitionHistoryEdge {
	if order == nil {
		order = DefaultWorkflowDefinitionHistoryOrder
	}
	return &WorkflowDefinitionHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowEventEdge is the edge representation of WorkflowEvent.
type WorkflowEventEdge struct {
	Node   *WorkflowEvent `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// WorkflowEventConnection is the connection containing edges to WorkflowEvent.
type WorkflowEventConnection struct {
	Edges      []*WorkflowEventEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *WorkflowEventConnection) build(nodes []*WorkflowEvent, pager *workfloweventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowEvent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowEvent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowEvent {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowEventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowEventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowEventPaginateOption enables pagination customization.
type WorkflowEventPaginateOption func(*workfloweventPager) error

// WithWorkflowEventOrder configures pagination ordering.
func WithWorkflowEventOrder(order []*WorkflowEventOrder) WorkflowEventPaginateOption {
	return func(pager *workfloweventPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowEventFilter configures pagination filter.
func WithWorkflowEventFilter(filter func(*WorkflowEventQuery) (*WorkflowEventQuery, error)) WorkflowEventPaginateOption {
	return func(pager *workfloweventPager) error {
		if filter == nil {
			return errors.New("WorkflowEventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workfloweventPager struct {
	reverse bool
	order   []*WorkflowEventOrder
	filter  func(*WorkflowEventQuery) (*WorkflowEventQuery, error)
}

func newWorkflowEventPager(opts []WorkflowEventPaginateOption, reverse bool) (*workfloweventPager, error) {
	pager := &workfloweventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workfloweventPager) applyFilter(query *WorkflowEventQuery) (*WorkflowEventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workfloweventPager) toCursor(_m *WorkflowEvent) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workfloweventPager) applyCursors(query *WorkflowEventQuery, after, before *Cursor) (*WorkflowEventQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowEventOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workfloweventPager) applyOrder(query *WorkflowEventQuery) *WorkflowEventQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowEventOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workfloweventPager) orderExpr(query *WorkflowEventQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowEventOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowEvent.
func (_m *WorkflowEventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowEventPaginateOption,
) (*WorkflowEventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowEventConnection{Edges: []*WorkflowEventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowEventOrderFieldCreatedAt orders WorkflowEvent by created_at.
	WorkflowEventOrderFieldCreatedAt = &WorkflowEventOrderField{
		Value: func(_m *WorkflowEvent) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowevent.FieldCreatedAt,
		toTerm: workflowevent.ByCreatedAt,
		toCursor: func(_m *WorkflowEvent) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowEventOrderFieldUpdatedAt orders WorkflowEvent by updated_at.
	WorkflowEventOrderFieldUpdatedAt = &WorkflowEventOrderField{
		Value: func(_m *WorkflowEvent) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowevent.FieldUpdatedAt,
		toTerm: workflowevent.ByUpdatedAt,
		toCursor: func(_m *WorkflowEvent) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowEventOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowEventOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowEventOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowEventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowEventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowEventOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowEventOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowEventOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowEventOrderField", str)
	}
	return nil
}

// WorkflowEventOrderField defines the ordering field of WorkflowEvent.
type WorkflowEventOrderField struct {
	// Value extracts the ordering value from the given WorkflowEvent.
	Value    func(*WorkflowEvent) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowevent.OrderOption
	toCursor func(*WorkflowEvent) Cursor
}

// WorkflowEventOrder defines the ordering of WorkflowEvent.
type WorkflowEventOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *WorkflowEventOrderField `json:"field"`
}

// DefaultWorkflowEventOrder is the default ordering of WorkflowEvent.
var DefaultWorkflowEventOrder = &WorkflowEventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowEventOrderField{
		Value: func(_m *WorkflowEvent) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowevent.FieldID,
		toTerm: workflowevent.ByID,
		toCursor: func(_m *WorkflowEvent) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowEvent into WorkflowEventEdge.
func (_m *WorkflowEvent) ToEdge(order *WorkflowEventOrder) *WorkflowEventEdge {
	if order == nil {
		order = DefaultWorkflowEventOrder
	}
	return &WorkflowEventEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowEventHistoryEdge is the edge representation of WorkflowEventHistory.
type WorkflowEventHistoryEdge struct {
	Node   *WorkflowEventHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// WorkflowEventHistoryConnection is the connection containing edges to WorkflowEventHistory.
type WorkflowEventHistoryConnection struct {
	Edges      []*WorkflowEventHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *WorkflowEventHistoryConnection) build(nodes []*WorkflowEventHistory, pager *workfloweventhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowEventHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowEventHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowEventHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowEventHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowEventHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowEventHistoryPaginateOption enables pagination customization.
type WorkflowEventHistoryPaginateOption func(*workfloweventhistoryPager) error

// WithWorkflowEventHistoryOrder configures pagination ordering.
func WithWorkflowEventHistoryOrder(order *WorkflowEventHistoryOrder) WorkflowEventHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowEventHistoryOrder
	}
	o := *order
	return func(pager *workfloweventhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowEventHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowEventHistoryFilter configures pagination filter.
func WithWorkflowEventHistoryFilter(filter func(*WorkflowEventHistoryQuery) (*WorkflowEventHistoryQuery, error)) WorkflowEventHistoryPaginateOption {
	return func(pager *workfloweventhistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowEventHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workfloweventhistoryPager struct {
	reverse bool
	order   *WorkflowEventHistoryOrder
	filter  func(*WorkflowEventHistoryQuery) (*WorkflowEventHistoryQuery, error)
}

func newWorkflowEventHistoryPager(opts []WorkflowEventHistoryPaginateOption, reverse bool) (*workfloweventhistoryPager, error) {
	pager := &workfloweventhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowEventHistoryOrder
	}
	return pager, nil
}

func (p *workfloweventhistoryPager) applyFilter(query *WorkflowEventHistoryQuery) (*WorkflowEventHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workfloweventhistoryPager) toCursor(_m *WorkflowEventHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workfloweventhistoryPager) applyCursors(query *WorkflowEventHistoryQuery, after, before *Cursor) (*WorkflowEventHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowEventHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workfloweventhistoryPager) applyOrder(query *WorkflowEventHistoryQuery) *WorkflowEventHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowEventHistoryOrder.Field {
		query = query.Order(DefaultWorkflowEventHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workfloweventhistoryPager) orderExpr(query *WorkflowEventHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowEventHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowEventHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowEventHistory.
func (_m *WorkflowEventHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowEventHistoryPaginateOption,
) (*WorkflowEventHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowEventHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowEventHistoryConnection{Edges: []*WorkflowEventHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowEventHistoryOrderFieldHistoryTime orders WorkflowEventHistory by history_time.
	WorkflowEventHistoryOrderFieldHistoryTime = &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workfloweventhistory.FieldHistoryTime,
		toTerm: workfloweventhistory.ByHistoryTime,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowEventHistoryOrderFieldCreatedAt orders WorkflowEventHistory by created_at.
	WorkflowEventHistoryOrderFieldCreatedAt = &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workfloweventhistory.FieldCreatedAt,
		toTerm: workfloweventhistory.ByCreatedAt,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowEventHistoryOrderFieldUpdatedAt orders WorkflowEventHistory by updated_at.
	WorkflowEventHistoryOrderFieldUpdatedAt = &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workfloweventhistory.FieldUpdatedAt,
		toTerm: workfloweventhistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowEventHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowEventHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowEventHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowEventHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowEventHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowEventHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowEventHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowEventHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowEventHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowEventHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowEventHistoryOrderField", str)
	}
	return nil
}

// WorkflowEventHistoryOrderField defines the ordering field of WorkflowEventHistory.
type WorkflowEventHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowEventHistory.
	Value    func(*WorkflowEventHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workfloweventhistory.OrderOption
	toCursor func(*WorkflowEventHistory) Cursor
}

// WorkflowEventHistoryOrder defines the ordering of WorkflowEventHistory.
type WorkflowEventHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *WorkflowEventHistoryOrderField `json:"field"`
}

// DefaultWorkflowEventHistoryOrder is the default ordering of WorkflowEventHistory.
var DefaultWorkflowEventHistoryOrder = &WorkflowEventHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowEventHistoryOrderField{
		Value: func(_m *WorkflowEventHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workfloweventhistory.FieldID,
		toTerm: workfloweventhistory.ByID,
		toCursor: func(_m *WorkflowEventHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowEventHistory into WorkflowEventHistoryEdge.
func (_m *WorkflowEventHistory) ToEdge(order *WorkflowEventHistoryOrder) *WorkflowEventHistoryEdge {
	if order == nil {
		order = DefaultWorkflowEventHistoryOrder
	}
	return &WorkflowEventHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowInstanceEdge is the edge representation of WorkflowInstance.
type WorkflowInstanceEdge struct {
	Node   *WorkflowInstance `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// WorkflowInstanceConnection is the connection containing edges to WorkflowInstance.
type WorkflowInstanceConnection struct {
	Edges      []*WorkflowInstanceEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *WorkflowInstanceConnection) build(nodes []*WorkflowInstance, pager *workflowinstancePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowInstance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowInstance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowInstance {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowInstanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowInstanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowInstancePaginateOption enables pagination customization.
type WorkflowInstancePaginateOption func(*workflowinstancePager) error

// WithWorkflowInstanceOrder configures pagination ordering.
func WithWorkflowInstanceOrder(order []*WorkflowInstanceOrder) WorkflowInstancePaginateOption {
	return func(pager *workflowinstancePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowInstanceFilter configures pagination filter.
func WithWorkflowInstanceFilter(filter func(*WorkflowInstanceQuery) (*WorkflowInstanceQuery, error)) WorkflowInstancePaginateOption {
	return func(pager *workflowinstancePager) error {
		if filter == nil {
			return errors.New("WorkflowInstanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowinstancePager struct {
	reverse bool
	order   []*WorkflowInstanceOrder
	filter  func(*WorkflowInstanceQuery) (*WorkflowInstanceQuery, error)
}

func newWorkflowInstancePager(opts []WorkflowInstancePaginateOption, reverse bool) (*workflowinstancePager, error) {
	pager := &workflowinstancePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowinstancePager) applyFilter(query *WorkflowInstanceQuery) (*WorkflowInstanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowinstancePager) toCursor(_m *WorkflowInstance) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowinstancePager) applyCursors(query *WorkflowInstanceQuery, after, before *Cursor) (*WorkflowInstanceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowInstanceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowinstancePager) applyOrder(query *WorkflowInstanceQuery) *WorkflowInstanceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowInstanceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowInstanceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowinstancePager) orderExpr(query *WorkflowInstanceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowInstanceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowInstance.
func (_m *WorkflowInstanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowInstancePaginateOption,
) (*WorkflowInstanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowInstancePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowInstanceConnection{Edges: []*WorkflowInstanceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowInstanceOrderFieldCreatedAt orders WorkflowInstance by created_at.
	WorkflowInstanceOrderFieldCreatedAt = &WorkflowInstanceOrderField{
		Value: func(_m *WorkflowInstance) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowinstance.FieldCreatedAt,
		toTerm: workflowinstance.ByCreatedAt,
		toCursor: func(_m *WorkflowInstance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowInstanceOrderFieldUpdatedAt orders WorkflowInstance by updated_at.
	WorkflowInstanceOrderFieldUpdatedAt = &WorkflowInstanceOrderField{
		Value: func(_m *WorkflowInstance) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowinstance.FieldUpdatedAt,
		toTerm: workflowinstance.ByUpdatedAt,
		toCursor: func(_m *WorkflowInstance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowInstanceOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowInstanceOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowInstanceOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowInstanceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowInstanceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowInstanceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowInstanceOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowInstanceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowInstanceOrderField", str)
	}
	return nil
}

// WorkflowInstanceOrderField defines the ordering field of WorkflowInstance.
type WorkflowInstanceOrderField struct {
	// Value extracts the ordering value from the given WorkflowInstance.
	Value    func(*WorkflowInstance) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowinstance.OrderOption
	toCursor func(*WorkflowInstance) Cursor
}

// WorkflowInstanceOrder defines the ordering of WorkflowInstance.
type WorkflowInstanceOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *WorkflowInstanceOrderField `json:"field"`
}

// DefaultWorkflowInstanceOrder is the default ordering of WorkflowInstance.
var DefaultWorkflowInstanceOrder = &WorkflowInstanceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowInstanceOrderField{
		Value: func(_m *WorkflowInstance) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowinstance.FieldID,
		toTerm: workflowinstance.ByID,
		toCursor: func(_m *WorkflowInstance) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowInstance into WorkflowInstanceEdge.
func (_m *WorkflowInstance) ToEdge(order *WorkflowInstanceOrder) *WorkflowInstanceEdge {
	if order == nil {
		order = DefaultWorkflowInstanceOrder
	}
	return &WorkflowInstanceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowInstanceHistoryEdge is the edge representation of WorkflowInstanceHistory.
type WorkflowInstanceHistoryEdge struct {
	Node   *WorkflowInstanceHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// WorkflowInstanceHistoryConnection is the connection containing edges to WorkflowInstanceHistory.
type WorkflowInstanceHistoryConnection struct {
	Edges      []*WorkflowInstanceHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *WorkflowInstanceHistoryConnection) build(nodes []*WorkflowInstanceHistory, pager *workflowinstancehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowInstanceHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowInstanceHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowInstanceHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowInstanceHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowInstanceHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowInstanceHistoryPaginateOption enables pagination customization.
type WorkflowInstanceHistoryPaginateOption func(*workflowinstancehistoryPager) error

// WithWorkflowInstanceHistoryOrder configures pagination ordering.
func WithWorkflowInstanceHistoryOrder(order *WorkflowInstanceHistoryOrder) WorkflowInstanceHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowInstanceHistoryOrder
	}
	o := *order
	return func(pager *workflowinstancehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowInstanceHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowInstanceHistoryFilter configures pagination filter.
func WithWorkflowInstanceHistoryFilter(filter func(*WorkflowInstanceHistoryQuery) (*WorkflowInstanceHistoryQuery, error)) WorkflowInstanceHistoryPaginateOption {
	return func(pager *workflowinstancehistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowInstanceHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowinstancehistoryPager struct {
	reverse bool
	order   *WorkflowInstanceHistoryOrder
	filter  func(*WorkflowInstanceHistoryQuery) (*WorkflowInstanceHistoryQuery, error)
}

func newWorkflowInstanceHistoryPager(opts []WorkflowInstanceHistoryPaginateOption, reverse bool) (*workflowinstancehistoryPager, error) {
	pager := &workflowinstancehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowInstanceHistoryOrder
	}
	return pager, nil
}

func (p *workflowinstancehistoryPager) applyFilter(query *WorkflowInstanceHistoryQuery) (*WorkflowInstanceHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowinstancehistoryPager) toCursor(_m *WorkflowInstanceHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowinstancehistoryPager) applyCursors(query *WorkflowInstanceHistoryQuery, after, before *Cursor) (*WorkflowInstanceHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowInstanceHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowinstancehistoryPager) applyOrder(query *WorkflowInstanceHistoryQuery) *WorkflowInstanceHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowInstanceHistoryOrder.Field {
		query = query.Order(DefaultWorkflowInstanceHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowinstancehistoryPager) orderExpr(query *WorkflowInstanceHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowInstanceHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowInstanceHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowInstanceHistory.
func (_m *WorkflowInstanceHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowInstanceHistoryPaginateOption,
) (*WorkflowInstanceHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowInstanceHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowInstanceHistoryConnection{Edges: []*WorkflowInstanceHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowInstanceHistoryOrderFieldHistoryTime orders WorkflowInstanceHistory by history_time.
	WorkflowInstanceHistoryOrderFieldHistoryTime = &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowinstancehistory.FieldHistoryTime,
		toTerm: workflowinstancehistory.ByHistoryTime,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowInstanceHistoryOrderFieldCreatedAt orders WorkflowInstanceHistory by created_at.
	WorkflowInstanceHistoryOrderFieldCreatedAt = &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowinstancehistory.FieldCreatedAt,
		toTerm: workflowinstancehistory.ByCreatedAt,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowInstanceHistoryOrderFieldUpdatedAt orders WorkflowInstanceHistory by updated_at.
	WorkflowInstanceHistoryOrderFieldUpdatedAt = &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowinstancehistory.FieldUpdatedAt,
		toTerm: workflowinstancehistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowInstanceHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowInstanceHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowInstanceHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowInstanceHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowInstanceHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowInstanceHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowInstanceHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowInstanceHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowInstanceHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowInstanceHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowInstanceHistoryOrderField", str)
	}
	return nil
}

// WorkflowInstanceHistoryOrderField defines the ordering field of WorkflowInstanceHistory.
type WorkflowInstanceHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowInstanceHistory.
	Value    func(*WorkflowInstanceHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowinstancehistory.OrderOption
	toCursor func(*WorkflowInstanceHistory) Cursor
}

// WorkflowInstanceHistoryOrder defines the ordering of WorkflowInstanceHistory.
type WorkflowInstanceHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *WorkflowInstanceHistoryOrderField `json:"field"`
}

// DefaultWorkflowInstanceHistoryOrder is the default ordering of WorkflowInstanceHistory.
var DefaultWorkflowInstanceHistoryOrder = &WorkflowInstanceHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowInstanceHistoryOrderField{
		Value: func(_m *WorkflowInstanceHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowinstancehistory.FieldID,
		toTerm: workflowinstancehistory.ByID,
		toCursor: func(_m *WorkflowInstanceHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowInstanceHistory into WorkflowInstanceHistoryEdge.
func (_m *WorkflowInstanceHistory) ToEdge(order *WorkflowInstanceHistoryOrder) *WorkflowInstanceHistoryEdge {
	if order == nil {
		order = DefaultWorkflowInstanceHistoryOrder
	}
	return &WorkflowInstanceHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowObjectRefEdge is the edge representation of WorkflowObjectRef.
type WorkflowObjectRefEdge struct {
	Node   *WorkflowObjectRef `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// WorkflowObjectRefConnection is the connection containing edges to WorkflowObjectRef.
type WorkflowObjectRefConnection struct {
	Edges      []*WorkflowObjectRefEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *WorkflowObjectRefConnection) build(nodes []*WorkflowObjectRef, pager *workflowobjectrefPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowObjectRef
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowObjectRef {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowObjectRef {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowObjectRefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowObjectRefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowObjectRefPaginateOption enables pagination customization.
type WorkflowObjectRefPaginateOption func(*workflowobjectrefPager) error

// WithWorkflowObjectRefOrder configures pagination ordering.
func WithWorkflowObjectRefOrder(order []*WorkflowObjectRefOrder) WorkflowObjectRefPaginateOption {
	return func(pager *workflowobjectrefPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowObjectRefFilter configures pagination filter.
func WithWorkflowObjectRefFilter(filter func(*WorkflowObjectRefQuery) (*WorkflowObjectRefQuery, error)) WorkflowObjectRefPaginateOption {
	return func(pager *workflowobjectrefPager) error {
		if filter == nil {
			return errors.New("WorkflowObjectRefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowobjectrefPager struct {
	reverse bool
	order   []*WorkflowObjectRefOrder
	filter  func(*WorkflowObjectRefQuery) (*WorkflowObjectRefQuery, error)
}

func newWorkflowObjectRefPager(opts []WorkflowObjectRefPaginateOption, reverse bool) (*workflowobjectrefPager, error) {
	pager := &workflowobjectrefPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowobjectrefPager) applyFilter(query *WorkflowObjectRefQuery) (*WorkflowObjectRefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowobjectrefPager) toCursor(_m *WorkflowObjectRef) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowobjectrefPager) applyCursors(query *WorkflowObjectRefQuery, after, before *Cursor) (*WorkflowObjectRefQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowObjectRefOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowobjectrefPager) applyOrder(query *WorkflowObjectRefQuery) *WorkflowObjectRefQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowObjectRefOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowObjectRefOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowobjectrefPager) orderExpr(query *WorkflowObjectRefQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowObjectRefOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowObjectRef.
func (_m *WorkflowObjectRefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowObjectRefPaginateOption,
) (*WorkflowObjectRefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowObjectRefPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowObjectRefConnection{Edges: []*WorkflowObjectRefEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowObjectRefOrderFieldCreatedAt orders WorkflowObjectRef by created_at.
	WorkflowObjectRefOrderFieldCreatedAt = &WorkflowObjectRefOrderField{
		Value: func(_m *WorkflowObjectRef) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowobjectref.FieldCreatedAt,
		toTerm: workflowobjectref.ByCreatedAt,
		toCursor: func(_m *WorkflowObjectRef) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowObjectRefOrderFieldUpdatedAt orders WorkflowObjectRef by updated_at.
	WorkflowObjectRefOrderFieldUpdatedAt = &WorkflowObjectRefOrderField{
		Value: func(_m *WorkflowObjectRef) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowobjectref.FieldUpdatedAt,
		toTerm: workflowobjectref.ByUpdatedAt,
		toCursor: func(_m *WorkflowObjectRef) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowObjectRefOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowObjectRefOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowObjectRefOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowObjectRefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowObjectRefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowObjectRefOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowObjectRefOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowObjectRefOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowObjectRefOrderField", str)
	}
	return nil
}

// WorkflowObjectRefOrderField defines the ordering field of WorkflowObjectRef.
type WorkflowObjectRefOrderField struct {
	// Value extracts the ordering value from the given WorkflowObjectRef.
	Value    func(*WorkflowObjectRef) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowobjectref.OrderOption
	toCursor func(*WorkflowObjectRef) Cursor
}

// WorkflowObjectRefOrder defines the ordering of WorkflowObjectRef.
type WorkflowObjectRefOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *WorkflowObjectRefOrderField `json:"field"`
}

// DefaultWorkflowObjectRefOrder is the default ordering of WorkflowObjectRef.
var DefaultWorkflowObjectRefOrder = &WorkflowObjectRefOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowObjectRefOrderField{
		Value: func(_m *WorkflowObjectRef) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowobjectref.FieldID,
		toTerm: workflowobjectref.ByID,
		toCursor: func(_m *WorkflowObjectRef) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowObjectRef into WorkflowObjectRefEdge.
func (_m *WorkflowObjectRef) ToEdge(order *WorkflowObjectRefOrder) *WorkflowObjectRefEdge {
	if order == nil {
		order = DefaultWorkflowObjectRefOrder
	}
	return &WorkflowObjectRefEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowObjectRefHistoryEdge is the edge representation of WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryEdge struct {
	Node   *WorkflowObjectRefHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// WorkflowObjectRefHistoryConnection is the connection containing edges to WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryConnection struct {
	Edges      []*WorkflowObjectRefHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *WorkflowObjectRefHistoryConnection) build(nodes []*WorkflowObjectRefHistory, pager *workflowobjectrefhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowObjectRefHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowObjectRefHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowObjectRefHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowObjectRefHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowObjectRefHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowObjectRefHistoryPaginateOption enables pagination customization.
type WorkflowObjectRefHistoryPaginateOption func(*workflowobjectrefhistoryPager) error

// WithWorkflowObjectRefHistoryOrder configures pagination ordering.
func WithWorkflowObjectRefHistoryOrder(order *WorkflowObjectRefHistoryOrder) WorkflowObjectRefHistoryPaginateOption {
	if order == nil {
		order = DefaultWorkflowObjectRefHistoryOrder
	}
	o := *order
	return func(pager *workflowobjectrefhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowObjectRefHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowObjectRefHistoryFilter configures pagination filter.
func WithWorkflowObjectRefHistoryFilter(filter func(*WorkflowObjectRefHistoryQuery) (*WorkflowObjectRefHistoryQuery, error)) WorkflowObjectRefHistoryPaginateOption {
	return func(pager *workflowobjectrefhistoryPager) error {
		if filter == nil {
			return errors.New("WorkflowObjectRefHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowobjectrefhistoryPager struct {
	reverse bool
	order   *WorkflowObjectRefHistoryOrder
	filter  func(*WorkflowObjectRefHistoryQuery) (*WorkflowObjectRefHistoryQuery, error)
}

func newWorkflowObjectRefHistoryPager(opts []WorkflowObjectRefHistoryPaginateOption, reverse bool) (*workflowobjectrefhistoryPager, error) {
	pager := &workflowobjectrefhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowObjectRefHistoryOrder
	}
	return pager, nil
}

func (p *workflowobjectrefhistoryPager) applyFilter(query *WorkflowObjectRefHistoryQuery) (*WorkflowObjectRefHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowobjectrefhistoryPager) toCursor(_m *WorkflowObjectRefHistory) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *workflowobjectrefhistoryPager) applyCursors(query *WorkflowObjectRefHistoryQuery, after, before *Cursor) (*WorkflowObjectRefHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkflowObjectRefHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workflowobjectrefhistoryPager) applyOrder(query *WorkflowObjectRefHistoryQuery) *WorkflowObjectRefHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkflowObjectRefHistoryOrder.Field {
		query = query.Order(DefaultWorkflowObjectRefHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workflowobjectrefhistoryPager) orderExpr(query *WorkflowObjectRefHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkflowObjectRefHistoryOrder.Field {
			b.Comma().Ident(DefaultWorkflowObjectRefHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowObjectRefHistory.
func (_m *WorkflowObjectRefHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowObjectRefHistoryPaginateOption,
) (*WorkflowObjectRefHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowObjectRefHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowObjectRefHistoryConnection{Edges: []*WorkflowObjectRefHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowObjectRefHistoryOrderFieldHistoryTime orders WorkflowObjectRefHistory by history_time.
	WorkflowObjectRefHistoryOrderFieldHistoryTime = &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.HistoryTime, nil
		},
		column: workflowobjectrefhistory.FieldHistoryTime,
		toTerm: workflowobjectrefhistory.ByHistoryTime,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.HistoryTime,
			}
		},
	}
	// WorkflowObjectRefHistoryOrderFieldCreatedAt orders WorkflowObjectRefHistory by created_at.
	WorkflowObjectRefHistoryOrderFieldCreatedAt = &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowobjectrefhistory.FieldCreatedAt,
		toTerm: workflowobjectrefhistory.ByCreatedAt,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowObjectRefHistoryOrderFieldUpdatedAt orders WorkflowObjectRefHistory by updated_at.
	WorkflowObjectRefHistoryOrderFieldUpdatedAt = &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowobjectrefhistory.FieldUpdatedAt,
		toTerm: workflowobjectrefhistory.ByUpdatedAt,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowObjectRefHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowObjectRefHistoryOrderFieldHistoryTime.column:
		str = "history_time"
	case WorkflowObjectRefHistoryOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowObjectRefHistoryOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowObjectRefHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowObjectRefHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowObjectRefHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "history_time":
		*f = *WorkflowObjectRefHistoryOrderFieldHistoryTime
	case "created_at":
		*f = *WorkflowObjectRefHistoryOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowObjectRefHistoryOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowObjectRefHistoryOrderField", str)
	}
	return nil
}

// WorkflowObjectRefHistoryOrderField defines the ordering field of WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryOrderField struct {
	// Value extracts the ordering value from the given WorkflowObjectRefHistory.
	Value    func(*WorkflowObjectRefHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowobjectrefhistory.OrderOption
	toCursor func(*WorkflowObjectRefHistory) Cursor
}

// WorkflowObjectRefHistoryOrder defines the ordering of WorkflowObjectRefHistory.
type WorkflowObjectRefHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *WorkflowObjectRefHistoryOrderField `json:"field"`
}

// DefaultWorkflowObjectRefHistoryOrder is the default ordering of WorkflowObjectRefHistory.
var DefaultWorkflowObjectRefHistoryOrder = &WorkflowObjectRefHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowObjectRefHistoryOrderField{
		Value: func(_m *WorkflowObjectRefHistory) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowobjectrefhistory.FieldID,
		toTerm: workflowobjectrefhistory.ByID,
		toCursor: func(_m *WorkflowObjectRefHistory) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowObjectRefHistory into WorkflowObjectRefHistoryEdge.
func (_m *WorkflowObjectRefHistory) ToEdge(order *WorkflowObjectRefHistoryOrder) *WorkflowObjectRefHistoryEdge {
	if order == nil {
		order = DefaultWorkflowObjectRefHistoryOrder
	}
	return &WorkflowObjectRefHistoryEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
