// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlement"
	"github.com/theopenlane/core/internal/ent/generated/entitlementhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplan"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeature"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeaturehistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/eventhistory"
	"github.com/theopenlane/core/internal/ent/generated/feature"
	"github.com/theopenlane/core/internal/ent/generated/featurehistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/oauthprovider"
	"github.com/theopenlane/core/internal/ent/generated/oauthproviderhistory"
	"github.com/theopenlane/core/internal/ent/generated/ohauthtootoken"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/webhook"
	"github.com/theopenlane/core/internal/ent/generated/webhookhistory"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// APITokenEdge is the edge representation of APIToken.
type APITokenEdge struct {
	Node   *APIToken `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// APITokenConnection is the connection containing edges to APIToken.
type APITokenConnection struct {
	Edges      []*APITokenEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *APITokenConnection) build(nodes []*APIToken, pager *apitokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *APIToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *APIToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *APIToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*APITokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &APITokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// APITokenPaginateOption enables pagination customization.
type APITokenPaginateOption func(*apitokenPager) error

// WithAPITokenOrder configures pagination ordering.
func WithAPITokenOrder(order *APITokenOrder) APITokenPaginateOption {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	o := *order
	return func(pager *apitokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAPITokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAPITokenFilter configures pagination filter.
func WithAPITokenFilter(filter func(*APITokenQuery) (*APITokenQuery, error)) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		if filter == nil {
			return errors.New("APITokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apitokenPager struct {
	reverse bool
	order   *APITokenOrder
	filter  func(*APITokenQuery) (*APITokenQuery, error)
}

func newAPITokenPager(opts []APITokenPaginateOption, reverse bool) (*apitokenPager, error) {
	pager := &apitokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAPITokenOrder
	}
	return pager, nil
}

func (p *apitokenPager) applyFilter(query *APITokenQuery) (*APITokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apitokenPager) toCursor(at *APIToken) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *apitokenPager) applyCursors(query *APITokenQuery, after, before *Cursor) (*APITokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAPITokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *apitokenPager) applyOrder(query *APITokenQuery) *APITokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAPITokenOrder.Field {
		query = query.Order(DefaultAPITokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *apitokenPager) orderExpr(query *APITokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAPITokenOrder.Field {
			b.Comma().Ident(DefaultAPITokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to APIToken.
func (at *APITokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...APITokenPaginateOption,
) (*APITokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAPITokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &APITokenConnection{Edges: []*APITokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := at.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if at, err = pager.applyCursors(at, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	at = pager.applyOrder(at)
	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// APITokenOrderField defines the ordering field of APIToken.
type APITokenOrderField struct {
	// Value extracts the ordering value from the given APIToken.
	Value    func(*APIToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apitoken.OrderOption
	toCursor func(*APIToken) Cursor
}

// APITokenOrder defines the ordering of APIToken.
type APITokenOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *APITokenOrderField `json:"field"`
}

// DefaultAPITokenOrder is the default ordering of APIToken.
var DefaultAPITokenOrder = &APITokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.ID, nil
		},
		column: apitoken.FieldID,
		toTerm: apitoken.ByID,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts APIToken into APITokenEdge.
func (at *APIToken) ToEdge(order *APITokenOrder) *APITokenEdge {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	return &APITokenEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// ActionPlanEdge is the edge representation of ActionPlan.
type ActionPlanEdge struct {
	Node   *ActionPlan `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ActionPlanConnection is the connection containing edges to ActionPlan.
type ActionPlanConnection struct {
	Edges      []*ActionPlanEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ActionPlanConnection) build(nodes []*ActionPlan, pager *actionplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ActionPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanPaginateOption enables pagination customization.
type ActionPlanPaginateOption func(*actionplanPager) error

// WithActionPlanOrder configures pagination ordering.
func WithActionPlanOrder(order *ActionPlanOrder) ActionPlanPaginateOption {
	if order == nil {
		order = DefaultActionPlanOrder
	}
	o := *order
	return func(pager *actionplanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActionPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActionPlanFilter configures pagination filter.
func WithActionPlanFilter(filter func(*ActionPlanQuery) (*ActionPlanQuery, error)) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		if filter == nil {
			return errors.New("ActionPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanPager struct {
	reverse bool
	order   *ActionPlanOrder
	filter  func(*ActionPlanQuery) (*ActionPlanQuery, error)
}

func newActionPlanPager(opts []ActionPlanPaginateOption, reverse bool) (*actionplanPager, error) {
	pager := &actionplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActionPlanOrder
	}
	return pager, nil
}

func (p *actionplanPager) applyFilter(query *ActionPlanQuery) (*ActionPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanPager) toCursor(ap *ActionPlan) Cursor {
	return p.order.Field.toCursor(ap)
}

func (p *actionplanPager) applyCursors(query *ActionPlanQuery, after, before *Cursor) (*ActionPlanQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultActionPlanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *actionplanPager) applyOrder(query *ActionPlanQuery) *ActionPlanQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultActionPlanOrder.Field {
		query = query.Order(DefaultActionPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *actionplanPager) orderExpr(query *ActionPlanQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultActionPlanOrder.Field {
			b.Comma().Ident(DefaultActionPlanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlan.
func (ap *ActionPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanPaginateOption,
) (*ActionPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ap, err = pager.applyFilter(ap); err != nil {
		return nil, err
	}
	conn := &ActionPlanConnection{Edges: []*ActionPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ap.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ap, err = pager.applyCursors(ap, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ap.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ap = pager.applyOrder(ap)
	nodes, err := ap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ActionPlanOrderField defines the ordering field of ActionPlan.
type ActionPlanOrderField struct {
	// Value extracts the ordering value from the given ActionPlan.
	Value    func(*ActionPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplan.OrderOption
	toCursor func(*ActionPlan) Cursor
}

// ActionPlanOrder defines the ordering of ActionPlan.
type ActionPlanOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ActionPlanOrderField `json:"field"`
}

// DefaultActionPlanOrder is the default ordering of ActionPlan.
var DefaultActionPlanOrder = &ActionPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanOrderField{
		Value: func(ap *ActionPlan) (ent.Value, error) {
			return ap.ID, nil
		},
		column: actionplan.FieldID,
		toTerm: actionplan.ByID,
		toCursor: func(ap *ActionPlan) Cursor {
			return Cursor{ID: ap.ID}
		},
	},
}

// ToEdge converts ActionPlan into ActionPlanEdge.
func (ap *ActionPlan) ToEdge(order *ActionPlanOrder) *ActionPlanEdge {
	if order == nil {
		order = DefaultActionPlanOrder
	}
	return &ActionPlanEdge{
		Node:   ap,
		Cursor: order.Field.toCursor(ap),
	}
}

// ActionPlanHistoryEdge is the edge representation of ActionPlanHistory.
type ActionPlanHistoryEdge struct {
	Node   *ActionPlanHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ActionPlanHistoryConnection is the connection containing edges to ActionPlanHistory.
type ActionPlanHistoryConnection struct {
	Edges      []*ActionPlanHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ActionPlanHistoryConnection) build(nodes []*ActionPlanHistory, pager *actionplanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ActionPlanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanHistoryPaginateOption enables pagination customization.
type ActionPlanHistoryPaginateOption func(*actionplanhistoryPager) error

// WithActionPlanHistoryOrder configures pagination ordering.
func WithActionPlanHistoryOrder(order *ActionPlanHistoryOrder) ActionPlanHistoryPaginateOption {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	o := *order
	return func(pager *actionplanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActionPlanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActionPlanHistoryFilter configures pagination filter.
func WithActionPlanHistoryFilter(filter func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)) ActionPlanHistoryPaginateOption {
	return func(pager *actionplanhistoryPager) error {
		if filter == nil {
			return errors.New("ActionPlanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanhistoryPager struct {
	reverse bool
	order   *ActionPlanHistoryOrder
	filter  func(*ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error)
}

func newActionPlanHistoryPager(opts []ActionPlanHistoryPaginateOption, reverse bool) (*actionplanhistoryPager, error) {
	pager := &actionplanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActionPlanHistoryOrder
	}
	return pager, nil
}

func (p *actionplanhistoryPager) applyFilter(query *ActionPlanHistoryQuery) (*ActionPlanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanhistoryPager) toCursor(aph *ActionPlanHistory) Cursor {
	return p.order.Field.toCursor(aph)
}

func (p *actionplanhistoryPager) applyCursors(query *ActionPlanHistoryQuery, after, before *Cursor) (*ActionPlanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultActionPlanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *actionplanhistoryPager) applyOrder(query *ActionPlanHistoryQuery) *ActionPlanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultActionPlanHistoryOrder.Field {
		query = query.Order(DefaultActionPlanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *actionplanhistoryPager) orderExpr(query *ActionPlanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultActionPlanHistoryOrder.Field {
			b.Comma().Ident(DefaultActionPlanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlanHistory.
func (aph *ActionPlanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanHistoryPaginateOption,
) (*ActionPlanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if aph, err = pager.applyFilter(aph); err != nil {
		return nil, err
	}
	conn := &ActionPlanHistoryConnection{Edges: []*ActionPlanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := aph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if aph, err = pager.applyCursors(aph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		aph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := aph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	aph = pager.applyOrder(aph)
	nodes, err := aph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ActionPlanHistoryOrderField defines the ordering field of ActionPlanHistory.
type ActionPlanHistoryOrderField struct {
	// Value extracts the ordering value from the given ActionPlanHistory.
	Value    func(*ActionPlanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplanhistory.OrderOption
	toCursor func(*ActionPlanHistory) Cursor
}

// ActionPlanHistoryOrder defines the ordering of ActionPlanHistory.
type ActionPlanHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ActionPlanHistoryOrderField `json:"field"`
}

// DefaultActionPlanHistoryOrder is the default ordering of ActionPlanHistory.
var DefaultActionPlanHistoryOrder = &ActionPlanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanHistoryOrderField{
		Value: func(aph *ActionPlanHistory) (ent.Value, error) {
			return aph.ID, nil
		},
		column: actionplanhistory.FieldID,
		toTerm: actionplanhistory.ByID,
		toCursor: func(aph *ActionPlanHistory) Cursor {
			return Cursor{ID: aph.ID}
		},
	},
}

// ToEdge converts ActionPlanHistory into ActionPlanHistoryEdge.
func (aph *ActionPlanHistory) ToEdge(order *ActionPlanHistoryOrder) *ActionPlanHistoryEdge {
	if order == nil {
		order = DefaultActionPlanHistoryOrder
	}
	return &ActionPlanHistoryEdge{
		Node:   aph,
		Cursor: order.Field.toCursor(aph),
	}
}

// ContactEdge is the edge representation of Contact.
type ContactEdge struct {
	Node   *Contact `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ContactConnection is the connection containing edges to Contact.
type ContactConnection struct {
	Edges      []*ContactEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ContactConnection) build(nodes []*Contact, pager *contactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Contact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Contact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Contact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactPaginateOption enables pagination customization.
type ContactPaginateOption func(*contactPager) error

// WithContactOrder configures pagination ordering.
func WithContactOrder(order *ContactOrder) ContactPaginateOption {
	if order == nil {
		order = DefaultContactOrder
	}
	o := *order
	return func(pager *contactPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactFilter configures pagination filter.
func WithContactFilter(filter func(*ContactQuery) (*ContactQuery, error)) ContactPaginateOption {
	return func(pager *contactPager) error {
		if filter == nil {
			return errors.New("ContactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contactPager struct {
	reverse bool
	order   *ContactOrder
	filter  func(*ContactQuery) (*ContactQuery, error)
}

func newContactPager(opts []ContactPaginateOption, reverse bool) (*contactPager, error) {
	pager := &contactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactOrder
	}
	return pager, nil
}

func (p *contactPager) applyFilter(query *ContactQuery) (*ContactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contactPager) toCursor(c *Contact) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *contactPager) applyCursors(query *ContactQuery, after, before *Cursor) (*ContactQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contactPager) applyOrder(query *ContactQuery) *ContactQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactOrder.Field {
		query = query.Order(DefaultContactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contactPager) orderExpr(query *ContactQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactOrder.Field {
			b.Comma().Ident(DefaultContactOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Contact.
func (c *ContactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactPaginateOption,
) (*ContactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ContactConnection{Edges: []*ContactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ContactOrderField defines the ordering field of Contact.
type ContactOrderField struct {
	// Value extracts the ordering value from the given Contact.
	Value    func(*Contact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contact.OrderOption
	toCursor func(*Contact) Cursor
}

// ContactOrder defines the ordering of Contact.
type ContactOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ContactOrderField `json:"field"`
}

// DefaultContactOrder is the default ordering of Contact.
var DefaultContactOrder = &ContactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.ID, nil
		},
		column: contact.FieldID,
		toTerm: contact.ByID,
		toCursor: func(c *Contact) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Contact into ContactEdge.
func (c *Contact) ToEdge(order *ContactOrder) *ContactEdge {
	if order == nil {
		order = DefaultContactOrder
	}
	return &ContactEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ContactHistoryEdge is the edge representation of ContactHistory.
type ContactHistoryEdge struct {
	Node   *ContactHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ContactHistoryConnection is the connection containing edges to ContactHistory.
type ContactHistoryConnection struct {
	Edges      []*ContactHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ContactHistoryConnection) build(nodes []*ContactHistory, pager *contacthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ContactHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ContactHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ContactHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactHistoryPaginateOption enables pagination customization.
type ContactHistoryPaginateOption func(*contacthistoryPager) error

// WithContactHistoryOrder configures pagination ordering.
func WithContactHistoryOrder(order *ContactHistoryOrder) ContactHistoryPaginateOption {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	o := *order
	return func(pager *contacthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactHistoryFilter configures pagination filter.
func WithContactHistoryFilter(filter func(*ContactHistoryQuery) (*ContactHistoryQuery, error)) ContactHistoryPaginateOption {
	return func(pager *contacthistoryPager) error {
		if filter == nil {
			return errors.New("ContactHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contacthistoryPager struct {
	reverse bool
	order   *ContactHistoryOrder
	filter  func(*ContactHistoryQuery) (*ContactHistoryQuery, error)
}

func newContactHistoryPager(opts []ContactHistoryPaginateOption, reverse bool) (*contacthistoryPager, error) {
	pager := &contacthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactHistoryOrder
	}
	return pager, nil
}

func (p *contacthistoryPager) applyFilter(query *ContactHistoryQuery) (*ContactHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contacthistoryPager) toCursor(ch *ContactHistory) Cursor {
	return p.order.Field.toCursor(ch)
}

func (p *contacthistoryPager) applyCursors(query *ContactHistoryQuery, after, before *Cursor) (*ContactHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contacthistoryPager) applyOrder(query *ContactHistoryQuery) *ContactHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactHistoryOrder.Field {
		query = query.Order(DefaultContactHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contacthistoryPager) orderExpr(query *ContactHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactHistoryOrder.Field {
			b.Comma().Ident(DefaultContactHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ContactHistory.
func (ch *ContactHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactHistoryPaginateOption,
) (*ContactHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ch, err = pager.applyFilter(ch); err != nil {
		return nil, err
	}
	conn := &ContactHistoryConnection{Edges: []*ContactHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ch, err = pager.applyCursors(ch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ch = pager.applyOrder(ch)
	nodes, err := ch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ContactHistoryOrderField defines the ordering field of ContactHistory.
type ContactHistoryOrderField struct {
	// Value extracts the ordering value from the given ContactHistory.
	Value    func(*ContactHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contacthistory.OrderOption
	toCursor func(*ContactHistory) Cursor
}

// ContactHistoryOrder defines the ordering of ContactHistory.
type ContactHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ContactHistoryOrderField `json:"field"`
}

// DefaultContactHistoryOrder is the default ordering of ContactHistory.
var DefaultContactHistoryOrder = &ContactHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactHistoryOrderField{
		Value: func(ch *ContactHistory) (ent.Value, error) {
			return ch.ID, nil
		},
		column: contacthistory.FieldID,
		toTerm: contacthistory.ByID,
		toCursor: func(ch *ContactHistory) Cursor {
			return Cursor{ID: ch.ID}
		},
	},
}

// ToEdge converts ContactHistory into ContactHistoryEdge.
func (ch *ContactHistory) ToEdge(order *ContactHistoryOrder) *ContactHistoryEdge {
	if order == nil {
		order = DefaultContactHistoryOrder
	}
	return &ContactHistoryEdge{
		Node:   ch,
		Cursor: order.Field.toCursor(ch),
	}
}

// ControlEdge is the edge representation of Control.
type ControlEdge struct {
	Node   *Control `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ControlConnection is the connection containing edges to Control.
type ControlConnection struct {
	Edges      []*ControlEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ControlConnection) build(nodes []*Control, pager *controlPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Control
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Control {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Control {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlPaginateOption enables pagination customization.
type ControlPaginateOption func(*controlPager) error

// WithControlOrder configures pagination ordering.
func WithControlOrder(order *ControlOrder) ControlPaginateOption {
	if order == nil {
		order = DefaultControlOrder
	}
	o := *order
	return func(pager *controlPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlFilter configures pagination filter.
func WithControlFilter(filter func(*ControlQuery) (*ControlQuery, error)) ControlPaginateOption {
	return func(pager *controlPager) error {
		if filter == nil {
			return errors.New("ControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlPager struct {
	reverse bool
	order   *ControlOrder
	filter  func(*ControlQuery) (*ControlQuery, error)
}

func newControlPager(opts []ControlPaginateOption, reverse bool) (*controlPager, error) {
	pager := &controlPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlOrder
	}
	return pager, nil
}

func (p *controlPager) applyFilter(query *ControlQuery) (*ControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlPager) toCursor(c *Control) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *controlPager) applyCursors(query *ControlQuery, after, before *Cursor) (*ControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlPager) applyOrder(query *ControlQuery) *ControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlOrder.Field {
		query = query.Order(DefaultControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlPager) orderExpr(query *ControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlOrder.Field {
			b.Comma().Ident(DefaultControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Control.
func (c *ControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlPaginateOption,
) (*ControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ControlConnection{Edges: []*ControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ControlOrderField defines the ordering field of Control.
type ControlOrderField struct {
	// Value extracts the ordering value from the given Control.
	Value    func(*Control) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) control.OrderOption
	toCursor func(*Control) Cursor
}

// ControlOrder defines the ordering of Control.
type ControlOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ControlOrderField `json:"field"`
}

// DefaultControlOrder is the default ordering of Control.
var DefaultControlOrder = &ControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlOrderField{
		Value: func(c *Control) (ent.Value, error) {
			return c.ID, nil
		},
		column: control.FieldID,
		toTerm: control.ByID,
		toCursor: func(c *Control) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Control into ControlEdge.
func (c *Control) ToEdge(order *ControlOrder) *ControlEdge {
	if order == nil {
		order = DefaultControlOrder
	}
	return &ControlEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ControlHistoryEdge is the edge representation of ControlHistory.
type ControlHistoryEdge struct {
	Node   *ControlHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ControlHistoryConnection is the connection containing edges to ControlHistory.
type ControlHistoryConnection struct {
	Edges      []*ControlHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ControlHistoryConnection) build(nodes []*ControlHistory, pager *controlhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ControlHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlHistoryPaginateOption enables pagination customization.
type ControlHistoryPaginateOption func(*controlhistoryPager) error

// WithControlHistoryOrder configures pagination ordering.
func WithControlHistoryOrder(order *ControlHistoryOrder) ControlHistoryPaginateOption {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	o := *order
	return func(pager *controlhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlHistoryFilter configures pagination filter.
func WithControlHistoryFilter(filter func(*ControlHistoryQuery) (*ControlHistoryQuery, error)) ControlHistoryPaginateOption {
	return func(pager *controlhistoryPager) error {
		if filter == nil {
			return errors.New("ControlHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlhistoryPager struct {
	reverse bool
	order   *ControlHistoryOrder
	filter  func(*ControlHistoryQuery) (*ControlHistoryQuery, error)
}

func newControlHistoryPager(opts []ControlHistoryPaginateOption, reverse bool) (*controlhistoryPager, error) {
	pager := &controlhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlHistoryOrder
	}
	return pager, nil
}

func (p *controlhistoryPager) applyFilter(query *ControlHistoryQuery) (*ControlHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlhistoryPager) toCursor(ch *ControlHistory) Cursor {
	return p.order.Field.toCursor(ch)
}

func (p *controlhistoryPager) applyCursors(query *ControlHistoryQuery, after, before *Cursor) (*ControlHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlhistoryPager) applyOrder(query *ControlHistoryQuery) *ControlHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlHistoryOrder.Field {
		query = query.Order(DefaultControlHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlhistoryPager) orderExpr(query *ControlHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlHistoryOrder.Field {
			b.Comma().Ident(DefaultControlHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlHistory.
func (ch *ControlHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlHistoryPaginateOption,
) (*ControlHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ch, err = pager.applyFilter(ch); err != nil {
		return nil, err
	}
	conn := &ControlHistoryConnection{Edges: []*ControlHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ch, err = pager.applyCursors(ch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ch = pager.applyOrder(ch)
	nodes, err := ch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ControlHistoryOrderField defines the ordering field of ControlHistory.
type ControlHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlHistory.
	Value    func(*ControlHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlhistory.OrderOption
	toCursor func(*ControlHistory) Cursor
}

// ControlHistoryOrder defines the ordering of ControlHistory.
type ControlHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ControlHistoryOrderField `json:"field"`
}

// DefaultControlHistoryOrder is the default ordering of ControlHistory.
var DefaultControlHistoryOrder = &ControlHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlHistoryOrderField{
		Value: func(ch *ControlHistory) (ent.Value, error) {
			return ch.ID, nil
		},
		column: controlhistory.FieldID,
		toTerm: controlhistory.ByID,
		toCursor: func(ch *ControlHistory) Cursor {
			return Cursor{ID: ch.ID}
		},
	},
}

// ToEdge converts ControlHistory into ControlHistoryEdge.
func (ch *ControlHistory) ToEdge(order *ControlHistoryOrder) *ControlHistoryEdge {
	if order == nil {
		order = DefaultControlHistoryOrder
	}
	return &ControlHistoryEdge{
		Node:   ch,
		Cursor: order.Field.toCursor(ch),
	}
}

// ControlObjectiveEdge is the edge representation of ControlObjective.
type ControlObjectiveEdge struct {
	Node   *ControlObjective `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ControlObjectiveConnection is the connection containing edges to ControlObjective.
type ControlObjectiveConnection struct {
	Edges      []*ControlObjectiveEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ControlObjectiveConnection) build(nodes []*ControlObjective, pager *controlobjectivePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ControlObjective
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjective {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjective {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectivePaginateOption enables pagination customization.
type ControlObjectivePaginateOption func(*controlobjectivePager) error

// WithControlObjectiveOrder configures pagination ordering.
func WithControlObjectiveOrder(order *ControlObjectiveOrder) ControlObjectivePaginateOption {
	if order == nil {
		order = DefaultControlObjectiveOrder
	}
	o := *order
	return func(pager *controlobjectivePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlObjectiveOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlObjectiveFilter configures pagination filter.
func WithControlObjectiveFilter(filter func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		if filter == nil {
			return errors.New("ControlObjectiveQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivePager struct {
	reverse bool
	order   *ControlObjectiveOrder
	filter  func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)
}

func newControlObjectivePager(opts []ControlObjectivePaginateOption, reverse bool) (*controlobjectivePager, error) {
	pager := &controlobjectivePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlObjectiveOrder
	}
	return pager, nil
}

func (p *controlobjectivePager) applyFilter(query *ControlObjectiveQuery) (*ControlObjectiveQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivePager) toCursor(co *ControlObjective) Cursor {
	return p.order.Field.toCursor(co)
}

func (p *controlobjectivePager) applyCursors(query *ControlObjectiveQuery, after, before *Cursor) (*ControlObjectiveQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlObjectiveOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlobjectivePager) applyOrder(query *ControlObjectiveQuery) *ControlObjectiveQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlObjectiveOrder.Field {
		query = query.Order(DefaultControlObjectiveOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlobjectivePager) orderExpr(query *ControlObjectiveQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlObjectiveOrder.Field {
			b.Comma().Ident(DefaultControlObjectiveOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjective.
func (co *ControlObjectiveQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectivePaginateOption,
) (*ControlObjectiveConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectivePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if co, err = pager.applyFilter(co); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveConnection{Edges: []*ControlObjectiveEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := co.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if co, err = pager.applyCursors(co, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		co.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := co.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	co = pager.applyOrder(co)
	nodes, err := co.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ControlObjectiveOrderField defines the ordering field of ControlObjective.
type ControlObjectiveOrderField struct {
	// Value extracts the ordering value from the given ControlObjective.
	Value    func(*ControlObjective) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjective.OrderOption
	toCursor func(*ControlObjective) Cursor
}

// ControlObjectiveOrder defines the ordering of ControlObjective.
type ControlObjectiveOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ControlObjectiveOrderField `json:"field"`
}

// DefaultControlObjectiveOrder is the default ordering of ControlObjective.
var DefaultControlObjectiveOrder = &ControlObjectiveOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveOrderField{
		Value: func(co *ControlObjective) (ent.Value, error) {
			return co.ID, nil
		},
		column: controlobjective.FieldID,
		toTerm: controlobjective.ByID,
		toCursor: func(co *ControlObjective) Cursor {
			return Cursor{ID: co.ID}
		},
	},
}

// ToEdge converts ControlObjective into ControlObjectiveEdge.
func (co *ControlObjective) ToEdge(order *ControlObjectiveOrder) *ControlObjectiveEdge {
	if order == nil {
		order = DefaultControlObjectiveOrder
	}
	return &ControlObjectiveEdge{
		Node:   co,
		Cursor: order.Field.toCursor(co),
	}
}

// ControlObjectiveHistoryEdge is the edge representation of ControlObjectiveHistory.
type ControlObjectiveHistoryEdge struct {
	Node   *ControlObjectiveHistory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// ControlObjectiveHistoryConnection is the connection containing edges to ControlObjectiveHistory.
type ControlObjectiveHistoryConnection struct {
	Edges      []*ControlObjectiveHistoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *ControlObjectiveHistoryConnection) build(nodes []*ControlObjectiveHistory, pager *controlobjectivehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ControlObjectiveHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjectiveHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectiveHistoryPaginateOption enables pagination customization.
type ControlObjectiveHistoryPaginateOption func(*controlobjectivehistoryPager) error

// WithControlObjectiveHistoryOrder configures pagination ordering.
func WithControlObjectiveHistoryOrder(order *ControlObjectiveHistoryOrder) ControlObjectiveHistoryPaginateOption {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	o := *order
	return func(pager *controlobjectivehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultControlObjectiveHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithControlObjectiveHistoryFilter configures pagination filter.
func WithControlObjectiveHistoryFilter(filter func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)) ControlObjectiveHistoryPaginateOption {
	return func(pager *controlobjectivehistoryPager) error {
		if filter == nil {
			return errors.New("ControlObjectiveHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivehistoryPager struct {
	reverse bool
	order   *ControlObjectiveHistoryOrder
	filter  func(*ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error)
}

func newControlObjectiveHistoryPager(opts []ControlObjectiveHistoryPaginateOption, reverse bool) (*controlobjectivehistoryPager, error) {
	pager := &controlobjectivehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultControlObjectiveHistoryOrder
	}
	return pager, nil
}

func (p *controlobjectivehistoryPager) applyFilter(query *ControlObjectiveHistoryQuery) (*ControlObjectiveHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) toCursor(coh *ControlObjectiveHistory) Cursor {
	return p.order.Field.toCursor(coh)
}

func (p *controlobjectivehistoryPager) applyCursors(query *ControlObjectiveHistoryQuery, after, before *Cursor) (*ControlObjectiveHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultControlObjectiveHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *controlobjectivehistoryPager) applyOrder(query *ControlObjectiveHistoryQuery) *ControlObjectiveHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
		query = query.Order(DefaultControlObjectiveHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *controlobjectivehistoryPager) orderExpr(query *ControlObjectiveHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultControlObjectiveHistoryOrder.Field {
			b.Comma().Ident(DefaultControlObjectiveHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjectiveHistory.
func (coh *ControlObjectiveHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectiveHistoryPaginateOption,
) (*ControlObjectiveHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectiveHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if coh, err = pager.applyFilter(coh); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveHistoryConnection{Edges: []*ControlObjectiveHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := coh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if coh, err = pager.applyCursors(coh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		coh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := coh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	coh = pager.applyOrder(coh)
	nodes, err := coh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ControlObjectiveHistoryOrderField defines the ordering field of ControlObjectiveHistory.
type ControlObjectiveHistoryOrderField struct {
	// Value extracts the ordering value from the given ControlObjectiveHistory.
	Value    func(*ControlObjectiveHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjectivehistory.OrderOption
	toCursor func(*ControlObjectiveHistory) Cursor
}

// ControlObjectiveHistoryOrder defines the ordering of ControlObjectiveHistory.
type ControlObjectiveHistoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *ControlObjectiveHistoryOrderField `json:"field"`
}

// DefaultControlObjectiveHistoryOrder is the default ordering of ControlObjectiveHistory.
var DefaultControlObjectiveHistoryOrder = &ControlObjectiveHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveHistoryOrderField{
		Value: func(coh *ControlObjectiveHistory) (ent.Value, error) {
			return coh.ID, nil
		},
		column: controlobjectivehistory.FieldID,
		toTerm: controlobjectivehistory.ByID,
		toCursor: func(coh *ControlObjectiveHistory) Cursor {
			return Cursor{ID: coh.ID}
		},
	},
}

// ToEdge converts ControlObjectiveHistory into ControlObjectiveHistoryEdge.
func (coh *ControlObjectiveHistory) ToEdge(order *ControlObjectiveHistoryOrder) *ControlObjectiveHistoryEdge {
	if order == nil {
		order = DefaultControlObjectiveHistoryOrder
	}
	return &ControlObjectiveHistoryEdge{
		Node:   coh,
		Cursor: order.Field.toCursor(coh),
	}
}

// DocumentDataEdge is the edge representation of DocumentData.
type DocumentDataEdge struct {
	Node   *DocumentData `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// DocumentDataConnection is the connection containing edges to DocumentData.
type DocumentDataConnection struct {
	Edges      []*DocumentDataEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *DocumentDataConnection) build(nodes []*DocumentData, pager *documentdataPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DocumentData
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentData {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentData {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataPaginateOption enables pagination customization.
type DocumentDataPaginateOption func(*documentdataPager) error

// WithDocumentDataOrder configures pagination ordering.
func WithDocumentDataOrder(order *DocumentDataOrder) DocumentDataPaginateOption {
	if order == nil {
		order = DefaultDocumentDataOrder
	}
	o := *order
	return func(pager *documentdataPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentDataOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentDataFilter configures pagination filter.
func WithDocumentDataFilter(filter func(*DocumentDataQuery) (*DocumentDataQuery, error)) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		if filter == nil {
			return errors.New("DocumentDataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdataPager struct {
	reverse bool
	order   *DocumentDataOrder
	filter  func(*DocumentDataQuery) (*DocumentDataQuery, error)
}

func newDocumentDataPager(opts []DocumentDataPaginateOption, reverse bool) (*documentdataPager, error) {
	pager := &documentdataPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentDataOrder
	}
	return pager, nil
}

func (p *documentdataPager) applyFilter(query *DocumentDataQuery) (*DocumentDataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdataPager) toCursor(dd *DocumentData) Cursor {
	return p.order.Field.toCursor(dd)
}

func (p *documentdataPager) applyCursors(query *DocumentDataQuery, after, before *Cursor) (*DocumentDataQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentDataOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentdataPager) applyOrder(query *DocumentDataQuery) *DocumentDataQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentDataOrder.Field {
		query = query.Order(DefaultDocumentDataOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentdataPager) orderExpr(query *DocumentDataQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentDataOrder.Field {
			b.Comma().Ident(DefaultDocumentDataOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentData.
func (dd *DocumentDataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataPaginateOption,
) (*DocumentDataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dd, err = pager.applyFilter(dd); err != nil {
		return nil, err
	}
	conn := &DocumentDataConnection{Edges: []*DocumentDataEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dd, err = pager.applyCursors(dd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dd = pager.applyOrder(dd)
	nodes, err := dd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DocumentDataOrderField defines the ordering field of DocumentData.
type DocumentDataOrderField struct {
	// Value extracts the ordering value from the given DocumentData.
	Value    func(*DocumentData) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdata.OrderOption
	toCursor func(*DocumentData) Cursor
}

// DocumentDataOrder defines the ordering of DocumentData.
type DocumentDataOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *DocumentDataOrderField `json:"field"`
}

// DefaultDocumentDataOrder is the default ordering of DocumentData.
var DefaultDocumentDataOrder = &DocumentDataOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataOrderField{
		Value: func(dd *DocumentData) (ent.Value, error) {
			return dd.ID, nil
		},
		column: documentdata.FieldID,
		toTerm: documentdata.ByID,
		toCursor: func(dd *DocumentData) Cursor {
			return Cursor{ID: dd.ID}
		},
	},
}

// ToEdge converts DocumentData into DocumentDataEdge.
func (dd *DocumentData) ToEdge(order *DocumentDataOrder) *DocumentDataEdge {
	if order == nil {
		order = DefaultDocumentDataOrder
	}
	return &DocumentDataEdge{
		Node:   dd,
		Cursor: order.Field.toCursor(dd),
	}
}

// DocumentDataHistoryEdge is the edge representation of DocumentDataHistory.
type DocumentDataHistoryEdge struct {
	Node   *DocumentDataHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DocumentDataHistoryConnection is the connection containing edges to DocumentDataHistory.
type DocumentDataHistoryConnection struct {
	Edges      []*DocumentDataHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DocumentDataHistoryConnection) build(nodes []*DocumentDataHistory, pager *documentdatahistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DocumentDataHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentDataHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataHistoryPaginateOption enables pagination customization.
type DocumentDataHistoryPaginateOption func(*documentdatahistoryPager) error

// WithDocumentDataHistoryOrder configures pagination ordering.
func WithDocumentDataHistoryOrder(order *DocumentDataHistoryOrder) DocumentDataHistoryPaginateOption {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	o := *order
	return func(pager *documentdatahistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentDataHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentDataHistoryFilter configures pagination filter.
func WithDocumentDataHistoryFilter(filter func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)) DocumentDataHistoryPaginateOption {
	return func(pager *documentdatahistoryPager) error {
		if filter == nil {
			return errors.New("DocumentDataHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdatahistoryPager struct {
	reverse bool
	order   *DocumentDataHistoryOrder
	filter  func(*DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error)
}

func newDocumentDataHistoryPager(opts []DocumentDataHistoryPaginateOption, reverse bool) (*documentdatahistoryPager, error) {
	pager := &documentdatahistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentDataHistoryOrder
	}
	return pager, nil
}

func (p *documentdatahistoryPager) applyFilter(query *DocumentDataHistoryQuery) (*DocumentDataHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdatahistoryPager) toCursor(ddh *DocumentDataHistory) Cursor {
	return p.order.Field.toCursor(ddh)
}

func (p *documentdatahistoryPager) applyCursors(query *DocumentDataHistoryQuery, after, before *Cursor) (*DocumentDataHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentDataHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentdatahistoryPager) applyOrder(query *DocumentDataHistoryQuery) *DocumentDataHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
		query = query.Order(DefaultDocumentDataHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentdatahistoryPager) orderExpr(query *DocumentDataHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentDataHistoryOrder.Field {
			b.Comma().Ident(DefaultDocumentDataHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentDataHistory.
func (ddh *DocumentDataHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataHistoryPaginateOption,
) (*DocumentDataHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ddh, err = pager.applyFilter(ddh); err != nil {
		return nil, err
	}
	conn := &DocumentDataHistoryConnection{Edges: []*DocumentDataHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ddh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ddh, err = pager.applyCursors(ddh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ddh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ddh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ddh = pager.applyOrder(ddh)
	nodes, err := ddh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DocumentDataHistoryOrderField defines the ordering field of DocumentDataHistory.
type DocumentDataHistoryOrderField struct {
	// Value extracts the ordering value from the given DocumentDataHistory.
	Value    func(*DocumentDataHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdatahistory.OrderOption
	toCursor func(*DocumentDataHistory) Cursor
}

// DocumentDataHistoryOrder defines the ordering of DocumentDataHistory.
type DocumentDataHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DocumentDataHistoryOrderField `json:"field"`
}

// DefaultDocumentDataHistoryOrder is the default ordering of DocumentDataHistory.
var DefaultDocumentDataHistoryOrder = &DocumentDataHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataHistoryOrderField{
		Value: func(ddh *DocumentDataHistory) (ent.Value, error) {
			return ddh.ID, nil
		},
		column: documentdatahistory.FieldID,
		toTerm: documentdatahistory.ByID,
		toCursor: func(ddh *DocumentDataHistory) Cursor {
			return Cursor{ID: ddh.ID}
		},
	},
}

// ToEdge converts DocumentDataHistory into DocumentDataHistoryEdge.
func (ddh *DocumentDataHistory) ToEdge(order *DocumentDataHistoryOrder) *DocumentDataHistoryEdge {
	if order == nil {
		order = DefaultDocumentDataHistoryOrder
	}
	return &DocumentDataHistoryEdge{
		Node:   ddh,
		Cursor: order.Field.toCursor(ddh),
	}
}

// EntitlementEdge is the edge representation of Entitlement.
type EntitlementEdge struct {
	Node   *Entitlement `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// EntitlementConnection is the connection containing edges to Entitlement.
type EntitlementConnection struct {
	Edges      []*EntitlementEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *EntitlementConnection) build(nodes []*Entitlement, pager *entitlementPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Entitlement
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Entitlement {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Entitlement {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitlementEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitlementEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitlementPaginateOption enables pagination customization.
type EntitlementPaginateOption func(*entitlementPager) error

// WithEntitlementOrder configures pagination ordering.
func WithEntitlementOrder(order *EntitlementOrder) EntitlementPaginateOption {
	if order == nil {
		order = DefaultEntitlementOrder
	}
	o := *order
	return func(pager *entitlementPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitlementOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitlementFilter configures pagination filter.
func WithEntitlementFilter(filter func(*EntitlementQuery) (*EntitlementQuery, error)) EntitlementPaginateOption {
	return func(pager *entitlementPager) error {
		if filter == nil {
			return errors.New("EntitlementQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitlementPager struct {
	reverse bool
	order   *EntitlementOrder
	filter  func(*EntitlementQuery) (*EntitlementQuery, error)
}

func newEntitlementPager(opts []EntitlementPaginateOption, reverse bool) (*entitlementPager, error) {
	pager := &entitlementPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitlementOrder
	}
	return pager, nil
}

func (p *entitlementPager) applyFilter(query *EntitlementQuery) (*EntitlementQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitlementPager) toCursor(e *Entitlement) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *entitlementPager) applyCursors(query *EntitlementQuery, after, before *Cursor) (*EntitlementQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntitlementOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitlementPager) applyOrder(query *EntitlementQuery) *EntitlementQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntitlementOrder.Field {
		query = query.Order(DefaultEntitlementOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitlementPager) orderExpr(query *EntitlementQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitlementOrder.Field {
			b.Comma().Ident(DefaultEntitlementOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Entitlement.
func (e *EntitlementQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitlementPaginateOption,
) (*EntitlementConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitlementPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EntitlementConnection{Edges: []*EntitlementEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntitlementOrderField defines the ordering field of Entitlement.
type EntitlementOrderField struct {
	// Value extracts the ordering value from the given Entitlement.
	Value    func(*Entitlement) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitlement.OrderOption
	toCursor func(*Entitlement) Cursor
}

// EntitlementOrder defines the ordering of Entitlement.
type EntitlementOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *EntitlementOrderField `json:"field"`
}

// DefaultEntitlementOrder is the default ordering of Entitlement.
var DefaultEntitlementOrder = &EntitlementOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntitlementOrderField{
		Value: func(e *Entitlement) (ent.Value, error) {
			return e.ID, nil
		},
		column: entitlement.FieldID,
		toTerm: entitlement.ByID,
		toCursor: func(e *Entitlement) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Entitlement into EntitlementEdge.
func (e *Entitlement) ToEdge(order *EntitlementOrder) *EntitlementEdge {
	if order == nil {
		order = DefaultEntitlementOrder
	}
	return &EntitlementEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EntitlementHistoryEdge is the edge representation of EntitlementHistory.
type EntitlementHistoryEdge struct {
	Node   *EntitlementHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// EntitlementHistoryConnection is the connection containing edges to EntitlementHistory.
type EntitlementHistoryConnection struct {
	Edges      []*EntitlementHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *EntitlementHistoryConnection) build(nodes []*EntitlementHistory, pager *entitlementhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntitlementHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntitlementHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntitlementHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitlementHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitlementHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitlementHistoryPaginateOption enables pagination customization.
type EntitlementHistoryPaginateOption func(*entitlementhistoryPager) error

// WithEntitlementHistoryOrder configures pagination ordering.
func WithEntitlementHistoryOrder(order *EntitlementHistoryOrder) EntitlementHistoryPaginateOption {
	if order == nil {
		order = DefaultEntitlementHistoryOrder
	}
	o := *order
	return func(pager *entitlementhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitlementHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitlementHistoryFilter configures pagination filter.
func WithEntitlementHistoryFilter(filter func(*EntitlementHistoryQuery) (*EntitlementHistoryQuery, error)) EntitlementHistoryPaginateOption {
	return func(pager *entitlementhistoryPager) error {
		if filter == nil {
			return errors.New("EntitlementHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitlementhistoryPager struct {
	reverse bool
	order   *EntitlementHistoryOrder
	filter  func(*EntitlementHistoryQuery) (*EntitlementHistoryQuery, error)
}

func newEntitlementHistoryPager(opts []EntitlementHistoryPaginateOption, reverse bool) (*entitlementhistoryPager, error) {
	pager := &entitlementhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitlementHistoryOrder
	}
	return pager, nil
}

func (p *entitlementhistoryPager) applyFilter(query *EntitlementHistoryQuery) (*EntitlementHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitlementhistoryPager) toCursor(eh *EntitlementHistory) Cursor {
	return p.order.Field.toCursor(eh)
}

func (p *entitlementhistoryPager) applyCursors(query *EntitlementHistoryQuery, after, before *Cursor) (*EntitlementHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntitlementHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitlementhistoryPager) applyOrder(query *EntitlementHistoryQuery) *EntitlementHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntitlementHistoryOrder.Field {
		query = query.Order(DefaultEntitlementHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitlementhistoryPager) orderExpr(query *EntitlementHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitlementHistoryOrder.Field {
			b.Comma().Ident(DefaultEntitlementHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntitlementHistory.
func (eh *EntitlementHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitlementHistoryPaginateOption,
) (*EntitlementHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitlementHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eh, err = pager.applyFilter(eh); err != nil {
		return nil, err
	}
	conn := &EntitlementHistoryConnection{Edges: []*EntitlementHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eh, err = pager.applyCursors(eh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eh = pager.applyOrder(eh)
	nodes, err := eh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntitlementHistoryOrderField defines the ordering field of EntitlementHistory.
type EntitlementHistoryOrderField struct {
	// Value extracts the ordering value from the given EntitlementHistory.
	Value    func(*EntitlementHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitlementhistory.OrderOption
	toCursor func(*EntitlementHistory) Cursor
}

// EntitlementHistoryOrder defines the ordering of EntitlementHistory.
type EntitlementHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *EntitlementHistoryOrderField `json:"field"`
}

// DefaultEntitlementHistoryOrder is the default ordering of EntitlementHistory.
var DefaultEntitlementHistoryOrder = &EntitlementHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntitlementHistoryOrderField{
		Value: func(eh *EntitlementHistory) (ent.Value, error) {
			return eh.ID, nil
		},
		column: entitlementhistory.FieldID,
		toTerm: entitlementhistory.ByID,
		toCursor: func(eh *EntitlementHistory) Cursor {
			return Cursor{ID: eh.ID}
		},
	},
}

// ToEdge converts EntitlementHistory into EntitlementHistoryEdge.
func (eh *EntitlementHistory) ToEdge(order *EntitlementHistoryOrder) *EntitlementHistoryEdge {
	if order == nil {
		order = DefaultEntitlementHistoryOrder
	}
	return &EntitlementHistoryEdge{
		Node:   eh,
		Cursor: order.Field.toCursor(eh),
	}
}

// EntitlementPlanEdge is the edge representation of EntitlementPlan.
type EntitlementPlanEdge struct {
	Node   *EntitlementPlan `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// EntitlementPlanConnection is the connection containing edges to EntitlementPlan.
type EntitlementPlanConnection struct {
	Edges      []*EntitlementPlanEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *EntitlementPlanConnection) build(nodes []*EntitlementPlan, pager *entitlementplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntitlementPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntitlementPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntitlementPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitlementPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitlementPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitlementPlanPaginateOption enables pagination customization.
type EntitlementPlanPaginateOption func(*entitlementplanPager) error

// WithEntitlementPlanOrder configures pagination ordering.
func WithEntitlementPlanOrder(order *EntitlementPlanOrder) EntitlementPlanPaginateOption {
	if order == nil {
		order = DefaultEntitlementPlanOrder
	}
	o := *order
	return func(pager *entitlementplanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitlementPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitlementPlanFilter configures pagination filter.
func WithEntitlementPlanFilter(filter func(*EntitlementPlanQuery) (*EntitlementPlanQuery, error)) EntitlementPlanPaginateOption {
	return func(pager *entitlementplanPager) error {
		if filter == nil {
			return errors.New("EntitlementPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitlementplanPager struct {
	reverse bool
	order   *EntitlementPlanOrder
	filter  func(*EntitlementPlanQuery) (*EntitlementPlanQuery, error)
}

func newEntitlementPlanPager(opts []EntitlementPlanPaginateOption, reverse bool) (*entitlementplanPager, error) {
	pager := &entitlementplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitlementPlanOrder
	}
	return pager, nil
}

func (p *entitlementplanPager) applyFilter(query *EntitlementPlanQuery) (*EntitlementPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitlementplanPager) toCursor(ep *EntitlementPlan) Cursor {
	return p.order.Field.toCursor(ep)
}

func (p *entitlementplanPager) applyCursors(query *EntitlementPlanQuery, after, before *Cursor) (*EntitlementPlanQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntitlementPlanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitlementplanPager) applyOrder(query *EntitlementPlanQuery) *EntitlementPlanQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntitlementPlanOrder.Field {
		query = query.Order(DefaultEntitlementPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitlementplanPager) orderExpr(query *EntitlementPlanQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitlementPlanOrder.Field {
			b.Comma().Ident(DefaultEntitlementPlanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntitlementPlan.
func (ep *EntitlementPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitlementPlanPaginateOption,
) (*EntitlementPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitlementPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ep, err = pager.applyFilter(ep); err != nil {
		return nil, err
	}
	conn := &EntitlementPlanConnection{Edges: []*EntitlementPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ep.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ep, err = pager.applyCursors(ep, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ep.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ep = pager.applyOrder(ep)
	nodes, err := ep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntitlementPlanOrderField defines the ordering field of EntitlementPlan.
type EntitlementPlanOrderField struct {
	// Value extracts the ordering value from the given EntitlementPlan.
	Value    func(*EntitlementPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitlementplan.OrderOption
	toCursor func(*EntitlementPlan) Cursor
}

// EntitlementPlanOrder defines the ordering of EntitlementPlan.
type EntitlementPlanOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *EntitlementPlanOrderField `json:"field"`
}

// DefaultEntitlementPlanOrder is the default ordering of EntitlementPlan.
var DefaultEntitlementPlanOrder = &EntitlementPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntitlementPlanOrderField{
		Value: func(ep *EntitlementPlan) (ent.Value, error) {
			return ep.ID, nil
		},
		column: entitlementplan.FieldID,
		toTerm: entitlementplan.ByID,
		toCursor: func(ep *EntitlementPlan) Cursor {
			return Cursor{ID: ep.ID}
		},
	},
}

// ToEdge converts EntitlementPlan into EntitlementPlanEdge.
func (ep *EntitlementPlan) ToEdge(order *EntitlementPlanOrder) *EntitlementPlanEdge {
	if order == nil {
		order = DefaultEntitlementPlanOrder
	}
	return &EntitlementPlanEdge{
		Node:   ep,
		Cursor: order.Field.toCursor(ep),
	}
}

// EntitlementPlanFeatureEdge is the edge representation of EntitlementPlanFeature.
type EntitlementPlanFeatureEdge struct {
	Node   *EntitlementPlanFeature `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// EntitlementPlanFeatureConnection is the connection containing edges to EntitlementPlanFeature.
type EntitlementPlanFeatureConnection struct {
	Edges      []*EntitlementPlanFeatureEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *EntitlementPlanFeatureConnection) build(nodes []*EntitlementPlanFeature, pager *entitlementplanfeaturePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntitlementPlanFeature
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntitlementPlanFeature {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntitlementPlanFeature {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitlementPlanFeatureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitlementPlanFeatureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitlementPlanFeaturePaginateOption enables pagination customization.
type EntitlementPlanFeaturePaginateOption func(*entitlementplanfeaturePager) error

// WithEntitlementPlanFeatureOrder configures pagination ordering.
func WithEntitlementPlanFeatureOrder(order *EntitlementPlanFeatureOrder) EntitlementPlanFeaturePaginateOption {
	if order == nil {
		order = DefaultEntitlementPlanFeatureOrder
	}
	o := *order
	return func(pager *entitlementplanfeaturePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitlementPlanFeatureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitlementPlanFeatureFilter configures pagination filter.
func WithEntitlementPlanFeatureFilter(filter func(*EntitlementPlanFeatureQuery) (*EntitlementPlanFeatureQuery, error)) EntitlementPlanFeaturePaginateOption {
	return func(pager *entitlementplanfeaturePager) error {
		if filter == nil {
			return errors.New("EntitlementPlanFeatureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitlementplanfeaturePager struct {
	reverse bool
	order   *EntitlementPlanFeatureOrder
	filter  func(*EntitlementPlanFeatureQuery) (*EntitlementPlanFeatureQuery, error)
}

func newEntitlementPlanFeaturePager(opts []EntitlementPlanFeaturePaginateOption, reverse bool) (*entitlementplanfeaturePager, error) {
	pager := &entitlementplanfeaturePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitlementPlanFeatureOrder
	}
	return pager, nil
}

func (p *entitlementplanfeaturePager) applyFilter(query *EntitlementPlanFeatureQuery) (*EntitlementPlanFeatureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitlementplanfeaturePager) toCursor(epf *EntitlementPlanFeature) Cursor {
	return p.order.Field.toCursor(epf)
}

func (p *entitlementplanfeaturePager) applyCursors(query *EntitlementPlanFeatureQuery, after, before *Cursor) (*EntitlementPlanFeatureQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntitlementPlanFeatureOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitlementplanfeaturePager) applyOrder(query *EntitlementPlanFeatureQuery) *EntitlementPlanFeatureQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntitlementPlanFeatureOrder.Field {
		query = query.Order(DefaultEntitlementPlanFeatureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitlementplanfeaturePager) orderExpr(query *EntitlementPlanFeatureQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitlementPlanFeatureOrder.Field {
			b.Comma().Ident(DefaultEntitlementPlanFeatureOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntitlementPlanFeature.
func (epf *EntitlementPlanFeatureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitlementPlanFeaturePaginateOption,
) (*EntitlementPlanFeatureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitlementPlanFeaturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if epf, err = pager.applyFilter(epf); err != nil {
		return nil, err
	}
	conn := &EntitlementPlanFeatureConnection{Edges: []*EntitlementPlanFeatureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := epf.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if epf, err = pager.applyCursors(epf, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		epf.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := epf.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	epf = pager.applyOrder(epf)
	nodes, err := epf.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntitlementPlanFeatureOrderField defines the ordering field of EntitlementPlanFeature.
type EntitlementPlanFeatureOrderField struct {
	// Value extracts the ordering value from the given EntitlementPlanFeature.
	Value    func(*EntitlementPlanFeature) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitlementplanfeature.OrderOption
	toCursor func(*EntitlementPlanFeature) Cursor
}

// EntitlementPlanFeatureOrder defines the ordering of EntitlementPlanFeature.
type EntitlementPlanFeatureOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *EntitlementPlanFeatureOrderField `json:"field"`
}

// DefaultEntitlementPlanFeatureOrder is the default ordering of EntitlementPlanFeature.
var DefaultEntitlementPlanFeatureOrder = &EntitlementPlanFeatureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntitlementPlanFeatureOrderField{
		Value: func(epf *EntitlementPlanFeature) (ent.Value, error) {
			return epf.ID, nil
		},
		column: entitlementplanfeature.FieldID,
		toTerm: entitlementplanfeature.ByID,
		toCursor: func(epf *EntitlementPlanFeature) Cursor {
			return Cursor{ID: epf.ID}
		},
	},
}

// ToEdge converts EntitlementPlanFeature into EntitlementPlanFeatureEdge.
func (epf *EntitlementPlanFeature) ToEdge(order *EntitlementPlanFeatureOrder) *EntitlementPlanFeatureEdge {
	if order == nil {
		order = DefaultEntitlementPlanFeatureOrder
	}
	return &EntitlementPlanFeatureEdge{
		Node:   epf,
		Cursor: order.Field.toCursor(epf),
	}
}

// EntitlementPlanFeatureHistoryEdge is the edge representation of EntitlementPlanFeatureHistory.
type EntitlementPlanFeatureHistoryEdge struct {
	Node   *EntitlementPlanFeatureHistory `json:"node"`
	Cursor Cursor                         `json:"cursor"`
}

// EntitlementPlanFeatureHistoryConnection is the connection containing edges to EntitlementPlanFeatureHistory.
type EntitlementPlanFeatureHistoryConnection struct {
	Edges      []*EntitlementPlanFeatureHistoryEdge `json:"edges"`
	PageInfo   PageInfo                             `json:"pageInfo"`
	TotalCount int                                  `json:"totalCount"`
}

func (c *EntitlementPlanFeatureHistoryConnection) build(nodes []*EntitlementPlanFeatureHistory, pager *entitlementplanfeaturehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntitlementPlanFeatureHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntitlementPlanFeatureHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntitlementPlanFeatureHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitlementPlanFeatureHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitlementPlanFeatureHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitlementPlanFeatureHistoryPaginateOption enables pagination customization.
type EntitlementPlanFeatureHistoryPaginateOption func(*entitlementplanfeaturehistoryPager) error

// WithEntitlementPlanFeatureHistoryOrder configures pagination ordering.
func WithEntitlementPlanFeatureHistoryOrder(order *EntitlementPlanFeatureHistoryOrder) EntitlementPlanFeatureHistoryPaginateOption {
	if order == nil {
		order = DefaultEntitlementPlanFeatureHistoryOrder
	}
	o := *order
	return func(pager *entitlementplanfeaturehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitlementPlanFeatureHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitlementPlanFeatureHistoryFilter configures pagination filter.
func WithEntitlementPlanFeatureHistoryFilter(filter func(*EntitlementPlanFeatureHistoryQuery) (*EntitlementPlanFeatureHistoryQuery, error)) EntitlementPlanFeatureHistoryPaginateOption {
	return func(pager *entitlementplanfeaturehistoryPager) error {
		if filter == nil {
			return errors.New("EntitlementPlanFeatureHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitlementplanfeaturehistoryPager struct {
	reverse bool
	order   *EntitlementPlanFeatureHistoryOrder
	filter  func(*EntitlementPlanFeatureHistoryQuery) (*EntitlementPlanFeatureHistoryQuery, error)
}

func newEntitlementPlanFeatureHistoryPager(opts []EntitlementPlanFeatureHistoryPaginateOption, reverse bool) (*entitlementplanfeaturehistoryPager, error) {
	pager := &entitlementplanfeaturehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitlementPlanFeatureHistoryOrder
	}
	return pager, nil
}

func (p *entitlementplanfeaturehistoryPager) applyFilter(query *EntitlementPlanFeatureHistoryQuery) (*EntitlementPlanFeatureHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitlementplanfeaturehistoryPager) toCursor(epfh *EntitlementPlanFeatureHistory) Cursor {
	return p.order.Field.toCursor(epfh)
}

func (p *entitlementplanfeaturehistoryPager) applyCursors(query *EntitlementPlanFeatureHistoryQuery, after, before *Cursor) (*EntitlementPlanFeatureHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntitlementPlanFeatureHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitlementplanfeaturehistoryPager) applyOrder(query *EntitlementPlanFeatureHistoryQuery) *EntitlementPlanFeatureHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntitlementPlanFeatureHistoryOrder.Field {
		query = query.Order(DefaultEntitlementPlanFeatureHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitlementplanfeaturehistoryPager) orderExpr(query *EntitlementPlanFeatureHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitlementPlanFeatureHistoryOrder.Field {
			b.Comma().Ident(DefaultEntitlementPlanFeatureHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntitlementPlanFeatureHistory.
func (epfh *EntitlementPlanFeatureHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitlementPlanFeatureHistoryPaginateOption,
) (*EntitlementPlanFeatureHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitlementPlanFeatureHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if epfh, err = pager.applyFilter(epfh); err != nil {
		return nil, err
	}
	conn := &EntitlementPlanFeatureHistoryConnection{Edges: []*EntitlementPlanFeatureHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := epfh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if epfh, err = pager.applyCursors(epfh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		epfh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := epfh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	epfh = pager.applyOrder(epfh)
	nodes, err := epfh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntitlementPlanFeatureHistoryOrderField defines the ordering field of EntitlementPlanFeatureHistory.
type EntitlementPlanFeatureHistoryOrderField struct {
	// Value extracts the ordering value from the given EntitlementPlanFeatureHistory.
	Value    func(*EntitlementPlanFeatureHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitlementplanfeaturehistory.OrderOption
	toCursor func(*EntitlementPlanFeatureHistory) Cursor
}

// EntitlementPlanFeatureHistoryOrder defines the ordering of EntitlementPlanFeatureHistory.
type EntitlementPlanFeatureHistoryOrder struct {
	Direction OrderDirection                           `json:"direction"`
	Field     *EntitlementPlanFeatureHistoryOrderField `json:"field"`
}

// DefaultEntitlementPlanFeatureHistoryOrder is the default ordering of EntitlementPlanFeatureHistory.
var DefaultEntitlementPlanFeatureHistoryOrder = &EntitlementPlanFeatureHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntitlementPlanFeatureHistoryOrderField{
		Value: func(epfh *EntitlementPlanFeatureHistory) (ent.Value, error) {
			return epfh.ID, nil
		},
		column: entitlementplanfeaturehistory.FieldID,
		toTerm: entitlementplanfeaturehistory.ByID,
		toCursor: func(epfh *EntitlementPlanFeatureHistory) Cursor {
			return Cursor{ID: epfh.ID}
		},
	},
}

// ToEdge converts EntitlementPlanFeatureHistory into EntitlementPlanFeatureHistoryEdge.
func (epfh *EntitlementPlanFeatureHistory) ToEdge(order *EntitlementPlanFeatureHistoryOrder) *EntitlementPlanFeatureHistoryEdge {
	if order == nil {
		order = DefaultEntitlementPlanFeatureHistoryOrder
	}
	return &EntitlementPlanFeatureHistoryEdge{
		Node:   epfh,
		Cursor: order.Field.toCursor(epfh),
	}
}

// EntitlementPlanHistoryEdge is the edge representation of EntitlementPlanHistory.
type EntitlementPlanHistoryEdge struct {
	Node   *EntitlementPlanHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// EntitlementPlanHistoryConnection is the connection containing edges to EntitlementPlanHistory.
type EntitlementPlanHistoryConnection struct {
	Edges      []*EntitlementPlanHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *EntitlementPlanHistoryConnection) build(nodes []*EntitlementPlanHistory, pager *entitlementplanhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntitlementPlanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntitlementPlanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntitlementPlanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitlementPlanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitlementPlanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitlementPlanHistoryPaginateOption enables pagination customization.
type EntitlementPlanHistoryPaginateOption func(*entitlementplanhistoryPager) error

// WithEntitlementPlanHistoryOrder configures pagination ordering.
func WithEntitlementPlanHistoryOrder(order *EntitlementPlanHistoryOrder) EntitlementPlanHistoryPaginateOption {
	if order == nil {
		order = DefaultEntitlementPlanHistoryOrder
	}
	o := *order
	return func(pager *entitlementplanhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitlementPlanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitlementPlanHistoryFilter configures pagination filter.
func WithEntitlementPlanHistoryFilter(filter func(*EntitlementPlanHistoryQuery) (*EntitlementPlanHistoryQuery, error)) EntitlementPlanHistoryPaginateOption {
	return func(pager *entitlementplanhistoryPager) error {
		if filter == nil {
			return errors.New("EntitlementPlanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitlementplanhistoryPager struct {
	reverse bool
	order   *EntitlementPlanHistoryOrder
	filter  func(*EntitlementPlanHistoryQuery) (*EntitlementPlanHistoryQuery, error)
}

func newEntitlementPlanHistoryPager(opts []EntitlementPlanHistoryPaginateOption, reverse bool) (*entitlementplanhistoryPager, error) {
	pager := &entitlementplanhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitlementPlanHistoryOrder
	}
	return pager, nil
}

func (p *entitlementplanhistoryPager) applyFilter(query *EntitlementPlanHistoryQuery) (*EntitlementPlanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitlementplanhistoryPager) toCursor(eph *EntitlementPlanHistory) Cursor {
	return p.order.Field.toCursor(eph)
}

func (p *entitlementplanhistoryPager) applyCursors(query *EntitlementPlanHistoryQuery, after, before *Cursor) (*EntitlementPlanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntitlementPlanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitlementplanhistoryPager) applyOrder(query *EntitlementPlanHistoryQuery) *EntitlementPlanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntitlementPlanHistoryOrder.Field {
		query = query.Order(DefaultEntitlementPlanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitlementplanhistoryPager) orderExpr(query *EntitlementPlanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitlementPlanHistoryOrder.Field {
			b.Comma().Ident(DefaultEntitlementPlanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntitlementPlanHistory.
func (eph *EntitlementPlanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitlementPlanHistoryPaginateOption,
) (*EntitlementPlanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitlementPlanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eph, err = pager.applyFilter(eph); err != nil {
		return nil, err
	}
	conn := &EntitlementPlanHistoryConnection{Edges: []*EntitlementPlanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eph, err = pager.applyCursors(eph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eph = pager.applyOrder(eph)
	nodes, err := eph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntitlementPlanHistoryOrderField defines the ordering field of EntitlementPlanHistory.
type EntitlementPlanHistoryOrderField struct {
	// Value extracts the ordering value from the given EntitlementPlanHistory.
	Value    func(*EntitlementPlanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitlementplanhistory.OrderOption
	toCursor func(*EntitlementPlanHistory) Cursor
}

// EntitlementPlanHistoryOrder defines the ordering of EntitlementPlanHistory.
type EntitlementPlanHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *EntitlementPlanHistoryOrderField `json:"field"`
}

// DefaultEntitlementPlanHistoryOrder is the default ordering of EntitlementPlanHistory.
var DefaultEntitlementPlanHistoryOrder = &EntitlementPlanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntitlementPlanHistoryOrderField{
		Value: func(eph *EntitlementPlanHistory) (ent.Value, error) {
			return eph.ID, nil
		},
		column: entitlementplanhistory.FieldID,
		toTerm: entitlementplanhistory.ByID,
		toCursor: func(eph *EntitlementPlanHistory) Cursor {
			return Cursor{ID: eph.ID}
		},
	},
}

// ToEdge converts EntitlementPlanHistory into EntitlementPlanHistoryEdge.
func (eph *EntitlementPlanHistory) ToEdge(order *EntitlementPlanHistoryOrder) *EntitlementPlanHistoryEdge {
	if order == nil {
		order = DefaultEntitlementPlanHistoryOrder
	}
	return &EntitlementPlanHistoryEdge{
		Node:   eph,
		Cursor: order.Field.toCursor(eph),
	}
}

// EntityEdge is the edge representation of Entity.
type EntityEdge struct {
	Node   *Entity `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EntityConnection is the connection containing edges to Entity.
type EntityConnection struct {
	Edges      []*EntityEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *EntityConnection) build(nodes []*Entity, pager *entityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Entity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Entity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Entity {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityPaginateOption enables pagination customization.
type EntityPaginateOption func(*entityPager) error

// WithEntityOrder configures pagination ordering.
func WithEntityOrder(order *EntityOrder) EntityPaginateOption {
	if order == nil {
		order = DefaultEntityOrder
	}
	o := *order
	return func(pager *entityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityFilter configures pagination filter.
func WithEntityFilter(filter func(*EntityQuery) (*EntityQuery, error)) EntityPaginateOption {
	return func(pager *entityPager) error {
		if filter == nil {
			return errors.New("EntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityPager struct {
	reverse bool
	order   *EntityOrder
	filter  func(*EntityQuery) (*EntityQuery, error)
}

func newEntityPager(opts []EntityPaginateOption, reverse bool) (*entityPager, error) {
	pager := &entityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityOrder
	}
	return pager, nil
}

func (p *entityPager) applyFilter(query *EntityQuery) (*EntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityPager) toCursor(e *Entity) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *entityPager) applyCursors(query *EntityQuery, after, before *Cursor) (*EntityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entityPager) applyOrder(query *EntityQuery) *EntityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityOrder.Field {
		query = query.Order(DefaultEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entityPager) orderExpr(query *EntityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityOrder.Field {
			b.Comma().Ident(DefaultEntityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Entity.
func (e *EntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityPaginateOption,
) (*EntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EntityConnection{Edges: []*EntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityOrderFieldName orders Entity by name.
	EntityOrderFieldName = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.Name, nil
		},
		column: entity.FieldName,
		toTerm: entity.ByName,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Name,
			}
		},
	}
	// EntityOrderFieldDisplayName orders Entity by display_name.
	EntityOrderFieldDisplayName = &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.DisplayName, nil
		},
		column: entity.FieldDisplayName,
		toTerm: entity.ByDisplayName,
		toCursor: func(e *Entity) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityOrderField) String() string {
	var str string
	switch f.column {
	case EntityOrderFieldName.column:
		str = "name"
	case EntityOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *EntityOrderFieldName
	case "display_name":
		*f = *EntityOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

// EntityOrderField defines the ordering field of Entity.
type EntityOrderField struct {
	// Value extracts the ordering value from the given Entity.
	Value    func(*Entity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entity.OrderOption
	toCursor func(*Entity) Cursor
}

// EntityOrder defines the ordering of Entity.
type EntityOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EntityOrderField `json:"field"`
}

// DefaultEntityOrder is the default ordering of Entity.
var DefaultEntityOrder = &EntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityOrderField{
		Value: func(e *Entity) (ent.Value, error) {
			return e.ID, nil
		},
		column: entity.FieldID,
		toTerm: entity.ByID,
		toCursor: func(e *Entity) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Entity into EntityEdge.
func (e *Entity) ToEdge(order *EntityOrder) *EntityEdge {
	if order == nil {
		order = DefaultEntityOrder
	}
	return &EntityEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EntityHistoryEdge is the edge representation of EntityHistory.
type EntityHistoryEdge struct {
	Node   *EntityHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EntityHistoryConnection is the connection containing edges to EntityHistory.
type EntityHistoryConnection struct {
	Edges      []*EntityHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EntityHistoryConnection) build(nodes []*EntityHistory, pager *entityhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntityHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityHistoryPaginateOption enables pagination customization.
type EntityHistoryPaginateOption func(*entityhistoryPager) error

// WithEntityHistoryOrder configures pagination ordering.
func WithEntityHistoryOrder(order *EntityHistoryOrder) EntityHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	o := *order
	return func(pager *entityhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityHistoryFilter configures pagination filter.
func WithEntityHistoryFilter(filter func(*EntityHistoryQuery) (*EntityHistoryQuery, error)) EntityHistoryPaginateOption {
	return func(pager *entityhistoryPager) error {
		if filter == nil {
			return errors.New("EntityHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityhistoryPager struct {
	reverse bool
	order   *EntityHistoryOrder
	filter  func(*EntityHistoryQuery) (*EntityHistoryQuery, error)
}

func newEntityHistoryPager(opts []EntityHistoryPaginateOption, reverse bool) (*entityhistoryPager, error) {
	pager := &entityhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityHistoryOrder
	}
	return pager, nil
}

func (p *entityhistoryPager) applyFilter(query *EntityHistoryQuery) (*EntityHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityhistoryPager) toCursor(eh *EntityHistory) Cursor {
	return p.order.Field.toCursor(eh)
}

func (p *entityhistoryPager) applyCursors(query *EntityHistoryQuery, after, before *Cursor) (*EntityHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entityhistoryPager) applyOrder(query *EntityHistoryQuery) *EntityHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityHistoryOrder.Field {
		query = query.Order(DefaultEntityHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entityhistoryPager) orderExpr(query *EntityHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityHistory.
func (eh *EntityHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityHistoryPaginateOption,
) (*EntityHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eh, err = pager.applyFilter(eh); err != nil {
		return nil, err
	}
	conn := &EntityHistoryConnection{Edges: []*EntityHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eh, err = pager.applyCursors(eh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eh = pager.applyOrder(eh)
	nodes, err := eh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityHistoryOrderFieldName orders EntityHistory by name.
	EntityHistoryOrderFieldName = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.Name, nil
		},
		column: entityhistory.FieldName,
		toTerm: entityhistory.ByName,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.Name,
			}
		},
	}
	// EntityHistoryOrderFieldDisplayName orders EntityHistory by display_name.
	EntityHistoryOrderFieldDisplayName = &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.DisplayName, nil
		},
		column: entityhistory.FieldDisplayName,
		toTerm: entityhistory.ByDisplayName,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{
				ID:    eh.ID,
				Value: eh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityHistoryOrderFieldName.column:
		str = "name"
	case EntityHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *EntityHistoryOrderFieldName
	case "display_name":
		*f = *EntityHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

// EntityHistoryOrderField defines the ordering field of EntityHistory.
type EntityHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityHistory.
	Value    func(*EntityHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entityhistory.OrderOption
	toCursor func(*EntityHistory) Cursor
}

// EntityHistoryOrder defines the ordering of EntityHistory.
type EntityHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EntityHistoryOrderField `json:"field"`
}

// DefaultEntityHistoryOrder is the default ordering of EntityHistory.
var DefaultEntityHistoryOrder = &EntityHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityHistoryOrderField{
		Value: func(eh *EntityHistory) (ent.Value, error) {
			return eh.ID, nil
		},
		column: entityhistory.FieldID,
		toTerm: entityhistory.ByID,
		toCursor: func(eh *EntityHistory) Cursor {
			return Cursor{ID: eh.ID}
		},
	},
}

// ToEdge converts EntityHistory into EntityHistoryEdge.
func (eh *EntityHistory) ToEdge(order *EntityHistoryOrder) *EntityHistoryEdge {
	if order == nil {
		order = DefaultEntityHistoryOrder
	}
	return &EntityHistoryEdge{
		Node:   eh,
		Cursor: order.Field.toCursor(eh),
	}
}

// EntityTypeEdge is the edge representation of EntityType.
type EntityTypeEdge struct {
	Node   *EntityType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// EntityTypeConnection is the connection containing edges to EntityType.
type EntityTypeConnection struct {
	Edges      []*EntityTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *EntityTypeConnection) build(nodes []*EntityType, pager *entitytypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntityType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityType {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypePaginateOption enables pagination customization.
type EntityTypePaginateOption func(*entitytypePager) error

// WithEntityTypeOrder configures pagination ordering.
func WithEntityTypeOrder(order *EntityTypeOrder) EntityTypePaginateOption {
	if order == nil {
		order = DefaultEntityTypeOrder
	}
	o := *order
	return func(pager *entitytypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityTypeFilter configures pagination filter.
func WithEntityTypeFilter(filter func(*EntityTypeQuery) (*EntityTypeQuery, error)) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		if filter == nil {
			return errors.New("EntityTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypePager struct {
	reverse bool
	order   *EntityTypeOrder
	filter  func(*EntityTypeQuery) (*EntityTypeQuery, error)
}

func newEntityTypePager(opts []EntityTypePaginateOption, reverse bool) (*entitytypePager, error) {
	pager := &entitytypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityTypeOrder
	}
	return pager, nil
}

func (p *entitytypePager) applyFilter(query *EntityTypeQuery) (*EntityTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypePager) toCursor(et *EntityType) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *entitytypePager) applyCursors(query *EntityTypeQuery, after, before *Cursor) (*EntityTypeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityTypeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitytypePager) applyOrder(query *EntityTypeQuery) *EntityTypeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityTypeOrder.Field {
		query = query.Order(DefaultEntityTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitytypePager) orderExpr(query *EntityTypeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityTypeOrder.Field {
			b.Comma().Ident(DefaultEntityTypeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityType.
func (et *EntityTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypePaginateOption,
) (*EntityTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}
	conn := &EntityTypeConnection{Edges: []*EntityTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := et.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if et, err = pager.applyCursors(et, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		et.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := et.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	et = pager.applyOrder(et)
	nodes, err := et.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeOrderFieldName orders EntityType by name.
	EntityTypeOrderFieldName = &EntityTypeOrderField{
		Value: func(et *EntityType) (ent.Value, error) {
			return et.Name, nil
		},
		column: entitytype.FieldName,
		toTerm: entitytype.ByName,
		toCursor: func(et *EntityType) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *EntityTypeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

// EntityTypeOrderField defines the ordering field of EntityType.
type EntityTypeOrderField struct {
	// Value extracts the ordering value from the given EntityType.
	Value    func(*EntityType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytype.OrderOption
	toCursor func(*EntityType) Cursor
}

// EntityTypeOrder defines the ordering of EntityType.
type EntityTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *EntityTypeOrderField `json:"field"`
}

// DefaultEntityTypeOrder is the default ordering of EntityType.
var DefaultEntityTypeOrder = &EntityTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeOrderField{
		Value: func(et *EntityType) (ent.Value, error) {
			return et.ID, nil
		},
		column: entitytype.FieldID,
		toTerm: entitytype.ByID,
		toCursor: func(et *EntityType) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// ToEdge converts EntityType into EntityTypeEdge.
func (et *EntityType) ToEdge(order *EntityTypeOrder) *EntityTypeEdge {
	if order == nil {
		order = DefaultEntityTypeOrder
	}
	return &EntityTypeEdge{
		Node:   et,
		Cursor: order.Field.toCursor(et),
	}
}

// EntityTypeHistoryEdge is the edge representation of EntityTypeHistory.
type EntityTypeHistoryEdge struct {
	Node   *EntityTypeHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EntityTypeHistoryConnection is the connection containing edges to EntityTypeHistory.
type EntityTypeHistoryConnection struct {
	Edges      []*EntityTypeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *EntityTypeHistoryConnection) build(nodes []*EntityTypeHistory, pager *entitytypehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntityTypeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityTypeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypeHistoryPaginateOption enables pagination customization.
type EntityTypeHistoryPaginateOption func(*entitytypehistoryPager) error

// WithEntityTypeHistoryOrder configures pagination ordering.
func WithEntityTypeHistoryOrder(order *EntityTypeHistoryOrder) EntityTypeHistoryPaginateOption {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	o := *order
	return func(pager *entitytypehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityTypeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityTypeHistoryFilter configures pagination filter.
func WithEntityTypeHistoryFilter(filter func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)) EntityTypeHistoryPaginateOption {
	return func(pager *entitytypehistoryPager) error {
		if filter == nil {
			return errors.New("EntityTypeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypehistoryPager struct {
	reverse bool
	order   *EntityTypeHistoryOrder
	filter  func(*EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error)
}

func newEntityTypeHistoryPager(opts []EntityTypeHistoryPaginateOption, reverse bool) (*entitytypehistoryPager, error) {
	pager := &entitytypehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityTypeHistoryOrder
	}
	return pager, nil
}

func (p *entitytypehistoryPager) applyFilter(query *EntityTypeHistoryQuery) (*EntityTypeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypehistoryPager) toCursor(eth *EntityTypeHistory) Cursor {
	return p.order.Field.toCursor(eth)
}

func (p *entitytypehistoryPager) applyCursors(query *EntityTypeHistoryQuery, after, before *Cursor) (*EntityTypeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntityTypeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entitytypehistoryPager) applyOrder(query *EntityTypeHistoryQuery) *EntityTypeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
		query = query.Order(DefaultEntityTypeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entitytypehistoryPager) orderExpr(query *EntityTypeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityTypeHistoryOrder.Field {
			b.Comma().Ident(DefaultEntityTypeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityTypeHistory.
func (eth *EntityTypeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypeHistoryPaginateOption,
) (*EntityTypeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eth, err = pager.applyFilter(eth); err != nil {
		return nil, err
	}
	conn := &EntityTypeHistoryConnection{Edges: []*EntityTypeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eth.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eth, err = pager.applyCursors(eth, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eth.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eth.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eth = pager.applyOrder(eth)
	nodes, err := eth.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeHistoryOrderFieldName orders EntityTypeHistory by name.
	EntityTypeHistoryOrderFieldName = &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.Name, nil
		},
		column: entitytypehistory.FieldName,
		toTerm: entitytypehistory.ByName,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{
				ID:    eth.ID,
				Value: eth.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *EntityTypeHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

// EntityTypeHistoryOrderField defines the ordering field of EntityTypeHistory.
type EntityTypeHistoryOrderField struct {
	// Value extracts the ordering value from the given EntityTypeHistory.
	Value    func(*EntityTypeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytypehistory.OrderOption
	toCursor func(*EntityTypeHistory) Cursor
}

// EntityTypeHistoryOrder defines the ordering of EntityTypeHistory.
type EntityTypeHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EntityTypeHistoryOrderField `json:"field"`
}

// DefaultEntityTypeHistoryOrder is the default ordering of EntityTypeHistory.
var DefaultEntityTypeHistoryOrder = &EntityTypeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeHistoryOrderField{
		Value: func(eth *EntityTypeHistory) (ent.Value, error) {
			return eth.ID, nil
		},
		column: entitytypehistory.FieldID,
		toTerm: entitytypehistory.ByID,
		toCursor: func(eth *EntityTypeHistory) Cursor {
			return Cursor{ID: eth.ID}
		},
	},
}

// ToEdge converts EntityTypeHistory into EntityTypeHistoryEdge.
func (eth *EntityTypeHistory) ToEdge(order *EntityTypeHistoryOrder) *EntityTypeHistoryEdge {
	if order == nil {
		order = DefaultEntityTypeHistoryOrder
	}
	return &EntityTypeHistoryEdge{
		Node:   eth,
		Cursor: order.Field.toCursor(eth),
	}
}

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EventConnection) build(nodes []*Event, pager *eventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order *EventOrder) EventPaginateOption {
	if order == nil {
		order = DefaultEventOrder
	}
	o := *order
	return func(pager *eventPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	reverse bool
	order   *EventOrder
	filter  func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption, reverse bool) (*eventPager, error) {
	pager := &eventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventOrder
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(e *Event) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) (*EventQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEventOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *eventPager) applyOrder(query *EventQuery) *EventQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEventOrder.Field {
		query = query.Order(DefaultEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *eventPager) orderExpr(query *EventQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEventOrder.Field {
			b.Comma().Ident(DefaultEventOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (e *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EventConnection{Edges: []*EventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	// Value extracts the ordering value from the given Event.
	Value    func(*Event) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) event.OrderOption
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EventOrderField{
		Value: func(e *Event) (ent.Value, error) {
			return e.ID, nil
		},
		column: event.FieldID,
		toTerm: event.ByID,
		toCursor: func(e *Event) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (e *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EventHistoryEdge is the edge representation of EventHistory.
type EventHistoryEdge struct {
	Node   *EventHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// EventHistoryConnection is the connection containing edges to EventHistory.
type EventHistoryConnection struct {
	Edges      []*EventHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *EventHistoryConnection) build(nodes []*EventHistory, pager *eventhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EventHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EventHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EventHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventHistoryPaginateOption enables pagination customization.
type EventHistoryPaginateOption func(*eventhistoryPager) error

// WithEventHistoryOrder configures pagination ordering.
func WithEventHistoryOrder(order *EventHistoryOrder) EventHistoryPaginateOption {
	if order == nil {
		order = DefaultEventHistoryOrder
	}
	o := *order
	return func(pager *eventhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventHistoryFilter configures pagination filter.
func WithEventHistoryFilter(filter func(*EventHistoryQuery) (*EventHistoryQuery, error)) EventHistoryPaginateOption {
	return func(pager *eventhistoryPager) error {
		if filter == nil {
			return errors.New("EventHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventhistoryPager struct {
	reverse bool
	order   *EventHistoryOrder
	filter  func(*EventHistoryQuery) (*EventHistoryQuery, error)
}

func newEventHistoryPager(opts []EventHistoryPaginateOption, reverse bool) (*eventhistoryPager, error) {
	pager := &eventhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventHistoryOrder
	}
	return pager, nil
}

func (p *eventhistoryPager) applyFilter(query *EventHistoryQuery) (*EventHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventhistoryPager) toCursor(eh *EventHistory) Cursor {
	return p.order.Field.toCursor(eh)
}

func (p *eventhistoryPager) applyCursors(query *EventHistoryQuery, after, before *Cursor) (*EventHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEventHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *eventhistoryPager) applyOrder(query *EventHistoryQuery) *EventHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEventHistoryOrder.Field {
		query = query.Order(DefaultEventHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *eventhistoryPager) orderExpr(query *EventHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEventHistoryOrder.Field {
			b.Comma().Ident(DefaultEventHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EventHistory.
func (eh *EventHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventHistoryPaginateOption,
) (*EventHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if eh, err = pager.applyFilter(eh); err != nil {
		return nil, err
	}
	conn := &EventHistoryConnection{Edges: []*EventHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := eh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if eh, err = pager.applyCursors(eh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		eh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := eh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	eh = pager.applyOrder(eh)
	nodes, err := eh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EventHistoryOrderField defines the ordering field of EventHistory.
type EventHistoryOrderField struct {
	// Value extracts the ordering value from the given EventHistory.
	Value    func(*EventHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) eventhistory.OrderOption
	toCursor func(*EventHistory) Cursor
}

// EventHistoryOrder defines the ordering of EventHistory.
type EventHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *EventHistoryOrderField `json:"field"`
}

// DefaultEventHistoryOrder is the default ordering of EventHistory.
var DefaultEventHistoryOrder = &EventHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EventHistoryOrderField{
		Value: func(eh *EventHistory) (ent.Value, error) {
			return eh.ID, nil
		},
		column: eventhistory.FieldID,
		toTerm: eventhistory.ByID,
		toCursor: func(eh *EventHistory) Cursor {
			return Cursor{ID: eh.ID}
		},
	},
}

// ToEdge converts EventHistory into EventHistoryEdge.
func (eh *EventHistory) ToEdge(order *EventHistoryOrder) *EventHistoryEdge {
	if order == nil {
		order = DefaultEventHistoryOrder
	}
	return &EventHistoryEdge{
		Node:   eh,
		Cursor: order.Field.toCursor(eh),
	}
}

// FeatureEdge is the edge representation of Feature.
type FeatureEdge struct {
	Node   *Feature `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FeatureConnection is the connection containing edges to Feature.
type FeatureConnection struct {
	Edges      []*FeatureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *FeatureConnection) build(nodes []*Feature, pager *featurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Feature
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Feature {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Feature {
			return nodes[i]
		}
	}
	c.Edges = make([]*FeatureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FeatureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FeaturePaginateOption enables pagination customization.
type FeaturePaginateOption func(*featurePager) error

// WithFeatureOrder configures pagination ordering.
func WithFeatureOrder(order *FeatureOrder) FeaturePaginateOption {
	if order == nil {
		order = DefaultFeatureOrder
	}
	o := *order
	return func(pager *featurePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFeatureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFeatureFilter configures pagination filter.
func WithFeatureFilter(filter func(*FeatureQuery) (*FeatureQuery, error)) FeaturePaginateOption {
	return func(pager *featurePager) error {
		if filter == nil {
			return errors.New("FeatureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type featurePager struct {
	reverse bool
	order   *FeatureOrder
	filter  func(*FeatureQuery) (*FeatureQuery, error)
}

func newFeaturePager(opts []FeaturePaginateOption, reverse bool) (*featurePager, error) {
	pager := &featurePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFeatureOrder
	}
	return pager, nil
}

func (p *featurePager) applyFilter(query *FeatureQuery) (*FeatureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *featurePager) toCursor(f *Feature) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *featurePager) applyCursors(query *FeatureQuery, after, before *Cursor) (*FeatureQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFeatureOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *featurePager) applyOrder(query *FeatureQuery) *FeatureQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFeatureOrder.Field {
		query = query.Order(DefaultFeatureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *featurePager) orderExpr(query *FeatureQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFeatureOrder.Field {
			b.Comma().Ident(DefaultFeatureOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Feature.
func (f *FeatureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FeaturePaginateOption,
) (*FeatureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFeaturePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FeatureConnection{Edges: []*FeatureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := f.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FeatureOrderField defines the ordering field of Feature.
type FeatureOrderField struct {
	// Value extracts the ordering value from the given Feature.
	Value    func(*Feature) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) feature.OrderOption
	toCursor func(*Feature) Cursor
}

// FeatureOrder defines the ordering of Feature.
type FeatureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FeatureOrderField `json:"field"`
}

// DefaultFeatureOrder is the default ordering of Feature.
var DefaultFeatureOrder = &FeatureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FeatureOrderField{
		Value: func(f *Feature) (ent.Value, error) {
			return f.ID, nil
		},
		column: feature.FieldID,
		toTerm: feature.ByID,
		toCursor: func(f *Feature) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Feature into FeatureEdge.
func (f *Feature) ToEdge(order *FeatureOrder) *FeatureEdge {
	if order == nil {
		order = DefaultFeatureOrder
	}
	return &FeatureEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// FeatureHistoryEdge is the edge representation of FeatureHistory.
type FeatureHistoryEdge struct {
	Node   *FeatureHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// FeatureHistoryConnection is the connection containing edges to FeatureHistory.
type FeatureHistoryConnection struct {
	Edges      []*FeatureHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *FeatureHistoryConnection) build(nodes []*FeatureHistory, pager *featurehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FeatureHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FeatureHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FeatureHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FeatureHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FeatureHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FeatureHistoryPaginateOption enables pagination customization.
type FeatureHistoryPaginateOption func(*featurehistoryPager) error

// WithFeatureHistoryOrder configures pagination ordering.
func WithFeatureHistoryOrder(order *FeatureHistoryOrder) FeatureHistoryPaginateOption {
	if order == nil {
		order = DefaultFeatureHistoryOrder
	}
	o := *order
	return func(pager *featurehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFeatureHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFeatureHistoryFilter configures pagination filter.
func WithFeatureHistoryFilter(filter func(*FeatureHistoryQuery) (*FeatureHistoryQuery, error)) FeatureHistoryPaginateOption {
	return func(pager *featurehistoryPager) error {
		if filter == nil {
			return errors.New("FeatureHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type featurehistoryPager struct {
	reverse bool
	order   *FeatureHistoryOrder
	filter  func(*FeatureHistoryQuery) (*FeatureHistoryQuery, error)
}

func newFeatureHistoryPager(opts []FeatureHistoryPaginateOption, reverse bool) (*featurehistoryPager, error) {
	pager := &featurehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFeatureHistoryOrder
	}
	return pager, nil
}

func (p *featurehistoryPager) applyFilter(query *FeatureHistoryQuery) (*FeatureHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *featurehistoryPager) toCursor(fh *FeatureHistory) Cursor {
	return p.order.Field.toCursor(fh)
}

func (p *featurehistoryPager) applyCursors(query *FeatureHistoryQuery, after, before *Cursor) (*FeatureHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFeatureHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *featurehistoryPager) applyOrder(query *FeatureHistoryQuery) *FeatureHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFeatureHistoryOrder.Field {
		query = query.Order(DefaultFeatureHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *featurehistoryPager) orderExpr(query *FeatureHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFeatureHistoryOrder.Field {
			b.Comma().Ident(DefaultFeatureHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FeatureHistory.
func (fh *FeatureHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FeatureHistoryPaginateOption,
) (*FeatureHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFeatureHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fh, err = pager.applyFilter(fh); err != nil {
		return nil, err
	}
	conn := &FeatureHistoryConnection{Edges: []*FeatureHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := fh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fh, err = pager.applyCursors(fh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		fh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fh = pager.applyOrder(fh)
	nodes, err := fh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FeatureHistoryOrderField defines the ordering field of FeatureHistory.
type FeatureHistoryOrderField struct {
	// Value extracts the ordering value from the given FeatureHistory.
	Value    func(*FeatureHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) featurehistory.OrderOption
	toCursor func(*FeatureHistory) Cursor
}

// FeatureHistoryOrder defines the ordering of FeatureHistory.
type FeatureHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *FeatureHistoryOrderField `json:"field"`
}

// DefaultFeatureHistoryOrder is the default ordering of FeatureHistory.
var DefaultFeatureHistoryOrder = &FeatureHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FeatureHistoryOrderField{
		Value: func(fh *FeatureHistory) (ent.Value, error) {
			return fh.ID, nil
		},
		column: featurehistory.FieldID,
		toTerm: featurehistory.ByID,
		toCursor: func(fh *FeatureHistory) Cursor {
			return Cursor{ID: fh.ID}
		},
	},
}

// ToEdge converts FeatureHistory into FeatureHistoryEdge.
func (fh *FeatureHistory) ToEdge(order *FeatureHistoryOrder) *FeatureHistoryEdge {
	if order == nil {
		order = DefaultFeatureHistoryOrder
	}
	return &FeatureHistoryEdge{
		Node:   fh,
		Cursor: order.Field.toCursor(fh),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   *FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := f.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// FileHistoryEdge is the edge representation of FileHistory.
type FileHistoryEdge struct {
	Node   *FileHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileHistoryConnection is the connection containing edges to FileHistory.
type FileHistoryConnection struct {
	Edges      []*FileHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *FileHistoryConnection) build(nodes []*FileHistory, pager *filehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FileHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileHistoryPaginateOption enables pagination customization.
type FileHistoryPaginateOption func(*filehistoryPager) error

// WithFileHistoryOrder configures pagination ordering.
func WithFileHistoryOrder(order *FileHistoryOrder) FileHistoryPaginateOption {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	o := *order
	return func(pager *filehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileHistoryFilter configures pagination filter.
func WithFileHistoryFilter(filter func(*FileHistoryQuery) (*FileHistoryQuery, error)) FileHistoryPaginateOption {
	return func(pager *filehistoryPager) error {
		if filter == nil {
			return errors.New("FileHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filehistoryPager struct {
	reverse bool
	order   *FileHistoryOrder
	filter  func(*FileHistoryQuery) (*FileHistoryQuery, error)
}

func newFileHistoryPager(opts []FileHistoryPaginateOption, reverse bool) (*filehistoryPager, error) {
	pager := &filehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileHistoryOrder
	}
	return pager, nil
}

func (p *filehistoryPager) applyFilter(query *FileHistoryQuery) (*FileHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filehistoryPager) toCursor(fh *FileHistory) Cursor {
	return p.order.Field.toCursor(fh)
}

func (p *filehistoryPager) applyCursors(query *FileHistoryQuery, after, before *Cursor) (*FileHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filehistoryPager) applyOrder(query *FileHistoryQuery) *FileHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileHistoryOrder.Field {
		query = query.Order(DefaultFileHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filehistoryPager) orderExpr(query *FileHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileHistoryOrder.Field {
			b.Comma().Ident(DefaultFileHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileHistory.
func (fh *FileHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileHistoryPaginateOption,
) (*FileHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fh, err = pager.applyFilter(fh); err != nil {
		return nil, err
	}
	conn := &FileHistoryConnection{Edges: []*FileHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := fh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fh, err = pager.applyCursors(fh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		fh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fh = pager.applyOrder(fh)
	nodes, err := fh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileHistoryOrderField defines the ordering field of FileHistory.
type FileHistoryOrderField struct {
	// Value extracts the ordering value from the given FileHistory.
	Value    func(*FileHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filehistory.OrderOption
	toCursor func(*FileHistory) Cursor
}

// FileHistoryOrder defines the ordering of FileHistory.
type FileHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileHistoryOrderField `json:"field"`
}

// DefaultFileHistoryOrder is the default ordering of FileHistory.
var DefaultFileHistoryOrder = &FileHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileHistoryOrderField{
		Value: func(fh *FileHistory) (ent.Value, error) {
			return fh.ID, nil
		},
		column: filehistory.FieldID,
		toTerm: filehistory.ByID,
		toCursor: func(fh *FileHistory) Cursor {
			return Cursor{ID: fh.ID}
		},
	},
}

// ToEdge converts FileHistory into FileHistoryEdge.
func (fh *FileHistory) ToEdge(order *FileHistoryOrder) *FileHistoryEdge {
	if order == nil {
		order = DefaultFileHistoryOrder
	}
	return &FileHistoryEdge{
		Node:   fh,
		Cursor: order.Field.toCursor(fh),
	}
}

// GroupEdge is the edge representation of Group.
type GroupEdge struct {
	Node   *Group `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GroupConnection is the connection containing edges to Group.
type GroupConnection struct {
	Edges      []*GroupEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *GroupConnection) build(nodes []*Group, pager *groupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Group
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Group {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Group {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupPaginateOption enables pagination customization.
type GroupPaginateOption func(*groupPager) error

// WithGroupOrder configures pagination ordering.
func WithGroupOrder(order *GroupOrder) GroupPaginateOption {
	if order == nil {
		order = DefaultGroupOrder
	}
	o := *order
	return func(pager *groupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupFilter configures pagination filter.
func WithGroupFilter(filter func(*GroupQuery) (*GroupQuery, error)) GroupPaginateOption {
	return func(pager *groupPager) error {
		if filter == nil {
			return errors.New("GroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupPager struct {
	reverse bool
	order   *GroupOrder
	filter  func(*GroupQuery) (*GroupQuery, error)
}

func newGroupPager(opts []GroupPaginateOption, reverse bool) (*groupPager, error) {
	pager := &groupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupOrder
	}
	return pager, nil
}

func (p *groupPager) applyFilter(query *GroupQuery) (*GroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupPager) toCursor(gr *Group) Cursor {
	return p.order.Field.toCursor(gr)
}

func (p *groupPager) applyCursors(query *GroupQuery, after, before *Cursor) (*GroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupPager) applyOrder(query *GroupQuery) *GroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupOrder.Field {
		query = query.Order(DefaultGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupPager) orderExpr(query *GroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupOrder.Field {
			b.Comma().Ident(DefaultGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Group.
func (gr *GroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupPaginateOption,
) (*GroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gr, err = pager.applyFilter(gr); err != nil {
		return nil, err
	}
	conn := &GroupConnection{Edges: []*GroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gr, err = pager.applyCursors(gr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gr = pager.applyOrder(gr)
	nodes, err := gr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupOrderFieldName orders Group by name.
	GroupOrderFieldName = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.Name, nil
		},
		column: group.FieldName,
		toTerm: group.ByName,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.Name,
			}
		},
	}
	// GroupOrderFieldDisplayName orders Group by display_name.
	GroupOrderFieldDisplayName = &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.DisplayName, nil
		},
		column: group.FieldDisplayName,
		toTerm: group.ByDisplayName,
		toCursor: func(gr *Group) Cursor {
			return Cursor{
				ID:    gr.ID,
				Value: gr.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupOrderField) String() string {
	var str string
	switch f.column {
	case GroupOrderFieldName.column:
		str = "name"
	case GroupOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *GroupOrderFieldName
	case "display_name":
		*f = *GroupOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

// GroupOrderField defines the ordering field of Group.
type GroupOrderField struct {
	// Value extracts the ordering value from the given Group.
	Value    func(*Group) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) group.OrderOption
	toCursor func(*Group) Cursor
}

// GroupOrder defines the ordering of Group.
type GroupOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *GroupOrderField `json:"field"`
}

// DefaultGroupOrder is the default ordering of Group.
var DefaultGroupOrder = &GroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.ID, nil
		},
		column: group.FieldID,
		toTerm: group.ByID,
		toCursor: func(gr *Group) Cursor {
			return Cursor{ID: gr.ID}
		},
	},
}

// ToEdge converts Group into GroupEdge.
func (gr *Group) ToEdge(order *GroupOrder) *GroupEdge {
	if order == nil {
		order = DefaultGroupOrder
	}
	return &GroupEdge{
		Node:   gr,
		Cursor: order.Field.toCursor(gr),
	}
}

// GroupHistoryEdge is the edge representation of GroupHistory.
type GroupHistoryEdge struct {
	Node   *GroupHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupHistoryConnection is the connection containing edges to GroupHistory.
type GroupHistoryConnection struct {
	Edges      []*GroupHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupHistoryConnection) build(nodes []*GroupHistory, pager *grouphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupHistoryPaginateOption enables pagination customization.
type GroupHistoryPaginateOption func(*grouphistoryPager) error

// WithGroupHistoryOrder configures pagination ordering.
func WithGroupHistoryOrder(order *GroupHistoryOrder) GroupHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	o := *order
	return func(pager *grouphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupHistoryFilter configures pagination filter.
func WithGroupHistoryFilter(filter func(*GroupHistoryQuery) (*GroupHistoryQuery, error)) GroupHistoryPaginateOption {
	return func(pager *grouphistoryPager) error {
		if filter == nil {
			return errors.New("GroupHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type grouphistoryPager struct {
	reverse bool
	order   *GroupHistoryOrder
	filter  func(*GroupHistoryQuery) (*GroupHistoryQuery, error)
}

func newGroupHistoryPager(opts []GroupHistoryPaginateOption, reverse bool) (*grouphistoryPager, error) {
	pager := &grouphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupHistoryOrder
	}
	return pager, nil
}

func (p *grouphistoryPager) applyFilter(query *GroupHistoryQuery) (*GroupHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *grouphistoryPager) toCursor(gh *GroupHistory) Cursor {
	return p.order.Field.toCursor(gh)
}

func (p *grouphistoryPager) applyCursors(query *GroupHistoryQuery, after, before *Cursor) (*GroupHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *grouphistoryPager) applyOrder(query *GroupHistoryQuery) *GroupHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupHistoryOrder.Field {
		query = query.Order(DefaultGroupHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *grouphistoryPager) orderExpr(query *GroupHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupHistory.
func (gh *GroupHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupHistoryPaginateOption,
) (*GroupHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gh, err = pager.applyFilter(gh); err != nil {
		return nil, err
	}
	conn := &GroupHistoryConnection{Edges: []*GroupHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gh, err = pager.applyCursors(gh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gh = pager.applyOrder(gh)
	nodes, err := gh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupHistoryOrderFieldName orders GroupHistory by name.
	GroupHistoryOrderFieldName = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.Name, nil
		},
		column: grouphistory.FieldName,
		toTerm: grouphistory.ByName,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.Name,
			}
		},
	}
	// GroupHistoryOrderFieldDisplayName orders GroupHistory by display_name.
	GroupHistoryOrderFieldDisplayName = &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.DisplayName, nil
		},
		column: grouphistory.FieldDisplayName,
		toTerm: grouphistory.ByDisplayName,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupHistoryOrderField) String() string {
	var str string
	switch f.column {
	case GroupHistoryOrderFieldName.column:
		str = "name"
	case GroupHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *GroupHistoryOrderFieldName
	case "display_name":
		*f = *GroupHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

// GroupHistoryOrderField defines the ordering field of GroupHistory.
type GroupHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupHistory.
	Value    func(*GroupHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) grouphistory.OrderOption
	toCursor func(*GroupHistory) Cursor
}

// GroupHistoryOrder defines the ordering of GroupHistory.
type GroupHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupHistoryOrderField `json:"field"`
}

// DefaultGroupHistoryOrder is the default ordering of GroupHistory.
var DefaultGroupHistoryOrder = &GroupHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupHistoryOrderField{
		Value: func(gh *GroupHistory) (ent.Value, error) {
			return gh.ID, nil
		},
		column: grouphistory.FieldID,
		toTerm: grouphistory.ByID,
		toCursor: func(gh *GroupHistory) Cursor {
			return Cursor{ID: gh.ID}
		},
	},
}

// ToEdge converts GroupHistory into GroupHistoryEdge.
func (gh *GroupHistory) ToEdge(order *GroupHistoryOrder) *GroupHistoryEdge {
	if order == nil {
		order = DefaultGroupHistoryOrder
	}
	return &GroupHistoryEdge{
		Node:   gh,
		Cursor: order.Field.toCursor(gh),
	}
}

// GroupMembershipEdge is the edge representation of GroupMembership.
type GroupMembershipEdge struct {
	Node   *GroupMembership `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// GroupMembershipConnection is the connection containing edges to GroupMembership.
type GroupMembershipConnection struct {
	Edges      []*GroupMembershipEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *GroupMembershipConnection) build(nodes []*GroupMembership, pager *groupmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipPaginateOption enables pagination customization.
type GroupMembershipPaginateOption func(*groupmembershipPager) error

// WithGroupMembershipOrder configures pagination ordering.
func WithGroupMembershipOrder(order *GroupMembershipOrder) GroupMembershipPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	o := *order
	return func(pager *groupmembershipPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipFilter configures pagination filter.
func WithGroupMembershipFilter(filter func(*GroupMembershipQuery) (*GroupMembershipQuery, error)) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		if filter == nil {
			return errors.New("GroupMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershipPager struct {
	reverse bool
	order   *GroupMembershipOrder
	filter  func(*GroupMembershipQuery) (*GroupMembershipQuery, error)
}

func newGroupMembershipPager(opts []GroupMembershipPaginateOption, reverse bool) (*groupmembershipPager, error) {
	pager := &groupmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipOrder
	}
	return pager, nil
}

func (p *groupmembershipPager) applyFilter(query *GroupMembershipQuery) (*GroupMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershipPager) toCursor(gm *GroupMembership) Cursor {
	return p.order.Field.toCursor(gm)
}

func (p *groupmembershipPager) applyCursors(query *GroupMembershipQuery, after, before *Cursor) (*GroupMembershipQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershipPager) applyOrder(query *GroupMembershipQuery) *GroupMembershipQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipOrder.Field {
		query = query.Order(DefaultGroupMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershipPager) orderExpr(query *GroupMembershipQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembership.
func (gm *GroupMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipPaginateOption,
) (*GroupMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gm, err = pager.applyFilter(gm); err != nil {
		return nil, err
	}
	conn := &GroupMembershipConnection{Edges: []*GroupMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gm.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gm, err = pager.applyCursors(gm, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gm.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gm = pager.applyOrder(gm)
	nodes, err := gm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupMembershipOrderField defines the ordering field of GroupMembership.
type GroupMembershipOrderField struct {
	// Value extracts the ordering value from the given GroupMembership.
	Value    func(*GroupMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembership.OrderOption
	toCursor func(*GroupMembership) Cursor
}

// GroupMembershipOrder defines the ordering of GroupMembership.
type GroupMembershipOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *GroupMembershipOrderField `json:"field"`
}

// DefaultGroupMembershipOrder is the default ordering of GroupMembership.
var DefaultGroupMembershipOrder = &GroupMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipOrderField{
		Value: func(gm *GroupMembership) (ent.Value, error) {
			return gm.ID, nil
		},
		column: groupmembership.FieldID,
		toTerm: groupmembership.ByID,
		toCursor: func(gm *GroupMembership) Cursor {
			return Cursor{ID: gm.ID}
		},
	},
}

// ToEdge converts GroupMembership into GroupMembershipEdge.
func (gm *GroupMembership) ToEdge(order *GroupMembershipOrder) *GroupMembershipEdge {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	return &GroupMembershipEdge{
		Node:   gm,
		Cursor: order.Field.toCursor(gm),
	}
}

// GroupMembershipHistoryEdge is the edge representation of GroupMembershipHistory.
type GroupMembershipHistoryEdge struct {
	Node   *GroupMembershipHistory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// GroupMembershipHistoryConnection is the connection containing edges to GroupMembershipHistory.
type GroupMembershipHistoryConnection struct {
	Edges      []*GroupMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *GroupMembershipHistoryConnection) build(nodes []*GroupMembershipHistory, pager *groupmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipHistoryPaginateOption enables pagination customization.
type GroupMembershipHistoryPaginateOption func(*groupmembershiphistoryPager) error

// WithGroupMembershipHistoryOrder configures pagination ordering.
func WithGroupMembershipHistoryOrder(order *GroupMembershipHistoryOrder) GroupMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	o := *order
	return func(pager *groupmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipHistoryFilter configures pagination filter.
func WithGroupMembershipHistoryFilter(filter func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)) GroupMembershipHistoryPaginateOption {
	return func(pager *groupmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("GroupMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershiphistoryPager struct {
	reverse bool
	order   *GroupMembershipHistoryOrder
	filter  func(*GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error)
}

func newGroupMembershipHistoryPager(opts []GroupMembershipHistoryPaginateOption, reverse bool) (*groupmembershiphistoryPager, error) {
	pager := &groupmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipHistoryOrder
	}
	return pager, nil
}

func (p *groupmembershiphistoryPager) applyFilter(query *GroupMembershipHistoryQuery) (*GroupMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) toCursor(gmh *GroupMembershipHistory) Cursor {
	return p.order.Field.toCursor(gmh)
}

func (p *groupmembershiphistoryPager) applyCursors(query *GroupMembershipHistoryQuery, after, before *Cursor) (*GroupMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershiphistoryPager) applyOrder(query *GroupMembershipHistoryQuery) *GroupMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
		query = query.Order(DefaultGroupMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershiphistoryPager) orderExpr(query *GroupMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembershipHistory.
func (gmh *GroupMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipHistoryPaginateOption,
) (*GroupMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gmh, err = pager.applyFilter(gmh); err != nil {
		return nil, err
	}
	conn := &GroupMembershipHistoryConnection{Edges: []*GroupMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gmh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gmh, err = pager.applyCursors(gmh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gmh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gmh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gmh = pager.applyOrder(gmh)
	nodes, err := gmh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupMembershipHistoryOrderField defines the ordering field of GroupMembershipHistory.
type GroupMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupMembershipHistory.
	Value    func(*GroupMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembershiphistory.OrderOption
	toCursor func(*GroupMembershipHistory) Cursor
}

// GroupMembershipHistoryOrder defines the ordering of GroupMembershipHistory.
type GroupMembershipHistoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *GroupMembershipHistoryOrderField `json:"field"`
}

// DefaultGroupMembershipHistoryOrder is the default ordering of GroupMembershipHistory.
var DefaultGroupMembershipHistoryOrder = &GroupMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipHistoryOrderField{
		Value: func(gmh *GroupMembershipHistory) (ent.Value, error) {
			return gmh.ID, nil
		},
		column: groupmembershiphistory.FieldID,
		toTerm: groupmembershiphistory.ByID,
		toCursor: func(gmh *GroupMembershipHistory) Cursor {
			return Cursor{ID: gmh.ID}
		},
	},
}

// ToEdge converts GroupMembershipHistory into GroupMembershipHistoryEdge.
func (gmh *GroupMembershipHistory) ToEdge(order *GroupMembershipHistoryOrder) *GroupMembershipHistoryEdge {
	if order == nil {
		order = DefaultGroupMembershipHistoryOrder
	}
	return &GroupMembershipHistoryEdge{
		Node:   gmh,
		Cursor: order.Field.toCursor(gmh),
	}
}

// GroupSettingEdge is the edge representation of GroupSetting.
type GroupSettingEdge struct {
	Node   *GroupSetting `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupSettingConnection is the connection containing edges to GroupSetting.
type GroupSettingConnection struct {
	Edges      []*GroupSettingEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupSettingConnection) build(nodes []*GroupSetting, pager *groupsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingPaginateOption enables pagination customization.
type GroupSettingPaginateOption func(*groupsettingPager) error

// WithGroupSettingOrder configures pagination ordering.
func WithGroupSettingOrder(order *GroupSettingOrder) GroupSettingPaginateOption {
	if order == nil {
		order = DefaultGroupSettingOrder
	}
	o := *order
	return func(pager *groupsettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupSettingFilter configures pagination filter.
func WithGroupSettingFilter(filter func(*GroupSettingQuery) (*GroupSettingQuery, error)) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		if filter == nil {
			return errors.New("GroupSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettingPager struct {
	reverse bool
	order   *GroupSettingOrder
	filter  func(*GroupSettingQuery) (*GroupSettingQuery, error)
}

func newGroupSettingPager(opts []GroupSettingPaginateOption, reverse bool) (*groupsettingPager, error) {
	pager := &groupsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupSettingOrder
	}
	return pager, nil
}

func (p *groupsettingPager) applyFilter(query *GroupSettingQuery) (*GroupSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettingPager) toCursor(gs *GroupSetting) Cursor {
	return p.order.Field.toCursor(gs)
}

func (p *groupsettingPager) applyCursors(query *GroupSettingQuery, after, before *Cursor) (*GroupSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupSettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupsettingPager) applyOrder(query *GroupSettingQuery) *GroupSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupSettingOrder.Field {
		query = query.Order(DefaultGroupSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupsettingPager) orderExpr(query *GroupSettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupSettingOrder.Field {
			b.Comma().Ident(DefaultGroupSettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSetting.
func (gs *GroupSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingPaginateOption,
) (*GroupSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gs, err = pager.applyFilter(gs); err != nil {
		return nil, err
	}
	conn := &GroupSettingConnection{Edges: []*GroupSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gs, err = pager.applyCursors(gs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gs = pager.applyOrder(gs)
	nodes, err := gs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupSettingOrderField defines the ordering field of GroupSetting.
type GroupSettingOrderField struct {
	// Value extracts the ordering value from the given GroupSetting.
	Value    func(*GroupSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsetting.OrderOption
	toCursor func(*GroupSetting) Cursor
}

// GroupSettingOrder defines the ordering of GroupSetting.
type GroupSettingOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupSettingOrderField `json:"field"`
}

// DefaultGroupSettingOrder is the default ordering of GroupSetting.
var DefaultGroupSettingOrder = &GroupSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingOrderField{
		Value: func(gs *GroupSetting) (ent.Value, error) {
			return gs.ID, nil
		},
		column: groupsetting.FieldID,
		toTerm: groupsetting.ByID,
		toCursor: func(gs *GroupSetting) Cursor {
			return Cursor{ID: gs.ID}
		},
	},
}

// ToEdge converts GroupSetting into GroupSettingEdge.
func (gs *GroupSetting) ToEdge(order *GroupSettingOrder) *GroupSettingEdge {
	if order == nil {
		order = DefaultGroupSettingOrder
	}
	return &GroupSettingEdge{
		Node:   gs,
		Cursor: order.Field.toCursor(gs),
	}
}

// GroupSettingHistoryEdge is the edge representation of GroupSettingHistory.
type GroupSettingHistoryEdge struct {
	Node   *GroupSettingHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// GroupSettingHistoryConnection is the connection containing edges to GroupSettingHistory.
type GroupSettingHistoryConnection struct {
	Edges      []*GroupSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *GroupSettingHistoryConnection) build(nodes []*GroupSettingHistory, pager *groupsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingHistoryPaginateOption enables pagination customization.
type GroupSettingHistoryPaginateOption func(*groupsettinghistoryPager) error

// WithGroupSettingHistoryOrder configures pagination ordering.
func WithGroupSettingHistoryOrder(order *GroupSettingHistoryOrder) GroupSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	o := *order
	return func(pager *groupsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupSettingHistoryFilter configures pagination filter.
func WithGroupSettingHistoryFilter(filter func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)) GroupSettingHistoryPaginateOption {
	return func(pager *groupsettinghistoryPager) error {
		if filter == nil {
			return errors.New("GroupSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettinghistoryPager struct {
	reverse bool
	order   *GroupSettingHistoryOrder
	filter  func(*GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error)
}

func newGroupSettingHistoryPager(opts []GroupSettingHistoryPaginateOption, reverse bool) (*groupsettinghistoryPager, error) {
	pager := &groupsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupSettingHistoryOrder
	}
	return pager, nil
}

func (p *groupsettinghistoryPager) applyFilter(query *GroupSettingHistoryQuery) (*GroupSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) toCursor(gsh *GroupSettingHistory) Cursor {
	return p.order.Field.toCursor(gsh)
}

func (p *groupsettinghistoryPager) applyCursors(query *GroupSettingHistoryQuery, after, before *Cursor) (*GroupSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupsettinghistoryPager) applyOrder(query *GroupSettingHistoryQuery) *GroupSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
		query = query.Order(DefaultGroupSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupsettinghistoryPager) orderExpr(query *GroupSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultGroupSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSettingHistory.
func (gsh *GroupSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingHistoryPaginateOption,
) (*GroupSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gsh, err = pager.applyFilter(gsh); err != nil {
		return nil, err
	}
	conn := &GroupSettingHistoryConnection{Edges: []*GroupSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gsh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gsh, err = pager.applyCursors(gsh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gsh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gsh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gsh = pager.applyOrder(gsh)
	nodes, err := gsh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupSettingHistoryOrderField defines the ordering field of GroupSettingHistory.
type GroupSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given GroupSettingHistory.
	Value    func(*GroupSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsettinghistory.OrderOption
	toCursor func(*GroupSettingHistory) Cursor
}

// GroupSettingHistoryOrder defines the ordering of GroupSettingHistory.
type GroupSettingHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *GroupSettingHistoryOrderField `json:"field"`
}

// DefaultGroupSettingHistoryOrder is the default ordering of GroupSettingHistory.
var DefaultGroupSettingHistoryOrder = &GroupSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingHistoryOrderField{
		Value: func(gsh *GroupSettingHistory) (ent.Value, error) {
			return gsh.ID, nil
		},
		column: groupsettinghistory.FieldID,
		toTerm: groupsettinghistory.ByID,
		toCursor: func(gsh *GroupSettingHistory) Cursor {
			return Cursor{ID: gsh.ID}
		},
	},
}

// ToEdge converts GroupSettingHistory into GroupSettingHistoryEdge.
func (gsh *GroupSettingHistory) ToEdge(order *GroupSettingHistoryOrder) *GroupSettingHistoryEdge {
	if order == nil {
		order = DefaultGroupSettingHistoryOrder
	}
	return &GroupSettingHistoryEdge{
		Node:   gsh,
		Cursor: order.Field.toCursor(gsh),
	}
}

// HushEdge is the edge representation of Hush.
type HushEdge struct {
	Node   *Hush  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HushConnection is the connection containing edges to Hush.
type HushConnection struct {
	Edges      []*HushEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *HushConnection) build(nodes []*Hush, pager *hushPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Hush
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Hush {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Hush {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushPaginateOption enables pagination customization.
type HushPaginateOption func(*hushPager) error

// WithHushOrder configures pagination ordering.
func WithHushOrder(order *HushOrder) HushPaginateOption {
	if order == nil {
		order = DefaultHushOrder
	}
	o := *order
	return func(pager *hushPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHushOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHushFilter configures pagination filter.
func WithHushFilter(filter func(*HushQuery) (*HushQuery, error)) HushPaginateOption {
	return func(pager *hushPager) error {
		if filter == nil {
			return errors.New("HushQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushPager struct {
	reverse bool
	order   *HushOrder
	filter  func(*HushQuery) (*HushQuery, error)
}

func newHushPager(opts []HushPaginateOption, reverse bool) (*hushPager, error) {
	pager := &hushPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHushOrder
	}
	return pager, nil
}

func (p *hushPager) applyFilter(query *HushQuery) (*HushQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushPager) toCursor(h *Hush) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *hushPager) applyCursors(query *HushQuery, after, before *Cursor) (*HushQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHushOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hushPager) applyOrder(query *HushQuery) *HushQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHushOrder.Field {
		query = query.Order(DefaultHushOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hushPager) orderExpr(query *HushQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHushOrder.Field {
			b.Comma().Ident(DefaultHushOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Hush.
func (h *HushQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushPaginateOption,
) (*HushConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}
	conn := &HushConnection{Edges: []*HushEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := h.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if h, err = pager.applyCursors(h, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		h.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := h.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	h = pager.applyOrder(h)
	nodes, err := h.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushOrderFieldName orders Hush by name.
	HushOrderFieldName = &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.Name, nil
		},
		column: hush.FieldName,
		toTerm: hush.ByName,
		toCursor: func(h *Hush) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.Name,
			}
		},
	}
	// HushOrderFieldKind orders Hush by kind.
	HushOrderFieldKind = &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.Kind, nil
		},
		column: hush.FieldKind,
		toTerm: hush.ByKind,
		toCursor: func(h *Hush) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushOrderField) String() string {
	var str string
	switch f.column {
	case HushOrderFieldName.column:
		str = "name"
	case HushOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *HushOrderFieldName
	case "kind":
		*f = *HushOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

// HushOrderField defines the ordering field of Hush.
type HushOrderField struct {
	// Value extracts the ordering value from the given Hush.
	Value    func(*Hush) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hush.OrderOption
	toCursor func(*Hush) Cursor
}

// HushOrder defines the ordering of Hush.
type HushOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HushOrderField `json:"field"`
}

// DefaultHushOrder is the default ordering of Hush.
var DefaultHushOrder = &HushOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushOrderField{
		Value: func(h *Hush) (ent.Value, error) {
			return h.ID, nil
		},
		column: hush.FieldID,
		toTerm: hush.ByID,
		toCursor: func(h *Hush) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Hush into HushEdge.
func (h *Hush) ToEdge(order *HushOrder) *HushEdge {
	if order == nil {
		order = DefaultHushOrder
	}
	return &HushEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// HushHistoryEdge is the edge representation of HushHistory.
type HushHistoryEdge struct {
	Node   *HushHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// HushHistoryConnection is the connection containing edges to HushHistory.
type HushHistoryConnection struct {
	Edges      []*HushHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *HushHistoryConnection) build(nodes []*HushHistory, pager *hushhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HushHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HushHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HushHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushHistoryPaginateOption enables pagination customization.
type HushHistoryPaginateOption func(*hushhistoryPager) error

// WithHushHistoryOrder configures pagination ordering.
func WithHushHistoryOrder(order *HushHistoryOrder) HushHistoryPaginateOption {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	o := *order
	return func(pager *hushhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHushHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHushHistoryFilter configures pagination filter.
func WithHushHistoryFilter(filter func(*HushHistoryQuery) (*HushHistoryQuery, error)) HushHistoryPaginateOption {
	return func(pager *hushhistoryPager) error {
		if filter == nil {
			return errors.New("HushHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushhistoryPager struct {
	reverse bool
	order   *HushHistoryOrder
	filter  func(*HushHistoryQuery) (*HushHistoryQuery, error)
}

func newHushHistoryPager(opts []HushHistoryPaginateOption, reverse bool) (*hushhistoryPager, error) {
	pager := &hushhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHushHistoryOrder
	}
	return pager, nil
}

func (p *hushhistoryPager) applyFilter(query *HushHistoryQuery) (*HushHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushhistoryPager) toCursor(hh *HushHistory) Cursor {
	return p.order.Field.toCursor(hh)
}

func (p *hushhistoryPager) applyCursors(query *HushHistoryQuery, after, before *Cursor) (*HushHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHushHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hushhistoryPager) applyOrder(query *HushHistoryQuery) *HushHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHushHistoryOrder.Field {
		query = query.Order(DefaultHushHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hushhistoryPager) orderExpr(query *HushHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHushHistoryOrder.Field {
			b.Comma().Ident(DefaultHushHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HushHistory.
func (hh *HushHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushHistoryPaginateOption,
) (*HushHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hh, err = pager.applyFilter(hh); err != nil {
		return nil, err
	}
	conn := &HushHistoryConnection{Edges: []*HushHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := hh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if hh, err = pager.applyCursors(hh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		hh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	hh = pager.applyOrder(hh)
	nodes, err := hh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushHistoryOrderFieldName orders HushHistory by name.
	HushHistoryOrderFieldName = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.Name, nil
		},
		column: hushhistory.FieldName,
		toTerm: hushhistory.ByName,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.Name,
			}
		},
	}
	// HushHistoryOrderFieldKind orders HushHistory by kind.
	HushHistoryOrderFieldKind = &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.Kind, nil
		},
		column: hushhistory.FieldKind,
		toTerm: hushhistory.ByKind,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{
				ID:    hh.ID,
				Value: hh.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushHistoryOrderField) String() string {
	var str string
	switch f.column {
	case HushHistoryOrderFieldName.column:
		str = "name"
	case HushHistoryOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *HushHistoryOrderFieldName
	case "kind":
		*f = *HushHistoryOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

// HushHistoryOrderField defines the ordering field of HushHistory.
type HushHistoryOrderField struct {
	// Value extracts the ordering value from the given HushHistory.
	Value    func(*HushHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hushhistory.OrderOption
	toCursor func(*HushHistory) Cursor
}

// HushHistoryOrder defines the ordering of HushHistory.
type HushHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *HushHistoryOrderField `json:"field"`
}

// DefaultHushHistoryOrder is the default ordering of HushHistory.
var DefaultHushHistoryOrder = &HushHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushHistoryOrderField{
		Value: func(hh *HushHistory) (ent.Value, error) {
			return hh.ID, nil
		},
		column: hushhistory.FieldID,
		toTerm: hushhistory.ByID,
		toCursor: func(hh *HushHistory) Cursor {
			return Cursor{ID: hh.ID}
		},
	},
}

// ToEdge converts HushHistory into HushHistoryEdge.
func (hh *HushHistory) ToEdge(order *HushHistoryOrder) *HushHistoryEdge {
	if order == nil {
		order = DefaultHushHistoryOrder
	}
	return &HushHistoryEdge{
		Node:   hh,
		Cursor: order.Field.toCursor(hh),
	}
}

// IntegrationEdge is the edge representation of Integration.
type IntegrationEdge struct {
	Node   *Integration `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// IntegrationConnection is the connection containing edges to Integration.
type IntegrationConnection struct {
	Edges      []*IntegrationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *IntegrationConnection) build(nodes []*Integration, pager *integrationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Integration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Integration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Integration {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationPaginateOption enables pagination customization.
type IntegrationPaginateOption func(*integrationPager) error

// WithIntegrationOrder configures pagination ordering.
func WithIntegrationOrder(order *IntegrationOrder) IntegrationPaginateOption {
	if order == nil {
		order = DefaultIntegrationOrder
	}
	o := *order
	return func(pager *integrationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIntegrationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIntegrationFilter configures pagination filter.
func WithIntegrationFilter(filter func(*IntegrationQuery) (*IntegrationQuery, error)) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		if filter == nil {
			return errors.New("IntegrationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationPager struct {
	reverse bool
	order   *IntegrationOrder
	filter  func(*IntegrationQuery) (*IntegrationQuery, error)
}

func newIntegrationPager(opts []IntegrationPaginateOption, reverse bool) (*integrationPager, error) {
	pager := &integrationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIntegrationOrder
	}
	return pager, nil
}

func (p *integrationPager) applyFilter(query *IntegrationQuery) (*IntegrationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationPager) toCursor(i *Integration) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *integrationPager) applyCursors(query *IntegrationQuery, after, before *Cursor) (*IntegrationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIntegrationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *integrationPager) applyOrder(query *IntegrationQuery) *IntegrationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIntegrationOrder.Field {
		query = query.Order(DefaultIntegrationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *integrationPager) orderExpr(query *IntegrationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIntegrationOrder.Field {
			b.Comma().Ident(DefaultIntegrationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Integration.
func (i *IntegrationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationPaginateOption,
) (*IntegrationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IntegrationConnection{Edges: []*IntegrationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := i.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationOrderFieldName orders Integration by name.
	IntegrationOrderFieldName = &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.Name, nil
		},
		column: integration.FieldName,
		toTerm: integration.ByName,
		toCursor: func(i *Integration) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Name,
			}
		},
	}
	// IntegrationOrderFieldKind orders Integration by kind.
	IntegrationOrderFieldKind = &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.Kind, nil
		},
		column: integration.FieldKind,
		toTerm: integration.ByKind,
		toCursor: func(i *Integration) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationOrderFieldName.column:
		str = "name"
	case IntegrationOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *IntegrationOrderFieldName
	case "kind":
		*f = *IntegrationOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

// IntegrationOrderField defines the ordering field of Integration.
type IntegrationOrderField struct {
	// Value extracts the ordering value from the given Integration.
	Value    func(*Integration) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integration.OrderOption
	toCursor func(*Integration) Cursor
}

// IntegrationOrder defines the ordering of Integration.
type IntegrationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *IntegrationOrderField `json:"field"`
}

// DefaultIntegrationOrder is the default ordering of Integration.
var DefaultIntegrationOrder = &IntegrationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationOrderField{
		Value: func(i *Integration) (ent.Value, error) {
			return i.ID, nil
		},
		column: integration.FieldID,
		toTerm: integration.ByID,
		toCursor: func(i *Integration) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Integration into IntegrationEdge.
func (i *Integration) ToEdge(order *IntegrationOrder) *IntegrationEdge {
	if order == nil {
		order = DefaultIntegrationOrder
	}
	return &IntegrationEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// IntegrationHistoryEdge is the edge representation of IntegrationHistory.
type IntegrationHistoryEdge struct {
	Node   *IntegrationHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// IntegrationHistoryConnection is the connection containing edges to IntegrationHistory.
type IntegrationHistoryConnection struct {
	Edges      []*IntegrationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *IntegrationHistoryConnection) build(nodes []*IntegrationHistory, pager *integrationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *IntegrationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IntegrationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationHistoryPaginateOption enables pagination customization.
type IntegrationHistoryPaginateOption func(*integrationhistoryPager) error

// WithIntegrationHistoryOrder configures pagination ordering.
func WithIntegrationHistoryOrder(order *IntegrationHistoryOrder) IntegrationHistoryPaginateOption {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	o := *order
	return func(pager *integrationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIntegrationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIntegrationHistoryFilter configures pagination filter.
func WithIntegrationHistoryFilter(filter func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)) IntegrationHistoryPaginateOption {
	return func(pager *integrationhistoryPager) error {
		if filter == nil {
			return errors.New("IntegrationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationhistoryPager struct {
	reverse bool
	order   *IntegrationHistoryOrder
	filter  func(*IntegrationHistoryQuery) (*IntegrationHistoryQuery, error)
}

func newIntegrationHistoryPager(opts []IntegrationHistoryPaginateOption, reverse bool) (*integrationhistoryPager, error) {
	pager := &integrationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIntegrationHistoryOrder
	}
	return pager, nil
}

func (p *integrationhistoryPager) applyFilter(query *IntegrationHistoryQuery) (*IntegrationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationhistoryPager) toCursor(ih *IntegrationHistory) Cursor {
	return p.order.Field.toCursor(ih)
}

func (p *integrationhistoryPager) applyCursors(query *IntegrationHistoryQuery, after, before *Cursor) (*IntegrationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIntegrationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *integrationhistoryPager) applyOrder(query *IntegrationHistoryQuery) *IntegrationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIntegrationHistoryOrder.Field {
		query = query.Order(DefaultIntegrationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *integrationhistoryPager) orderExpr(query *IntegrationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIntegrationHistoryOrder.Field {
			b.Comma().Ident(DefaultIntegrationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IntegrationHistory.
func (ih *IntegrationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationHistoryPaginateOption,
) (*IntegrationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ih, err = pager.applyFilter(ih); err != nil {
		return nil, err
	}
	conn := &IntegrationHistoryConnection{Edges: []*IntegrationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ih.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ih, err = pager.applyCursors(ih, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ih.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ih.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ih = pager.applyOrder(ih)
	nodes, err := ih.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationHistoryOrderFieldName orders IntegrationHistory by name.
	IntegrationHistoryOrderFieldName = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.Name, nil
		},
		column: integrationhistory.FieldName,
		toTerm: integrationhistory.ByName,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.Name,
			}
		},
	}
	// IntegrationHistoryOrderFieldKind orders IntegrationHistory by kind.
	IntegrationHistoryOrderFieldKind = &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.Kind, nil
		},
		column: integrationhistory.FieldKind,
		toTerm: integrationhistory.ByKind,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{
				ID:    ih.ID,
				Value: ih.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationHistoryOrderFieldName.column:
		str = "name"
	case IntegrationHistoryOrderFieldKind.column:
		str = "kind"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *IntegrationHistoryOrderFieldName
	case "kind":
		*f = *IntegrationHistoryOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

// IntegrationHistoryOrderField defines the ordering field of IntegrationHistory.
type IntegrationHistoryOrderField struct {
	// Value extracts the ordering value from the given IntegrationHistory.
	Value    func(*IntegrationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integrationhistory.OrderOption
	toCursor func(*IntegrationHistory) Cursor
}

// IntegrationHistoryOrder defines the ordering of IntegrationHistory.
type IntegrationHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *IntegrationHistoryOrderField `json:"field"`
}

// DefaultIntegrationHistoryOrder is the default ordering of IntegrationHistory.
var DefaultIntegrationHistoryOrder = &IntegrationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationHistoryOrderField{
		Value: func(ih *IntegrationHistory) (ent.Value, error) {
			return ih.ID, nil
		},
		column: integrationhistory.FieldID,
		toTerm: integrationhistory.ByID,
		toCursor: func(ih *IntegrationHistory) Cursor {
			return Cursor{ID: ih.ID}
		},
	},
}

// ToEdge converts IntegrationHistory into IntegrationHistoryEdge.
func (ih *IntegrationHistory) ToEdge(order *IntegrationHistoryOrder) *IntegrationHistoryEdge {
	if order == nil {
		order = DefaultIntegrationHistoryOrder
	}
	return &IntegrationHistoryEdge{
		Node:   ih,
		Cursor: order.Field.toCursor(ih),
	}
}

// InternalPolicyEdge is the edge representation of InternalPolicy.
type InternalPolicyEdge struct {
	Node   *InternalPolicy `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// InternalPolicyConnection is the connection containing edges to InternalPolicy.
type InternalPolicyConnection struct {
	Edges      []*InternalPolicyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *InternalPolicyConnection) build(nodes []*InternalPolicy, pager *internalpolicyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InternalPolicy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicy {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyPaginateOption enables pagination customization.
type InternalPolicyPaginateOption func(*internalpolicyPager) error

// WithInternalPolicyOrder configures pagination ordering.
func WithInternalPolicyOrder(order *InternalPolicyOrder) InternalPolicyPaginateOption {
	if order == nil {
		order = DefaultInternalPolicyOrder
	}
	o := *order
	return func(pager *internalpolicyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInternalPolicyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInternalPolicyFilter configures pagination filter.
func WithInternalPolicyFilter(filter func(*InternalPolicyQuery) (*InternalPolicyQuery, error)) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		if filter == nil {
			return errors.New("InternalPolicyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyPager struct {
	reverse bool
	order   *InternalPolicyOrder
	filter  func(*InternalPolicyQuery) (*InternalPolicyQuery, error)
}

func newInternalPolicyPager(opts []InternalPolicyPaginateOption, reverse bool) (*internalpolicyPager, error) {
	pager := &internalpolicyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInternalPolicyOrder
	}
	return pager, nil
}

func (p *internalpolicyPager) applyFilter(query *InternalPolicyQuery) (*InternalPolicyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyPager) toCursor(ip *InternalPolicy) Cursor {
	return p.order.Field.toCursor(ip)
}

func (p *internalpolicyPager) applyCursors(query *InternalPolicyQuery, after, before *Cursor) (*InternalPolicyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInternalPolicyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *internalpolicyPager) applyOrder(query *InternalPolicyQuery) *InternalPolicyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInternalPolicyOrder.Field {
		query = query.Order(DefaultInternalPolicyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *internalpolicyPager) orderExpr(query *InternalPolicyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInternalPolicyOrder.Field {
			b.Comma().Ident(DefaultInternalPolicyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicy.
func (ip *InternalPolicyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyPaginateOption,
) (*InternalPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ip, err = pager.applyFilter(ip); err != nil {
		return nil, err
	}
	conn := &InternalPolicyConnection{Edges: []*InternalPolicyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ip.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ip, err = pager.applyCursors(ip, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ip.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ip.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ip = pager.applyOrder(ip)
	nodes, err := ip.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// InternalPolicyOrderField defines the ordering field of InternalPolicy.
type InternalPolicyOrderField struct {
	// Value extracts the ordering value from the given InternalPolicy.
	Value    func(*InternalPolicy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicy.OrderOption
	toCursor func(*InternalPolicy) Cursor
}

// InternalPolicyOrder defines the ordering of InternalPolicy.
type InternalPolicyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *InternalPolicyOrderField `json:"field"`
}

// DefaultInternalPolicyOrder is the default ordering of InternalPolicy.
var DefaultInternalPolicyOrder = &InternalPolicyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyOrderField{
		Value: func(ip *InternalPolicy) (ent.Value, error) {
			return ip.ID, nil
		},
		column: internalpolicy.FieldID,
		toTerm: internalpolicy.ByID,
		toCursor: func(ip *InternalPolicy) Cursor {
			return Cursor{ID: ip.ID}
		},
	},
}

// ToEdge converts InternalPolicy into InternalPolicyEdge.
func (ip *InternalPolicy) ToEdge(order *InternalPolicyOrder) *InternalPolicyEdge {
	if order == nil {
		order = DefaultInternalPolicyOrder
	}
	return &InternalPolicyEdge{
		Node:   ip,
		Cursor: order.Field.toCursor(ip),
	}
}

// InternalPolicyHistoryEdge is the edge representation of InternalPolicyHistory.
type InternalPolicyHistoryEdge struct {
	Node   *InternalPolicyHistory `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// InternalPolicyHistoryConnection is the connection containing edges to InternalPolicyHistory.
type InternalPolicyHistoryConnection struct {
	Edges      []*InternalPolicyHistoryEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *InternalPolicyHistoryConnection) build(nodes []*InternalPolicyHistory, pager *internalpolicyhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InternalPolicyHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicyHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyHistoryPaginateOption enables pagination customization.
type InternalPolicyHistoryPaginateOption func(*internalpolicyhistoryPager) error

// WithInternalPolicyHistoryOrder configures pagination ordering.
func WithInternalPolicyHistoryOrder(order *InternalPolicyHistoryOrder) InternalPolicyHistoryPaginateOption {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	o := *order
	return func(pager *internalpolicyhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInternalPolicyHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInternalPolicyHistoryFilter configures pagination filter.
func WithInternalPolicyHistoryFilter(filter func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)) InternalPolicyHistoryPaginateOption {
	return func(pager *internalpolicyhistoryPager) error {
		if filter == nil {
			return errors.New("InternalPolicyHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyhistoryPager struct {
	reverse bool
	order   *InternalPolicyHistoryOrder
	filter  func(*InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error)
}

func newInternalPolicyHistoryPager(opts []InternalPolicyHistoryPaginateOption, reverse bool) (*internalpolicyhistoryPager, error) {
	pager := &internalpolicyhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInternalPolicyHistoryOrder
	}
	return pager, nil
}

func (p *internalpolicyhistoryPager) applyFilter(query *InternalPolicyHistoryQuery) (*InternalPolicyHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) toCursor(iph *InternalPolicyHistory) Cursor {
	return p.order.Field.toCursor(iph)
}

func (p *internalpolicyhistoryPager) applyCursors(query *InternalPolicyHistoryQuery, after, before *Cursor) (*InternalPolicyHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInternalPolicyHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *internalpolicyhistoryPager) applyOrder(query *InternalPolicyHistoryQuery) *InternalPolicyHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
		query = query.Order(DefaultInternalPolicyHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *internalpolicyhistoryPager) orderExpr(query *InternalPolicyHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInternalPolicyHistoryOrder.Field {
			b.Comma().Ident(DefaultInternalPolicyHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicyHistory.
func (iph *InternalPolicyHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyHistoryPaginateOption,
) (*InternalPolicyHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if iph, err = pager.applyFilter(iph); err != nil {
		return nil, err
	}
	conn := &InternalPolicyHistoryConnection{Edges: []*InternalPolicyHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := iph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if iph, err = pager.applyCursors(iph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		iph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := iph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	iph = pager.applyOrder(iph)
	nodes, err := iph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// InternalPolicyHistoryOrderField defines the ordering field of InternalPolicyHistory.
type InternalPolicyHistoryOrderField struct {
	// Value extracts the ordering value from the given InternalPolicyHistory.
	Value    func(*InternalPolicyHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicyhistory.OrderOption
	toCursor func(*InternalPolicyHistory) Cursor
}

// InternalPolicyHistoryOrder defines the ordering of InternalPolicyHistory.
type InternalPolicyHistoryOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *InternalPolicyHistoryOrderField `json:"field"`
}

// DefaultInternalPolicyHistoryOrder is the default ordering of InternalPolicyHistory.
var DefaultInternalPolicyHistoryOrder = &InternalPolicyHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyHistoryOrderField{
		Value: func(iph *InternalPolicyHistory) (ent.Value, error) {
			return iph.ID, nil
		},
		column: internalpolicyhistory.FieldID,
		toTerm: internalpolicyhistory.ByID,
		toCursor: func(iph *InternalPolicyHistory) Cursor {
			return Cursor{ID: iph.ID}
		},
	},
}

// ToEdge converts InternalPolicyHistory into InternalPolicyHistoryEdge.
func (iph *InternalPolicyHistory) ToEdge(order *InternalPolicyHistoryOrder) *InternalPolicyHistoryEdge {
	if order == nil {
		order = DefaultInternalPolicyHistoryOrder
	}
	return &InternalPolicyHistoryEdge{
		Node:   iph,
		Cursor: order.Field.toCursor(iph),
	}
}

// InviteEdge is the edge representation of Invite.
type InviteEdge struct {
	Node   *Invite `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// InviteConnection is the connection containing edges to Invite.
type InviteConnection struct {
	Edges      []*InviteEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *InviteConnection) build(nodes []*Invite, pager *invitePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Invite
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Invite {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Invite {
			return nodes[i]
		}
	}
	c.Edges = make([]*InviteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InviteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InvitePaginateOption enables pagination customization.
type InvitePaginateOption func(*invitePager) error

// WithInviteOrder configures pagination ordering.
func WithInviteOrder(order *InviteOrder) InvitePaginateOption {
	if order == nil {
		order = DefaultInviteOrder
	}
	o := *order
	return func(pager *invitePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInviteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInviteFilter configures pagination filter.
func WithInviteFilter(filter func(*InviteQuery) (*InviteQuery, error)) InvitePaginateOption {
	return func(pager *invitePager) error {
		if filter == nil {
			return errors.New("InviteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type invitePager struct {
	reverse bool
	order   *InviteOrder
	filter  func(*InviteQuery) (*InviteQuery, error)
}

func newInvitePager(opts []InvitePaginateOption, reverse bool) (*invitePager, error) {
	pager := &invitePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInviteOrder
	}
	return pager, nil
}

func (p *invitePager) applyFilter(query *InviteQuery) (*InviteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *invitePager) toCursor(i *Invite) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *invitePager) applyCursors(query *InviteQuery, after, before *Cursor) (*InviteQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInviteOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *invitePager) applyOrder(query *InviteQuery) *InviteQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInviteOrder.Field {
		query = query.Order(DefaultInviteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *invitePager) orderExpr(query *InviteQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInviteOrder.Field {
			b.Comma().Ident(DefaultInviteOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Invite.
func (i *InviteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InvitePaginateOption,
) (*InviteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInvitePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &InviteConnection{Edges: []*InviteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := i.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// InviteOrderField defines the ordering field of Invite.
type InviteOrderField struct {
	// Value extracts the ordering value from the given Invite.
	Value    func(*Invite) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) invite.OrderOption
	toCursor func(*Invite) Cursor
}

// InviteOrder defines the ordering of Invite.
type InviteOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *InviteOrderField `json:"field"`
}

// DefaultInviteOrder is the default ordering of Invite.
var DefaultInviteOrder = &InviteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InviteOrderField{
		Value: func(i *Invite) (ent.Value, error) {
			return i.ID, nil
		},
		column: invite.FieldID,
		toTerm: invite.ByID,
		toCursor: func(i *Invite) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Invite into InviteEdge.
func (i *Invite) ToEdge(order *InviteOrder) *InviteEdge {
	if order == nil {
		order = DefaultInviteOrder
	}
	return &InviteEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// NarrativeEdge is the edge representation of Narrative.
type NarrativeEdge struct {
	Node   *Narrative `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// NarrativeConnection is the connection containing edges to Narrative.
type NarrativeConnection struct {
	Edges      []*NarrativeEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *NarrativeConnection) build(nodes []*Narrative, pager *narrativePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Narrative
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Narrative {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Narrative {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativePaginateOption enables pagination customization.
type NarrativePaginateOption func(*narrativePager) error

// WithNarrativeOrder configures pagination ordering.
func WithNarrativeOrder(order *NarrativeOrder) NarrativePaginateOption {
	if order == nil {
		order = DefaultNarrativeOrder
	}
	o := *order
	return func(pager *narrativePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNarrativeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNarrativeFilter configures pagination filter.
func WithNarrativeFilter(filter func(*NarrativeQuery) (*NarrativeQuery, error)) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		if filter == nil {
			return errors.New("NarrativeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativePager struct {
	reverse bool
	order   *NarrativeOrder
	filter  func(*NarrativeQuery) (*NarrativeQuery, error)
}

func newNarrativePager(opts []NarrativePaginateOption, reverse bool) (*narrativePager, error) {
	pager := &narrativePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNarrativeOrder
	}
	return pager, nil
}

func (p *narrativePager) applyFilter(query *NarrativeQuery) (*NarrativeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativePager) toCursor(n *Narrative) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *narrativePager) applyCursors(query *NarrativeQuery, after, before *Cursor) (*NarrativeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNarrativeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *narrativePager) applyOrder(query *NarrativeQuery) *NarrativeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNarrativeOrder.Field {
		query = query.Order(DefaultNarrativeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *narrativePager) orderExpr(query *NarrativeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNarrativeOrder.Field {
			b.Comma().Ident(DefaultNarrativeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Narrative.
func (n *NarrativeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativePaginateOption,
) (*NarrativeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NarrativeConnection{Edges: []*NarrativeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := n.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NarrativeOrderField defines the ordering field of Narrative.
type NarrativeOrderField struct {
	// Value extracts the ordering value from the given Narrative.
	Value    func(*Narrative) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrative.OrderOption
	toCursor func(*Narrative) Cursor
}

// NarrativeOrder defines the ordering of Narrative.
type NarrativeOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *NarrativeOrderField `json:"field"`
}

// DefaultNarrativeOrder is the default ordering of Narrative.
var DefaultNarrativeOrder = &NarrativeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeOrderField{
		Value: func(n *Narrative) (ent.Value, error) {
			return n.ID, nil
		},
		column: narrative.FieldID,
		toTerm: narrative.ByID,
		toCursor: func(n *Narrative) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Narrative into NarrativeEdge.
func (n *Narrative) ToEdge(order *NarrativeOrder) *NarrativeEdge {
	if order == nil {
		order = DefaultNarrativeOrder
	}
	return &NarrativeEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// NarrativeHistoryEdge is the edge representation of NarrativeHistory.
type NarrativeHistoryEdge struct {
	Node   *NarrativeHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// NarrativeHistoryConnection is the connection containing edges to NarrativeHistory.
type NarrativeHistoryConnection struct {
	Edges      []*NarrativeHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *NarrativeHistoryConnection) build(nodes []*NarrativeHistory, pager *narrativehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *NarrativeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NarrativeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativeHistoryPaginateOption enables pagination customization.
type NarrativeHistoryPaginateOption func(*narrativehistoryPager) error

// WithNarrativeHistoryOrder configures pagination ordering.
func WithNarrativeHistoryOrder(order *NarrativeHistoryOrder) NarrativeHistoryPaginateOption {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	o := *order
	return func(pager *narrativehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNarrativeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNarrativeHistoryFilter configures pagination filter.
func WithNarrativeHistoryFilter(filter func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)) NarrativeHistoryPaginateOption {
	return func(pager *narrativehistoryPager) error {
		if filter == nil {
			return errors.New("NarrativeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativehistoryPager struct {
	reverse bool
	order   *NarrativeHistoryOrder
	filter  func(*NarrativeHistoryQuery) (*NarrativeHistoryQuery, error)
}

func newNarrativeHistoryPager(opts []NarrativeHistoryPaginateOption, reverse bool) (*narrativehistoryPager, error) {
	pager := &narrativehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNarrativeHistoryOrder
	}
	return pager, nil
}

func (p *narrativehistoryPager) applyFilter(query *NarrativeHistoryQuery) (*NarrativeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativehistoryPager) toCursor(nh *NarrativeHistory) Cursor {
	return p.order.Field.toCursor(nh)
}

func (p *narrativehistoryPager) applyCursors(query *NarrativeHistoryQuery, after, before *Cursor) (*NarrativeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNarrativeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *narrativehistoryPager) applyOrder(query *NarrativeHistoryQuery) *NarrativeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNarrativeHistoryOrder.Field {
		query = query.Order(DefaultNarrativeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *narrativehistoryPager) orderExpr(query *NarrativeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNarrativeHistoryOrder.Field {
			b.Comma().Ident(DefaultNarrativeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NarrativeHistory.
func (nh *NarrativeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativeHistoryPaginateOption,
) (*NarrativeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if nh, err = pager.applyFilter(nh); err != nil {
		return nil, err
	}
	conn := &NarrativeHistoryConnection{Edges: []*NarrativeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := nh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if nh, err = pager.applyCursors(nh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		nh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := nh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	nh = pager.applyOrder(nh)
	nodes, err := nh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NarrativeHistoryOrderField defines the ordering field of NarrativeHistory.
type NarrativeHistoryOrderField struct {
	// Value extracts the ordering value from the given NarrativeHistory.
	Value    func(*NarrativeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrativehistory.OrderOption
	toCursor func(*NarrativeHistory) Cursor
}

// NarrativeHistoryOrder defines the ordering of NarrativeHistory.
type NarrativeHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *NarrativeHistoryOrderField `json:"field"`
}

// DefaultNarrativeHistoryOrder is the default ordering of NarrativeHistory.
var DefaultNarrativeHistoryOrder = &NarrativeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeHistoryOrderField{
		Value: func(nh *NarrativeHistory) (ent.Value, error) {
			return nh.ID, nil
		},
		column: narrativehistory.FieldID,
		toTerm: narrativehistory.ByID,
		toCursor: func(nh *NarrativeHistory) Cursor {
			return Cursor{ID: nh.ID}
		},
	},
}

// ToEdge converts NarrativeHistory into NarrativeHistoryEdge.
func (nh *NarrativeHistory) ToEdge(order *NarrativeHistoryOrder) *NarrativeHistoryEdge {
	if order == nil {
		order = DefaultNarrativeHistoryOrder
	}
	return &NarrativeHistoryEdge{
		Node:   nh,
		Cursor: order.Field.toCursor(nh),
	}
}

// NoteEdge is the edge representation of Note.
type NoteEdge struct {
	Node   *Note  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// NoteConnection is the connection containing edges to Note.
type NoteConnection struct {
	Edges      []*NoteEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *NoteConnection) build(nodes []*Note, pager *notePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Note
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Note {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Note {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotePaginateOption enables pagination customization.
type NotePaginateOption func(*notePager) error

// WithNoteOrder configures pagination ordering.
func WithNoteOrder(order *NoteOrder) NotePaginateOption {
	if order == nil {
		order = DefaultNoteOrder
	}
	o := *order
	return func(pager *notePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNoteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNoteFilter configures pagination filter.
func WithNoteFilter(filter func(*NoteQuery) (*NoteQuery, error)) NotePaginateOption {
	return func(pager *notePager) error {
		if filter == nil {
			return errors.New("NoteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notePager struct {
	reverse bool
	order   *NoteOrder
	filter  func(*NoteQuery) (*NoteQuery, error)
}

func newNotePager(opts []NotePaginateOption, reverse bool) (*notePager, error) {
	pager := &notePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNoteOrder
	}
	return pager, nil
}

func (p *notePager) applyFilter(query *NoteQuery) (*NoteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notePager) toCursor(n *Note) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *notePager) applyCursors(query *NoteQuery, after, before *Cursor) (*NoteQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNoteOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notePager) applyOrder(query *NoteQuery) *NoteQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNoteOrder.Field {
		query = query.Order(DefaultNoteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notePager) orderExpr(query *NoteQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNoteOrder.Field {
			b.Comma().Ident(DefaultNoteOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Note.
func (n *NoteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotePaginateOption,
) (*NoteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NoteConnection{Edges: []*NoteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := n.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NoteOrderField defines the ordering field of Note.
type NoteOrderField struct {
	// Value extracts the ordering value from the given Note.
	Value    func(*Note) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) note.OrderOption
	toCursor func(*Note) Cursor
}

// NoteOrder defines the ordering of Note.
type NoteOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *NoteOrderField `json:"field"`
}

// DefaultNoteOrder is the default ordering of Note.
var DefaultNoteOrder = &NoteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteOrderField{
		Value: func(n *Note) (ent.Value, error) {
			return n.ID, nil
		},
		column: note.FieldID,
		toTerm: note.ByID,
		toCursor: func(n *Note) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Note into NoteEdge.
func (n *Note) ToEdge(order *NoteOrder) *NoteEdge {
	if order == nil {
		order = DefaultNoteOrder
	}
	return &NoteEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// NoteHistoryEdge is the edge representation of NoteHistory.
type NoteHistoryEdge struct {
	Node   *NoteHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// NoteHistoryConnection is the connection containing edges to NoteHistory.
type NoteHistoryConnection struct {
	Edges      []*NoteHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *NoteHistoryConnection) build(nodes []*NoteHistory, pager *notehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *NoteHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NoteHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NoteHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NoteHistoryPaginateOption enables pagination customization.
type NoteHistoryPaginateOption func(*notehistoryPager) error

// WithNoteHistoryOrder configures pagination ordering.
func WithNoteHistoryOrder(order *NoteHistoryOrder) NoteHistoryPaginateOption {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	o := *order
	return func(pager *notehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNoteHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNoteHistoryFilter configures pagination filter.
func WithNoteHistoryFilter(filter func(*NoteHistoryQuery) (*NoteHistoryQuery, error)) NoteHistoryPaginateOption {
	return func(pager *notehistoryPager) error {
		if filter == nil {
			return errors.New("NoteHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notehistoryPager struct {
	reverse bool
	order   *NoteHistoryOrder
	filter  func(*NoteHistoryQuery) (*NoteHistoryQuery, error)
}

func newNoteHistoryPager(opts []NoteHistoryPaginateOption, reverse bool) (*notehistoryPager, error) {
	pager := &notehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNoteHistoryOrder
	}
	return pager, nil
}

func (p *notehistoryPager) applyFilter(query *NoteHistoryQuery) (*NoteHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notehistoryPager) toCursor(nh *NoteHistory) Cursor {
	return p.order.Field.toCursor(nh)
}

func (p *notehistoryPager) applyCursors(query *NoteHistoryQuery, after, before *Cursor) (*NoteHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNoteHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notehistoryPager) applyOrder(query *NoteHistoryQuery) *NoteHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNoteHistoryOrder.Field {
		query = query.Order(DefaultNoteHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notehistoryPager) orderExpr(query *NoteHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNoteHistoryOrder.Field {
			b.Comma().Ident(DefaultNoteHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NoteHistory.
func (nh *NoteHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NoteHistoryPaginateOption,
) (*NoteHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNoteHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if nh, err = pager.applyFilter(nh); err != nil {
		return nil, err
	}
	conn := &NoteHistoryConnection{Edges: []*NoteHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := nh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if nh, err = pager.applyCursors(nh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		nh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := nh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	nh = pager.applyOrder(nh)
	nodes, err := nh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NoteHistoryOrderField defines the ordering field of NoteHistory.
type NoteHistoryOrderField struct {
	// Value extracts the ordering value from the given NoteHistory.
	Value    func(*NoteHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notehistory.OrderOption
	toCursor func(*NoteHistory) Cursor
}

// NoteHistoryOrder defines the ordering of NoteHistory.
type NoteHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *NoteHistoryOrderField `json:"field"`
}

// DefaultNoteHistoryOrder is the default ordering of NoteHistory.
var DefaultNoteHistoryOrder = &NoteHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteHistoryOrderField{
		Value: func(nh *NoteHistory) (ent.Value, error) {
			return nh.ID, nil
		},
		column: notehistory.FieldID,
		toTerm: notehistory.ByID,
		toCursor: func(nh *NoteHistory) Cursor {
			return Cursor{ID: nh.ID}
		},
	},
}

// ToEdge converts NoteHistory into NoteHistoryEdge.
func (nh *NoteHistory) ToEdge(order *NoteHistoryOrder) *NoteHistoryEdge {
	if order == nil {
		order = DefaultNoteHistoryOrder
	}
	return &NoteHistoryEdge{
		Node:   nh,
		Cursor: order.Field.toCursor(nh),
	}
}

// OauthProviderEdge is the edge representation of OauthProvider.
type OauthProviderEdge struct {
	Node   *OauthProvider `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// OauthProviderConnection is the connection containing edges to OauthProvider.
type OauthProviderConnection struct {
	Edges      []*OauthProviderEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *OauthProviderConnection) build(nodes []*OauthProvider, pager *oauthproviderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OauthProvider
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OauthProvider {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OauthProvider {
			return nodes[i]
		}
	}
	c.Edges = make([]*OauthProviderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OauthProviderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OauthProviderPaginateOption enables pagination customization.
type OauthProviderPaginateOption func(*oauthproviderPager) error

// WithOauthProviderOrder configures pagination ordering.
func WithOauthProviderOrder(order *OauthProviderOrder) OauthProviderPaginateOption {
	if order == nil {
		order = DefaultOauthProviderOrder
	}
	o := *order
	return func(pager *oauthproviderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOauthProviderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOauthProviderFilter configures pagination filter.
func WithOauthProviderFilter(filter func(*OauthProviderQuery) (*OauthProviderQuery, error)) OauthProviderPaginateOption {
	return func(pager *oauthproviderPager) error {
		if filter == nil {
			return errors.New("OauthProviderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type oauthproviderPager struct {
	reverse bool
	order   *OauthProviderOrder
	filter  func(*OauthProviderQuery) (*OauthProviderQuery, error)
}

func newOauthProviderPager(opts []OauthProviderPaginateOption, reverse bool) (*oauthproviderPager, error) {
	pager := &oauthproviderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOauthProviderOrder
	}
	return pager, nil
}

func (p *oauthproviderPager) applyFilter(query *OauthProviderQuery) (*OauthProviderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *oauthproviderPager) toCursor(op *OauthProvider) Cursor {
	return p.order.Field.toCursor(op)
}

func (p *oauthproviderPager) applyCursors(query *OauthProviderQuery, after, before *Cursor) (*OauthProviderQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOauthProviderOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *oauthproviderPager) applyOrder(query *OauthProviderQuery) *OauthProviderQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOauthProviderOrder.Field {
		query = query.Order(DefaultOauthProviderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *oauthproviderPager) orderExpr(query *OauthProviderQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOauthProviderOrder.Field {
			b.Comma().Ident(DefaultOauthProviderOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OauthProvider.
func (op *OauthProviderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OauthProviderPaginateOption,
) (*OauthProviderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOauthProviderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if op, err = pager.applyFilter(op); err != nil {
		return nil, err
	}
	conn := &OauthProviderConnection{Edges: []*OauthProviderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := op.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if op, err = pager.applyCursors(op, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		op.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := op.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	op = pager.applyOrder(op)
	nodes, err := op.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OauthProviderOrderField defines the ordering field of OauthProvider.
type OauthProviderOrderField struct {
	// Value extracts the ordering value from the given OauthProvider.
	Value    func(*OauthProvider) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) oauthprovider.OrderOption
	toCursor func(*OauthProvider) Cursor
}

// OauthProviderOrder defines the ordering of OauthProvider.
type OauthProviderOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *OauthProviderOrderField `json:"field"`
}

// DefaultOauthProviderOrder is the default ordering of OauthProvider.
var DefaultOauthProviderOrder = &OauthProviderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OauthProviderOrderField{
		Value: func(op *OauthProvider) (ent.Value, error) {
			return op.ID, nil
		},
		column: oauthprovider.FieldID,
		toTerm: oauthprovider.ByID,
		toCursor: func(op *OauthProvider) Cursor {
			return Cursor{ID: op.ID}
		},
	},
}

// ToEdge converts OauthProvider into OauthProviderEdge.
func (op *OauthProvider) ToEdge(order *OauthProviderOrder) *OauthProviderEdge {
	if order == nil {
		order = DefaultOauthProviderOrder
	}
	return &OauthProviderEdge{
		Node:   op,
		Cursor: order.Field.toCursor(op),
	}
}

// OauthProviderHistoryEdge is the edge representation of OauthProviderHistory.
type OauthProviderHistoryEdge struct {
	Node   *OauthProviderHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// OauthProviderHistoryConnection is the connection containing edges to OauthProviderHistory.
type OauthProviderHistoryConnection struct {
	Edges      []*OauthProviderHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *OauthProviderHistoryConnection) build(nodes []*OauthProviderHistory, pager *oauthproviderhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OauthProviderHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OauthProviderHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OauthProviderHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OauthProviderHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OauthProviderHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OauthProviderHistoryPaginateOption enables pagination customization.
type OauthProviderHistoryPaginateOption func(*oauthproviderhistoryPager) error

// WithOauthProviderHistoryOrder configures pagination ordering.
func WithOauthProviderHistoryOrder(order *OauthProviderHistoryOrder) OauthProviderHistoryPaginateOption {
	if order == nil {
		order = DefaultOauthProviderHistoryOrder
	}
	o := *order
	return func(pager *oauthproviderhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOauthProviderHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOauthProviderHistoryFilter configures pagination filter.
func WithOauthProviderHistoryFilter(filter func(*OauthProviderHistoryQuery) (*OauthProviderHistoryQuery, error)) OauthProviderHistoryPaginateOption {
	return func(pager *oauthproviderhistoryPager) error {
		if filter == nil {
			return errors.New("OauthProviderHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type oauthproviderhistoryPager struct {
	reverse bool
	order   *OauthProviderHistoryOrder
	filter  func(*OauthProviderHistoryQuery) (*OauthProviderHistoryQuery, error)
}

func newOauthProviderHistoryPager(opts []OauthProviderHistoryPaginateOption, reverse bool) (*oauthproviderhistoryPager, error) {
	pager := &oauthproviderhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOauthProviderHistoryOrder
	}
	return pager, nil
}

func (p *oauthproviderhistoryPager) applyFilter(query *OauthProviderHistoryQuery) (*OauthProviderHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *oauthproviderhistoryPager) toCursor(oph *OauthProviderHistory) Cursor {
	return p.order.Field.toCursor(oph)
}

func (p *oauthproviderhistoryPager) applyCursors(query *OauthProviderHistoryQuery, after, before *Cursor) (*OauthProviderHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOauthProviderHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *oauthproviderhistoryPager) applyOrder(query *OauthProviderHistoryQuery) *OauthProviderHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOauthProviderHistoryOrder.Field {
		query = query.Order(DefaultOauthProviderHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *oauthproviderhistoryPager) orderExpr(query *OauthProviderHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOauthProviderHistoryOrder.Field {
			b.Comma().Ident(DefaultOauthProviderHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OauthProviderHistory.
func (oph *OauthProviderHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OauthProviderHistoryPaginateOption,
) (*OauthProviderHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOauthProviderHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if oph, err = pager.applyFilter(oph); err != nil {
		return nil, err
	}
	conn := &OauthProviderHistoryConnection{Edges: []*OauthProviderHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := oph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if oph, err = pager.applyCursors(oph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		oph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := oph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	oph = pager.applyOrder(oph)
	nodes, err := oph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OauthProviderHistoryOrderField defines the ordering field of OauthProviderHistory.
type OauthProviderHistoryOrderField struct {
	// Value extracts the ordering value from the given OauthProviderHistory.
	Value    func(*OauthProviderHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) oauthproviderhistory.OrderOption
	toCursor func(*OauthProviderHistory) Cursor
}

// OauthProviderHistoryOrder defines the ordering of OauthProviderHistory.
type OauthProviderHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *OauthProviderHistoryOrderField `json:"field"`
}

// DefaultOauthProviderHistoryOrder is the default ordering of OauthProviderHistory.
var DefaultOauthProviderHistoryOrder = &OauthProviderHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OauthProviderHistoryOrderField{
		Value: func(oph *OauthProviderHistory) (ent.Value, error) {
			return oph.ID, nil
		},
		column: oauthproviderhistory.FieldID,
		toTerm: oauthproviderhistory.ByID,
		toCursor: func(oph *OauthProviderHistory) Cursor {
			return Cursor{ID: oph.ID}
		},
	},
}

// ToEdge converts OauthProviderHistory into OauthProviderHistoryEdge.
func (oph *OauthProviderHistory) ToEdge(order *OauthProviderHistoryOrder) *OauthProviderHistoryEdge {
	if order == nil {
		order = DefaultOauthProviderHistoryOrder
	}
	return &OauthProviderHistoryEdge{
		Node:   oph,
		Cursor: order.Field.toCursor(oph),
	}
}

// OhAuthTooTokenEdge is the edge representation of OhAuthTooToken.
type OhAuthTooTokenEdge struct {
	Node   *OhAuthTooToken `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// OhAuthTooTokenConnection is the connection containing edges to OhAuthTooToken.
type OhAuthTooTokenConnection struct {
	Edges      []*OhAuthTooTokenEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *OhAuthTooTokenConnection) build(nodes []*OhAuthTooToken, pager *ohauthtootokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OhAuthTooToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OhAuthTooToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OhAuthTooToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*OhAuthTooTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OhAuthTooTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OhAuthTooTokenPaginateOption enables pagination customization.
type OhAuthTooTokenPaginateOption func(*ohauthtootokenPager) error

// WithOhAuthTooTokenOrder configures pagination ordering.
func WithOhAuthTooTokenOrder(order *OhAuthTooTokenOrder) OhAuthTooTokenPaginateOption {
	if order == nil {
		order = DefaultOhAuthTooTokenOrder
	}
	o := *order
	return func(pager *ohauthtootokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOhAuthTooTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOhAuthTooTokenFilter configures pagination filter.
func WithOhAuthTooTokenFilter(filter func(*OhAuthTooTokenQuery) (*OhAuthTooTokenQuery, error)) OhAuthTooTokenPaginateOption {
	return func(pager *ohauthtootokenPager) error {
		if filter == nil {
			return errors.New("OhAuthTooTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ohauthtootokenPager struct {
	reverse bool
	order   *OhAuthTooTokenOrder
	filter  func(*OhAuthTooTokenQuery) (*OhAuthTooTokenQuery, error)
}

func newOhAuthTooTokenPager(opts []OhAuthTooTokenPaginateOption, reverse bool) (*ohauthtootokenPager, error) {
	pager := &ohauthtootokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOhAuthTooTokenOrder
	}
	return pager, nil
}

func (p *ohauthtootokenPager) applyFilter(query *OhAuthTooTokenQuery) (*OhAuthTooTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ohauthtootokenPager) toCursor(oatt *OhAuthTooToken) Cursor {
	return p.order.Field.toCursor(oatt)
}

func (p *ohauthtootokenPager) applyCursors(query *OhAuthTooTokenQuery, after, before *Cursor) (*OhAuthTooTokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOhAuthTooTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *ohauthtootokenPager) applyOrder(query *OhAuthTooTokenQuery) *OhAuthTooTokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOhAuthTooTokenOrder.Field {
		query = query.Order(DefaultOhAuthTooTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *ohauthtootokenPager) orderExpr(query *OhAuthTooTokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOhAuthTooTokenOrder.Field {
			b.Comma().Ident(DefaultOhAuthTooTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OhAuthTooToken.
func (oatt *OhAuthTooTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OhAuthTooTokenPaginateOption,
) (*OhAuthTooTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOhAuthTooTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if oatt, err = pager.applyFilter(oatt); err != nil {
		return nil, err
	}
	conn := &OhAuthTooTokenConnection{Edges: []*OhAuthTooTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := oatt.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if oatt, err = pager.applyCursors(oatt, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		oatt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := oatt.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	oatt = pager.applyOrder(oatt)
	nodes, err := oatt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OhAuthTooTokenOrderField defines the ordering field of OhAuthTooToken.
type OhAuthTooTokenOrderField struct {
	// Value extracts the ordering value from the given OhAuthTooToken.
	Value    func(*OhAuthTooToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) ohauthtootoken.OrderOption
	toCursor func(*OhAuthTooToken) Cursor
}

// OhAuthTooTokenOrder defines the ordering of OhAuthTooToken.
type OhAuthTooTokenOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *OhAuthTooTokenOrderField `json:"field"`
}

// DefaultOhAuthTooTokenOrder is the default ordering of OhAuthTooToken.
var DefaultOhAuthTooTokenOrder = &OhAuthTooTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OhAuthTooTokenOrderField{
		Value: func(oatt *OhAuthTooToken) (ent.Value, error) {
			return oatt.ID, nil
		},
		column: ohauthtootoken.FieldID,
		toTerm: ohauthtootoken.ByID,
		toCursor: func(oatt *OhAuthTooToken) Cursor {
			return Cursor{ID: oatt.ID}
		},
	},
}

// ToEdge converts OhAuthTooToken into OhAuthTooTokenEdge.
func (oatt *OhAuthTooToken) ToEdge(order *OhAuthTooTokenOrder) *OhAuthTooTokenEdge {
	if order == nil {
		order = DefaultOhAuthTooTokenOrder
	}
	return &OhAuthTooTokenEdge{
		Node:   oatt,
		Cursor: order.Field.toCursor(oatt),
	}
}

// OrgMembershipEdge is the edge representation of OrgMembership.
type OrgMembershipEdge struct {
	Node   *OrgMembership `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// OrgMembershipConnection is the connection containing edges to OrgMembership.
type OrgMembershipConnection struct {
	Edges      []*OrgMembershipEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *OrgMembershipConnection) build(nodes []*OrgMembership, pager *orgmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrgMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipPaginateOption enables pagination customization.
type OrgMembershipPaginateOption func(*orgmembershipPager) error

// WithOrgMembershipOrder configures pagination ordering.
func WithOrgMembershipOrder(order *OrgMembershipOrder) OrgMembershipPaginateOption {
	if order == nil {
		order = DefaultOrgMembershipOrder
	}
	o := *order
	return func(pager *orgmembershipPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgMembershipOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgMembershipFilter configures pagination filter.
func WithOrgMembershipFilter(filter func(*OrgMembershipQuery) (*OrgMembershipQuery, error)) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		if filter == nil {
			return errors.New("OrgMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershipPager struct {
	reverse bool
	order   *OrgMembershipOrder
	filter  func(*OrgMembershipQuery) (*OrgMembershipQuery, error)
}

func newOrgMembershipPager(opts []OrgMembershipPaginateOption, reverse bool) (*orgmembershipPager, error) {
	pager := &orgmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgMembershipOrder
	}
	return pager, nil
}

func (p *orgmembershipPager) applyFilter(query *OrgMembershipQuery) (*OrgMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershipPager) toCursor(om *OrgMembership) Cursor {
	return p.order.Field.toCursor(om)
}

func (p *orgmembershipPager) applyCursors(query *OrgMembershipQuery, after, before *Cursor) (*OrgMembershipQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgMembershipOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgmembershipPager) applyOrder(query *OrgMembershipQuery) *OrgMembershipQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgMembershipOrder.Field {
		query = query.Order(DefaultOrgMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgmembershipPager) orderExpr(query *OrgMembershipQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgMembershipOrder.Field {
			b.Comma().Ident(DefaultOrgMembershipOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembership.
func (om *OrgMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipPaginateOption,
) (*OrgMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if om, err = pager.applyFilter(om); err != nil {
		return nil, err
	}
	conn := &OrgMembershipConnection{Edges: []*OrgMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := om.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if om, err = pager.applyCursors(om, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		om.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := om.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	om = pager.applyOrder(om)
	nodes, err := om.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrgMembershipOrderField defines the ordering field of OrgMembership.
type OrgMembershipOrderField struct {
	// Value extracts the ordering value from the given OrgMembership.
	Value    func(*OrgMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembership.OrderOption
	toCursor func(*OrgMembership) Cursor
}

// OrgMembershipOrder defines the ordering of OrgMembership.
type OrgMembershipOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *OrgMembershipOrderField `json:"field"`
}

// DefaultOrgMembershipOrder is the default ordering of OrgMembership.
var DefaultOrgMembershipOrder = &OrgMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipOrderField{
		Value: func(om *OrgMembership) (ent.Value, error) {
			return om.ID, nil
		},
		column: orgmembership.FieldID,
		toTerm: orgmembership.ByID,
		toCursor: func(om *OrgMembership) Cursor {
			return Cursor{ID: om.ID}
		},
	},
}

// ToEdge converts OrgMembership into OrgMembershipEdge.
func (om *OrgMembership) ToEdge(order *OrgMembershipOrder) *OrgMembershipEdge {
	if order == nil {
		order = DefaultOrgMembershipOrder
	}
	return &OrgMembershipEdge{
		Node:   om,
		Cursor: order.Field.toCursor(om),
	}
}

// OrgMembershipHistoryEdge is the edge representation of OrgMembershipHistory.
type OrgMembershipHistoryEdge struct {
	Node   *OrgMembershipHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// OrgMembershipHistoryConnection is the connection containing edges to OrgMembershipHistory.
type OrgMembershipHistoryConnection struct {
	Edges      []*OrgMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *OrgMembershipHistoryConnection) build(nodes []*OrgMembershipHistory, pager *orgmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrgMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipHistoryPaginateOption enables pagination customization.
type OrgMembershipHistoryPaginateOption func(*orgmembershiphistoryPager) error

// WithOrgMembershipHistoryOrder configures pagination ordering.
func WithOrgMembershipHistoryOrder(order *OrgMembershipHistoryOrder) OrgMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	o := *order
	return func(pager *orgmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgMembershipHistoryFilter configures pagination filter.
func WithOrgMembershipHistoryFilter(filter func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)) OrgMembershipHistoryPaginateOption {
	return func(pager *orgmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("OrgMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershiphistoryPager struct {
	reverse bool
	order   *OrgMembershipHistoryOrder
	filter  func(*OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error)
}

func newOrgMembershipHistoryPager(opts []OrgMembershipHistoryPaginateOption, reverse bool) (*orgmembershiphistoryPager, error) {
	pager := &orgmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgMembershipHistoryOrder
	}
	return pager, nil
}

func (p *orgmembershiphistoryPager) applyFilter(query *OrgMembershipHistoryQuery) (*OrgMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) toCursor(omh *OrgMembershipHistory) Cursor {
	return p.order.Field.toCursor(omh)
}

func (p *orgmembershiphistoryPager) applyCursors(query *OrgMembershipHistoryQuery, after, before *Cursor) (*OrgMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgmembershiphistoryPager) applyOrder(query *OrgMembershipHistoryQuery) *OrgMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
		query = query.Order(DefaultOrgMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgmembershiphistoryPager) orderExpr(query *OrgMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultOrgMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembershipHistory.
func (omh *OrgMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipHistoryPaginateOption,
) (*OrgMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if omh, err = pager.applyFilter(omh); err != nil {
		return nil, err
	}
	conn := &OrgMembershipHistoryConnection{Edges: []*OrgMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := omh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if omh, err = pager.applyCursors(omh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		omh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := omh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	omh = pager.applyOrder(omh)
	nodes, err := omh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrgMembershipHistoryOrderField defines the ordering field of OrgMembershipHistory.
type OrgMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given OrgMembershipHistory.
	Value    func(*OrgMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembershiphistory.OrderOption
	toCursor func(*OrgMembershipHistory) Cursor
}

// OrgMembershipHistoryOrder defines the ordering of OrgMembershipHistory.
type OrgMembershipHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *OrgMembershipHistoryOrderField `json:"field"`
}

// DefaultOrgMembershipHistoryOrder is the default ordering of OrgMembershipHistory.
var DefaultOrgMembershipHistoryOrder = &OrgMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipHistoryOrderField{
		Value: func(omh *OrgMembershipHistory) (ent.Value, error) {
			return omh.ID, nil
		},
		column: orgmembershiphistory.FieldID,
		toTerm: orgmembershiphistory.ByID,
		toCursor: func(omh *OrgMembershipHistory) Cursor {
			return Cursor{ID: omh.ID}
		},
	},
}

// ToEdge converts OrgMembershipHistory into OrgMembershipHistoryEdge.
func (omh *OrgMembershipHistory) ToEdge(order *OrgMembershipHistoryOrder) *OrgMembershipHistoryEdge {
	if order == nil {
		order = DefaultOrgMembershipHistoryOrder
	}
	return &OrgMembershipHistoryEdge{
		Node:   omh,
		Cursor: order.Field.toCursor(omh),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   *OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationOrder.Field {
			b.Comma().Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationOrderFieldName orders Organization by name.
	OrganizationOrderFieldName = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.Name, nil
		},
		column: organization.FieldName,
		toTerm: organization.ByName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Name,
			}
		},
	}
	// OrganizationOrderFieldDisplayName orders Organization by display_name.
	OrganizationOrderFieldDisplayName = &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.DisplayName, nil
		},
		column: organization.FieldDisplayName,
		toTerm: organization.ByDisplayName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationOrderFieldName.column:
		str = "name"
	case OrganizationOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *OrganizationOrderFieldName
	case "display_name":
		*f = *OrganizationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// OrganizationHistoryEdge is the edge representation of OrganizationHistory.
type OrganizationHistoryEdge struct {
	Node   *OrganizationHistory `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationHistoryConnection is the connection containing edges to OrganizationHistory.
type OrganizationHistoryConnection struct {
	Edges      []*OrganizationHistoryEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationHistoryConnection) build(nodes []*OrganizationHistory, pager *organizationhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrganizationHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationHistoryPaginateOption enables pagination customization.
type OrganizationHistoryPaginateOption func(*organizationhistoryPager) error

// WithOrganizationHistoryOrder configures pagination ordering.
func WithOrganizationHistoryOrder(order *OrganizationHistoryOrder) OrganizationHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	o := *order
	return func(pager *organizationhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationHistoryFilter configures pagination filter.
func WithOrganizationHistoryFilter(filter func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)) OrganizationHistoryPaginateOption {
	return func(pager *organizationhistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationhistoryPager struct {
	reverse bool
	order   *OrganizationHistoryOrder
	filter  func(*OrganizationHistoryQuery) (*OrganizationHistoryQuery, error)
}

func newOrganizationHistoryPager(opts []OrganizationHistoryPaginateOption, reverse bool) (*organizationhistoryPager, error) {
	pager := &organizationhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationHistoryOrder
	}
	return pager, nil
}

func (p *organizationhistoryPager) applyFilter(query *OrganizationHistoryQuery) (*OrganizationHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationhistoryPager) toCursor(oh *OrganizationHistory) Cursor {
	return p.order.Field.toCursor(oh)
}

func (p *organizationhistoryPager) applyCursors(query *OrganizationHistoryQuery, after, before *Cursor) (*OrganizationHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationhistoryPager) applyOrder(query *OrganizationHistoryQuery) *OrganizationHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationHistoryOrder.Field {
		query = query.Order(DefaultOrganizationHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationhistoryPager) orderExpr(query *OrganizationHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationHistory.
func (oh *OrganizationHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationHistoryPaginateOption,
) (*OrganizationHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if oh, err = pager.applyFilter(oh); err != nil {
		return nil, err
	}
	conn := &OrganizationHistoryConnection{Edges: []*OrganizationHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := oh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if oh, err = pager.applyCursors(oh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		oh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := oh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	oh = pager.applyOrder(oh)
	nodes, err := oh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationHistoryOrderFieldName orders OrganizationHistory by name.
	OrganizationHistoryOrderFieldName = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.Name, nil
		},
		column: organizationhistory.FieldName,
		toTerm: organizationhistory.ByName,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.Name,
			}
		},
	}
	// OrganizationHistoryOrderFieldDisplayName orders OrganizationHistory by display_name.
	OrganizationHistoryOrderFieldDisplayName = &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.DisplayName, nil
		},
		column: organizationhistory.FieldDisplayName,
		toTerm: organizationhistory.ByDisplayName,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{
				ID:    oh.ID,
				Value: oh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationHistoryOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationHistoryOrderFieldName.column:
		str = "name"
	case OrganizationHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *OrganizationHistoryOrderFieldName
	case "display_name":
		*f = *OrganizationHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

// OrganizationHistoryOrderField defines the ordering field of OrganizationHistory.
type OrganizationHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationHistory.
	Value    func(*OrganizationHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationhistory.OrderOption
	toCursor func(*OrganizationHistory) Cursor
}

// OrganizationHistoryOrder defines the ordering of OrganizationHistory.
type OrganizationHistoryOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationHistoryOrderField `json:"field"`
}

// DefaultOrganizationHistoryOrder is the default ordering of OrganizationHistory.
var DefaultOrganizationHistoryOrder = &OrganizationHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationHistoryOrderField{
		Value: func(oh *OrganizationHistory) (ent.Value, error) {
			return oh.ID, nil
		},
		column: organizationhistory.FieldID,
		toTerm: organizationhistory.ByID,
		toCursor: func(oh *OrganizationHistory) Cursor {
			return Cursor{ID: oh.ID}
		},
	},
}

// ToEdge converts OrganizationHistory into OrganizationHistoryEdge.
func (oh *OrganizationHistory) ToEdge(order *OrganizationHistoryOrder) *OrganizationHistoryEdge {
	if order == nil {
		order = DefaultOrganizationHistoryOrder
	}
	return &OrganizationHistoryEdge{
		Node:   oh,
		Cursor: order.Field.toCursor(oh),
	}
}

// OrganizationSettingEdge is the edge representation of OrganizationSetting.
type OrganizationSettingEdge struct {
	Node   *OrganizationSetting `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationSettingConnection is the connection containing edges to OrganizationSetting.
type OrganizationSettingConnection struct {
	Edges      []*OrganizationSettingEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationSettingConnection) build(nodes []*OrganizationSetting, pager *organizationsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrganizationSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingPaginateOption enables pagination customization.
type OrganizationSettingPaginateOption func(*organizationsettingPager) error

// WithOrganizationSettingOrder configures pagination ordering.
func WithOrganizationSettingOrder(order *OrganizationSettingOrder) OrganizationSettingPaginateOption {
	if order == nil {
		order = DefaultOrganizationSettingOrder
	}
	o := *order
	return func(pager *organizationsettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationSettingFilter configures pagination filter.
func WithOrganizationSettingFilter(filter func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettingPager struct {
	reverse bool
	order   *OrganizationSettingOrder
	filter  func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)
}

func newOrganizationSettingPager(opts []OrganizationSettingPaginateOption, reverse bool) (*organizationsettingPager, error) {
	pager := &organizationsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationSettingOrder
	}
	return pager, nil
}

func (p *organizationsettingPager) applyFilter(query *OrganizationSettingQuery) (*OrganizationSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettingPager) toCursor(os *OrganizationSetting) Cursor {
	return p.order.Field.toCursor(os)
}

func (p *organizationsettingPager) applyCursors(query *OrganizationSettingQuery, after, before *Cursor) (*OrganizationSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationSettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationsettingPager) applyOrder(query *OrganizationSettingQuery) *OrganizationSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationSettingOrder.Field {
		query = query.Order(DefaultOrganizationSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationsettingPager) orderExpr(query *OrganizationSettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationSettingOrder.Field {
			b.Comma().Ident(DefaultOrganizationSettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSetting.
func (os *OrganizationSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingPaginateOption,
) (*OrganizationSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if os, err = pager.applyFilter(os); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingConnection{Edges: []*OrganizationSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := os.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if os, err = pager.applyCursors(os, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		os.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := os.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	os = pager.applyOrder(os)
	nodes, err := os.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrganizationSettingOrderField defines the ordering field of OrganizationSetting.
type OrganizationSettingOrderField struct {
	// Value extracts the ordering value from the given OrganizationSetting.
	Value    func(*OrganizationSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsetting.OrderOption
	toCursor func(*OrganizationSetting) Cursor
}

// OrganizationSettingOrder defines the ordering of OrganizationSetting.
type OrganizationSettingOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationSettingOrderField `json:"field"`
}

// DefaultOrganizationSettingOrder is the default ordering of OrganizationSetting.
var DefaultOrganizationSettingOrder = &OrganizationSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingOrderField{
		Value: func(os *OrganizationSetting) (ent.Value, error) {
			return os.ID, nil
		},
		column: organizationsetting.FieldID,
		toTerm: organizationsetting.ByID,
		toCursor: func(os *OrganizationSetting) Cursor {
			return Cursor{ID: os.ID}
		},
	},
}

// ToEdge converts OrganizationSetting into OrganizationSettingEdge.
func (os *OrganizationSetting) ToEdge(order *OrganizationSettingOrder) *OrganizationSettingEdge {
	if order == nil {
		order = DefaultOrganizationSettingOrder
	}
	return &OrganizationSettingEdge{
		Node:   os,
		Cursor: order.Field.toCursor(os),
	}
}

// OrganizationSettingHistoryEdge is the edge representation of OrganizationSettingHistory.
type OrganizationSettingHistoryEdge struct {
	Node   *OrganizationSettingHistory `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// OrganizationSettingHistoryConnection is the connection containing edges to OrganizationSettingHistory.
type OrganizationSettingHistoryConnection struct {
	Edges      []*OrganizationSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *OrganizationSettingHistoryConnection) build(nodes []*OrganizationSettingHistory, pager *organizationsettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrganizationSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingHistoryPaginateOption enables pagination customization.
type OrganizationSettingHistoryPaginateOption func(*organizationsettinghistoryPager) error

// WithOrganizationSettingHistoryOrder configures pagination ordering.
func WithOrganizationSettingHistoryOrder(order *OrganizationSettingHistoryOrder) OrganizationSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	o := *order
	return func(pager *organizationsettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationSettingHistoryFilter configures pagination filter.
func WithOrganizationSettingHistoryFilter(filter func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)) OrganizationSettingHistoryPaginateOption {
	return func(pager *organizationsettinghistoryPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettinghistoryPager struct {
	reverse bool
	order   *OrganizationSettingHistoryOrder
	filter  func(*OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error)
}

func newOrganizationSettingHistoryPager(opts []OrganizationSettingHistoryPaginateOption, reverse bool) (*organizationsettinghistoryPager, error) {
	pager := &organizationsettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationSettingHistoryOrder
	}
	return pager, nil
}

func (p *organizationsettinghistoryPager) applyFilter(query *OrganizationSettingHistoryQuery) (*OrganizationSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) toCursor(osh *OrganizationSettingHistory) Cursor {
	return p.order.Field.toCursor(osh)
}

func (p *organizationsettinghistoryPager) applyCursors(query *OrganizationSettingHistoryQuery, after, before *Cursor) (*OrganizationSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationsettinghistoryPager) applyOrder(query *OrganizationSettingHistoryQuery) *OrganizationSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
		query = query.Order(DefaultOrganizationSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationsettinghistoryPager) orderExpr(query *OrganizationSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultOrganizationSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSettingHistory.
func (osh *OrganizationSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingHistoryPaginateOption,
) (*OrganizationSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if osh, err = pager.applyFilter(osh); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingHistoryConnection{Edges: []*OrganizationSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := osh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if osh, err = pager.applyCursors(osh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		osh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := osh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	osh = pager.applyOrder(osh)
	nodes, err := osh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrganizationSettingHistoryOrderField defines the ordering field of OrganizationSettingHistory.
type OrganizationSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given OrganizationSettingHistory.
	Value    func(*OrganizationSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsettinghistory.OrderOption
	toCursor func(*OrganizationSettingHistory) Cursor
}

// OrganizationSettingHistoryOrder defines the ordering of OrganizationSettingHistory.
type OrganizationSettingHistoryOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *OrganizationSettingHistoryOrderField `json:"field"`
}

// DefaultOrganizationSettingHistoryOrder is the default ordering of OrganizationSettingHistory.
var DefaultOrganizationSettingHistoryOrder = &OrganizationSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingHistoryOrderField{
		Value: func(osh *OrganizationSettingHistory) (ent.Value, error) {
			return osh.ID, nil
		},
		column: organizationsettinghistory.FieldID,
		toTerm: organizationsettinghistory.ByID,
		toCursor: func(osh *OrganizationSettingHistory) Cursor {
			return Cursor{ID: osh.ID}
		},
	},
}

// ToEdge converts OrganizationSettingHistory into OrganizationSettingHistoryEdge.
func (osh *OrganizationSettingHistory) ToEdge(order *OrganizationSettingHistoryOrder) *OrganizationSettingHistoryEdge {
	if order == nil {
		order = DefaultOrganizationSettingHistoryOrder
	}
	return &OrganizationSettingHistoryEdge{
		Node:   osh,
		Cursor: order.Field.toCursor(osh),
	}
}

// PersonalAccessTokenEdge is the edge representation of PersonalAccessToken.
type PersonalAccessTokenEdge struct {
	Node   *PersonalAccessToken `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// PersonalAccessTokenConnection is the connection containing edges to PersonalAccessToken.
type PersonalAccessTokenConnection struct {
	Edges      []*PersonalAccessTokenEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *PersonalAccessTokenConnection) build(nodes []*PersonalAccessToken, pager *personalaccesstokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PersonalAccessToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonalAccessTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonalAccessTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonalAccessTokenPaginateOption enables pagination customization.
type PersonalAccessTokenPaginateOption func(*personalaccesstokenPager) error

// WithPersonalAccessTokenOrder configures pagination ordering.
func WithPersonalAccessTokenOrder(order *PersonalAccessTokenOrder) PersonalAccessTokenPaginateOption {
	if order == nil {
		order = DefaultPersonalAccessTokenOrder
	}
	o := *order
	return func(pager *personalaccesstokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPersonalAccessTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPersonalAccessTokenFilter configures pagination filter.
func WithPersonalAccessTokenFilter(filter func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		if filter == nil {
			return errors.New("PersonalAccessTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personalaccesstokenPager struct {
	reverse bool
	order   *PersonalAccessTokenOrder
	filter  func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)
}

func newPersonalAccessTokenPager(opts []PersonalAccessTokenPaginateOption, reverse bool) (*personalaccesstokenPager, error) {
	pager := &personalaccesstokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPersonalAccessTokenOrder
	}
	return pager, nil
}

func (p *personalaccesstokenPager) applyFilter(query *PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personalaccesstokenPager) toCursor(pat *PersonalAccessToken) Cursor {
	return p.order.Field.toCursor(pat)
}

func (p *personalaccesstokenPager) applyCursors(query *PersonalAccessTokenQuery, after, before *Cursor) (*PersonalAccessTokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPersonalAccessTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *personalaccesstokenPager) applyOrder(query *PersonalAccessTokenQuery) *PersonalAccessTokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPersonalAccessTokenOrder.Field {
		query = query.Order(DefaultPersonalAccessTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *personalaccesstokenPager) orderExpr(query *PersonalAccessTokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPersonalAccessTokenOrder.Field {
			b.Comma().Ident(DefaultPersonalAccessTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PersonalAccessToken.
func (pat *PersonalAccessTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PersonalAccessTokenPaginateOption,
) (*PersonalAccessTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonalAccessTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pat, err = pager.applyFilter(pat); err != nil {
		return nil, err
	}
	conn := &PersonalAccessTokenConnection{Edges: []*PersonalAccessTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pat.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pat, err = pager.applyCursors(pat, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pat.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pat.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pat = pager.applyOrder(pat)
	nodes, err := pat.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PersonalAccessTokenOrderField defines the ordering field of PersonalAccessToken.
type PersonalAccessTokenOrderField struct {
	// Value extracts the ordering value from the given PersonalAccessToken.
	Value    func(*PersonalAccessToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) personalaccesstoken.OrderOption
	toCursor func(*PersonalAccessToken) Cursor
}

// PersonalAccessTokenOrder defines the ordering of PersonalAccessToken.
type PersonalAccessTokenOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *PersonalAccessTokenOrderField `json:"field"`
}

// DefaultPersonalAccessTokenOrder is the default ordering of PersonalAccessToken.
var DefaultPersonalAccessTokenOrder = &PersonalAccessTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonalAccessTokenOrderField{
		Value: func(pat *PersonalAccessToken) (ent.Value, error) {
			return pat.ID, nil
		},
		column: personalaccesstoken.FieldID,
		toTerm: personalaccesstoken.ByID,
		toCursor: func(pat *PersonalAccessToken) Cursor {
			return Cursor{ID: pat.ID}
		},
	},
}

// ToEdge converts PersonalAccessToken into PersonalAccessTokenEdge.
func (pat *PersonalAccessToken) ToEdge(order *PersonalAccessTokenOrder) *PersonalAccessTokenEdge {
	if order == nil {
		order = DefaultPersonalAccessTokenOrder
	}
	return &PersonalAccessTokenEdge{
		Node:   pat,
		Cursor: order.Field.toCursor(pat),
	}
}

// ProcedureEdge is the edge representation of Procedure.
type ProcedureEdge struct {
	Node   *Procedure `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ProcedureConnection is the connection containing edges to Procedure.
type ProcedureConnection struct {
	Edges      []*ProcedureEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ProcedureConnection) build(nodes []*Procedure, pager *procedurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Procedure
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Procedure {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Procedure {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedurePaginateOption enables pagination customization.
type ProcedurePaginateOption func(*procedurePager) error

// WithProcedureOrder configures pagination ordering.
func WithProcedureOrder(order *ProcedureOrder) ProcedurePaginateOption {
	if order == nil {
		order = DefaultProcedureOrder
	}
	o := *order
	return func(pager *procedurePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcedureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcedureFilter configures pagination filter.
func WithProcedureFilter(filter func(*ProcedureQuery) (*ProcedureQuery, error)) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		if filter == nil {
			return errors.New("ProcedureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurePager struct {
	reverse bool
	order   *ProcedureOrder
	filter  func(*ProcedureQuery) (*ProcedureQuery, error)
}

func newProcedurePager(opts []ProcedurePaginateOption, reverse bool) (*procedurePager, error) {
	pager := &procedurePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcedureOrder
	}
	return pager, nil
}

func (p *procedurePager) applyFilter(query *ProcedureQuery) (*ProcedureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurePager) toCursor(pr *Procedure) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *procedurePager) applyCursors(query *ProcedureQuery, after, before *Cursor) (*ProcedureQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcedureOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procedurePager) applyOrder(query *ProcedureQuery) *ProcedureQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcedureOrder.Field {
		query = query.Order(DefaultProcedureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procedurePager) orderExpr(query *ProcedureQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcedureOrder.Field {
			b.Comma().Ident(DefaultProcedureOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Procedure.
func (pr *ProcedureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedurePaginateOption,
) (*ProcedureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedurePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProcedureConnection{Edges: []*ProcedureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProcedureOrderField defines the ordering field of Procedure.
type ProcedureOrderField struct {
	// Value extracts the ordering value from the given Procedure.
	Value    func(*Procedure) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedure.OrderOption
	toCursor func(*Procedure) Cursor
}

// ProcedureOrder defines the ordering of Procedure.
type ProcedureOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ProcedureOrderField `json:"field"`
}

// DefaultProcedureOrder is the default ordering of Procedure.
var DefaultProcedureOrder = &ProcedureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureOrderField{
		Value: func(pr *Procedure) (ent.Value, error) {
			return pr.ID, nil
		},
		column: procedure.FieldID,
		toTerm: procedure.ByID,
		toCursor: func(pr *Procedure) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Procedure into ProcedureEdge.
func (pr *Procedure) ToEdge(order *ProcedureOrder) *ProcedureEdge {
	if order == nil {
		order = DefaultProcedureOrder
	}
	return &ProcedureEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProcedureHistoryEdge is the edge representation of ProcedureHistory.
type ProcedureHistoryEdge struct {
	Node   *ProcedureHistory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProcedureHistoryConnection is the connection containing edges to ProcedureHistory.
type ProcedureHistoryConnection struct {
	Edges      []*ProcedureHistoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProcedureHistoryConnection) build(nodes []*ProcedureHistory, pager *procedurehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProcedureHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProcedureHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedureHistoryPaginateOption enables pagination customization.
type ProcedureHistoryPaginateOption func(*procedurehistoryPager) error

// WithProcedureHistoryOrder configures pagination ordering.
func WithProcedureHistoryOrder(order *ProcedureHistoryOrder) ProcedureHistoryPaginateOption {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	o := *order
	return func(pager *procedurehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcedureHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcedureHistoryFilter configures pagination filter.
func WithProcedureHistoryFilter(filter func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)) ProcedureHistoryPaginateOption {
	return func(pager *procedurehistoryPager) error {
		if filter == nil {
			return errors.New("ProcedureHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurehistoryPager struct {
	reverse bool
	order   *ProcedureHistoryOrder
	filter  func(*ProcedureHistoryQuery) (*ProcedureHistoryQuery, error)
}

func newProcedureHistoryPager(opts []ProcedureHistoryPaginateOption, reverse bool) (*procedurehistoryPager, error) {
	pager := &procedurehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcedureHistoryOrder
	}
	return pager, nil
}

func (p *procedurehistoryPager) applyFilter(query *ProcedureHistoryQuery) (*ProcedureHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurehistoryPager) toCursor(ph *ProcedureHistory) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *procedurehistoryPager) applyCursors(query *ProcedureHistoryQuery, after, before *Cursor) (*ProcedureHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcedureHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procedurehistoryPager) applyOrder(query *ProcedureHistoryQuery) *ProcedureHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcedureHistoryOrder.Field {
		query = query.Order(DefaultProcedureHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procedurehistoryPager) orderExpr(query *ProcedureHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcedureHistoryOrder.Field {
			b.Comma().Ident(DefaultProcedureHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProcedureHistory.
func (ph *ProcedureHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedureHistoryPaginateOption,
) (*ProcedureHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedureHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &ProcedureHistoryConnection{Edges: []*ProcedureHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ph = pager.applyOrder(ph)
	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProcedureHistoryOrderField defines the ordering field of ProcedureHistory.
type ProcedureHistoryOrderField struct {
	// Value extracts the ordering value from the given ProcedureHistory.
	Value    func(*ProcedureHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedurehistory.OrderOption
	toCursor func(*ProcedureHistory) Cursor
}

// ProcedureHistoryOrder defines the ordering of ProcedureHistory.
type ProcedureHistoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProcedureHistoryOrderField `json:"field"`
}

// DefaultProcedureHistoryOrder is the default ordering of ProcedureHistory.
var DefaultProcedureHistoryOrder = &ProcedureHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureHistoryOrderField{
		Value: func(ph *ProcedureHistory) (ent.Value, error) {
			return ph.ID, nil
		},
		column: procedurehistory.FieldID,
		toTerm: procedurehistory.ByID,
		toCursor: func(ph *ProcedureHistory) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProcedureHistory into ProcedureHistoryEdge.
func (ph *ProcedureHistory) ToEdge(order *ProcedureHistoryOrder) *ProcedureHistoryEdge {
	if order == nil {
		order = DefaultProcedureHistoryOrder
	}
	return &ProcedureHistoryEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProgramEdge is the edge representation of Program.
type ProgramEdge struct {
	Node   *Program `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProgramConnection is the connection containing edges to Program.
type ProgramConnection struct {
	Edges      []*ProgramEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProgramConnection) build(nodes []*Program, pager *programPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Program
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Program {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Program {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramPaginateOption enables pagination customization.
type ProgramPaginateOption func(*programPager) error

// WithProgramOrder configures pagination ordering.
func WithProgramOrder(order *ProgramOrder) ProgramPaginateOption {
	if order == nil {
		order = DefaultProgramOrder
	}
	o := *order
	return func(pager *programPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramFilter configures pagination filter.
func WithProgramFilter(filter func(*ProgramQuery) (*ProgramQuery, error)) ProgramPaginateOption {
	return func(pager *programPager) error {
		if filter == nil {
			return errors.New("ProgramQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programPager struct {
	reverse bool
	order   *ProgramOrder
	filter  func(*ProgramQuery) (*ProgramQuery, error)
}

func newProgramPager(opts []ProgramPaginateOption, reverse bool) (*programPager, error) {
	pager := &programPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramOrder
	}
	return pager, nil
}

func (p *programPager) applyFilter(query *ProgramQuery) (*ProgramQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programPager) toCursor(pr *Program) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *programPager) applyCursors(query *ProgramQuery, after, before *Cursor) (*ProgramQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programPager) applyOrder(query *ProgramQuery) *ProgramQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramOrder.Field {
		query = query.Order(DefaultProgramOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programPager) orderExpr(query *ProgramQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramOrder.Field {
			b.Comma().Ident(DefaultProgramOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Program.
func (pr *ProgramQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramPaginateOption,
) (*ProgramConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProgramConnection{Edges: []*ProgramEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProgramOrderField defines the ordering field of Program.
type ProgramOrderField struct {
	// Value extracts the ordering value from the given Program.
	Value    func(*Program) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) program.OrderOption
	toCursor func(*Program) Cursor
}

// ProgramOrder defines the ordering of Program.
type ProgramOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProgramOrderField `json:"field"`
}

// DefaultProgramOrder is the default ordering of Program.
var DefaultProgramOrder = &ProgramOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramOrderField{
		Value: func(pr *Program) (ent.Value, error) {
			return pr.ID, nil
		},
		column: program.FieldID,
		toTerm: program.ByID,
		toCursor: func(pr *Program) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Program into ProgramEdge.
func (pr *Program) ToEdge(order *ProgramOrder) *ProgramEdge {
	if order == nil {
		order = DefaultProgramOrder
	}
	return &ProgramEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProgramHistoryEdge is the edge representation of ProgramHistory.
type ProgramHistoryEdge struct {
	Node   *ProgramHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ProgramHistoryConnection is the connection containing edges to ProgramHistory.
type ProgramHistoryConnection struct {
	Edges      []*ProgramHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ProgramHistoryConnection) build(nodes []*ProgramHistory, pager *programhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProgramHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramHistoryPaginateOption enables pagination customization.
type ProgramHistoryPaginateOption func(*programhistoryPager) error

// WithProgramHistoryOrder configures pagination ordering.
func WithProgramHistoryOrder(order *ProgramHistoryOrder) ProgramHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	o := *order
	return func(pager *programhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramHistoryFilter configures pagination filter.
func WithProgramHistoryFilter(filter func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)) ProgramHistoryPaginateOption {
	return func(pager *programhistoryPager) error {
		if filter == nil {
			return errors.New("ProgramHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programhistoryPager struct {
	reverse bool
	order   *ProgramHistoryOrder
	filter  func(*ProgramHistoryQuery) (*ProgramHistoryQuery, error)
}

func newProgramHistoryPager(opts []ProgramHistoryPaginateOption, reverse bool) (*programhistoryPager, error) {
	pager := &programhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramHistoryOrder
	}
	return pager, nil
}

func (p *programhistoryPager) applyFilter(query *ProgramHistoryQuery) (*ProgramHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programhistoryPager) toCursor(ph *ProgramHistory) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *programhistoryPager) applyCursors(query *ProgramHistoryQuery, after, before *Cursor) (*ProgramHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programhistoryPager) applyOrder(query *ProgramHistoryQuery) *ProgramHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramHistoryOrder.Field {
		query = query.Order(DefaultProgramHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programhistoryPager) orderExpr(query *ProgramHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramHistory.
func (ph *ProgramHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramHistoryPaginateOption,
) (*ProgramHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &ProgramHistoryConnection{Edges: []*ProgramHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ph = pager.applyOrder(ph)
	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProgramHistoryOrderField defines the ordering field of ProgramHistory.
type ProgramHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramHistory.
	Value    func(*ProgramHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programhistory.OrderOption
	toCursor func(*ProgramHistory) Cursor
}

// ProgramHistoryOrder defines the ordering of ProgramHistory.
type ProgramHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ProgramHistoryOrderField `json:"field"`
}

// DefaultProgramHistoryOrder is the default ordering of ProgramHistory.
var DefaultProgramHistoryOrder = &ProgramHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramHistoryOrderField{
		Value: func(ph *ProgramHistory) (ent.Value, error) {
			return ph.ID, nil
		},
		column: programhistory.FieldID,
		toTerm: programhistory.ByID,
		toCursor: func(ph *ProgramHistory) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProgramHistory into ProgramHistoryEdge.
func (ph *ProgramHistory) ToEdge(order *ProgramHistoryOrder) *ProgramHistoryEdge {
	if order == nil {
		order = DefaultProgramHistoryOrder
	}
	return &ProgramHistoryEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProgramMembershipEdge is the edge representation of ProgramMembership.
type ProgramMembershipEdge struct {
	Node   *ProgramMembership `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ProgramMembershipConnection is the connection containing edges to ProgramMembership.
type ProgramMembershipConnection struct {
	Edges      []*ProgramMembershipEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ProgramMembershipConnection) build(nodes []*ProgramMembership, pager *programmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProgramMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipPaginateOption enables pagination customization.
type ProgramMembershipPaginateOption func(*programmembershipPager) error

// WithProgramMembershipOrder configures pagination ordering.
func WithProgramMembershipOrder(order *ProgramMembershipOrder) ProgramMembershipPaginateOption {
	if order == nil {
		order = DefaultProgramMembershipOrder
	}
	o := *order
	return func(pager *programmembershipPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramMembershipOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramMembershipFilter configures pagination filter.
func WithProgramMembershipFilter(filter func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershipPager struct {
	reverse bool
	order   *ProgramMembershipOrder
	filter  func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)
}

func newProgramMembershipPager(opts []ProgramMembershipPaginateOption, reverse bool) (*programmembershipPager, error) {
	pager := &programmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramMembershipOrder
	}
	return pager, nil
}

func (p *programmembershipPager) applyFilter(query *ProgramMembershipQuery) (*ProgramMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershipPager) toCursor(pm *ProgramMembership) Cursor {
	return p.order.Field.toCursor(pm)
}

func (p *programmembershipPager) applyCursors(query *ProgramMembershipQuery, after, before *Cursor) (*ProgramMembershipQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramMembershipOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programmembershipPager) applyOrder(query *ProgramMembershipQuery) *ProgramMembershipQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramMembershipOrder.Field {
		query = query.Order(DefaultProgramMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programmembershipPager) orderExpr(query *ProgramMembershipQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramMembershipOrder.Field {
			b.Comma().Ident(DefaultProgramMembershipOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembership.
func (pm *ProgramMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipPaginateOption,
) (*ProgramMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pm, err = pager.applyFilter(pm); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipConnection{Edges: []*ProgramMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pm.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pm, err = pager.applyCursors(pm, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pm.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pm = pager.applyOrder(pm)
	nodes, err := pm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProgramMembershipOrderField defines the ordering field of ProgramMembership.
type ProgramMembershipOrderField struct {
	// Value extracts the ordering value from the given ProgramMembership.
	Value    func(*ProgramMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembership.OrderOption
	toCursor func(*ProgramMembership) Cursor
}

// ProgramMembershipOrder defines the ordering of ProgramMembership.
type ProgramMembershipOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ProgramMembershipOrderField `json:"field"`
}

// DefaultProgramMembershipOrder is the default ordering of ProgramMembership.
var DefaultProgramMembershipOrder = &ProgramMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipOrderField{
		Value: func(pm *ProgramMembership) (ent.Value, error) {
			return pm.ID, nil
		},
		column: programmembership.FieldID,
		toTerm: programmembership.ByID,
		toCursor: func(pm *ProgramMembership) Cursor {
			return Cursor{ID: pm.ID}
		},
	},
}

// ToEdge converts ProgramMembership into ProgramMembershipEdge.
func (pm *ProgramMembership) ToEdge(order *ProgramMembershipOrder) *ProgramMembershipEdge {
	if order == nil {
		order = DefaultProgramMembershipOrder
	}
	return &ProgramMembershipEdge{
		Node:   pm,
		Cursor: order.Field.toCursor(pm),
	}
}

// ProgramMembershipHistoryEdge is the edge representation of ProgramMembershipHistory.
type ProgramMembershipHistoryEdge struct {
	Node   *ProgramMembershipHistory `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// ProgramMembershipHistoryConnection is the connection containing edges to ProgramMembershipHistory.
type ProgramMembershipHistoryConnection struct {
	Edges      []*ProgramMembershipHistoryEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *ProgramMembershipHistoryConnection) build(nodes []*ProgramMembershipHistory, pager *programmembershiphistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProgramMembershipHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembershipHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipHistoryPaginateOption enables pagination customization.
type ProgramMembershipHistoryPaginateOption func(*programmembershiphistoryPager) error

// WithProgramMembershipHistoryOrder configures pagination ordering.
func WithProgramMembershipHistoryOrder(order *ProgramMembershipHistoryOrder) ProgramMembershipHistoryPaginateOption {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	o := *order
	return func(pager *programmembershiphistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProgramMembershipHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProgramMembershipHistoryFilter configures pagination filter.
func WithProgramMembershipHistoryFilter(filter func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)) ProgramMembershipHistoryPaginateOption {
	return func(pager *programmembershiphistoryPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershiphistoryPager struct {
	reverse bool
	order   *ProgramMembershipHistoryOrder
	filter  func(*ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error)
}

func newProgramMembershipHistoryPager(opts []ProgramMembershipHistoryPaginateOption, reverse bool) (*programmembershiphistoryPager, error) {
	pager := &programmembershiphistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProgramMembershipHistoryOrder
	}
	return pager, nil
}

func (p *programmembershiphistoryPager) applyFilter(query *ProgramMembershipHistoryQuery) (*ProgramMembershipHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) toCursor(pmh *ProgramMembershipHistory) Cursor {
	return p.order.Field.toCursor(pmh)
}

func (p *programmembershiphistoryPager) applyCursors(query *ProgramMembershipHistoryQuery, after, before *Cursor) (*ProgramMembershipHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProgramMembershipHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *programmembershiphistoryPager) applyOrder(query *ProgramMembershipHistoryQuery) *ProgramMembershipHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
		query = query.Order(DefaultProgramMembershipHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *programmembershiphistoryPager) orderExpr(query *ProgramMembershipHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProgramMembershipHistoryOrder.Field {
			b.Comma().Ident(DefaultProgramMembershipHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembershipHistory.
func (pmh *ProgramMembershipHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipHistoryPaginateOption,
) (*ProgramMembershipHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pmh, err = pager.applyFilter(pmh); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipHistoryConnection{Edges: []*ProgramMembershipHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pmh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pmh, err = pager.applyCursors(pmh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pmh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pmh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pmh = pager.applyOrder(pmh)
	nodes, err := pmh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProgramMembershipHistoryOrderField defines the ordering field of ProgramMembershipHistory.
type ProgramMembershipHistoryOrderField struct {
	// Value extracts the ordering value from the given ProgramMembershipHistory.
	Value    func(*ProgramMembershipHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembershiphistory.OrderOption
	toCursor func(*ProgramMembershipHistory) Cursor
}

// ProgramMembershipHistoryOrder defines the ordering of ProgramMembershipHistory.
type ProgramMembershipHistoryOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *ProgramMembershipHistoryOrderField `json:"field"`
}

// DefaultProgramMembershipHistoryOrder is the default ordering of ProgramMembershipHistory.
var DefaultProgramMembershipHistoryOrder = &ProgramMembershipHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipHistoryOrderField{
		Value: func(pmh *ProgramMembershipHistory) (ent.Value, error) {
			return pmh.ID, nil
		},
		column: programmembershiphistory.FieldID,
		toTerm: programmembershiphistory.ByID,
		toCursor: func(pmh *ProgramMembershipHistory) Cursor {
			return Cursor{ID: pmh.ID}
		},
	},
}

// ToEdge converts ProgramMembershipHistory into ProgramMembershipHistoryEdge.
func (pmh *ProgramMembershipHistory) ToEdge(order *ProgramMembershipHistoryOrder) *ProgramMembershipHistoryEdge {
	if order == nil {
		order = DefaultProgramMembershipHistoryOrder
	}
	return &ProgramMembershipHistoryEdge{
		Node:   pmh,
		Cursor: order.Field.toCursor(pmh),
	}
}

// RiskEdge is the edge representation of Risk.
type RiskEdge struct {
	Node   *Risk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RiskConnection is the connection containing edges to Risk.
type RiskConnection struct {
	Edges      []*RiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *RiskConnection) build(nodes []*Risk, pager *riskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Risk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Risk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Risk {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskPaginateOption enables pagination customization.
type RiskPaginateOption func(*riskPager) error

// WithRiskOrder configures pagination ordering.
func WithRiskOrder(order *RiskOrder) RiskPaginateOption {
	if order == nil {
		order = DefaultRiskOrder
	}
	o := *order
	return func(pager *riskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRiskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRiskFilter configures pagination filter.
func WithRiskFilter(filter func(*RiskQuery) (*RiskQuery, error)) RiskPaginateOption {
	return func(pager *riskPager) error {
		if filter == nil {
			return errors.New("RiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskPager struct {
	reverse bool
	order   *RiskOrder
	filter  func(*RiskQuery) (*RiskQuery, error)
}

func newRiskPager(opts []RiskPaginateOption, reverse bool) (*riskPager, error) {
	pager := &riskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRiskOrder
	}
	return pager, nil
}

func (p *riskPager) applyFilter(query *RiskQuery) (*RiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskPager) toCursor(r *Risk) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *riskPager) applyCursors(query *RiskQuery, after, before *Cursor) (*RiskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRiskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *riskPager) applyOrder(query *RiskQuery) *RiskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRiskOrder.Field {
		query = query.Order(DefaultRiskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *riskPager) orderExpr(query *RiskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRiskOrder.Field {
			b.Comma().Ident(DefaultRiskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Risk.
func (r *RiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskPaginateOption,
) (*RiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RiskConnection{Edges: []*RiskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RiskOrderField defines the ordering field of Risk.
type RiskOrderField struct {
	// Value extracts the ordering value from the given Risk.
	Value    func(*Risk) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) risk.OrderOption
	toCursor func(*Risk) Cursor
}

// RiskOrder defines the ordering of Risk.
type RiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RiskOrderField `json:"field"`
}

// DefaultRiskOrder is the default ordering of Risk.
var DefaultRiskOrder = &RiskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskOrderField{
		Value: func(r *Risk) (ent.Value, error) {
			return r.ID, nil
		},
		column: risk.FieldID,
		toTerm: risk.ByID,
		toCursor: func(r *Risk) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Risk into RiskEdge.
func (r *Risk) ToEdge(order *RiskOrder) *RiskEdge {
	if order == nil {
		order = DefaultRiskOrder
	}
	return &RiskEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RiskHistoryEdge is the edge representation of RiskHistory.
type RiskHistoryEdge struct {
	Node   *RiskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// RiskHistoryConnection is the connection containing edges to RiskHistory.
type RiskHistoryConnection struct {
	Edges      []*RiskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *RiskHistoryConnection) build(nodes []*RiskHistory, pager *riskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RiskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RiskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RiskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskHistoryPaginateOption enables pagination customization.
type RiskHistoryPaginateOption func(*riskhistoryPager) error

// WithRiskHistoryOrder configures pagination ordering.
func WithRiskHistoryOrder(order *RiskHistoryOrder) RiskHistoryPaginateOption {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	o := *order
	return func(pager *riskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRiskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRiskHistoryFilter configures pagination filter.
func WithRiskHistoryFilter(filter func(*RiskHistoryQuery) (*RiskHistoryQuery, error)) RiskHistoryPaginateOption {
	return func(pager *riskhistoryPager) error {
		if filter == nil {
			return errors.New("RiskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskhistoryPager struct {
	reverse bool
	order   *RiskHistoryOrder
	filter  func(*RiskHistoryQuery) (*RiskHistoryQuery, error)
}

func newRiskHistoryPager(opts []RiskHistoryPaginateOption, reverse bool) (*riskhistoryPager, error) {
	pager := &riskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRiskHistoryOrder
	}
	return pager, nil
}

func (p *riskhistoryPager) applyFilter(query *RiskHistoryQuery) (*RiskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskhistoryPager) toCursor(rh *RiskHistory) Cursor {
	return p.order.Field.toCursor(rh)
}

func (p *riskhistoryPager) applyCursors(query *RiskHistoryQuery, after, before *Cursor) (*RiskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRiskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *riskhistoryPager) applyOrder(query *RiskHistoryQuery) *RiskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRiskHistoryOrder.Field {
		query = query.Order(DefaultRiskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *riskhistoryPager) orderExpr(query *RiskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRiskHistoryOrder.Field {
			b.Comma().Ident(DefaultRiskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RiskHistory.
func (rh *RiskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskHistoryPaginateOption,
) (*RiskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rh, err = pager.applyFilter(rh); err != nil {
		return nil, err
	}
	conn := &RiskHistoryConnection{Edges: []*RiskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rh, err = pager.applyCursors(rh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rh = pager.applyOrder(rh)
	nodes, err := rh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RiskHistoryOrderField defines the ordering field of RiskHistory.
type RiskHistoryOrderField struct {
	// Value extracts the ordering value from the given RiskHistory.
	Value    func(*RiskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) riskhistory.OrderOption
	toCursor func(*RiskHistory) Cursor
}

// RiskHistoryOrder defines the ordering of RiskHistory.
type RiskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *RiskHistoryOrderField `json:"field"`
}

// DefaultRiskHistoryOrder is the default ordering of RiskHistory.
var DefaultRiskHistoryOrder = &RiskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskHistoryOrderField{
		Value: func(rh *RiskHistory) (ent.Value, error) {
			return rh.ID, nil
		},
		column: riskhistory.FieldID,
		toTerm: riskhistory.ByID,
		toCursor: func(rh *RiskHistory) Cursor {
			return Cursor{ID: rh.ID}
		},
	},
}

// ToEdge converts RiskHistory into RiskHistoryEdge.
func (rh *RiskHistory) ToEdge(order *RiskHistoryOrder) *RiskHistoryEdge {
	if order == nil {
		order = DefaultRiskHistoryOrder
	}
	return &RiskHistoryEdge{
		Node:   rh,
		Cursor: order.Field.toCursor(rh),
	}
}

// StandardEdge is the edge representation of Standard.
type StandardEdge struct {
	Node   *Standard `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// StandardConnection is the connection containing edges to Standard.
type StandardConnection struct {
	Edges      []*StandardEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *StandardConnection) build(nodes []*Standard, pager *standardPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Standard
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Standard {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Standard {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardPaginateOption enables pagination customization.
type StandardPaginateOption func(*standardPager) error

// WithStandardOrder configures pagination ordering.
func WithStandardOrder(order *StandardOrder) StandardPaginateOption {
	if order == nil {
		order = DefaultStandardOrder
	}
	o := *order
	return func(pager *standardPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStandardOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStandardFilter configures pagination filter.
func WithStandardFilter(filter func(*StandardQuery) (*StandardQuery, error)) StandardPaginateOption {
	return func(pager *standardPager) error {
		if filter == nil {
			return errors.New("StandardQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardPager struct {
	reverse bool
	order   *StandardOrder
	filter  func(*StandardQuery) (*StandardQuery, error)
}

func newStandardPager(opts []StandardPaginateOption, reverse bool) (*standardPager, error) {
	pager := &standardPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStandardOrder
	}
	return pager, nil
}

func (p *standardPager) applyFilter(query *StandardQuery) (*StandardQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardPager) toCursor(s *Standard) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *standardPager) applyCursors(query *StandardQuery, after, before *Cursor) (*StandardQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStandardOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *standardPager) applyOrder(query *StandardQuery) *StandardQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStandardOrder.Field {
		query = query.Order(DefaultStandardOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *standardPager) orderExpr(query *StandardQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStandardOrder.Field {
			b.Comma().Ident(DefaultStandardOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Standard.
func (s *StandardQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardPaginateOption,
) (*StandardConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &StandardConnection{Edges: []*StandardEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StandardOrderField defines the ordering field of Standard.
type StandardOrderField struct {
	// Value extracts the ordering value from the given Standard.
	Value    func(*Standard) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standard.OrderOption
	toCursor func(*Standard) Cursor
}

// StandardOrder defines the ordering of Standard.
type StandardOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *StandardOrderField `json:"field"`
}

// DefaultStandardOrder is the default ordering of Standard.
var DefaultStandardOrder = &StandardOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardOrderField{
		Value: func(s *Standard) (ent.Value, error) {
			return s.ID, nil
		},
		column: standard.FieldID,
		toTerm: standard.ByID,
		toCursor: func(s *Standard) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Standard into StandardEdge.
func (s *Standard) ToEdge(order *StandardOrder) *StandardEdge {
	if order == nil {
		order = DefaultStandardOrder
	}
	return &StandardEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// StandardHistoryEdge is the edge representation of StandardHistory.
type StandardHistoryEdge struct {
	Node   *StandardHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// StandardHistoryConnection is the connection containing edges to StandardHistory.
type StandardHistoryConnection struct {
	Edges      []*StandardHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *StandardHistoryConnection) build(nodes []*StandardHistory, pager *standardhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *StandardHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *StandardHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *StandardHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardHistoryPaginateOption enables pagination customization.
type StandardHistoryPaginateOption func(*standardhistoryPager) error

// WithStandardHistoryOrder configures pagination ordering.
func WithStandardHistoryOrder(order *StandardHistoryOrder) StandardHistoryPaginateOption {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	o := *order
	return func(pager *standardhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStandardHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStandardHistoryFilter configures pagination filter.
func WithStandardHistoryFilter(filter func(*StandardHistoryQuery) (*StandardHistoryQuery, error)) StandardHistoryPaginateOption {
	return func(pager *standardhistoryPager) error {
		if filter == nil {
			return errors.New("StandardHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardhistoryPager struct {
	reverse bool
	order   *StandardHistoryOrder
	filter  func(*StandardHistoryQuery) (*StandardHistoryQuery, error)
}

func newStandardHistoryPager(opts []StandardHistoryPaginateOption, reverse bool) (*standardhistoryPager, error) {
	pager := &standardhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStandardHistoryOrder
	}
	return pager, nil
}

func (p *standardhistoryPager) applyFilter(query *StandardHistoryQuery) (*StandardHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardhistoryPager) toCursor(sh *StandardHistory) Cursor {
	return p.order.Field.toCursor(sh)
}

func (p *standardhistoryPager) applyCursors(query *StandardHistoryQuery, after, before *Cursor) (*StandardHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStandardHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *standardhistoryPager) applyOrder(query *StandardHistoryQuery) *StandardHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStandardHistoryOrder.Field {
		query = query.Order(DefaultStandardHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *standardhistoryPager) orderExpr(query *StandardHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStandardHistoryOrder.Field {
			b.Comma().Ident(DefaultStandardHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to StandardHistory.
func (sh *StandardHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardHistoryPaginateOption,
) (*StandardHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sh, err = pager.applyFilter(sh); err != nil {
		return nil, err
	}
	conn := &StandardHistoryConnection{Edges: []*StandardHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sh, err = pager.applyCursors(sh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sh = pager.applyOrder(sh)
	nodes, err := sh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StandardHistoryOrderField defines the ordering field of StandardHistory.
type StandardHistoryOrderField struct {
	// Value extracts the ordering value from the given StandardHistory.
	Value    func(*StandardHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standardhistory.OrderOption
	toCursor func(*StandardHistory) Cursor
}

// StandardHistoryOrder defines the ordering of StandardHistory.
type StandardHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *StandardHistoryOrderField `json:"field"`
}

// DefaultStandardHistoryOrder is the default ordering of StandardHistory.
var DefaultStandardHistoryOrder = &StandardHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardHistoryOrderField{
		Value: func(sh *StandardHistory) (ent.Value, error) {
			return sh.ID, nil
		},
		column: standardhistory.FieldID,
		toTerm: standardhistory.ByID,
		toCursor: func(sh *StandardHistory) Cursor {
			return Cursor{ID: sh.ID}
		},
	},
}

// ToEdge converts StandardHistory into StandardHistoryEdge.
func (sh *StandardHistory) ToEdge(order *StandardHistoryOrder) *StandardHistoryEdge {
	if order == nil {
		order = DefaultStandardHistoryOrder
	}
	return &StandardHistoryEdge{
		Node:   sh,
		Cursor: order.Field.toCursor(sh),
	}
}

// SubcontrolEdge is the edge representation of Subcontrol.
type SubcontrolEdge struct {
	Node   *Subcontrol `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubcontrolConnection is the connection containing edges to Subcontrol.
type SubcontrolConnection struct {
	Edges      []*SubcontrolEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubcontrolConnection) build(nodes []*Subcontrol, pager *subcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Subcontrol
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subcontrol {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subcontrol {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolPaginateOption enables pagination customization.
type SubcontrolPaginateOption func(*subcontrolPager) error

// WithSubcontrolOrder configures pagination ordering.
func WithSubcontrolOrder(order *SubcontrolOrder) SubcontrolPaginateOption {
	if order == nil {
		order = DefaultSubcontrolOrder
	}
	o := *order
	return func(pager *subcontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubcontrolOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubcontrolFilter configures pagination filter.
func WithSubcontrolFilter(filter func(*SubcontrolQuery) (*SubcontrolQuery, error)) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		if filter == nil {
			return errors.New("SubcontrolQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolPager struct {
	reverse bool
	order   *SubcontrolOrder
	filter  func(*SubcontrolQuery) (*SubcontrolQuery, error)
}

func newSubcontrolPager(opts []SubcontrolPaginateOption, reverse bool) (*subcontrolPager, error) {
	pager := &subcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubcontrolOrder
	}
	return pager, nil
}

func (p *subcontrolPager) applyFilter(query *SubcontrolQuery) (*SubcontrolQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolPager) toCursor(s *Subcontrol) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *subcontrolPager) applyCursors(query *SubcontrolQuery, after, before *Cursor) (*SubcontrolQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubcontrolOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subcontrolPager) applyOrder(query *SubcontrolQuery) *SubcontrolQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubcontrolOrder.Field {
		query = query.Order(DefaultSubcontrolOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subcontrolPager) orderExpr(query *SubcontrolQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubcontrolOrder.Field {
			b.Comma().Ident(DefaultSubcontrolOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subcontrol.
func (s *SubcontrolQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolPaginateOption,
) (*SubcontrolConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SubcontrolConnection{Edges: []*SubcontrolEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SubcontrolOrderField defines the ordering field of Subcontrol.
type SubcontrolOrderField struct {
	// Value extracts the ordering value from the given Subcontrol.
	Value    func(*Subcontrol) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrol.OrderOption
	toCursor func(*Subcontrol) Cursor
}

// SubcontrolOrder defines the ordering of Subcontrol.
type SubcontrolOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubcontrolOrderField `json:"field"`
}

// DefaultSubcontrolOrder is the default ordering of Subcontrol.
var DefaultSubcontrolOrder = &SubcontrolOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolOrderField{
		Value: func(s *Subcontrol) (ent.Value, error) {
			return s.ID, nil
		},
		column: subcontrol.FieldID,
		toTerm: subcontrol.ByID,
		toCursor: func(s *Subcontrol) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Subcontrol into SubcontrolEdge.
func (s *Subcontrol) ToEdge(order *SubcontrolOrder) *SubcontrolEdge {
	if order == nil {
		order = DefaultSubcontrolOrder
	}
	return &SubcontrolEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SubcontrolHistoryEdge is the edge representation of SubcontrolHistory.
type SubcontrolHistoryEdge struct {
	Node   *SubcontrolHistory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// SubcontrolHistoryConnection is the connection containing edges to SubcontrolHistory.
type SubcontrolHistoryConnection struct {
	Edges      []*SubcontrolHistoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *SubcontrolHistoryConnection) build(nodes []*SubcontrolHistory, pager *subcontrolhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SubcontrolHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubcontrolHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolHistoryPaginateOption enables pagination customization.
type SubcontrolHistoryPaginateOption func(*subcontrolhistoryPager) error

// WithSubcontrolHistoryOrder configures pagination ordering.
func WithSubcontrolHistoryOrder(order *SubcontrolHistoryOrder) SubcontrolHistoryPaginateOption {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	o := *order
	return func(pager *subcontrolhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubcontrolHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubcontrolHistoryFilter configures pagination filter.
func WithSubcontrolHistoryFilter(filter func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)) SubcontrolHistoryPaginateOption {
	return func(pager *subcontrolhistoryPager) error {
		if filter == nil {
			return errors.New("SubcontrolHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolhistoryPager struct {
	reverse bool
	order   *SubcontrolHistoryOrder
	filter  func(*SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error)
}

func newSubcontrolHistoryPager(opts []SubcontrolHistoryPaginateOption, reverse bool) (*subcontrolhistoryPager, error) {
	pager := &subcontrolhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubcontrolHistoryOrder
	}
	return pager, nil
}

func (p *subcontrolhistoryPager) applyFilter(query *SubcontrolHistoryQuery) (*SubcontrolHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) toCursor(sh *SubcontrolHistory) Cursor {
	return p.order.Field.toCursor(sh)
}

func (p *subcontrolhistoryPager) applyCursors(query *SubcontrolHistoryQuery, after, before *Cursor) (*SubcontrolHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubcontrolHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subcontrolhistoryPager) applyOrder(query *SubcontrolHistoryQuery) *SubcontrolHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
		query = query.Order(DefaultSubcontrolHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subcontrolhistoryPager) orderExpr(query *SubcontrolHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubcontrolHistoryOrder.Field {
			b.Comma().Ident(DefaultSubcontrolHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubcontrolHistory.
func (sh *SubcontrolHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolHistoryPaginateOption,
) (*SubcontrolHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sh, err = pager.applyFilter(sh); err != nil {
		return nil, err
	}
	conn := &SubcontrolHistoryConnection{Edges: []*SubcontrolHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sh, err = pager.applyCursors(sh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sh = pager.applyOrder(sh)
	nodes, err := sh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SubcontrolHistoryOrderField defines the ordering field of SubcontrolHistory.
type SubcontrolHistoryOrderField struct {
	// Value extracts the ordering value from the given SubcontrolHistory.
	Value    func(*SubcontrolHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrolhistory.OrderOption
	toCursor func(*SubcontrolHistory) Cursor
}

// SubcontrolHistoryOrder defines the ordering of SubcontrolHistory.
type SubcontrolHistoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *SubcontrolHistoryOrderField `json:"field"`
}

// DefaultSubcontrolHistoryOrder is the default ordering of SubcontrolHistory.
var DefaultSubcontrolHistoryOrder = &SubcontrolHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolHistoryOrderField{
		Value: func(sh *SubcontrolHistory) (ent.Value, error) {
			return sh.ID, nil
		},
		column: subcontrolhistory.FieldID,
		toTerm: subcontrolhistory.ByID,
		toCursor: func(sh *SubcontrolHistory) Cursor {
			return Cursor{ID: sh.ID}
		},
	},
}

// ToEdge converts SubcontrolHistory into SubcontrolHistoryEdge.
func (sh *SubcontrolHistory) ToEdge(order *SubcontrolHistoryOrder) *SubcontrolHistoryEdge {
	if order == nil {
		order = DefaultSubcontrolHistoryOrder
	}
	return &SubcontrolHistoryEdge{
		Node:   sh,
		Cursor: order.Field.toCursor(sh),
	}
}

// SubscriberEdge is the edge representation of Subscriber.
type SubscriberEdge struct {
	Node   *Subscriber `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubscriberConnection is the connection containing edges to Subscriber.
type SubscriberConnection struct {
	Edges      []*SubscriberEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubscriberConnection) build(nodes []*Subscriber, pager *subscriberPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Subscriber
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subscriber {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subscriber {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubscriberEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubscriberEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubscriberPaginateOption enables pagination customization.
type SubscriberPaginateOption func(*subscriberPager) error

// WithSubscriberOrder configures pagination ordering.
func WithSubscriberOrder(order *SubscriberOrder) SubscriberPaginateOption {
	if order == nil {
		order = DefaultSubscriberOrder
	}
	o := *order
	return func(pager *subscriberPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubscriberOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubscriberFilter configures pagination filter.
func WithSubscriberFilter(filter func(*SubscriberQuery) (*SubscriberQuery, error)) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		if filter == nil {
			return errors.New("SubscriberQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subscriberPager struct {
	reverse bool
	order   *SubscriberOrder
	filter  func(*SubscriberQuery) (*SubscriberQuery, error)
}

func newSubscriberPager(opts []SubscriberPaginateOption, reverse bool) (*subscriberPager, error) {
	pager := &subscriberPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubscriberOrder
	}
	return pager, nil
}

func (p *subscriberPager) applyFilter(query *SubscriberQuery) (*SubscriberQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subscriberPager) toCursor(s *Subscriber) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *subscriberPager) applyCursors(query *SubscriberQuery, after, before *Cursor) (*SubscriberQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubscriberOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subscriberPager) applyOrder(query *SubscriberQuery) *SubscriberQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubscriberOrder.Field {
		query = query.Order(DefaultSubscriberOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subscriberPager) orderExpr(query *SubscriberQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubscriberOrder.Field {
			b.Comma().Ident(DefaultSubscriberOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subscriber.
func (s *SubscriberQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubscriberPaginateOption,
) (*SubscriberConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubscriberPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SubscriberConnection{Edges: []*SubscriberEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SubscriberOrderField defines the ordering field of Subscriber.
type SubscriberOrderField struct {
	// Value extracts the ordering value from the given Subscriber.
	Value    func(*Subscriber) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subscriber.OrderOption
	toCursor func(*Subscriber) Cursor
}

// SubscriberOrder defines the ordering of Subscriber.
type SubscriberOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubscriberOrderField `json:"field"`
}

// DefaultSubscriberOrder is the default ordering of Subscriber.
var DefaultSubscriberOrder = &SubscriberOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubscriberOrderField{
		Value: func(s *Subscriber) (ent.Value, error) {
			return s.ID, nil
		},
		column: subscriber.FieldID,
		toTerm: subscriber.ByID,
		toCursor: func(s *Subscriber) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Subscriber into SubscriberEdge.
func (s *Subscriber) ToEdge(order *SubscriberOrder) *SubscriberEdge {
	if order == nil {
		order = DefaultSubscriberOrder
	}
	return &SubscriberEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TFASettingEdge is the edge representation of TFASetting.
type TFASettingEdge struct {
	Node   *TFASetting `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// TFASettingConnection is the connection containing edges to TFASetting.
type TFASettingConnection struct {
	Edges      []*TFASettingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *TFASettingConnection) build(nodes []*TFASetting, pager *tfasettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TFASetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TFASetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TFASetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TFASettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TFASettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TFASettingPaginateOption enables pagination customization.
type TFASettingPaginateOption func(*tfasettingPager) error

// WithTFASettingOrder configures pagination ordering.
func WithTFASettingOrder(order *TFASettingOrder) TFASettingPaginateOption {
	if order == nil {
		order = DefaultTFASettingOrder
	}
	o := *order
	return func(pager *tfasettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTFASettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTFASettingFilter configures pagination filter.
func WithTFASettingFilter(filter func(*TFASettingQuery) (*TFASettingQuery, error)) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		if filter == nil {
			return errors.New("TFASettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tfasettingPager struct {
	reverse bool
	order   *TFASettingOrder
	filter  func(*TFASettingQuery) (*TFASettingQuery, error)
}

func newTFASettingPager(opts []TFASettingPaginateOption, reverse bool) (*tfasettingPager, error) {
	pager := &tfasettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTFASettingOrder
	}
	return pager, nil
}

func (p *tfasettingPager) applyFilter(query *TFASettingQuery) (*TFASettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tfasettingPager) toCursor(ts *TFASetting) Cursor {
	return p.order.Field.toCursor(ts)
}

func (p *tfasettingPager) applyCursors(query *TFASettingQuery, after, before *Cursor) (*TFASettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTFASettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tfasettingPager) applyOrder(query *TFASettingQuery) *TFASettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTFASettingOrder.Field {
		query = query.Order(DefaultTFASettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tfasettingPager) orderExpr(query *TFASettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTFASettingOrder.Field {
			b.Comma().Ident(DefaultTFASettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TFASetting.
func (ts *TFASettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TFASettingPaginateOption,
) (*TFASettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTFASettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ts, err = pager.applyFilter(ts); err != nil {
		return nil, err
	}
	conn := &TFASettingConnection{Edges: []*TFASettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ts.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ts, err = pager.applyCursors(ts, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ts.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ts.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ts = pager.applyOrder(ts)
	nodes, err := ts.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TFASettingOrderField defines the ordering field of TFASetting.
type TFASettingOrderField struct {
	// Value extracts the ordering value from the given TFASetting.
	Value    func(*TFASetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tfasetting.OrderOption
	toCursor func(*TFASetting) Cursor
}

// TFASettingOrder defines the ordering of TFASetting.
type TFASettingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *TFASettingOrderField `json:"field"`
}

// DefaultTFASettingOrder is the default ordering of TFASetting.
var DefaultTFASettingOrder = &TFASettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TFASettingOrderField{
		Value: func(ts *TFASetting) (ent.Value, error) {
			return ts.ID, nil
		},
		column: tfasetting.FieldID,
		toTerm: tfasetting.ByID,
		toCursor: func(ts *TFASetting) Cursor {
			return Cursor{ID: ts.ID}
		},
	},
}

// ToEdge converts TFASetting into TFASettingEdge.
func (ts *TFASetting) ToEdge(order *TFASettingOrder) *TFASettingEdge {
	if order == nil {
		order = DefaultTFASettingOrder
	}
	return &TFASettingEdge{
		Node:   ts,
		Cursor: order.Field.toCursor(ts),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order *TaskOrder) TaskPaginateOption {
	if order == nil {
		order = DefaultTaskOrder
	}
	o := *order
	return func(pager *taskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   *TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskOrder
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(t *Task) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTaskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTaskOrder.Field {
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTaskOrder.Field {
			b.Comma().Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (t *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(t *Task) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (t *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TaskHistoryEdge is the edge representation of TaskHistory.
type TaskHistoryEdge struct {
	Node   *TaskHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TaskHistoryConnection is the connection containing edges to TaskHistory.
type TaskHistoryConnection struct {
	Edges      []*TaskHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TaskHistoryConnection) build(nodes []*TaskHistory, pager *taskhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TaskHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TaskHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TaskHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskHistoryPaginateOption enables pagination customization.
type TaskHistoryPaginateOption func(*taskhistoryPager) error

// WithTaskHistoryOrder configures pagination ordering.
func WithTaskHistoryOrder(order *TaskHistoryOrder) TaskHistoryPaginateOption {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	o := *order
	return func(pager *taskhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskHistoryFilter configures pagination filter.
func WithTaskHistoryFilter(filter func(*TaskHistoryQuery) (*TaskHistoryQuery, error)) TaskHistoryPaginateOption {
	return func(pager *taskhistoryPager) error {
		if filter == nil {
			return errors.New("TaskHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskhistoryPager struct {
	reverse bool
	order   *TaskHistoryOrder
	filter  func(*TaskHistoryQuery) (*TaskHistoryQuery, error)
}

func newTaskHistoryPager(opts []TaskHistoryPaginateOption, reverse bool) (*taskhistoryPager, error) {
	pager := &taskhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskHistoryOrder
	}
	return pager, nil
}

func (p *taskhistoryPager) applyFilter(query *TaskHistoryQuery) (*TaskHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskhistoryPager) toCursor(th *TaskHistory) Cursor {
	return p.order.Field.toCursor(th)
}

func (p *taskhistoryPager) applyCursors(query *TaskHistoryQuery, after, before *Cursor) (*TaskHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTaskHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskhistoryPager) applyOrder(query *TaskHistoryQuery) *TaskHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTaskHistoryOrder.Field {
		query = query.Order(DefaultTaskHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *taskhistoryPager) orderExpr(query *TaskHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTaskHistoryOrder.Field {
			b.Comma().Ident(DefaultTaskHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TaskHistory.
func (th *TaskHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskHistoryPaginateOption,
) (*TaskHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if th, err = pager.applyFilter(th); err != nil {
		return nil, err
	}
	conn := &TaskHistoryConnection{Edges: []*TaskHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := th.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if th, err = pager.applyCursors(th, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		th.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := th.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	th = pager.applyOrder(th)
	nodes, err := th.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TaskHistoryOrderField defines the ordering field of TaskHistory.
type TaskHistoryOrderField struct {
	// Value extracts the ordering value from the given TaskHistory.
	Value    func(*TaskHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) taskhistory.OrderOption
	toCursor func(*TaskHistory) Cursor
}

// TaskHistoryOrder defines the ordering of TaskHistory.
type TaskHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TaskHistoryOrderField `json:"field"`
}

// DefaultTaskHistoryOrder is the default ordering of TaskHistory.
var DefaultTaskHistoryOrder = &TaskHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskHistoryOrderField{
		Value: func(th *TaskHistory) (ent.Value, error) {
			return th.ID, nil
		},
		column: taskhistory.FieldID,
		toTerm: taskhistory.ByID,
		toCursor: func(th *TaskHistory) Cursor {
			return Cursor{ID: th.ID}
		},
	},
}

// ToEdge converts TaskHistory into TaskHistoryEdge.
func (th *TaskHistory) ToEdge(order *TaskHistoryOrder) *TaskHistoryEdge {
	if order == nil {
		order = DefaultTaskHistoryOrder
	}
	return &TaskHistoryEdge{
		Node:   th,
		Cursor: order.Field.toCursor(th),
	}
}

// TemplateEdge is the edge representation of Template.
type TemplateEdge struct {
	Node   *Template `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TemplateConnection is the connection containing edges to Template.
type TemplateConnection struct {
	Edges      []*TemplateEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *TemplateConnection) build(nodes []*Template, pager *templatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Template
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Template {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Template {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplatePaginateOption enables pagination customization.
type TemplatePaginateOption func(*templatePager) error

// WithTemplateOrder configures pagination ordering.
func WithTemplateOrder(order *TemplateOrder) TemplatePaginateOption {
	if order == nil {
		order = DefaultTemplateOrder
	}
	o := *order
	return func(pager *templatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateFilter configures pagination filter.
func WithTemplateFilter(filter func(*TemplateQuery) (*TemplateQuery, error)) TemplatePaginateOption {
	return func(pager *templatePager) error {
		if filter == nil {
			return errors.New("TemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatePager struct {
	reverse bool
	order   *TemplateOrder
	filter  func(*TemplateQuery) (*TemplateQuery, error)
}

func newTemplatePager(opts []TemplatePaginateOption, reverse bool) (*templatePager, error) {
	pager := &templatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateOrder
	}
	return pager, nil
}

func (p *templatePager) applyFilter(query *TemplateQuery) (*TemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatePager) toCursor(t *Template) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *templatePager) applyCursors(query *TemplateQuery, after, before *Cursor) (*TemplateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTemplateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *templatePager) applyOrder(query *TemplateQuery) *TemplateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTemplateOrder.Field {
		query = query.Order(DefaultTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *templatePager) orderExpr(query *TemplateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTemplateOrder.Field {
			b.Comma().Ident(DefaultTemplateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Template.
func (t *TemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplatePaginateOption,
) (*TemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TemplateConnection{Edges: []*TemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateOrderFieldName orders Template by name.
	TemplateOrderFieldName = &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.Name, nil
		},
		column: template.FieldName,
		toTerm: template.ByName,
		toCursor: func(t *Template) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateOrderField) String() string {
	var str string
	switch f.column {
	case TemplateOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *TemplateOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

// TemplateOrderField defines the ordering field of Template.
type TemplateOrderField struct {
	// Value extracts the ordering value from the given Template.
	Value    func(*Template) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) template.OrderOption
	toCursor func(*Template) Cursor
}

// TemplateOrder defines the ordering of Template.
type TemplateOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TemplateOrderField `json:"field"`
}

// DefaultTemplateOrder is the default ordering of Template.
var DefaultTemplateOrder = &TemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateOrderField{
		Value: func(t *Template) (ent.Value, error) {
			return t.ID, nil
		},
		column: template.FieldID,
		toTerm: template.ByID,
		toCursor: func(t *Template) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Template into TemplateEdge.
func (t *Template) ToEdge(order *TemplateOrder) *TemplateEdge {
	if order == nil {
		order = DefaultTemplateOrder
	}
	return &TemplateEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TemplateHistoryEdge is the edge representation of TemplateHistory.
type TemplateHistoryEdge struct {
	Node   *TemplateHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TemplateHistoryConnection is the connection containing edges to TemplateHistory.
type TemplateHistoryConnection struct {
	Edges      []*TemplateHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TemplateHistoryConnection) build(nodes []*TemplateHistory, pager *templatehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TemplateHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TemplateHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TemplateHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplateHistoryPaginateOption enables pagination customization.
type TemplateHistoryPaginateOption func(*templatehistoryPager) error

// WithTemplateHistoryOrder configures pagination ordering.
func WithTemplateHistoryOrder(order *TemplateHistoryOrder) TemplateHistoryPaginateOption {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	o := *order
	return func(pager *templatehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTemplateHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTemplateHistoryFilter configures pagination filter.
func WithTemplateHistoryFilter(filter func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)) TemplateHistoryPaginateOption {
	return func(pager *templatehistoryPager) error {
		if filter == nil {
			return errors.New("TemplateHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatehistoryPager struct {
	reverse bool
	order   *TemplateHistoryOrder
	filter  func(*TemplateHistoryQuery) (*TemplateHistoryQuery, error)
}

func newTemplateHistoryPager(opts []TemplateHistoryPaginateOption, reverse bool) (*templatehistoryPager, error) {
	pager := &templatehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTemplateHistoryOrder
	}
	return pager, nil
}

func (p *templatehistoryPager) applyFilter(query *TemplateHistoryQuery) (*TemplateHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatehistoryPager) toCursor(th *TemplateHistory) Cursor {
	return p.order.Field.toCursor(th)
}

func (p *templatehistoryPager) applyCursors(query *TemplateHistoryQuery, after, before *Cursor) (*TemplateHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTemplateHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *templatehistoryPager) applyOrder(query *TemplateHistoryQuery) *TemplateHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTemplateHistoryOrder.Field {
		query = query.Order(DefaultTemplateHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *templatehistoryPager) orderExpr(query *TemplateHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTemplateHistoryOrder.Field {
			b.Comma().Ident(DefaultTemplateHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TemplateHistory.
func (th *TemplateHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplateHistoryPaginateOption,
) (*TemplateHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplateHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if th, err = pager.applyFilter(th); err != nil {
		return nil, err
	}
	conn := &TemplateHistoryConnection{Edges: []*TemplateHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := th.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if th, err = pager.applyCursors(th, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		th.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := th.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	th = pager.applyOrder(th)
	nodes, err := th.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateHistoryOrderFieldName orders TemplateHistory by name.
	TemplateHistoryOrderFieldName = &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.Name, nil
		},
		column: templatehistory.FieldName,
		toTerm: templatehistory.ByName,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{
				ID:    th.ID,
				Value: th.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateHistoryOrderField) String() string {
	var str string
	switch f.column {
	case TemplateHistoryOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *TemplateHistoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

// TemplateHistoryOrderField defines the ordering field of TemplateHistory.
type TemplateHistoryOrderField struct {
	// Value extracts the ordering value from the given TemplateHistory.
	Value    func(*TemplateHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) templatehistory.OrderOption
	toCursor func(*TemplateHistory) Cursor
}

// TemplateHistoryOrder defines the ordering of TemplateHistory.
type TemplateHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TemplateHistoryOrderField `json:"field"`
}

// DefaultTemplateHistoryOrder is the default ordering of TemplateHistory.
var DefaultTemplateHistoryOrder = &TemplateHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateHistoryOrderField{
		Value: func(th *TemplateHistory) (ent.Value, error) {
			return th.ID, nil
		},
		column: templatehistory.FieldID,
		toTerm: templatehistory.ByID,
		toCursor: func(th *TemplateHistory) Cursor {
			return Cursor{ID: th.ID}
		},
	},
}

// ToEdge converts TemplateHistory into TemplateHistoryEdge.
func (th *TemplateHistory) ToEdge(order *TemplateHistoryOrder) *TemplateHistoryEdge {
	if order == nil {
		order = DefaultTemplateHistoryOrder
	}
	return &TemplateHistoryEdge{
		Node:   th,
		Cursor: order.Field.toCursor(th),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldFirstName orders User by first_name.
	UserOrderFieldFirstName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.FirstName, nil
		},
		column: user.FieldFirstName,
		toTerm: user.ByFirstName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.FirstName,
			}
		},
	}
	// UserOrderFieldLastName orders User by last_name.
	UserOrderFieldLastName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.LastName, nil
		},
		column: user.FieldLastName,
		toTerm: user.ByLastName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.LastName,
			}
		},
	}
	// UserOrderFieldDisplayName orders User by display_name.
	UserOrderFieldDisplayName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.DisplayName, nil
		},
		column: user.FieldDisplayName,
		toTerm: user.ByDisplayName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldFirstName.column:
		str = "first_name"
	case UserOrderFieldLastName.column:
		str = "last_name"
	case UserOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "first_name":
		*f = *UserOrderFieldFirstName
	case "last_name":
		*f = *UserOrderFieldLastName
	case "display_name":
		*f = *UserOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserHistoryEdge is the edge representation of UserHistory.
type UserHistoryEdge struct {
	Node   *UserHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserHistoryConnection is the connection containing edges to UserHistory.
type UserHistoryConnection struct {
	Edges      []*UserHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserHistoryConnection) build(nodes []*UserHistory, pager *userhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserHistoryPaginateOption enables pagination customization.
type UserHistoryPaginateOption func(*userhistoryPager) error

// WithUserHistoryOrder configures pagination ordering.
func WithUserHistoryOrder(order *UserHistoryOrder) UserHistoryPaginateOption {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	o := *order
	return func(pager *userhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserHistoryFilter configures pagination filter.
func WithUserHistoryFilter(filter func(*UserHistoryQuery) (*UserHistoryQuery, error)) UserHistoryPaginateOption {
	return func(pager *userhistoryPager) error {
		if filter == nil {
			return errors.New("UserHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userhistoryPager struct {
	reverse bool
	order   *UserHistoryOrder
	filter  func(*UserHistoryQuery) (*UserHistoryQuery, error)
}

func newUserHistoryPager(opts []UserHistoryPaginateOption, reverse bool) (*userhistoryPager, error) {
	pager := &userhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserHistoryOrder
	}
	return pager, nil
}

func (p *userhistoryPager) applyFilter(query *UserHistoryQuery) (*UserHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userhistoryPager) toCursor(uh *UserHistory) Cursor {
	return p.order.Field.toCursor(uh)
}

func (p *userhistoryPager) applyCursors(query *UserHistoryQuery, after, before *Cursor) (*UserHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userhistoryPager) applyOrder(query *UserHistoryQuery) *UserHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserHistoryOrder.Field {
		query = query.Order(DefaultUserHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userhistoryPager) orderExpr(query *UserHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserHistoryOrder.Field {
			b.Comma().Ident(DefaultUserHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserHistory.
func (uh *UserHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserHistoryPaginateOption,
) (*UserHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if uh, err = pager.applyFilter(uh); err != nil {
		return nil, err
	}
	conn := &UserHistoryConnection{Edges: []*UserHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := uh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if uh, err = pager.applyCursors(uh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		uh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := uh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	uh = pager.applyOrder(uh)
	nodes, err := uh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserHistoryOrderFieldFirstName orders UserHistory by first_name.
	UserHistoryOrderFieldFirstName = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.FirstName, nil
		},
		column: userhistory.FieldFirstName,
		toTerm: userhistory.ByFirstName,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.FirstName,
			}
		},
	}
	// UserHistoryOrderFieldLastName orders UserHistory by last_name.
	UserHistoryOrderFieldLastName = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.LastName, nil
		},
		column: userhistory.FieldLastName,
		toTerm: userhistory.ByLastName,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.LastName,
			}
		},
	}
	// UserHistoryOrderFieldDisplayName orders UserHistory by display_name.
	UserHistoryOrderFieldDisplayName = &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.DisplayName, nil
		},
		column: userhistory.FieldDisplayName,
		toTerm: userhistory.ByDisplayName,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{
				ID:    uh.ID,
				Value: uh.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserHistoryOrderField) String() string {
	var str string
	switch f.column {
	case UserHistoryOrderFieldFirstName.column:
		str = "first_name"
	case UserHistoryOrderFieldLastName.column:
		str = "last_name"
	case UserHistoryOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "first_name":
		*f = *UserHistoryOrderFieldFirstName
	case "last_name":
		*f = *UserHistoryOrderFieldLastName
	case "display_name":
		*f = *UserHistoryOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

// UserHistoryOrderField defines the ordering field of UserHistory.
type UserHistoryOrderField struct {
	// Value extracts the ordering value from the given UserHistory.
	Value    func(*UserHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userhistory.OrderOption
	toCursor func(*UserHistory) Cursor
}

// UserHistoryOrder defines the ordering of UserHistory.
type UserHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserHistoryOrderField `json:"field"`
}

// DefaultUserHistoryOrder is the default ordering of UserHistory.
var DefaultUserHistoryOrder = &UserHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserHistoryOrderField{
		Value: func(uh *UserHistory) (ent.Value, error) {
			return uh.ID, nil
		},
		column: userhistory.FieldID,
		toTerm: userhistory.ByID,
		toCursor: func(uh *UserHistory) Cursor {
			return Cursor{ID: uh.ID}
		},
	},
}

// ToEdge converts UserHistory into UserHistoryEdge.
func (uh *UserHistory) ToEdge(order *UserHistoryOrder) *UserHistoryEdge {
	if order == nil {
		order = DefaultUserHistoryOrder
	}
	return &UserHistoryEdge{
		Node:   uh,
		Cursor: order.Field.toCursor(uh),
	}
}

// UserSettingEdge is the edge representation of UserSetting.
type UserSettingEdge struct {
	Node   *UserSetting `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserSettingConnection is the connection containing edges to UserSetting.
type UserSettingConnection struct {
	Edges      []*UserSettingEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserSettingConnection) build(nodes []*UserSetting, pager *usersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingPaginateOption enables pagination customization.
type UserSettingPaginateOption func(*usersettingPager) error

// WithUserSettingOrder configures pagination ordering.
func WithUserSettingOrder(order *UserSettingOrder) UserSettingPaginateOption {
	if order == nil {
		order = DefaultUserSettingOrder
	}
	o := *order
	return func(pager *usersettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSettingFilter configures pagination filter.
func WithUserSettingFilter(filter func(*UserSettingQuery) (*UserSettingQuery, error)) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		if filter == nil {
			return errors.New("UserSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettingPager struct {
	reverse bool
	order   *UserSettingOrder
	filter  func(*UserSettingQuery) (*UserSettingQuery, error)
}

func newUserSettingPager(opts []UserSettingPaginateOption, reverse bool) (*usersettingPager, error) {
	pager := &usersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSettingOrder
	}
	return pager, nil
}

func (p *usersettingPager) applyFilter(query *UserSettingQuery) (*UserSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettingPager) toCursor(us *UserSetting) Cursor {
	return p.order.Field.toCursor(us)
}

func (p *usersettingPager) applyCursors(query *UserSettingQuery, after, before *Cursor) (*UserSettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersettingPager) applyOrder(query *UserSettingQuery) *UserSettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSettingOrder.Field {
		query = query.Order(DefaultUserSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersettingPager) orderExpr(query *UserSettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSettingOrder.Field {
			b.Comma().Ident(DefaultUserSettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSetting.
func (us *UserSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingPaginateOption,
) (*UserSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserSettingConnection{Edges: []*UserSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := us.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserSettingOrderField defines the ordering field of UserSetting.
type UserSettingOrderField struct {
	// Value extracts the ordering value from the given UserSetting.
	Value    func(*UserSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersetting.OrderOption
	toCursor func(*UserSetting) Cursor
}

// UserSettingOrder defines the ordering of UserSetting.
type UserSettingOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserSettingOrderField `json:"field"`
}

// DefaultUserSettingOrder is the default ordering of UserSetting.
var DefaultUserSettingOrder = &UserSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingOrderField{
		Value: func(us *UserSetting) (ent.Value, error) {
			return us.ID, nil
		},
		column: usersetting.FieldID,
		toTerm: usersetting.ByID,
		toCursor: func(us *UserSetting) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserSetting into UserSettingEdge.
func (us *UserSetting) ToEdge(order *UserSettingOrder) *UserSettingEdge {
	if order == nil {
		order = DefaultUserSettingOrder
	}
	return &UserSettingEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}

// UserSettingHistoryEdge is the edge representation of UserSettingHistory.
type UserSettingHistoryEdge struct {
	Node   *UserSettingHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// UserSettingHistoryConnection is the connection containing edges to UserSettingHistory.
type UserSettingHistoryConnection struct {
	Edges      []*UserSettingHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *UserSettingHistoryConnection) build(nodes []*UserSettingHistory, pager *usersettinghistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSettingHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSettingHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingHistoryPaginateOption enables pagination customization.
type UserSettingHistoryPaginateOption func(*usersettinghistoryPager) error

// WithUserSettingHistoryOrder configures pagination ordering.
func WithUserSettingHistoryOrder(order *UserSettingHistoryOrder) UserSettingHistoryPaginateOption {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	o := *order
	return func(pager *usersettinghistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSettingHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSettingHistoryFilter configures pagination filter.
func WithUserSettingHistoryFilter(filter func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)) UserSettingHistoryPaginateOption {
	return func(pager *usersettinghistoryPager) error {
		if filter == nil {
			return errors.New("UserSettingHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettinghistoryPager struct {
	reverse bool
	order   *UserSettingHistoryOrder
	filter  func(*UserSettingHistoryQuery) (*UserSettingHistoryQuery, error)
}

func newUserSettingHistoryPager(opts []UserSettingHistoryPaginateOption, reverse bool) (*usersettinghistoryPager, error) {
	pager := &usersettinghistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSettingHistoryOrder
	}
	return pager, nil
}

func (p *usersettinghistoryPager) applyFilter(query *UserSettingHistoryQuery) (*UserSettingHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettinghistoryPager) toCursor(ush *UserSettingHistory) Cursor {
	return p.order.Field.toCursor(ush)
}

func (p *usersettinghistoryPager) applyCursors(query *UserSettingHistoryQuery, after, before *Cursor) (*UserSettingHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSettingHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersettinghistoryPager) applyOrder(query *UserSettingHistoryQuery) *UserSettingHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSettingHistoryOrder.Field {
		query = query.Order(DefaultUserSettingHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersettinghistoryPager) orderExpr(query *UserSettingHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSettingHistoryOrder.Field {
			b.Comma().Ident(DefaultUserSettingHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSettingHistory.
func (ush *UserSettingHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingHistoryPaginateOption,
) (*UserSettingHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ush, err = pager.applyFilter(ush); err != nil {
		return nil, err
	}
	conn := &UserSettingHistoryConnection{Edges: []*UserSettingHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ush.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ush, err = pager.applyCursors(ush, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ush.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ush.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ush = pager.applyOrder(ush)
	nodes, err := ush.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserSettingHistoryOrderField defines the ordering field of UserSettingHistory.
type UserSettingHistoryOrderField struct {
	// Value extracts the ordering value from the given UserSettingHistory.
	Value    func(*UserSettingHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersettinghistory.OrderOption
	toCursor func(*UserSettingHistory) Cursor
}

// UserSettingHistoryOrder defines the ordering of UserSettingHistory.
type UserSettingHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *UserSettingHistoryOrderField `json:"field"`
}

// DefaultUserSettingHistoryOrder is the default ordering of UserSettingHistory.
var DefaultUserSettingHistoryOrder = &UserSettingHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingHistoryOrderField{
		Value: func(ush *UserSettingHistory) (ent.Value, error) {
			return ush.ID, nil
		},
		column: usersettinghistory.FieldID,
		toTerm: usersettinghistory.ByID,
		toCursor: func(ush *UserSettingHistory) Cursor {
			return Cursor{ID: ush.ID}
		},
	},
}

// ToEdge converts UserSettingHistory into UserSettingHistoryEdge.
func (ush *UserSettingHistory) ToEdge(order *UserSettingHistoryOrder) *UserSettingHistoryEdge {
	if order == nil {
		order = DefaultUserSettingHistoryOrder
	}
	return &UserSettingHistoryEdge{
		Node:   ush,
		Cursor: order.Field.toCursor(ush),
	}
}

// WebhookEdge is the edge representation of Webhook.
type WebhookEdge struct {
	Node   *Webhook `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// WebhookConnection is the connection containing edges to Webhook.
type WebhookConnection struct {
	Edges      []*WebhookEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *WebhookConnection) build(nodes []*Webhook, pager *webhookPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Webhook
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Webhook {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Webhook {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebhookEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebhookEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebhookPaginateOption enables pagination customization.
type WebhookPaginateOption func(*webhookPager) error

// WithWebhookOrder configures pagination ordering.
func WithWebhookOrder(order *WebhookOrder) WebhookPaginateOption {
	if order == nil {
		order = DefaultWebhookOrder
	}
	o := *order
	return func(pager *webhookPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebhookOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebhookFilter configures pagination filter.
func WithWebhookFilter(filter func(*WebhookQuery) (*WebhookQuery, error)) WebhookPaginateOption {
	return func(pager *webhookPager) error {
		if filter == nil {
			return errors.New("WebhookQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type webhookPager struct {
	reverse bool
	order   *WebhookOrder
	filter  func(*WebhookQuery) (*WebhookQuery, error)
}

func newWebhookPager(opts []WebhookPaginateOption, reverse bool) (*webhookPager, error) {
	pager := &webhookPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebhookOrder
	}
	return pager, nil
}

func (p *webhookPager) applyFilter(query *WebhookQuery) (*WebhookQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *webhookPager) toCursor(w *Webhook) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *webhookPager) applyCursors(query *WebhookQuery, after, before *Cursor) (*WebhookQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWebhookOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *webhookPager) applyOrder(query *WebhookQuery) *WebhookQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWebhookOrder.Field {
		query = query.Order(DefaultWebhookOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *webhookPager) orderExpr(query *WebhookQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebhookOrder.Field {
			b.Comma().Ident(DefaultWebhookOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Webhook.
func (w *WebhookQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebhookPaginateOption,
) (*WebhookConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebhookPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WebhookConnection{Edges: []*WebhookEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := w.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebhookOrderFieldName orders Webhook by name.
	WebhookOrderFieldName = &WebhookOrderField{
		Value: func(w *Webhook) (ent.Value, error) {
			return w.Name, nil
		},
		column: webhook.FieldName,
		toTerm: webhook.ByName,
		toCursor: func(w *Webhook) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Name,
			}
		},
	}
	// WebhookOrderFieldDestinationURL orders Webhook by destination_url.
	WebhookOrderFieldDestinationURL = &WebhookOrderField{
		Value: func(w *Webhook) (ent.Value, error) {
			return w.DestinationURL, nil
		},
		column: webhook.FieldDestinationURL,
		toTerm: webhook.ByDestinationURL,
		toCursor: func(w *Webhook) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.DestinationURL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebhookOrderField) String() string {
	var str string
	switch f.column {
	case WebhookOrderFieldName.column:
		str = "name"
	case WebhookOrderFieldDestinationURL.column:
		str = "url"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebhookOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebhookOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebhookOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *WebhookOrderFieldName
	case "url":
		*f = *WebhookOrderFieldDestinationURL
	default:
		return fmt.Errorf("%s is not a valid WebhookOrderField", str)
	}
	return nil
}

// WebhookOrderField defines the ordering field of Webhook.
type WebhookOrderField struct {
	// Value extracts the ordering value from the given Webhook.
	Value    func(*Webhook) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) webhook.OrderOption
	toCursor func(*Webhook) Cursor
}

// WebhookOrder defines the ordering of Webhook.
type WebhookOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *WebhookOrderField `json:"field"`
}

// DefaultWebhookOrder is the default ordering of Webhook.
var DefaultWebhookOrder = &WebhookOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WebhookOrderField{
		Value: func(w *Webhook) (ent.Value, error) {
			return w.ID, nil
		},
		column: webhook.FieldID,
		toTerm: webhook.ByID,
		toCursor: func(w *Webhook) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Webhook into WebhookEdge.
func (w *Webhook) ToEdge(order *WebhookOrder) *WebhookEdge {
	if order == nil {
		order = DefaultWebhookOrder
	}
	return &WebhookEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WebhookHistoryEdge is the edge representation of WebhookHistory.
type WebhookHistoryEdge struct {
	Node   *WebhookHistory `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// WebhookHistoryConnection is the connection containing edges to WebhookHistory.
type WebhookHistoryConnection struct {
	Edges      []*WebhookHistoryEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *WebhookHistoryConnection) build(nodes []*WebhookHistory, pager *webhookhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WebhookHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WebhookHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WebhookHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebhookHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebhookHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebhookHistoryPaginateOption enables pagination customization.
type WebhookHistoryPaginateOption func(*webhookhistoryPager) error

// WithWebhookHistoryOrder configures pagination ordering.
func WithWebhookHistoryOrder(order *WebhookHistoryOrder) WebhookHistoryPaginateOption {
	if order == nil {
		order = DefaultWebhookHistoryOrder
	}
	o := *order
	return func(pager *webhookhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebhookHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebhookHistoryFilter configures pagination filter.
func WithWebhookHistoryFilter(filter func(*WebhookHistoryQuery) (*WebhookHistoryQuery, error)) WebhookHistoryPaginateOption {
	return func(pager *webhookhistoryPager) error {
		if filter == nil {
			return errors.New("WebhookHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type webhookhistoryPager struct {
	reverse bool
	order   *WebhookHistoryOrder
	filter  func(*WebhookHistoryQuery) (*WebhookHistoryQuery, error)
}

func newWebhookHistoryPager(opts []WebhookHistoryPaginateOption, reverse bool) (*webhookhistoryPager, error) {
	pager := &webhookhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebhookHistoryOrder
	}
	return pager, nil
}

func (p *webhookhistoryPager) applyFilter(query *WebhookHistoryQuery) (*WebhookHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *webhookhistoryPager) toCursor(wh *WebhookHistory) Cursor {
	return p.order.Field.toCursor(wh)
}

func (p *webhookhistoryPager) applyCursors(query *WebhookHistoryQuery, after, before *Cursor) (*WebhookHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWebhookHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *webhookhistoryPager) applyOrder(query *WebhookHistoryQuery) *WebhookHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWebhookHistoryOrder.Field {
		query = query.Order(DefaultWebhookHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *webhookhistoryPager) orderExpr(query *WebhookHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebhookHistoryOrder.Field {
			b.Comma().Ident(DefaultWebhookHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WebhookHistory.
func (wh *WebhookHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebhookHistoryPaginateOption,
) (*WebhookHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebhookHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wh, err = pager.applyFilter(wh); err != nil {
		return nil, err
	}
	conn := &WebhookHistoryConnection{Edges: []*WebhookHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := wh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wh, err = pager.applyCursors(wh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		wh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wh = pager.applyOrder(wh)
	nodes, err := wh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebhookHistoryOrderFieldName orders WebhookHistory by name.
	WebhookHistoryOrderFieldName = &WebhookHistoryOrderField{
		Value: func(wh *WebhookHistory) (ent.Value, error) {
			return wh.Name, nil
		},
		column: webhookhistory.FieldName,
		toTerm: webhookhistory.ByName,
		toCursor: func(wh *WebhookHistory) Cursor {
			return Cursor{
				ID:    wh.ID,
				Value: wh.Name,
			}
		},
	}
	// WebhookHistoryOrderFieldDestinationURL orders WebhookHistory by destination_url.
	WebhookHistoryOrderFieldDestinationURL = &WebhookHistoryOrderField{
		Value: func(wh *WebhookHistory) (ent.Value, error) {
			return wh.DestinationURL, nil
		},
		column: webhookhistory.FieldDestinationURL,
		toTerm: webhookhistory.ByDestinationURL,
		toCursor: func(wh *WebhookHistory) Cursor {
			return Cursor{
				ID:    wh.ID,
				Value: wh.DestinationURL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebhookHistoryOrderField) String() string {
	var str string
	switch f.column {
	case WebhookHistoryOrderFieldName.column:
		str = "name"
	case WebhookHistoryOrderFieldDestinationURL.column:
		str = "url"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebhookHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebhookHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebhookHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *WebhookHistoryOrderFieldName
	case "url":
		*f = *WebhookHistoryOrderFieldDestinationURL
	default:
		return fmt.Errorf("%s is not a valid WebhookHistoryOrderField", str)
	}
	return nil
}

// WebhookHistoryOrderField defines the ordering field of WebhookHistory.
type WebhookHistoryOrderField struct {
	// Value extracts the ordering value from the given WebhookHistory.
	Value    func(*WebhookHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) webhookhistory.OrderOption
	toCursor func(*WebhookHistory) Cursor
}

// WebhookHistoryOrder defines the ordering of WebhookHistory.
type WebhookHistoryOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *WebhookHistoryOrderField `json:"field"`
}

// DefaultWebhookHistoryOrder is the default ordering of WebhookHistory.
var DefaultWebhookHistoryOrder = &WebhookHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WebhookHistoryOrderField{
		Value: func(wh *WebhookHistory) (ent.Value, error) {
			return wh.ID, nil
		},
		column: webhookhistory.FieldID,
		toTerm: webhookhistory.ByID,
		toCursor: func(wh *WebhookHistory) Cursor {
			return Cursor{ID: wh.ID}
		},
	},
}

// ToEdge converts WebhookHistory into WebhookHistoryEdge.
func (wh *WebhookHistory) ToEdge(order *WebhookHistoryOrder) *WebhookHistoryEdge {
	if order == nil {
		order = DefaultWebhookHistoryOrder
	}
	return &WebhookHistoryEdge{
		Node:   wh,
		Cursor: order.Field.toCursor(wh),
	}
}
