// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/assessment"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponse"
	"github.com/theopenlane/core/internal/ent/generated/asset"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementation"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/customdomain"
	"github.com/theopenlane/core/internal/ent/generated/customtypeenum"
	"github.com/theopenlane/core/internal/ent/generated/directoryaccount"
	"github.com/theopenlane/core/internal/ent/generated/directorygroup"
	"github.com/theopenlane/core/internal/ent/generated/directorymembership"
	"github.com/theopenlane/core/internal/ent/generated/directorysyncrun"
	"github.com/theopenlane/core/internal/ent/generated/discussion"
	"github.com/theopenlane/core/internal/ent/generated/dnsverification"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/evidence"
	"github.com/theopenlane/core/internal/ent/generated/export"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/finding"
	"github.com/theopenlane/core/internal/ent/generated/findingcontrol"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/jobresult"
	"github.com/theopenlane/core/internal/ent/generated/jobrunner"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnerregistrationtoken"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnertoken"
	"github.com/theopenlane/core/internal/ent/generated/jobtemplate"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomain"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrol"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notification"
	"github.com/theopenlane/core/internal/ent/generated/onboarding"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscription"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/remediation"
	"github.com/theopenlane/core/internal/ent/generated/review"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/scan"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobrun"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subprocessor"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/tagdefinition"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcenter"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliance"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdoc"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterentity"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessor"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfig"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/vulnerability"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignment"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignmenttarget"
	"github.com/theopenlane/core/internal/ent/generated/workflowdefinition"
	"github.com/theopenlane/core/internal/ent/generated/workflowevent"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstance"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectref"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// paginateLimit calculates the limit for pagination based on the first and last arguments.
// and returns the limit multiplied by 10.
// This is to ensure we overfetch the data to get the number of requested results.
func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first * 10
	} else if last != nil {
		limit = *last * 10
	}
	return limit
}

// APITokenEdge is the edge representation of APIToken.
type APITokenEdge struct {
	Node   *APIToken `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// APITokenConnection is the connection containing edges to APIToken.
type APITokenConnection struct {
	Edges      []*APITokenEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *APITokenConnection) build(nodes []*APIToken, pager *apitokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *APIToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *APIToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *APIToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*APITokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &APITokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// APITokenPaginateOption enables pagination customization.
type APITokenPaginateOption func(*apitokenPager) error

// WithAPITokenOrder configures pagination ordering.
func WithAPITokenOrder(order []*APITokenOrder) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAPITokenFilter configures pagination filter.
func WithAPITokenFilter(filter func(*APITokenQuery) (*APITokenQuery, error)) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		if filter == nil {
			return errors.New("APITokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apitokenPager struct {
	reverse bool
	order   []*APITokenOrder
	filter  func(*APITokenQuery) (*APITokenQuery, error)
}

func newAPITokenPager(opts []APITokenPaginateOption, reverse bool) (*apitokenPager, error) {
	pager := &apitokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *apitokenPager) applyFilter(query *APITokenQuery) (*APITokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apitokenPager) toCursor(_m *APIToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *apitokenPager) applyCursors(query *APITokenQuery, after, before *Cursor) (*APITokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAPITokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *apitokenPager) applyOrder(query *APITokenQuery) *APITokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAPITokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAPITokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *apitokenPager) orderExpr(query *APITokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAPITokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to APIToken.
func (_m *APITokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...APITokenPaginateOption,
) (*APITokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAPITokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &APITokenConnection{Edges: []*APITokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// APITokenOrderFieldCreatedAt orders APIToken by created_at.
	APITokenOrderFieldCreatedAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: apitoken.FieldCreatedAt,
		toTerm: apitoken.ByCreatedAt,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// APITokenOrderFieldUpdatedAt orders APIToken by updated_at.
	APITokenOrderFieldUpdatedAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: apitoken.FieldUpdatedAt,
		toTerm: apitoken.ByUpdatedAt,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// APITokenOrderFieldName orders APIToken by name.
	APITokenOrderFieldName = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.Name, nil
		},
		column: apitoken.FieldName,
		toTerm: apitoken.ByName,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// APITokenOrderFieldExpiresAt orders APIToken by expires_at.
	APITokenOrderFieldExpiresAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: apitoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) apitoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return apitoken.ByExpiresAt(opts...)
		},
		toCursor: func(_m *APIToken) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// APITokenOrderFieldLastUsedAt orders APIToken by last_used_at.
	APITokenOrderFieldLastUsedAt = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: apitoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) apitoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return apitoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *APIToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// APITokenOrderFieldIsActive orders APIToken by is_active.
	APITokenOrderFieldIsActive = &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.IsActive, nil
		},
		column: apitoken.FieldIsActive,
		toTerm: apitoken.ByIsActive,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsActive,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f APITokenOrderField) String() string {
	var str string
	switch f.column {
	case APITokenOrderFieldCreatedAt.column:
		str = "created_at"
	case APITokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case APITokenOrderFieldName.column:
		str = "name"
	case APITokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case APITokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case APITokenOrderFieldIsActive.column:
		str = "is_active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f APITokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *APITokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("APITokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *APITokenOrderFieldCreatedAt
	case "updated_at":
		*f = *APITokenOrderFieldUpdatedAt
	case "name":
		*f = *APITokenOrderFieldName
	case "expires_at":
		*f = *APITokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *APITokenOrderFieldLastUsedAt
	case "is_active":
		*f = *APITokenOrderFieldIsActive
	default:
		return fmt.Errorf("%s is not a valid APITokenOrderField", str)
	}
	return nil
}

// APITokenOrderField defines the ordering field of APIToken.
type APITokenOrderField struct {
	// Value extracts the ordering value from the given APIToken.
	Value    func(*APIToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apitoken.OrderOption
	toCursor func(*APIToken) Cursor
}

// APITokenOrder defines the ordering of APIToken.
type APITokenOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *APITokenOrderField `json:"field"`
}

// DefaultAPITokenOrder is the default ordering of APIToken.
var DefaultAPITokenOrder = &APITokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &APITokenOrderField{
		Value: func(_m *APIToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: apitoken.FieldID,
		toTerm: apitoken.ByID,
		toCursor: func(_m *APIToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts APIToken into APITokenEdge.
func (_m *APIToken) ToEdge(order *APITokenOrder) *APITokenEdge {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	return &APITokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ActionPlanEdge is the edge representation of ActionPlan.
type ActionPlanEdge struct {
	Node   *ActionPlan `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ActionPlanConnection is the connection containing edges to ActionPlan.
type ActionPlanConnection struct {
	Edges      []*ActionPlanEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ActionPlanConnection) build(nodes []*ActionPlan, pager *actionplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ActionPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ActionPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ActionPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ActionPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ActionPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ActionPlanPaginateOption enables pagination customization.
type ActionPlanPaginateOption func(*actionplanPager) error

// WithActionPlanOrder configures pagination ordering.
func WithActionPlanOrder(order []*ActionPlanOrder) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithActionPlanFilter configures pagination filter.
func WithActionPlanFilter(filter func(*ActionPlanQuery) (*ActionPlanQuery, error)) ActionPlanPaginateOption {
	return func(pager *actionplanPager) error {
		if filter == nil {
			return errors.New("ActionPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type actionplanPager struct {
	reverse bool
	order   []*ActionPlanOrder
	filter  func(*ActionPlanQuery) (*ActionPlanQuery, error)
}

func newActionPlanPager(opts []ActionPlanPaginateOption, reverse bool) (*actionplanPager, error) {
	pager := &actionplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *actionplanPager) applyFilter(query *ActionPlanQuery) (*ActionPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *actionplanPager) toCursor(_m *ActionPlan) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *actionplanPager) applyCursors(query *ActionPlanQuery, after, before *Cursor) (*ActionPlanQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultActionPlanOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *actionplanPager) applyOrder(query *ActionPlanQuery) *ActionPlanQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultActionPlanOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultActionPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *actionplanPager) orderExpr(query *ActionPlanQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultActionPlanOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ActionPlan.
func (_m *ActionPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActionPlanPaginateOption,
) (*ActionPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActionPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ActionPlanConnection{Edges: []*ActionPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ActionPlanOrderFieldCreatedAt orders ActionPlan by created_at.
	ActionPlanOrderFieldCreatedAt = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: actionplan.FieldCreatedAt,
		toTerm: actionplan.ByCreatedAt,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ActionPlanOrderFieldUpdatedAt orders ActionPlan by updated_at.
	ActionPlanOrderFieldUpdatedAt = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: actionplan.FieldUpdatedAt,
		toTerm: actionplan.ByUpdatedAt,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ActionPlanOrderFieldRevision orders ActionPlan by revision.
	ActionPlanOrderFieldRevision = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: actionplan.FieldRevision,
		toTerm: actionplan.ByRevision,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ActionPlanOrderFieldName orders ActionPlan by name.
	ActionPlanOrderFieldName = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Name, nil
		},
		column: actionplan.FieldName,
		toTerm: actionplan.ByName,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ActionPlanOrderFieldStatus orders ActionPlan by status.
	ActionPlanOrderFieldStatus = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Status, nil
		},
		column: actionplan.FieldStatus,
		toTerm: actionplan.ByStatus,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ActionPlanOrderFieldReviewDue orders ActionPlan by review_due.
	ActionPlanOrderFieldReviewDue = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: actionplan.FieldReviewDue,
		toTerm: actionplan.ByReviewDue,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ActionPlanOrderFieldReviewFrequency orders ActionPlan by review_frequency.
	ActionPlanOrderFieldReviewFrequency = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: actionplan.FieldReviewFrequency,
		toTerm: actionplan.ByReviewFrequency,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
	// ActionPlanOrderFieldTitle orders ActionPlan by title.
	ActionPlanOrderFieldTitle = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Title, nil
		},
		column: actionplan.FieldTitle,
		toTerm: actionplan.ByTitle,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ActionPlanOrderFieldDueDate orders ActionPlan by due_date.
	ActionPlanOrderFieldDueDate = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: actionplan.FieldDueDate,
		toTerm: actionplan.ByDueDate,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
	// ActionPlanOrderFieldPriority orders ActionPlan by priority.
	ActionPlanOrderFieldPriority = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Priority, nil
		},
		column: actionplan.FieldPriority,
		toTerm: actionplan.ByPriority,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Priority,
			}
		},
	}
	// ActionPlanOrderFieldSource orders ActionPlan by source.
	ActionPlanOrderFieldSource = &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.Source, nil
		},
		column: actionplan.FieldSource,
		toTerm: actionplan.BySource,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActionPlanOrderField) String() string {
	var str string
	switch f.column {
	case ActionPlanOrderFieldCreatedAt.column:
		str = "created_at"
	case ActionPlanOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ActionPlanOrderFieldRevision.column:
		str = "revision"
	case ActionPlanOrderFieldName.column:
		str = "name"
	case ActionPlanOrderFieldStatus.column:
		str = "STATUS"
	case ActionPlanOrderFieldReviewDue.column:
		str = "review_due"
	case ActionPlanOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	case ActionPlanOrderFieldTitle.column:
		str = "title"
	case ActionPlanOrderFieldDueDate.column:
		str = "due_date"
	case ActionPlanOrderFieldPriority.column:
		str = "PRIORITY"
	case ActionPlanOrderFieldSource.column:
		str = "source"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActionPlanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActionPlanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActionPlanOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ActionPlanOrderFieldCreatedAt
	case "updated_at":
		*f = *ActionPlanOrderFieldUpdatedAt
	case "revision":
		*f = *ActionPlanOrderFieldRevision
	case "name":
		*f = *ActionPlanOrderFieldName
	case "STATUS":
		*f = *ActionPlanOrderFieldStatus
	case "review_due":
		*f = *ActionPlanOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ActionPlanOrderFieldReviewFrequency
	case "title":
		*f = *ActionPlanOrderFieldTitle
	case "due_date":
		*f = *ActionPlanOrderFieldDueDate
	case "PRIORITY":
		*f = *ActionPlanOrderFieldPriority
	case "source":
		*f = *ActionPlanOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid ActionPlanOrderField", str)
	}
	return nil
}

// ActionPlanOrderField defines the ordering field of ActionPlan.
type ActionPlanOrderField struct {
	// Value extracts the ordering value from the given ActionPlan.
	Value    func(*ActionPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) actionplan.OrderOption
	toCursor func(*ActionPlan) Cursor
}

// ActionPlanOrder defines the ordering of ActionPlan.
type ActionPlanOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ActionPlanOrderField `json:"field"`
}

// DefaultActionPlanOrder is the default ordering of ActionPlan.
var DefaultActionPlanOrder = &ActionPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ActionPlanOrderField{
		Value: func(_m *ActionPlan) (ent.Value, error) {
			return _m.ID, nil
		},
		column: actionplan.FieldID,
		toTerm: actionplan.ByID,
		toCursor: func(_m *ActionPlan) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ActionPlan into ActionPlanEdge.
func (_m *ActionPlan) ToEdge(order *ActionPlanOrder) *ActionPlanEdge {
	if order == nil {
		order = DefaultActionPlanOrder
	}
	return &ActionPlanEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentEdge is the edge representation of Assessment.
type AssessmentEdge struct {
	Node   *Assessment `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AssessmentConnection is the connection containing edges to Assessment.
type AssessmentConnection struct {
	Edges      []*AssessmentEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AssessmentConnection) build(nodes []*Assessment, pager *assessmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Assessment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Assessment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Assessment {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentPaginateOption enables pagination customization.
type AssessmentPaginateOption func(*assessmentPager) error

// WithAssessmentOrder configures pagination ordering.
func WithAssessmentOrder(order []*AssessmentOrder) AssessmentPaginateOption {
	return func(pager *assessmentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssessmentFilter configures pagination filter.
func WithAssessmentFilter(filter func(*AssessmentQuery) (*AssessmentQuery, error)) AssessmentPaginateOption {
	return func(pager *assessmentPager) error {
		if filter == nil {
			return errors.New("AssessmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentPager struct {
	reverse bool
	order   []*AssessmentOrder
	filter  func(*AssessmentQuery) (*AssessmentQuery, error)
}

func newAssessmentPager(opts []AssessmentPaginateOption, reverse bool) (*assessmentPager, error) {
	pager := &assessmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assessmentPager) applyFilter(query *AssessmentQuery) (*AssessmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentPager) toCursor(_m *Assessment) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *assessmentPager) applyCursors(query *AssessmentQuery, after, before *Cursor) (*AssessmentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssessmentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assessmentPager) applyOrder(query *AssessmentQuery) *AssessmentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssessmentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssessmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assessmentPager) orderExpr(query *AssessmentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssessmentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Assessment.
func (_m *AssessmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentPaginateOption,
) (*AssessmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentConnection{Edges: []*AssessmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentOrderFieldCreatedAt orders Assessment by created_at.
	AssessmentOrderFieldCreatedAt = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessment.FieldCreatedAt,
		toTerm: assessment.ByCreatedAt,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentOrderFieldUpdatedAt orders Assessment by updated_at.
	AssessmentOrderFieldUpdatedAt = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessment.FieldUpdatedAt,
		toTerm: assessment.ByUpdatedAt,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentOrderFieldName orders Assessment by name.
	AssessmentOrderFieldName = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.Name, nil
		},
		column: assessment.FieldName,
		toTerm: assessment.ByName,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// AssessmentOrderFieldAssessmentType orders Assessment by assessment_type.
	AssessmentOrderFieldAssessmentType = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.AssessmentType, nil
		},
		column: assessment.FieldAssessmentType,
		toTerm: assessment.ByAssessmentType,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssessmentType,
			}
		},
	}
	// AssessmentOrderFieldResponseDueDuration orders Assessment by response_due_duration.
	AssessmentOrderFieldResponseDueDuration = &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.ResponseDueDuration, nil
		},
		column: assessment.FieldResponseDueDuration,
		toTerm: assessment.ByResponseDueDuration,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ResponseDueDuration,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentOrderFieldName.column:
		str = "name"
	case AssessmentOrderFieldAssessmentType.column:
		str = "assessment_type"
	case AssessmentOrderFieldResponseDueDuration.column:
		str = "response_due_duration"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssessmentOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentOrderFieldUpdatedAt
	case "name":
		*f = *AssessmentOrderFieldName
	case "assessment_type":
		*f = *AssessmentOrderFieldAssessmentType
	case "response_due_duration":
		*f = *AssessmentOrderFieldResponseDueDuration
	default:
		return fmt.Errorf("%s is not a valid AssessmentOrderField", str)
	}
	return nil
}

// AssessmentOrderField defines the ordering field of Assessment.
type AssessmentOrderField struct {
	// Value extracts the ordering value from the given Assessment.
	Value    func(*Assessment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessment.OrderOption
	toCursor func(*Assessment) Cursor
}

// AssessmentOrder defines the ordering of Assessment.
type AssessmentOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AssessmentOrderField `json:"field"`
}

// DefaultAssessmentOrder is the default ordering of Assessment.
var DefaultAssessmentOrder = &AssessmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentOrderField{
		Value: func(_m *Assessment) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessment.FieldID,
		toTerm: assessment.ByID,
		toCursor: func(_m *Assessment) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Assessment into AssessmentEdge.
func (_m *Assessment) ToEdge(order *AssessmentOrder) *AssessmentEdge {
	if order == nil {
		order = DefaultAssessmentOrder
	}
	return &AssessmentEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssessmentResponseEdge is the edge representation of AssessmentResponse.
type AssessmentResponseEdge struct {
	Node   *AssessmentResponse `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// AssessmentResponseConnection is the connection containing edges to AssessmentResponse.
type AssessmentResponseConnection struct {
	Edges      []*AssessmentResponseEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *AssessmentResponseConnection) build(nodes []*AssessmentResponse, pager *assessmentresponsePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *AssessmentResponse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssessmentResponse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssessmentResponse {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssessmentResponseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssessmentResponseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssessmentResponsePaginateOption enables pagination customization.
type AssessmentResponsePaginateOption func(*assessmentresponsePager) error

// WithAssessmentResponseOrder configures pagination ordering.
func WithAssessmentResponseOrder(order []*AssessmentResponseOrder) AssessmentResponsePaginateOption {
	return func(pager *assessmentresponsePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssessmentResponseFilter configures pagination filter.
func WithAssessmentResponseFilter(filter func(*AssessmentResponseQuery) (*AssessmentResponseQuery, error)) AssessmentResponsePaginateOption {
	return func(pager *assessmentresponsePager) error {
		if filter == nil {
			return errors.New("AssessmentResponseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assessmentresponsePager struct {
	reverse bool
	order   []*AssessmentResponseOrder
	filter  func(*AssessmentResponseQuery) (*AssessmentResponseQuery, error)
}

func newAssessmentResponsePager(opts []AssessmentResponsePaginateOption, reverse bool) (*assessmentresponsePager, error) {
	pager := &assessmentresponsePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assessmentresponsePager) applyFilter(query *AssessmentResponseQuery) (*AssessmentResponseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assessmentresponsePager) toCursor(_m *AssessmentResponse) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *assessmentresponsePager) applyCursors(query *AssessmentResponseQuery, after, before *Cursor) (*AssessmentResponseQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssessmentResponseOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assessmentresponsePager) applyOrder(query *AssessmentResponseQuery) *AssessmentResponseQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssessmentResponseOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssessmentResponseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assessmentresponsePager) orderExpr(query *AssessmentResponseQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssessmentResponseOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssessmentResponse.
func (_m *AssessmentResponseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssessmentResponsePaginateOption,
) (*AssessmentResponseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssessmentResponsePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssessmentResponseConnection{Edges: []*AssessmentResponseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssessmentResponseOrderFieldCreatedAt orders AssessmentResponse by created_at.
	AssessmentResponseOrderFieldCreatedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: assessmentresponse.FieldCreatedAt,
		toTerm: assessmentresponse.ByCreatedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldUpdatedAt orders AssessmentResponse by updated_at.
	AssessmentResponseOrderFieldUpdatedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: assessmentresponse.FieldUpdatedAt,
		toTerm: assessmentresponse.ByUpdatedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldEmail orders AssessmentResponse by email.
	AssessmentResponseOrderFieldEmail = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.Email, nil
		},
		column: assessmentresponse.FieldEmail,
		toTerm: assessmentresponse.ByEmail,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// AssessmentResponseOrderFieldSendAttempts orders AssessmentResponse by send_attempts.
	AssessmentResponseOrderFieldSendAttempts = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: assessmentresponse.FieldSendAttempts,
		toTerm: assessmentresponse.BySendAttempts,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
	// AssessmentResponseOrderFieldStatus orders AssessmentResponse by status.
	AssessmentResponseOrderFieldStatus = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.Status, nil
		},
		column: assessmentresponse.FieldStatus,
		toTerm: assessmentresponse.ByStatus,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// AssessmentResponseOrderFieldAssignedAt orders AssessmentResponse by assigned_at.
	AssessmentResponseOrderFieldAssignedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.AssignedAt, nil
		},
		column: assessmentresponse.FieldAssignedAt,
		toTerm: assessmentresponse.ByAssignedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssignedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldStartedAt orders AssessmentResponse by started_at.
	AssessmentResponseOrderFieldStartedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: assessmentresponse.FieldStartedAt,
		toTerm: assessmentresponse.ByStartedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldCompletedAt orders AssessmentResponse by completed_at.
	AssessmentResponseOrderFieldCompletedAt = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.CompletedAt, nil
		},
		column: assessmentresponse.FieldCompletedAt,
		toTerm: assessmentresponse.ByCompletedAt,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CompletedAt,
			}
		},
	}
	// AssessmentResponseOrderFieldDueDate orders AssessmentResponse by due_date.
	AssessmentResponseOrderFieldDueDate = &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.DueDate, nil
		},
		column: assessmentresponse.FieldDueDate,
		toTerm: assessmentresponse.ByDueDate,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DueDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssessmentResponseOrderField) String() string {
	var str string
	switch f.column {
	case AssessmentResponseOrderFieldCreatedAt.column:
		str = "created_at"
	case AssessmentResponseOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssessmentResponseOrderFieldEmail.column:
		str = "email"
	case AssessmentResponseOrderFieldSendAttempts.column:
		str = "send_attempts"
	case AssessmentResponseOrderFieldStatus.column:
		str = "status"
	case AssessmentResponseOrderFieldAssignedAt.column:
		str = "assigned_at"
	case AssessmentResponseOrderFieldStartedAt.column:
		str = "started_at"
	case AssessmentResponseOrderFieldCompletedAt.column:
		str = "completed_at"
	case AssessmentResponseOrderFieldDueDate.column:
		str = "due_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssessmentResponseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssessmentResponseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssessmentResponseOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssessmentResponseOrderFieldCreatedAt
	case "updated_at":
		*f = *AssessmentResponseOrderFieldUpdatedAt
	case "email":
		*f = *AssessmentResponseOrderFieldEmail
	case "send_attempts":
		*f = *AssessmentResponseOrderFieldSendAttempts
	case "status":
		*f = *AssessmentResponseOrderFieldStatus
	case "assigned_at":
		*f = *AssessmentResponseOrderFieldAssignedAt
	case "started_at":
		*f = *AssessmentResponseOrderFieldStartedAt
	case "completed_at":
		*f = *AssessmentResponseOrderFieldCompletedAt
	case "due_date":
		*f = *AssessmentResponseOrderFieldDueDate
	default:
		return fmt.Errorf("%s is not a valid AssessmentResponseOrderField", str)
	}
	return nil
}

// AssessmentResponseOrderField defines the ordering field of AssessmentResponse.
type AssessmentResponseOrderField struct {
	// Value extracts the ordering value from the given AssessmentResponse.
	Value    func(*AssessmentResponse) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) assessmentresponse.OrderOption
	toCursor func(*AssessmentResponse) Cursor
}

// AssessmentResponseOrder defines the ordering of AssessmentResponse.
type AssessmentResponseOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *AssessmentResponseOrderField `json:"field"`
}

// DefaultAssessmentResponseOrder is the default ordering of AssessmentResponse.
var DefaultAssessmentResponseOrder = &AssessmentResponseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssessmentResponseOrderField{
		Value: func(_m *AssessmentResponse) (ent.Value, error) {
			return _m.ID, nil
		},
		column: assessmentresponse.FieldID,
		toTerm: assessmentresponse.ByID,
		toCursor: func(_m *AssessmentResponse) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts AssessmentResponse into AssessmentResponseEdge.
func (_m *AssessmentResponse) ToEdge(order *AssessmentResponseOrder) *AssessmentResponseEdge {
	if order == nil {
		order = DefaultAssessmentResponseOrder
	}
	return &AssessmentResponseEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// AssetEdge is the edge representation of Asset.
type AssetEdge struct {
	Node   *Asset `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AssetConnection is the connection containing edges to Asset.
type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AssetConnection) build(nodes []*Asset, pager *assetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Asset
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Asset {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Asset {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetPaginateOption enables pagination customization.
type AssetPaginateOption func(*assetPager) error

// WithAssetOrder configures pagination ordering.
func WithAssetOrder(order []*AssetOrder) AssetPaginateOption {
	return func(pager *assetPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAssetFilter configures pagination filter.
func WithAssetFilter(filter func(*AssetQuery) (*AssetQuery, error)) AssetPaginateOption {
	return func(pager *assetPager) error {
		if filter == nil {
			return errors.New("AssetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetPager struct {
	reverse bool
	order   []*AssetOrder
	filter  func(*AssetQuery) (*AssetQuery, error)
}

func newAssetPager(opts []AssetPaginateOption, reverse bool) (*assetPager, error) {
	pager := &assetPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *assetPager) applyFilter(query *AssetQuery) (*AssetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetPager) toCursor(_m *Asset) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *assetPager) applyCursors(query *AssetQuery, after, before *Cursor) (*AssetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAssetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *assetPager) applyOrder(query *AssetQuery) *AssetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAssetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAssetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *assetPager) orderExpr(query *AssetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAssetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Asset.
func (_m *AssetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetPaginateOption,
) (*AssetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &AssetConnection{Edges: []*AssetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetOrderFieldCreatedAt orders Asset by created_at.
	AssetOrderFieldCreatedAt = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: asset.FieldCreatedAt,
		toTerm: asset.ByCreatedAt,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// AssetOrderFieldUpdatedAt orders Asset by updated_at.
	AssetOrderFieldUpdatedAt = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: asset.FieldUpdatedAt,
		toTerm: asset.ByUpdatedAt,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// AssetOrderFieldAssetType orders Asset by asset_type.
	AssetOrderFieldAssetType = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.AssetType, nil
		},
		column: asset.FieldAssetType,
		toTerm: asset.ByAssetType,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.AssetType,
			}
		},
	}
	// AssetOrderFieldName orders Asset by name.
	AssetOrderFieldName = &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.Name, nil
		},
		column: asset.FieldName,
		toTerm: asset.ByName,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetOrderField) String() string {
	var str string
	switch f.column {
	case AssetOrderFieldCreatedAt.column:
		str = "created_at"
	case AssetOrderFieldUpdatedAt.column:
		str = "updated_at"
	case AssetOrderFieldAssetType.column:
		str = "ASSET_TYPE"
	case AssetOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AssetOrderFieldCreatedAt
	case "updated_at":
		*f = *AssetOrderFieldUpdatedAt
	case "ASSET_TYPE":
		*f = *AssetOrderFieldAssetType
	case "name":
		*f = *AssetOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AssetOrderField", str)
	}
	return nil
}

// AssetOrderField defines the ordering field of Asset.
type AssetOrderField struct {
	// Value extracts the ordering value from the given Asset.
	Value    func(*Asset) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) asset.OrderOption
	toCursor func(*Asset) Cursor
}

// AssetOrder defines the ordering of Asset.
type AssetOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AssetOrderField `json:"field"`
}

// DefaultAssetOrder is the default ordering of Asset.
var DefaultAssetOrder = &AssetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AssetOrderField{
		Value: func(_m *Asset) (ent.Value, error) {
			return _m.ID, nil
		},
		column: asset.FieldID,
		toTerm: asset.ByID,
		toCursor: func(_m *Asset) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Asset into AssetEdge.
func (_m *Asset) ToEdge(order *AssetOrder) *AssetEdge {
	if order == nil {
		order = DefaultAssetOrder
	}
	return &AssetEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ContactEdge is the edge representation of Contact.
type ContactEdge struct {
	Node   *Contact `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ContactConnection is the connection containing edges to Contact.
type ContactConnection struct {
	Edges      []*ContactEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ContactConnection) build(nodes []*Contact, pager *contactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Contact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Contact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Contact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactPaginateOption enables pagination customization.
type ContactPaginateOption func(*contactPager) error

// WithContactOrder configures pagination ordering.
func WithContactOrder(order []*ContactOrder) ContactPaginateOption {
	return func(pager *contactPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithContactFilter configures pagination filter.
func WithContactFilter(filter func(*ContactQuery) (*ContactQuery, error)) ContactPaginateOption {
	return func(pager *contactPager) error {
		if filter == nil {
			return errors.New("ContactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contactPager struct {
	reverse bool
	order   []*ContactOrder
	filter  func(*ContactQuery) (*ContactQuery, error)
}

func newContactPager(opts []ContactPaginateOption, reverse bool) (*contactPager, error) {
	pager := &contactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *contactPager) applyFilter(query *ContactQuery) (*ContactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contactPager) toCursor(_m *Contact) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *contactPager) applyCursors(query *ContactQuery, after, before *Cursor) (*ContactQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultContactOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *contactPager) applyOrder(query *ContactQuery) *ContactQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultContactOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultContactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *contactPager) orderExpr(query *ContactQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultContactOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Contact.
func (_m *ContactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactPaginateOption,
) (*ContactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ContactConnection{Edges: []*ContactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactOrderFieldCreatedAt orders Contact by created_at.
	ContactOrderFieldCreatedAt = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: contact.FieldCreatedAt,
		toTerm: contact.ByCreatedAt,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ContactOrderFieldUpdatedAt orders Contact by updated_at.
	ContactOrderFieldUpdatedAt = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: contact.FieldUpdatedAt,
		toTerm: contact.ByUpdatedAt,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ContactOrderFieldFullName orders Contact by full_name.
	ContactOrderFieldFullName = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.FullName, nil
		},
		column: contact.FieldFullName,
		toTerm: contact.ByFullName,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FullName,
			}
		},
	}
	// ContactOrderFieldTitle orders Contact by title.
	ContactOrderFieldTitle = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Title, nil
		},
		column: contact.FieldTitle,
		toTerm: contact.ByTitle,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ContactOrderFieldCompany orders Contact by company.
	ContactOrderFieldCompany = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Company, nil
		},
		column: contact.FieldCompany,
		toTerm: contact.ByCompany,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Company,
			}
		},
	}
	// ContactOrderFieldEmail orders Contact by email.
	ContactOrderFieldEmail = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Email, nil
		},
		column: contact.FieldEmail,
		toTerm: contact.ByEmail,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// ContactOrderFieldStatus orders Contact by status.
	ContactOrderFieldStatus = &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.Status, nil
		},
		column: contact.FieldStatus,
		toTerm: contact.ByStatus,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactOrderField) String() string {
	var str string
	switch f.column {
	case ContactOrderFieldCreatedAt.column:
		str = "created_at"
	case ContactOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ContactOrderFieldFullName.column:
		str = "full_name"
	case ContactOrderFieldTitle.column:
		str = "title"
	case ContactOrderFieldCompany.column:
		str = "company"
	case ContactOrderFieldEmail.column:
		str = "email"
	case ContactOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ContactOrderFieldCreatedAt
	case "updated_at":
		*f = *ContactOrderFieldUpdatedAt
	case "full_name":
		*f = *ContactOrderFieldFullName
	case "title":
		*f = *ContactOrderFieldTitle
	case "company":
		*f = *ContactOrderFieldCompany
	case "email":
		*f = *ContactOrderFieldEmail
	case "STATUS":
		*f = *ContactOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ContactOrderField", str)
	}
	return nil
}

// ContactOrderField defines the ordering field of Contact.
type ContactOrderField struct {
	// Value extracts the ordering value from the given Contact.
	Value    func(*Contact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contact.OrderOption
	toCursor func(*Contact) Cursor
}

// ContactOrder defines the ordering of Contact.
type ContactOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ContactOrderField `json:"field"`
}

// DefaultContactOrder is the default ordering of Contact.
var DefaultContactOrder = &ContactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactOrderField{
		Value: func(_m *Contact) (ent.Value, error) {
			return _m.ID, nil
		},
		column: contact.FieldID,
		toTerm: contact.ByID,
		toCursor: func(_m *Contact) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Contact into ContactEdge.
func (_m *Contact) ToEdge(order *ContactOrder) *ContactEdge {
	if order == nil {
		order = DefaultContactOrder
	}
	return &ContactEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlEdge is the edge representation of Control.
type ControlEdge struct {
	Node   *Control `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ControlConnection is the connection containing edges to Control.
type ControlConnection struct {
	Edges      []*ControlEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ControlConnection) build(nodes []*Control, pager *controlPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Control
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Control {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Control {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlPaginateOption enables pagination customization.
type ControlPaginateOption func(*controlPager) error

// WithControlOrder configures pagination ordering.
func WithControlOrder(order []*ControlOrder) ControlPaginateOption {
	return func(pager *controlPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlFilter configures pagination filter.
func WithControlFilter(filter func(*ControlQuery) (*ControlQuery, error)) ControlPaginateOption {
	return func(pager *controlPager) error {
		if filter == nil {
			return errors.New("ControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlPager struct {
	reverse bool
	order   []*ControlOrder
	filter  func(*ControlQuery) (*ControlQuery, error)
}

func newControlPager(opts []ControlPaginateOption, reverse bool) (*controlPager, error) {
	pager := &controlPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlPager) applyFilter(query *ControlQuery) (*ControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlPager) toCursor(_m *Control) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *controlPager) applyCursors(query *ControlQuery, after, before *Cursor) (*ControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlPager) applyOrder(query *ControlQuery) *ControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case ControlOrderFieldControlOwnerName.column, ControlOrderFieldDelegateName.column, ControlOrderFieldResponsiblePartyName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlPager) orderExpr(query *ControlQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case ControlOrderFieldControlOwnerName.column, ControlOrderFieldDelegateName.column, ControlOrderFieldResponsiblePartyName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Control.
func (_m *ControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlPaginateOption,
) (*ControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlConnection{Edges: []*ControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlOrderFieldCreatedAt orders Control by created_at.
	ControlOrderFieldCreatedAt = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: control.FieldCreatedAt,
		toTerm: control.ByCreatedAt,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlOrderFieldUpdatedAt orders Control by updated_at.
	ControlOrderFieldUpdatedAt = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: control.FieldUpdatedAt,
		toTerm: control.ByUpdatedAt,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlOrderFieldTitle orders Control by title.
	ControlOrderFieldTitle = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Title, nil
		},
		column: control.FieldTitle,
		toTerm: control.ByTitle,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ControlOrderFieldStatus orders Control by status.
	ControlOrderFieldStatus = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Status, nil
		},
		column: control.FieldStatus,
		toTerm: control.ByStatus,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlOrderFieldSource orders Control by source.
	ControlOrderFieldSource = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Source, nil
		},
		column: control.FieldSource,
		toTerm: control.BySource,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlOrderFieldReferenceFramework orders Control by reference_framework.
	ControlOrderFieldReferenceFramework = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: control.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return control.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *Control) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// ControlOrderFieldControlType orders Control by control_type.
	ControlOrderFieldControlType = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.ControlType, nil
		},
		column: control.FieldControlType,
		toTerm: control.ByControlType,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlType,
			}
		},
	}
	// ControlOrderFieldCategory orders Control by category.
	ControlOrderFieldCategory = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Category, nil
		},
		column: control.FieldCategory,
		toTerm: control.ByCategory,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlOrderFieldSubcategory orders Control by subcategory.
	ControlOrderFieldSubcategory = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: control.FieldSubcategory,
		toTerm: control.BySubcategory,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// ControlOrderFieldRefCode orders Control by ref_code.
	ControlOrderFieldRefCode = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: control.FieldRefCode,
		toTerm: control.ByRefCode,
		toCursor: func(_m *Control) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
	// ControlOrderFieldControlOwnerName orders by CONTROL_OWNER_name.
	ControlOrderFieldControlOwnerName = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Value("control_owner_name")
		},
		column: "control_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByControlOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("control_owner_name"))...,
			)
		},
		toCursor: func(_m *Control) Cursor {
			cv, _ := _m.Value("control_owner_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// ControlOrderFieldDelegateName orders by DELEGATE_name.
	ControlOrderFieldDelegateName = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Value("delegate_name")
		},
		column: "delegate_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByDelegateField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("delegate_name"))...,
			)
		},
		toCursor: func(_m *Control) Cursor {
			cv, _ := _m.Value("delegate_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// ControlOrderFieldResponsiblePartyName orders by RESPONSIBLE_PARTY_name.
	ControlOrderFieldResponsiblePartyName = &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.Value("responsible_party_name")
		},
		column: "responsible_party_name",
		toTerm: func(opts ...sql.OrderTermOption) control.OrderOption {
			return control.ByResponsiblePartyField(
				entity.FieldName,
				append(opts, sql.OrderSelectAs("responsible_party_name"))...,
			)
		},
		toCursor: func(_m *Control) Cursor {
			cv, _ := _m.Value("responsible_party_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlOrderField) String() string {
	var str string
	switch f.column {
	case ControlOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlOrderFieldTitle.column:
		str = "title"
	case ControlOrderFieldStatus.column:
		str = "STATUS"
	case ControlOrderFieldSource.column:
		str = "SOURCE"
	case ControlOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case ControlOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case ControlOrderFieldCategory.column:
		str = "category"
	case ControlOrderFieldSubcategory.column:
		str = "subcategory"
	case ControlOrderFieldRefCode.column:
		str = "ref_code"
	case ControlOrderFieldControlOwnerName.column:
		str = "CONTROL_OWNER_name"
	case ControlOrderFieldDelegateName.column:
		str = "DELEGATE_name"
	case ControlOrderFieldResponsiblePartyName.column:
		str = "RESPONSIBLE_PARTY_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlOrderFieldUpdatedAt
	case "title":
		*f = *ControlOrderFieldTitle
	case "STATUS":
		*f = *ControlOrderFieldStatus
	case "SOURCE":
		*f = *ControlOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *ControlOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *ControlOrderFieldControlType
	case "category":
		*f = *ControlOrderFieldCategory
	case "subcategory":
		*f = *ControlOrderFieldSubcategory
	case "ref_code":
		*f = *ControlOrderFieldRefCode
	case "CONTROL_OWNER_name":
		*f = *ControlOrderFieldControlOwnerName
	case "DELEGATE_name":
		*f = *ControlOrderFieldDelegateName
	case "RESPONSIBLE_PARTY_name":
		*f = *ControlOrderFieldResponsiblePartyName
	default:
		return fmt.Errorf("%s is not a valid ControlOrderField", str)
	}
	return nil
}

// ControlOrderField defines the ordering field of Control.
type ControlOrderField struct {
	// Value extracts the ordering value from the given Control.
	Value    func(*Control) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) control.OrderOption
	toCursor func(*Control) Cursor
}

// ControlOrder defines the ordering of Control.
type ControlOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ControlOrderField `json:"field"`
}

// DefaultControlOrder is the default ordering of Control.
var DefaultControlOrder = &ControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlOrderField{
		Value: func(_m *Control) (ent.Value, error) {
			return _m.ID, nil
		},
		column: control.FieldID,
		toTerm: control.ByID,
		toCursor: func(_m *Control) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Control into ControlEdge.
func (_m *Control) ToEdge(order *ControlOrder) *ControlEdge {
	if order == nil {
		order = DefaultControlOrder
	}
	return &ControlEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlImplementationEdge is the edge representation of ControlImplementation.
type ControlImplementationEdge struct {
	Node   *ControlImplementation `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// ControlImplementationConnection is the connection containing edges to ControlImplementation.
type ControlImplementationConnection struct {
	Edges      []*ControlImplementationEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *ControlImplementationConnection) build(nodes []*ControlImplementation, pager *controlimplementationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlImplementation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlImplementation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlImplementation {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlImplementationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlImplementationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlImplementationPaginateOption enables pagination customization.
type ControlImplementationPaginateOption func(*controlimplementationPager) error

// WithControlImplementationOrder configures pagination ordering.
func WithControlImplementationOrder(order []*ControlImplementationOrder) ControlImplementationPaginateOption {
	return func(pager *controlimplementationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlImplementationFilter configures pagination filter.
func WithControlImplementationFilter(filter func(*ControlImplementationQuery) (*ControlImplementationQuery, error)) ControlImplementationPaginateOption {
	return func(pager *controlimplementationPager) error {
		if filter == nil {
			return errors.New("ControlImplementationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlimplementationPager struct {
	reverse bool
	order   []*ControlImplementationOrder
	filter  func(*ControlImplementationQuery) (*ControlImplementationQuery, error)
}

func newControlImplementationPager(opts []ControlImplementationPaginateOption, reverse bool) (*controlimplementationPager, error) {
	pager := &controlimplementationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlimplementationPager) applyFilter(query *ControlImplementationQuery) (*ControlImplementationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlimplementationPager) toCursor(_m *ControlImplementation) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *controlimplementationPager) applyCursors(query *ControlImplementationQuery, after, before *Cursor) (*ControlImplementationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlImplementationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlimplementationPager) applyOrder(query *ControlImplementationQuery) *ControlImplementationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlImplementationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlImplementationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlimplementationPager) orderExpr(query *ControlImplementationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlImplementationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlImplementation.
func (_m *ControlImplementationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlImplementationPaginateOption,
) (*ControlImplementationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlImplementationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlImplementationConnection{Edges: []*ControlImplementationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlImplementationOrderFieldCreatedAt orders ControlImplementation by created_at.
	ControlImplementationOrderFieldCreatedAt = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlimplementation.FieldCreatedAt,
		toTerm: controlimplementation.ByCreatedAt,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlImplementationOrderFieldUpdatedAt orders ControlImplementation by updated_at.
	ControlImplementationOrderFieldUpdatedAt = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlimplementation.FieldUpdatedAt,
		toTerm: controlimplementation.ByUpdatedAt,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlImplementationOrderFieldStatus orders ControlImplementation by status.
	ControlImplementationOrderFieldStatus = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlimplementation.FieldStatus,
		toTerm: controlimplementation.ByStatus,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlImplementationOrderFieldImplementationDate orders ControlImplementation by implementation_date.
	ControlImplementationOrderFieldImplementationDate = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.ImplementationDate, nil
		},
		column: controlimplementation.FieldImplementationDate,
		toTerm: controlimplementation.ByImplementationDate,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ImplementationDate,
			}
		},
	}
	// ControlImplementationOrderFieldVerified orders ControlImplementation by verified.
	ControlImplementationOrderFieldVerified = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.Verified, nil
		},
		column: controlimplementation.FieldVerified,
		toTerm: controlimplementation.ByVerified,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Verified,
			}
		},
	}
	// ControlImplementationOrderFieldVerificationDate orders ControlImplementation by verification_date.
	ControlImplementationOrderFieldVerificationDate = &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.VerificationDate, nil
		},
		column: controlimplementation.FieldVerificationDate,
		toTerm: controlimplementation.ByVerificationDate,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.VerificationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlImplementationOrderField) String() string {
	var str string
	switch f.column {
	case ControlImplementationOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlImplementationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlImplementationOrderFieldStatus.column:
		str = "STATUS"
	case ControlImplementationOrderFieldImplementationDate.column:
		str = "implementation_date"
	case ControlImplementationOrderFieldVerified.column:
		str = "verified"
	case ControlImplementationOrderFieldVerificationDate.column:
		str = "verification_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlImplementationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlImplementationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlImplementationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlImplementationOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlImplementationOrderFieldUpdatedAt
	case "STATUS":
		*f = *ControlImplementationOrderFieldStatus
	case "implementation_date":
		*f = *ControlImplementationOrderFieldImplementationDate
	case "verified":
		*f = *ControlImplementationOrderFieldVerified
	case "verification_date":
		*f = *ControlImplementationOrderFieldVerificationDate
	default:
		return fmt.Errorf("%s is not a valid ControlImplementationOrderField", str)
	}
	return nil
}

// ControlImplementationOrderField defines the ordering field of ControlImplementation.
type ControlImplementationOrderField struct {
	// Value extracts the ordering value from the given ControlImplementation.
	Value    func(*ControlImplementation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlimplementation.OrderOption
	toCursor func(*ControlImplementation) Cursor
}

// ControlImplementationOrder defines the ordering of ControlImplementation.
type ControlImplementationOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *ControlImplementationOrderField `json:"field"`
}

// DefaultControlImplementationOrder is the default ordering of ControlImplementation.
var DefaultControlImplementationOrder = &ControlImplementationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlImplementationOrderField{
		Value: func(_m *ControlImplementation) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlimplementation.FieldID,
		toTerm: controlimplementation.ByID,
		toCursor: func(_m *ControlImplementation) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlImplementation into ControlImplementationEdge.
func (_m *ControlImplementation) ToEdge(order *ControlImplementationOrder) *ControlImplementationEdge {
	if order == nil {
		order = DefaultControlImplementationOrder
	}
	return &ControlImplementationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ControlObjectiveEdge is the edge representation of ControlObjective.
type ControlObjectiveEdge struct {
	Node   *ControlObjective `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ControlObjectiveConnection is the connection containing edges to ControlObjective.
type ControlObjectiveConnection struct {
	Edges      []*ControlObjectiveEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ControlObjectiveConnection) build(nodes []*ControlObjective, pager *controlobjectivePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ControlObjective
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ControlObjective {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ControlObjective {
			return nodes[i]
		}
	}
	c.Edges = make([]*ControlObjectiveEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ControlObjectiveEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ControlObjectivePaginateOption enables pagination customization.
type ControlObjectivePaginateOption func(*controlobjectivePager) error

// WithControlObjectiveOrder configures pagination ordering.
func WithControlObjectiveOrder(order []*ControlObjectiveOrder) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithControlObjectiveFilter configures pagination filter.
func WithControlObjectiveFilter(filter func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)) ControlObjectivePaginateOption {
	return func(pager *controlobjectivePager) error {
		if filter == nil {
			return errors.New("ControlObjectiveQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type controlobjectivePager struct {
	reverse bool
	order   []*ControlObjectiveOrder
	filter  func(*ControlObjectiveQuery) (*ControlObjectiveQuery, error)
}

func newControlObjectivePager(opts []ControlObjectivePaginateOption, reverse bool) (*controlobjectivePager, error) {
	pager := &controlobjectivePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *controlobjectivePager) applyFilter(query *ControlObjectiveQuery) (*ControlObjectiveQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *controlobjectivePager) toCursor(_m *ControlObjective) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *controlobjectivePager) applyCursors(query *ControlObjectiveQuery, after, before *Cursor) (*ControlObjectiveQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultControlObjectiveOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *controlobjectivePager) applyOrder(query *ControlObjectiveQuery) *ControlObjectiveQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultControlObjectiveOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultControlObjectiveOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *controlobjectivePager) orderExpr(query *ControlObjectiveQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultControlObjectiveOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ControlObjective.
func (_m *ControlObjectiveQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ControlObjectivePaginateOption,
) (*ControlObjectiveConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newControlObjectivePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ControlObjectiveConnection{Edges: []*ControlObjectiveEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ControlObjectiveOrderFieldCreatedAt orders ControlObjective by created_at.
	ControlObjectiveOrderFieldCreatedAt = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: controlobjective.FieldCreatedAt,
		toTerm: controlobjective.ByCreatedAt,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ControlObjectiveOrderFieldUpdatedAt orders ControlObjective by updated_at.
	ControlObjectiveOrderFieldUpdatedAt = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: controlobjective.FieldUpdatedAt,
		toTerm: controlobjective.ByUpdatedAt,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ControlObjectiveOrderFieldRevision orders ControlObjective by revision.
	ControlObjectiveOrderFieldRevision = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: controlobjective.FieldRevision,
		toTerm: controlobjective.ByRevision,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ControlObjectiveOrderFieldName orders ControlObjective by name.
	ControlObjectiveOrderFieldName = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Name, nil
		},
		column: controlobjective.FieldName,
		toTerm: controlobjective.ByName,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ControlObjectiveOrderFieldStatus orders ControlObjective by status.
	ControlObjectiveOrderFieldStatus = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Status, nil
		},
		column: controlobjective.FieldStatus,
		toTerm: controlobjective.ByStatus,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ControlObjectiveOrderFieldSource orders ControlObjective by source.
	ControlObjectiveOrderFieldSource = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Source, nil
		},
		column: controlobjective.FieldSource,
		toTerm: controlobjective.BySource,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// ControlObjectiveOrderFieldControlObjectiveType orders ControlObjective by control_objective_type.
	ControlObjectiveOrderFieldControlObjectiveType = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.ControlObjectiveType, nil
		},
		column: controlobjective.FieldControlObjectiveType,
		toTerm: controlobjective.ByControlObjectiveType,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlObjectiveType,
			}
		},
	}
	// ControlObjectiveOrderFieldCategory orders ControlObjective by category.
	ControlObjectiveOrderFieldCategory = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Category, nil
		},
		column: controlobjective.FieldCategory,
		toTerm: controlobjective.ByCategory,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// ControlObjectiveOrderFieldSubcategory orders ControlObjective by subcategory.
	ControlObjectiveOrderFieldSubcategory = &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: controlobjective.FieldSubcategory,
		toTerm: controlobjective.BySubcategory,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ControlObjectiveOrderField) String() string {
	var str string
	switch f.column {
	case ControlObjectiveOrderFieldCreatedAt.column:
		str = "created_at"
	case ControlObjectiveOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ControlObjectiveOrderFieldRevision.column:
		str = "revision"
	case ControlObjectiveOrderFieldName.column:
		str = "name"
	case ControlObjectiveOrderFieldStatus.column:
		str = "status"
	case ControlObjectiveOrderFieldSource.column:
		str = "SOURCE"
	case ControlObjectiveOrderFieldControlObjectiveType.column:
		str = "control_objective_type"
	case ControlObjectiveOrderFieldCategory.column:
		str = "category"
	case ControlObjectiveOrderFieldSubcategory.column:
		str = "subcategory"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ControlObjectiveOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ControlObjectiveOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ControlObjectiveOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ControlObjectiveOrderFieldCreatedAt
	case "updated_at":
		*f = *ControlObjectiveOrderFieldUpdatedAt
	case "revision":
		*f = *ControlObjectiveOrderFieldRevision
	case "name":
		*f = *ControlObjectiveOrderFieldName
	case "status":
		*f = *ControlObjectiveOrderFieldStatus
	case "SOURCE":
		*f = *ControlObjectiveOrderFieldSource
	case "control_objective_type":
		*f = *ControlObjectiveOrderFieldControlObjectiveType
	case "category":
		*f = *ControlObjectiveOrderFieldCategory
	case "subcategory":
		*f = *ControlObjectiveOrderFieldSubcategory
	default:
		return fmt.Errorf("%s is not a valid ControlObjectiveOrderField", str)
	}
	return nil
}

// ControlObjectiveOrderField defines the ordering field of ControlObjective.
type ControlObjectiveOrderField struct {
	// Value extracts the ordering value from the given ControlObjective.
	Value    func(*ControlObjective) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) controlobjective.OrderOption
	toCursor func(*ControlObjective) Cursor
}

// ControlObjectiveOrder defines the ordering of ControlObjective.
type ControlObjectiveOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ControlObjectiveOrderField `json:"field"`
}

// DefaultControlObjectiveOrder is the default ordering of ControlObjective.
var DefaultControlObjectiveOrder = &ControlObjectiveOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ControlObjectiveOrderField{
		Value: func(_m *ControlObjective) (ent.Value, error) {
			return _m.ID, nil
		},
		column: controlobjective.FieldID,
		toTerm: controlobjective.ByID,
		toCursor: func(_m *ControlObjective) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ControlObjective into ControlObjectiveEdge.
func (_m *ControlObjective) ToEdge(order *ControlObjectiveOrder) *ControlObjectiveEdge {
	if order == nil {
		order = DefaultControlObjectiveOrder
	}
	return &ControlObjectiveEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CustomDomainEdge is the edge representation of CustomDomain.
type CustomDomainEdge struct {
	Node   *CustomDomain `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CustomDomainConnection is the connection containing edges to CustomDomain.
type CustomDomainConnection struct {
	Edges      []*CustomDomainEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CustomDomainConnection) build(nodes []*CustomDomain, pager *customdomainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomDomain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomDomain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomDomain {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomDomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomDomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomDomainPaginateOption enables pagination customization.
type CustomDomainPaginateOption func(*customdomainPager) error

// WithCustomDomainOrder configures pagination ordering.
func WithCustomDomainOrder(order []*CustomDomainOrder) CustomDomainPaginateOption {
	return func(pager *customdomainPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomDomainFilter configures pagination filter.
func WithCustomDomainFilter(filter func(*CustomDomainQuery) (*CustomDomainQuery, error)) CustomDomainPaginateOption {
	return func(pager *customdomainPager) error {
		if filter == nil {
			return errors.New("CustomDomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customdomainPager struct {
	reverse bool
	order   []*CustomDomainOrder
	filter  func(*CustomDomainQuery) (*CustomDomainQuery, error)
}

func newCustomDomainPager(opts []CustomDomainPaginateOption, reverse bool) (*customdomainPager, error) {
	pager := &customdomainPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customdomainPager) applyFilter(query *CustomDomainQuery) (*CustomDomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customdomainPager) toCursor(_m *CustomDomain) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *customdomainPager) applyCursors(query *CustomDomainQuery, after, before *Cursor) (*CustomDomainQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomDomainOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *customdomainPager) applyOrder(query *CustomDomainQuery) *CustomDomainQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomDomainOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomDomainOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customdomainPager) orderExpr(query *CustomDomainQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomDomainOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomDomain.
func (_m *CustomDomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomDomainPaginateOption,
) (*CustomDomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomDomainPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CustomDomainConnection{Edges: []*CustomDomainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomDomainOrderFieldCreatedAt orders CustomDomain by created_at.
	CustomDomainOrderFieldCreatedAt = &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: customdomain.FieldCreatedAt,
		toTerm: customdomain.ByCreatedAt,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CustomDomainOrderFieldUpdatedAt orders CustomDomain by updated_at.
	CustomDomainOrderFieldUpdatedAt = &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: customdomain.FieldUpdatedAt,
		toTerm: customdomain.ByUpdatedAt,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CustomDomainOrderFieldCnameRecord orders CustomDomain by cname_record.
	CustomDomainOrderFieldCnameRecord = &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.CnameRecord, nil
		},
		column: customdomain.FieldCnameRecord,
		toTerm: customdomain.ByCnameRecord,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CnameRecord,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomDomainOrderField) String() string {
	var str string
	switch f.column {
	case CustomDomainOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomDomainOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomDomainOrderFieldCnameRecord.column:
		str = "cname_record"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomDomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomDomainOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CustomDomainOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomDomainOrderFieldUpdatedAt
	case "cname_record":
		*f = *CustomDomainOrderFieldCnameRecord
	default:
		return fmt.Errorf("%s is not a valid CustomDomainOrderField", str)
	}
	return nil
}

// CustomDomainOrderField defines the ordering field of CustomDomain.
type CustomDomainOrderField struct {
	// Value extracts the ordering value from the given CustomDomain.
	Value    func(*CustomDomain) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customdomain.OrderOption
	toCursor func(*CustomDomain) Cursor
}

// CustomDomainOrder defines the ordering of CustomDomain.
type CustomDomainOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CustomDomainOrderField `json:"field"`
}

// DefaultCustomDomainOrder is the default ordering of CustomDomain.
var DefaultCustomDomainOrder = &CustomDomainOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomDomainOrderField{
		Value: func(_m *CustomDomain) (ent.Value, error) {
			return _m.ID, nil
		},
		column: customdomain.FieldID,
		toTerm: customdomain.ByID,
		toCursor: func(_m *CustomDomain) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CustomDomain into CustomDomainEdge.
func (_m *CustomDomain) ToEdge(order *CustomDomainOrder) *CustomDomainEdge {
	if order == nil {
		order = DefaultCustomDomainOrder
	}
	return &CustomDomainEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CustomTypeEnumEdge is the edge representation of CustomTypeEnum.
type CustomTypeEnumEdge struct {
	Node   *CustomTypeEnum `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CustomTypeEnumConnection is the connection containing edges to CustomTypeEnum.
type CustomTypeEnumConnection struct {
	Edges      []*CustomTypeEnumEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CustomTypeEnumConnection) build(nodes []*CustomTypeEnum, pager *customtypeenumPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *CustomTypeEnum
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CustomTypeEnum {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CustomTypeEnum {
			return nodes[i]
		}
	}
	c.Edges = make([]*CustomTypeEnumEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CustomTypeEnumEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CustomTypeEnumPaginateOption enables pagination customization.
type CustomTypeEnumPaginateOption func(*customtypeenumPager) error

// WithCustomTypeEnumOrder configures pagination ordering.
func WithCustomTypeEnumOrder(order []*CustomTypeEnumOrder) CustomTypeEnumPaginateOption {
	return func(pager *customtypeenumPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithCustomTypeEnumFilter configures pagination filter.
func WithCustomTypeEnumFilter(filter func(*CustomTypeEnumQuery) (*CustomTypeEnumQuery, error)) CustomTypeEnumPaginateOption {
	return func(pager *customtypeenumPager) error {
		if filter == nil {
			return errors.New("CustomTypeEnumQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customtypeenumPager struct {
	reverse bool
	order   []*CustomTypeEnumOrder
	filter  func(*CustomTypeEnumQuery) (*CustomTypeEnumQuery, error)
}

func newCustomTypeEnumPager(opts []CustomTypeEnumPaginateOption, reverse bool) (*customtypeenumPager, error) {
	pager := &customtypeenumPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *customtypeenumPager) applyFilter(query *CustomTypeEnumQuery) (*CustomTypeEnumQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customtypeenumPager) toCursor(_m *CustomTypeEnum) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *customtypeenumPager) applyCursors(query *CustomTypeEnumQuery, after, before *Cursor) (*CustomTypeEnumQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultCustomTypeEnumOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *customtypeenumPager) applyOrder(query *CustomTypeEnumQuery) *CustomTypeEnumQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultCustomTypeEnumOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultCustomTypeEnumOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *customtypeenumPager) orderExpr(query *CustomTypeEnumQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultCustomTypeEnumOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to CustomTypeEnum.
func (_m *CustomTypeEnumQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomTypeEnumPaginateOption,
) (*CustomTypeEnumConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomTypeEnumPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CustomTypeEnumConnection{Edges: []*CustomTypeEnumEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CustomTypeEnumOrderFieldCreatedAt orders CustomTypeEnum by created_at.
	CustomTypeEnumOrderFieldCreatedAt = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: customtypeenum.FieldCreatedAt,
		toTerm: customtypeenum.ByCreatedAt,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// CustomTypeEnumOrderFieldUpdatedAt orders CustomTypeEnum by updated_at.
	CustomTypeEnumOrderFieldUpdatedAt = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: customtypeenum.FieldUpdatedAt,
		toTerm: customtypeenum.ByUpdatedAt,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// CustomTypeEnumOrderFieldObjectType orders CustomTypeEnum by object_type.
	CustomTypeEnumOrderFieldObjectType = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.ObjectType, nil
		},
		column: customtypeenum.FieldObjectType,
		toTerm: customtypeenum.ByObjectType,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ObjectType,
			}
		},
	}
	// CustomTypeEnumOrderFieldField orders CustomTypeEnum by field.
	CustomTypeEnumOrderFieldField = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.Field, nil
		},
		column: customtypeenum.FieldField,
		toTerm: customtypeenum.ByField,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Field,
			}
		},
	}
	// CustomTypeEnumOrderFieldName orders CustomTypeEnum by name.
	CustomTypeEnumOrderFieldName = &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.Name, nil
		},
		column: customtypeenum.FieldName,
		toTerm: customtypeenum.ByName,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CustomTypeEnumOrderField) String() string {
	var str string
	switch f.column {
	case CustomTypeEnumOrderFieldCreatedAt.column:
		str = "created_at"
	case CustomTypeEnumOrderFieldUpdatedAt.column:
		str = "updated_at"
	case CustomTypeEnumOrderFieldObjectType.column:
		str = "object_type"
	case CustomTypeEnumOrderFieldField.column:
		str = "field"
	case CustomTypeEnumOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CustomTypeEnumOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CustomTypeEnumOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CustomTypeEnumOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CustomTypeEnumOrderFieldCreatedAt
	case "updated_at":
		*f = *CustomTypeEnumOrderFieldUpdatedAt
	case "object_type":
		*f = *CustomTypeEnumOrderFieldObjectType
	case "field":
		*f = *CustomTypeEnumOrderFieldField
	case "name":
		*f = *CustomTypeEnumOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid CustomTypeEnumOrderField", str)
	}
	return nil
}

// CustomTypeEnumOrderField defines the ordering field of CustomTypeEnum.
type CustomTypeEnumOrderField struct {
	// Value extracts the ordering value from the given CustomTypeEnum.
	Value    func(*CustomTypeEnum) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) customtypeenum.OrderOption
	toCursor func(*CustomTypeEnum) Cursor
}

// CustomTypeEnumOrder defines the ordering of CustomTypeEnum.
type CustomTypeEnumOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CustomTypeEnumOrderField `json:"field"`
}

// DefaultCustomTypeEnumOrder is the default ordering of CustomTypeEnum.
var DefaultCustomTypeEnumOrder = &CustomTypeEnumOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CustomTypeEnumOrderField{
		Value: func(_m *CustomTypeEnum) (ent.Value, error) {
			return _m.ID, nil
		},
		column: customtypeenum.FieldID,
		toTerm: customtypeenum.ByID,
		toCursor: func(_m *CustomTypeEnum) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CustomTypeEnum into CustomTypeEnumEdge.
func (_m *CustomTypeEnum) ToEdge(order *CustomTypeEnumOrder) *CustomTypeEnumEdge {
	if order == nil {
		order = DefaultCustomTypeEnumOrder
	}
	return &CustomTypeEnumEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DNSVerificationEdge is the edge representation of DNSVerification.
type DNSVerificationEdge struct {
	Node   *DNSVerification `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// DNSVerificationConnection is the connection containing edges to DNSVerification.
type DNSVerificationConnection struct {
	Edges      []*DNSVerificationEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *DNSVerificationConnection) build(nodes []*DNSVerification, pager *dnsverificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DNSVerification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSVerification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSVerification {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSVerificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSVerificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSVerificationPaginateOption enables pagination customization.
type DNSVerificationPaginateOption func(*dnsverificationPager) error

// WithDNSVerificationOrder configures pagination ordering.
func WithDNSVerificationOrder(order []*DNSVerificationOrder) DNSVerificationPaginateOption {
	return func(pager *dnsverificationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDNSVerificationFilter configures pagination filter.
func WithDNSVerificationFilter(filter func(*DNSVerificationQuery) (*DNSVerificationQuery, error)) DNSVerificationPaginateOption {
	return func(pager *dnsverificationPager) error {
		if filter == nil {
			return errors.New("DNSVerificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsverificationPager struct {
	reverse bool
	order   []*DNSVerificationOrder
	filter  func(*DNSVerificationQuery) (*DNSVerificationQuery, error)
}

func newDNSVerificationPager(opts []DNSVerificationPaginateOption, reverse bool) (*dnsverificationPager, error) {
	pager := &dnsverificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *dnsverificationPager) applyFilter(query *DNSVerificationQuery) (*DNSVerificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsverificationPager) toCursor(_m *DNSVerification) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *dnsverificationPager) applyCursors(query *DNSVerificationQuery, after, before *Cursor) (*DNSVerificationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDNSVerificationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *dnsverificationPager) applyOrder(query *DNSVerificationQuery) *DNSVerificationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDNSVerificationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDNSVerificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *dnsverificationPager) orderExpr(query *DNSVerificationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDNSVerificationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSVerification.
func (_m *DNSVerificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSVerificationPaginateOption,
) (*DNSVerificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSVerificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DNSVerificationConnection{Edges: []*DNSVerificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DNSVerificationOrderFieldCreatedAt orders DNSVerification by created_at.
	DNSVerificationOrderFieldCreatedAt = &DNSVerificationOrderField{
		Value: func(_m *DNSVerification) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: dnsverification.FieldCreatedAt,
		toTerm: dnsverification.ByCreatedAt,
		toCursor: func(_m *DNSVerification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DNSVerificationOrderFieldUpdatedAt orders DNSVerification by updated_at.
	DNSVerificationOrderFieldUpdatedAt = &DNSVerificationOrderField{
		Value: func(_m *DNSVerification) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: dnsverification.FieldUpdatedAt,
		toTerm: dnsverification.ByUpdatedAt,
		toCursor: func(_m *DNSVerification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DNSVerificationOrderField) String() string {
	var str string
	switch f.column {
	case DNSVerificationOrderFieldCreatedAt.column:
		str = "created_at"
	case DNSVerificationOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DNSVerificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DNSVerificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DNSVerificationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DNSVerificationOrderFieldCreatedAt
	case "updated_at":
		*f = *DNSVerificationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DNSVerificationOrderField", str)
	}
	return nil
}

// DNSVerificationOrderField defines the ordering field of DNSVerification.
type DNSVerificationOrderField struct {
	// Value extracts the ordering value from the given DNSVerification.
	Value    func(*DNSVerification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsverification.OrderOption
	toCursor func(*DNSVerification) Cursor
}

// DNSVerificationOrder defines the ordering of DNSVerification.
type DNSVerificationOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *DNSVerificationOrderField `json:"field"`
}

// DefaultDNSVerificationOrder is the default ordering of DNSVerification.
var DefaultDNSVerificationOrder = &DNSVerificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSVerificationOrderField{
		Value: func(_m *DNSVerification) (ent.Value, error) {
			return _m.ID, nil
		},
		column: dnsverification.FieldID,
		toTerm: dnsverification.ByID,
		toCursor: func(_m *DNSVerification) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DNSVerification into DNSVerificationEdge.
func (_m *DNSVerification) ToEdge(order *DNSVerificationOrder) *DNSVerificationEdge {
	if order == nil {
		order = DefaultDNSVerificationOrder
	}
	return &DNSVerificationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryAccountEdge is the edge representation of DirectoryAccount.
type DirectoryAccountEdge struct {
	Node   *DirectoryAccount `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DirectoryAccountConnection is the connection containing edges to DirectoryAccount.
type DirectoryAccountConnection struct {
	Edges      []*DirectoryAccountEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *DirectoryAccountConnection) build(nodes []*DirectoryAccount, pager *directoryaccountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryAccount
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryAccount {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryAccount {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryAccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryAccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryAccountPaginateOption enables pagination customization.
type DirectoryAccountPaginateOption func(*directoryaccountPager) error

// WithDirectoryAccountOrder configures pagination ordering.
func WithDirectoryAccountOrder(order []*DirectoryAccountOrder) DirectoryAccountPaginateOption {
	return func(pager *directoryaccountPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectoryAccountFilter configures pagination filter.
func WithDirectoryAccountFilter(filter func(*DirectoryAccountQuery) (*DirectoryAccountQuery, error)) DirectoryAccountPaginateOption {
	return func(pager *directoryaccountPager) error {
		if filter == nil {
			return errors.New("DirectoryAccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directoryaccountPager struct {
	reverse bool
	order   []*DirectoryAccountOrder
	filter  func(*DirectoryAccountQuery) (*DirectoryAccountQuery, error)
}

func newDirectoryAccountPager(opts []DirectoryAccountPaginateOption, reverse bool) (*directoryaccountPager, error) {
	pager := &directoryaccountPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directoryaccountPager) applyFilter(query *DirectoryAccountQuery) (*DirectoryAccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directoryaccountPager) toCursor(_m *DirectoryAccount) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directoryaccountPager) applyCursors(query *DirectoryAccountQuery, after, before *Cursor) (*DirectoryAccountQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectoryAccountOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directoryaccountPager) applyOrder(query *DirectoryAccountQuery) *DirectoryAccountQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectoryAccountOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectoryAccountOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directoryaccountPager) orderExpr(query *DirectoryAccountQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectoryAccountOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryAccount.
func (_m *DirectoryAccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryAccountPaginateOption,
) (*DirectoryAccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryAccountPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryAccountConnection{Edges: []*DirectoryAccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryAccountOrderFieldCreatedAt orders DirectoryAccount by created_at.
	DirectoryAccountOrderFieldCreatedAt = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directoryaccount.FieldCreatedAt,
		toTerm: directoryaccount.ByCreatedAt,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryAccountOrderFieldUpdatedAt orders DirectoryAccount by updated_at.
	DirectoryAccountOrderFieldUpdatedAt = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directoryaccount.FieldUpdatedAt,
		toTerm: directoryaccount.ByUpdatedAt,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryAccountOrderFieldExternalID orders DirectoryAccount by external_id.
	DirectoryAccountOrderFieldExternalID = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directoryaccount.FieldExternalID,
		toTerm: directoryaccount.ByExternalID,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryAccountOrderFieldCanonicalEmail orders DirectoryAccount by canonical_email.
	DirectoryAccountOrderFieldCanonicalEmail = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			// allow for nil values for fields
			if _m.CanonicalEmail == nil {
				return nil, nil
			}
			return _m.CanonicalEmail, nil
		},
		column: directoryaccount.FieldCanonicalEmail,
		toTerm: func(opts ...sql.OrderTermOption) directoryaccount.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directoryaccount.ByCanonicalEmail(opts...)
		},
		toCursor: func(_m *DirectoryAccount) Cursor {
			if _m.CanonicalEmail == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.CanonicalEmail,
			}
		},
	}
	// DirectoryAccountOrderFieldDisplayName orders DirectoryAccount by display_name.
	DirectoryAccountOrderFieldDisplayName = &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directoryaccount.FieldDisplayName,
		toTerm: directoryaccount.ByDisplayName,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryAccountOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryAccountOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryAccountOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryAccountOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryAccountOrderFieldCanonicalEmail.column:
		str = "canonical_email"
	case DirectoryAccountOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryAccountOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryAccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryAccountOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectoryAccountOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryAccountOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryAccountOrderFieldExternalID
	case "canonical_email":
		*f = *DirectoryAccountOrderFieldCanonicalEmail
	case "display_name":
		*f = *DirectoryAccountOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryAccountOrderField", str)
	}
	return nil
}

// DirectoryAccountOrderField defines the ordering field of DirectoryAccount.
type DirectoryAccountOrderField struct {
	// Value extracts the ordering value from the given DirectoryAccount.
	Value    func(*DirectoryAccount) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directoryaccount.OrderOption
	toCursor func(*DirectoryAccount) Cursor
}

// DirectoryAccountOrder defines the ordering of DirectoryAccount.
type DirectoryAccountOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DirectoryAccountOrderField `json:"field"`
}

// DefaultDirectoryAccountOrder is the default ordering of DirectoryAccount.
var DefaultDirectoryAccountOrder = &DirectoryAccountOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryAccountOrderField{
		Value: func(_m *DirectoryAccount) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directoryaccount.FieldID,
		toTerm: directoryaccount.ByID,
		toCursor: func(_m *DirectoryAccount) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryAccount into DirectoryAccountEdge.
func (_m *DirectoryAccount) ToEdge(order *DirectoryAccountOrder) *DirectoryAccountEdge {
	if order == nil {
		order = DefaultDirectoryAccountOrder
	}
	return &DirectoryAccountEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryGroupEdge is the edge representation of DirectoryGroup.
type DirectoryGroupEdge struct {
	Node   *DirectoryGroup `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// DirectoryGroupConnection is the connection containing edges to DirectoryGroup.
type DirectoryGroupConnection struct {
	Edges      []*DirectoryGroupEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *DirectoryGroupConnection) build(nodes []*DirectoryGroup, pager *directorygroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryGroupPaginateOption enables pagination customization.
type DirectoryGroupPaginateOption func(*directorygroupPager) error

// WithDirectoryGroupOrder configures pagination ordering.
func WithDirectoryGroupOrder(order []*DirectoryGroupOrder) DirectoryGroupPaginateOption {
	return func(pager *directorygroupPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectoryGroupFilter configures pagination filter.
func WithDirectoryGroupFilter(filter func(*DirectoryGroupQuery) (*DirectoryGroupQuery, error)) DirectoryGroupPaginateOption {
	return func(pager *directorygroupPager) error {
		if filter == nil {
			return errors.New("DirectoryGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorygroupPager struct {
	reverse bool
	order   []*DirectoryGroupOrder
	filter  func(*DirectoryGroupQuery) (*DirectoryGroupQuery, error)
}

func newDirectoryGroupPager(opts []DirectoryGroupPaginateOption, reverse bool) (*directorygroupPager, error) {
	pager := &directorygroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directorygroupPager) applyFilter(query *DirectoryGroupQuery) (*DirectoryGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorygroupPager) toCursor(_m *DirectoryGroup) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directorygroupPager) applyCursors(query *DirectoryGroupQuery, after, before *Cursor) (*DirectoryGroupQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectoryGroupOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directorygroupPager) applyOrder(query *DirectoryGroupQuery) *DirectoryGroupQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectoryGroupOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectoryGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directorygroupPager) orderExpr(query *DirectoryGroupQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectoryGroupOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryGroup.
func (_m *DirectoryGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryGroupPaginateOption,
) (*DirectoryGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryGroupConnection{Edges: []*DirectoryGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryGroupOrderFieldCreatedAt orders DirectoryGroup by created_at.
	DirectoryGroupOrderFieldCreatedAt = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorygroup.FieldCreatedAt,
		toTerm: directorygroup.ByCreatedAt,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryGroupOrderFieldUpdatedAt orders DirectoryGroup by updated_at.
	DirectoryGroupOrderFieldUpdatedAt = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorygroup.FieldUpdatedAt,
		toTerm: directorygroup.ByUpdatedAt,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectoryGroupOrderFieldExternalID orders DirectoryGroup by external_id.
	DirectoryGroupOrderFieldExternalID = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: directorygroup.FieldExternalID,
		toTerm: directorygroup.ByExternalID,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// DirectoryGroupOrderFieldEmail orders DirectoryGroup by email.
	DirectoryGroupOrderFieldEmail = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Email == nil {
				return nil, nil
			}
			return _m.Email, nil
		},
		column: directorygroup.FieldEmail,
		toTerm: func(opts ...sql.OrderTermOption) directorygroup.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return directorygroup.ByEmail(opts...)
		},
		toCursor: func(_m *DirectoryGroup) Cursor {
			if _m.Email == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// DirectoryGroupOrderFieldDisplayName orders DirectoryGroup by display_name.
	DirectoryGroupOrderFieldDisplayName = &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: directorygroup.FieldDisplayName,
		toTerm: directorygroup.ByDisplayName,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryGroupOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryGroupOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryGroupOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectoryGroupOrderFieldExternalID.column:
		str = "external_id"
	case DirectoryGroupOrderFieldEmail.column:
		str = "email"
	case DirectoryGroupOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryGroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryGroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryGroupOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectoryGroupOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryGroupOrderFieldUpdatedAt
	case "external_id":
		*f = *DirectoryGroupOrderFieldExternalID
	case "email":
		*f = *DirectoryGroupOrderFieldEmail
	case "display_name":
		*f = *DirectoryGroupOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid DirectoryGroupOrderField", str)
	}
	return nil
}

// DirectoryGroupOrderField defines the ordering field of DirectoryGroup.
type DirectoryGroupOrderField struct {
	// Value extracts the ordering value from the given DirectoryGroup.
	Value    func(*DirectoryGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorygroup.OrderOption
	toCursor func(*DirectoryGroup) Cursor
}

// DirectoryGroupOrder defines the ordering of DirectoryGroup.
type DirectoryGroupOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *DirectoryGroupOrderField `json:"field"`
}

// DefaultDirectoryGroupOrder is the default ordering of DirectoryGroup.
var DefaultDirectoryGroupOrder = &DirectoryGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryGroupOrderField{
		Value: func(_m *DirectoryGroup) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorygroup.FieldID,
		toTerm: directorygroup.ByID,
		toCursor: func(_m *DirectoryGroup) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryGroup into DirectoryGroupEdge.
func (_m *DirectoryGroup) ToEdge(order *DirectoryGroupOrder) *DirectoryGroupEdge {
	if order == nil {
		order = DefaultDirectoryGroupOrder
	}
	return &DirectoryGroupEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectoryMembershipEdge is the edge representation of DirectoryMembership.
type DirectoryMembershipEdge struct {
	Node   *DirectoryMembership `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DirectoryMembershipConnection is the connection containing edges to DirectoryMembership.
type DirectoryMembershipConnection struct {
	Edges      []*DirectoryMembershipEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DirectoryMembershipConnection) build(nodes []*DirectoryMembership, pager *directorymembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectoryMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectoryMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectoryMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectoryMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectoryMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectoryMembershipPaginateOption enables pagination customization.
type DirectoryMembershipPaginateOption func(*directorymembershipPager) error

// WithDirectoryMembershipOrder configures pagination ordering.
func WithDirectoryMembershipOrder(order []*DirectoryMembershipOrder) DirectoryMembershipPaginateOption {
	return func(pager *directorymembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectoryMembershipFilter configures pagination filter.
func WithDirectoryMembershipFilter(filter func(*DirectoryMembershipQuery) (*DirectoryMembershipQuery, error)) DirectoryMembershipPaginateOption {
	return func(pager *directorymembershipPager) error {
		if filter == nil {
			return errors.New("DirectoryMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorymembershipPager struct {
	reverse bool
	order   []*DirectoryMembershipOrder
	filter  func(*DirectoryMembershipQuery) (*DirectoryMembershipQuery, error)
}

func newDirectoryMembershipPager(opts []DirectoryMembershipPaginateOption, reverse bool) (*directorymembershipPager, error) {
	pager := &directorymembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directorymembershipPager) applyFilter(query *DirectoryMembershipQuery) (*DirectoryMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorymembershipPager) toCursor(_m *DirectoryMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directorymembershipPager) applyCursors(query *DirectoryMembershipQuery, after, before *Cursor) (*DirectoryMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectoryMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directorymembershipPager) applyOrder(query *DirectoryMembershipQuery) *DirectoryMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectoryMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectoryMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directorymembershipPager) orderExpr(query *DirectoryMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectoryMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectoryMembership.
func (_m *DirectoryMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectoryMembershipPaginateOption,
) (*DirectoryMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectoryMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectoryMembershipConnection{Edges: []*DirectoryMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectoryMembershipOrderFieldCreatedAt orders DirectoryMembership by created_at.
	DirectoryMembershipOrderFieldCreatedAt = &DirectoryMembershipOrderField{
		Value: func(_m *DirectoryMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorymembership.FieldCreatedAt,
		toTerm: directorymembership.ByCreatedAt,
		toCursor: func(_m *DirectoryMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectoryMembershipOrderFieldUpdatedAt orders DirectoryMembership by updated_at.
	DirectoryMembershipOrderFieldUpdatedAt = &DirectoryMembershipOrderField{
		Value: func(_m *DirectoryMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorymembership.FieldUpdatedAt,
		toTerm: directorymembership.ByUpdatedAt,
		toCursor: func(_m *DirectoryMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectoryMembershipOrderField) String() string {
	var str string
	switch f.column {
	case DirectoryMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectoryMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectoryMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectoryMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectoryMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectoryMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectoryMembershipOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DirectoryMembershipOrderField", str)
	}
	return nil
}

// DirectoryMembershipOrderField defines the ordering field of DirectoryMembership.
type DirectoryMembershipOrderField struct {
	// Value extracts the ordering value from the given DirectoryMembership.
	Value    func(*DirectoryMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorymembership.OrderOption
	toCursor func(*DirectoryMembership) Cursor
}

// DirectoryMembershipOrder defines the ordering of DirectoryMembership.
type DirectoryMembershipOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DirectoryMembershipOrderField `json:"field"`
}

// DefaultDirectoryMembershipOrder is the default ordering of DirectoryMembership.
var DefaultDirectoryMembershipOrder = &DirectoryMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectoryMembershipOrderField{
		Value: func(_m *DirectoryMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorymembership.FieldID,
		toTerm: directorymembership.ByID,
		toCursor: func(_m *DirectoryMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectoryMembership into DirectoryMembershipEdge.
func (_m *DirectoryMembership) ToEdge(order *DirectoryMembershipOrder) *DirectoryMembershipEdge {
	if order == nil {
		order = DefaultDirectoryMembershipOrder
	}
	return &DirectoryMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DirectorySyncRunEdge is the edge representation of DirectorySyncRun.
type DirectorySyncRunEdge struct {
	Node   *DirectorySyncRun `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DirectorySyncRunConnection is the connection containing edges to DirectorySyncRun.
type DirectorySyncRunConnection struct {
	Edges      []*DirectorySyncRunEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *DirectorySyncRunConnection) build(nodes []*DirectorySyncRun, pager *directorysyncrunPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DirectorySyncRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DirectorySyncRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DirectorySyncRun {
			return nodes[i]
		}
	}
	c.Edges = make([]*DirectorySyncRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DirectorySyncRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DirectorySyncRunPaginateOption enables pagination customization.
type DirectorySyncRunPaginateOption func(*directorysyncrunPager) error

// WithDirectorySyncRunOrder configures pagination ordering.
func WithDirectorySyncRunOrder(order []*DirectorySyncRunOrder) DirectorySyncRunPaginateOption {
	return func(pager *directorysyncrunPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDirectorySyncRunFilter configures pagination filter.
func WithDirectorySyncRunFilter(filter func(*DirectorySyncRunQuery) (*DirectorySyncRunQuery, error)) DirectorySyncRunPaginateOption {
	return func(pager *directorysyncrunPager) error {
		if filter == nil {
			return errors.New("DirectorySyncRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type directorysyncrunPager struct {
	reverse bool
	order   []*DirectorySyncRunOrder
	filter  func(*DirectorySyncRunQuery) (*DirectorySyncRunQuery, error)
}

func newDirectorySyncRunPager(opts []DirectorySyncRunPaginateOption, reverse bool) (*directorysyncrunPager, error) {
	pager := &directorysyncrunPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *directorysyncrunPager) applyFilter(query *DirectorySyncRunQuery) (*DirectorySyncRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *directorysyncrunPager) toCursor(_m *DirectorySyncRun) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *directorysyncrunPager) applyCursors(query *DirectorySyncRunQuery, after, before *Cursor) (*DirectorySyncRunQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDirectorySyncRunOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *directorysyncrunPager) applyOrder(query *DirectorySyncRunQuery) *DirectorySyncRunQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDirectorySyncRunOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDirectorySyncRunOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *directorysyncrunPager) orderExpr(query *DirectorySyncRunQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDirectorySyncRunOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DirectorySyncRun.
func (_m *DirectorySyncRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DirectorySyncRunPaginateOption,
) (*DirectorySyncRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDirectorySyncRunPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DirectorySyncRunConnection{Edges: []*DirectorySyncRunEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DirectorySyncRunOrderFieldCreatedAt orders DirectorySyncRun by created_at.
	DirectorySyncRunOrderFieldCreatedAt = &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: directorysyncrun.FieldCreatedAt,
		toTerm: directorysyncrun.ByCreatedAt,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DirectorySyncRunOrderFieldUpdatedAt orders DirectorySyncRun by updated_at.
	DirectorySyncRunOrderFieldUpdatedAt = &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: directorysyncrun.FieldUpdatedAt,
		toTerm: directorysyncrun.ByUpdatedAt,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// DirectorySyncRunOrderFieldStartedAt orders DirectorySyncRun by started_at.
	DirectorySyncRunOrderFieldStartedAt = &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: directorysyncrun.FieldStartedAt,
		toTerm: directorysyncrun.ByStartedAt,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DirectorySyncRunOrderField) String() string {
	var str string
	switch f.column {
	case DirectorySyncRunOrderFieldCreatedAt.column:
		str = "created_at"
	case DirectorySyncRunOrderFieldUpdatedAt.column:
		str = "updated_at"
	case DirectorySyncRunOrderFieldStartedAt.column:
		str = "started_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DirectorySyncRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DirectorySyncRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DirectorySyncRunOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DirectorySyncRunOrderFieldCreatedAt
	case "updated_at":
		*f = *DirectorySyncRunOrderFieldUpdatedAt
	case "started_at":
		*f = *DirectorySyncRunOrderFieldStartedAt
	default:
		return fmt.Errorf("%s is not a valid DirectorySyncRunOrderField", str)
	}
	return nil
}

// DirectorySyncRunOrderField defines the ordering field of DirectorySyncRun.
type DirectorySyncRunOrderField struct {
	// Value extracts the ordering value from the given DirectorySyncRun.
	Value    func(*DirectorySyncRun) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) directorysyncrun.OrderOption
	toCursor func(*DirectorySyncRun) Cursor
}

// DirectorySyncRunOrder defines the ordering of DirectorySyncRun.
type DirectorySyncRunOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DirectorySyncRunOrderField `json:"field"`
}

// DefaultDirectorySyncRunOrder is the default ordering of DirectorySyncRun.
var DefaultDirectorySyncRunOrder = &DirectorySyncRunOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DirectorySyncRunOrderField{
		Value: func(_m *DirectorySyncRun) (ent.Value, error) {
			return _m.ID, nil
		},
		column: directorysyncrun.FieldID,
		toTerm: directorysyncrun.ByID,
		toCursor: func(_m *DirectorySyncRun) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DirectorySyncRun into DirectorySyncRunEdge.
func (_m *DirectorySyncRun) ToEdge(order *DirectorySyncRunOrder) *DirectorySyncRunEdge {
	if order == nil {
		order = DefaultDirectorySyncRunOrder
	}
	return &DirectorySyncRunEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DiscussionEdge is the edge representation of Discussion.
type DiscussionEdge struct {
	Node   *Discussion `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// DiscussionConnection is the connection containing edges to Discussion.
type DiscussionConnection struct {
	Edges      []*DiscussionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *DiscussionConnection) build(nodes []*Discussion, pager *discussionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Discussion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Discussion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Discussion {
			return nodes[i]
		}
	}
	c.Edges = make([]*DiscussionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DiscussionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DiscussionPaginateOption enables pagination customization.
type DiscussionPaginateOption func(*discussionPager) error

// WithDiscussionOrder configures pagination ordering.
func WithDiscussionOrder(order []*DiscussionOrder) DiscussionPaginateOption {
	return func(pager *discussionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDiscussionFilter configures pagination filter.
func WithDiscussionFilter(filter func(*DiscussionQuery) (*DiscussionQuery, error)) DiscussionPaginateOption {
	return func(pager *discussionPager) error {
		if filter == nil {
			return errors.New("DiscussionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type discussionPager struct {
	reverse bool
	order   []*DiscussionOrder
	filter  func(*DiscussionQuery) (*DiscussionQuery, error)
}

func newDiscussionPager(opts []DiscussionPaginateOption, reverse bool) (*discussionPager, error) {
	pager := &discussionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *discussionPager) applyFilter(query *DiscussionQuery) (*DiscussionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *discussionPager) toCursor(_m *Discussion) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *discussionPager) applyCursors(query *DiscussionQuery, after, before *Cursor) (*DiscussionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDiscussionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *discussionPager) applyOrder(query *DiscussionQuery) *DiscussionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDiscussionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDiscussionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *discussionPager) orderExpr(query *DiscussionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDiscussionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Discussion.
func (_m *DiscussionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DiscussionPaginateOption,
) (*DiscussionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDiscussionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DiscussionConnection{Edges: []*DiscussionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DiscussionOrderFieldCreatedAt orders Discussion by created_at.
	DiscussionOrderFieldCreatedAt = &DiscussionOrderField{
		Value: func(_m *Discussion) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: discussion.FieldCreatedAt,
		toTerm: discussion.ByCreatedAt,
		toCursor: func(_m *Discussion) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DiscussionOrderFieldUpdatedAt orders Discussion by updated_at.
	DiscussionOrderFieldUpdatedAt = &DiscussionOrderField{
		Value: func(_m *Discussion) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: discussion.FieldUpdatedAt,
		toTerm: discussion.ByUpdatedAt,
		toCursor: func(_m *Discussion) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DiscussionOrderField) String() string {
	var str string
	switch f.column {
	case DiscussionOrderFieldCreatedAt.column:
		str = "created_at"
	case DiscussionOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DiscussionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DiscussionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DiscussionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DiscussionOrderFieldCreatedAt
	case "updated_at":
		*f = *DiscussionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DiscussionOrderField", str)
	}
	return nil
}

// DiscussionOrderField defines the ordering field of Discussion.
type DiscussionOrderField struct {
	// Value extracts the ordering value from the given Discussion.
	Value    func(*Discussion) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) discussion.OrderOption
	toCursor func(*Discussion) Cursor
}

// DiscussionOrder defines the ordering of Discussion.
type DiscussionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *DiscussionOrderField `json:"field"`
}

// DefaultDiscussionOrder is the default ordering of Discussion.
var DefaultDiscussionOrder = &DiscussionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DiscussionOrderField{
		Value: func(_m *Discussion) (ent.Value, error) {
			return _m.ID, nil
		},
		column: discussion.FieldID,
		toTerm: discussion.ByID,
		toCursor: func(_m *Discussion) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Discussion into DiscussionEdge.
func (_m *Discussion) ToEdge(order *DiscussionOrder) *DiscussionEdge {
	if order == nil {
		order = DefaultDiscussionOrder
	}
	return &DiscussionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// DocumentDataEdge is the edge representation of DocumentData.
type DocumentDataEdge struct {
	Node   *DocumentData `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// DocumentDataConnection is the connection containing edges to DocumentData.
type DocumentDataConnection struct {
	Edges      []*DocumentDataEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *DocumentDataConnection) build(nodes []*DocumentData, pager *documentdataPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *DocumentData
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentData {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentData {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentDataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentDataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentDataPaginateOption enables pagination customization.
type DocumentDataPaginateOption func(*documentdataPager) error

// WithDocumentDataOrder configures pagination ordering.
func WithDocumentDataOrder(order []*DocumentDataOrder) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithDocumentDataFilter configures pagination filter.
func WithDocumentDataFilter(filter func(*DocumentDataQuery) (*DocumentDataQuery, error)) DocumentDataPaginateOption {
	return func(pager *documentdataPager) error {
		if filter == nil {
			return errors.New("DocumentDataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentdataPager struct {
	reverse bool
	order   []*DocumentDataOrder
	filter  func(*DocumentDataQuery) (*DocumentDataQuery, error)
}

func newDocumentDataPager(opts []DocumentDataPaginateOption, reverse bool) (*documentdataPager, error) {
	pager := &documentdataPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *documentdataPager) applyFilter(query *DocumentDataQuery) (*DocumentDataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentdataPager) toCursor(_m *DocumentData) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *documentdataPager) applyCursors(query *DocumentDataQuery, after, before *Cursor) (*DocumentDataQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultDocumentDataOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *documentdataPager) applyOrder(query *DocumentDataQuery) *DocumentDataQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultDocumentDataOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultDocumentDataOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *documentdataPager) orderExpr(query *DocumentDataQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultDocumentDataOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentData.
func (_m *DocumentDataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentDataPaginateOption,
) (*DocumentDataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentDataPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &DocumentDataConnection{Edges: []*DocumentDataEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentDataOrderFieldCreatedAt orders DocumentData by created_at.
	DocumentDataOrderFieldCreatedAt = &DocumentDataOrderField{
		Value: func(_m *DocumentData) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: documentdata.FieldCreatedAt,
		toTerm: documentdata.ByCreatedAt,
		toCursor: func(_m *DocumentData) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// DocumentDataOrderFieldUpdatedAt orders DocumentData by updated_at.
	DocumentDataOrderFieldUpdatedAt = &DocumentDataOrderField{
		Value: func(_m *DocumentData) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: documentdata.FieldUpdatedAt,
		toTerm: documentdata.ByUpdatedAt,
		toCursor: func(_m *DocumentData) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentDataOrderField) String() string {
	var str string
	switch f.column {
	case DocumentDataOrderFieldCreatedAt.column:
		str = "created_at"
	case DocumentDataOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentDataOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentDataOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentDataOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *DocumentDataOrderFieldCreatedAt
	case "updated_at":
		*f = *DocumentDataOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentDataOrderField", str)
	}
	return nil
}

// DocumentDataOrderField defines the ordering field of DocumentData.
type DocumentDataOrderField struct {
	// Value extracts the ordering value from the given DocumentData.
	Value    func(*DocumentData) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentdata.OrderOption
	toCursor func(*DocumentData) Cursor
}

// DocumentDataOrder defines the ordering of DocumentData.
type DocumentDataOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *DocumentDataOrderField `json:"field"`
}

// DefaultDocumentDataOrder is the default ordering of DocumentData.
var DefaultDocumentDataOrder = &DocumentDataOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentDataOrderField{
		Value: func(_m *DocumentData) (ent.Value, error) {
			return _m.ID, nil
		},
		column: documentdata.FieldID,
		toTerm: documentdata.ByID,
		toCursor: func(_m *DocumentData) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts DocumentData into DocumentDataEdge.
func (_m *DocumentData) ToEdge(order *DocumentDataOrder) *DocumentDataEdge {
	if order == nil {
		order = DefaultDocumentDataOrder
	}
	return &DocumentDataEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityEdge is the edge representation of Entity.
type EntityEdge struct {
	Node   *Entity `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EntityConnection is the connection containing edges to Entity.
type EntityConnection struct {
	Edges      []*EntityEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *EntityConnection) build(nodes []*Entity, pager *entityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Entity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Entity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Entity {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityPaginateOption enables pagination customization.
type EntityPaginateOption func(*entityPager) error

// WithEntityOrder configures pagination ordering.
func WithEntityOrder(order []*EntityOrder) EntityPaginateOption {
	return func(pager *entityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEntityFilter configures pagination filter.
func WithEntityFilter(filter func(*EntityQuery) (*EntityQuery, error)) EntityPaginateOption {
	return func(pager *entityPager) error {
		if filter == nil {
			return errors.New("EntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityPager struct {
	reverse bool
	order   []*EntityOrder
	filter  func(*EntityQuery) (*EntityQuery, error)
}

func newEntityPager(opts []EntityPaginateOption, reverse bool) (*entityPager, error) {
	pager := &entityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *entityPager) applyFilter(query *EntityQuery) (*EntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityPager) toCursor(_m *Entity) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *entityPager) applyCursors(query *EntityQuery, after, before *Cursor) (*EntityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEntityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *entityPager) applyOrder(query *EntityQuery) *EntityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEntityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *entityPager) orderExpr(query *EntityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEntityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Entity.
func (_m *EntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityPaginateOption,
) (*EntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityConnection{Edges: []*EntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityOrderFieldCreatedAt orders Entity by created_at.
	EntityOrderFieldCreatedAt = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entity.FieldCreatedAt,
		toTerm: entity.ByCreatedAt,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityOrderFieldUpdatedAt orders Entity by updated_at.
	EntityOrderFieldUpdatedAt = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entity.FieldUpdatedAt,
		toTerm: entity.ByUpdatedAt,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityOrderFieldName orders Entity by name.
	EntityOrderFieldName = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entity.FieldName,
		toTerm: entity.ByName,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EntityOrderFieldDisplayName orders Entity by display_name.
	EntityOrderFieldDisplayName = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: entity.FieldDisplayName,
		toTerm: entity.ByDisplayName,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
	// EntityOrderFieldStatus orders Entity by status.
	EntityOrderFieldStatus = &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.Status, nil
		},
		column: entity.FieldStatus,
		toTerm: entity.ByStatus,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityOrderField) String() string {
	var str string
	switch f.column {
	case EntityOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityOrderFieldName.column:
		str = "name"
	case EntityOrderFieldDisplayName.column:
		str = "display_name"
	case EntityOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityOrderFieldUpdatedAt
	case "name":
		*f = *EntityOrderFieldName
	case "display_name":
		*f = *EntityOrderFieldDisplayName
	case "status":
		*f = *EntityOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

// EntityOrderField defines the ordering field of Entity.
type EntityOrderField struct {
	// Value extracts the ordering value from the given Entity.
	Value    func(*Entity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entity.OrderOption
	toCursor func(*Entity) Cursor
}

// EntityOrder defines the ordering of Entity.
type EntityOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EntityOrderField `json:"field"`
}

// DefaultEntityOrder is the default ordering of Entity.
var DefaultEntityOrder = &EntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityOrderField{
		Value: func(_m *Entity) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entity.FieldID,
		toTerm: entity.ByID,
		toCursor: func(_m *Entity) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Entity into EntityEdge.
func (_m *Entity) ToEdge(order *EntityOrder) *EntityEdge {
	if order == nil {
		order = DefaultEntityOrder
	}
	return &EntityEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EntityTypeEdge is the edge representation of EntityType.
type EntityTypeEdge struct {
	Node   *EntityType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// EntityTypeConnection is the connection containing edges to EntityType.
type EntityTypeConnection struct {
	Edges      []*EntityTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *EntityTypeConnection) build(nodes []*EntityType, pager *entitytypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *EntityType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityType {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityTypePaginateOption enables pagination customization.
type EntityTypePaginateOption func(*entitytypePager) error

// WithEntityTypeOrder configures pagination ordering.
func WithEntityTypeOrder(order []*EntityTypeOrder) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEntityTypeFilter configures pagination filter.
func WithEntityTypeFilter(filter func(*EntityTypeQuery) (*EntityTypeQuery, error)) EntityTypePaginateOption {
	return func(pager *entitytypePager) error {
		if filter == nil {
			return errors.New("EntityTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitytypePager struct {
	reverse bool
	order   []*EntityTypeOrder
	filter  func(*EntityTypeQuery) (*EntityTypeQuery, error)
}

func newEntityTypePager(opts []EntityTypePaginateOption, reverse bool) (*entitytypePager, error) {
	pager := &entitytypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *entitytypePager) applyFilter(query *EntityTypeQuery) (*EntityTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitytypePager) toCursor(_m *EntityType) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *entitytypePager) applyCursors(query *EntityTypeQuery, after, before *Cursor) (*EntityTypeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEntityTypeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *entitytypePager) applyOrder(query *EntityTypeQuery) *EntityTypeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEntityTypeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEntityTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *entitytypePager) orderExpr(query *EntityTypeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEntityTypeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityType.
func (_m *EntityTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityTypePaginateOption,
) (*EntityTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EntityTypeConnection{Edges: []*EntityTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityTypeOrderFieldCreatedAt orders EntityType by created_at.
	EntityTypeOrderFieldCreatedAt = &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: entitytype.FieldCreatedAt,
		toTerm: entitytype.ByCreatedAt,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EntityTypeOrderFieldUpdatedAt orders EntityType by updated_at.
	EntityTypeOrderFieldUpdatedAt = &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: entitytype.FieldUpdatedAt,
		toTerm: entitytype.ByUpdatedAt,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EntityTypeOrderFieldName orders EntityType by name.
	EntityTypeOrderFieldName = &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.Name, nil
		},
		column: entitytype.FieldName,
		toTerm: entitytype.ByName,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityTypeOrderField) String() string {
	var str string
	switch f.column {
	case EntityTypeOrderFieldCreatedAt.column:
		str = "created_at"
	case EntityTypeOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EntityTypeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityTypeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityTypeOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityTypeOrderFieldUpdatedAt
	case "name":
		*f = *EntityTypeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

// EntityTypeOrderField defines the ordering field of EntityType.
type EntityTypeOrderField struct {
	// Value extracts the ordering value from the given EntityType.
	Value    func(*EntityType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entitytype.OrderOption
	toCursor func(*EntityType) Cursor
}

// EntityTypeOrder defines the ordering of EntityType.
type EntityTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *EntityTypeOrderField `json:"field"`
}

// DefaultEntityTypeOrder is the default ordering of EntityType.
var DefaultEntityTypeOrder = &EntityTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntityTypeOrderField{
		Value: func(_m *EntityType) (ent.Value, error) {
			return _m.ID, nil
		},
		column: entitytype.FieldID,
		toTerm: entitytype.ByID,
		toCursor: func(_m *EntityType) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts EntityType into EntityTypeEdge.
func (_m *EntityType) ToEdge(order *EntityTypeOrder) *EntityTypeEdge {
	if order == nil {
		order = DefaultEntityTypeOrder
	}
	return &EntityTypeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EventConnection) build(nodes []*Event, pager *eventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order []*EventOrder) EventPaginateOption {
	return func(pager *eventPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	reverse bool
	order   []*EventOrder
	filter  func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption, reverse bool) (*eventPager, error) {
	pager := &eventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(_m *Event) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) (*EventQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEventOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *eventPager) applyOrder(query *EventQuery) *EventQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEventOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *eventPager) orderExpr(query *EventQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEventOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (_m *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EventConnection{Edges: []*EventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EventOrderFieldCreatedAt orders Event by created_at.
	EventOrderFieldCreatedAt = &EventOrderField{
		Value: func(_m *Event) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: event.FieldCreatedAt,
		toTerm: event.ByCreatedAt,
		toCursor: func(_m *Event) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EventOrderFieldUpdatedAt orders Event by updated_at.
	EventOrderFieldUpdatedAt = &EventOrderField{
		Value: func(_m *Event) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: event.FieldUpdatedAt,
		toTerm: event.ByUpdatedAt,
		toCursor: func(_m *Event) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventOrderField) String() string {
	var str string
	switch f.column {
	case EventOrderFieldCreatedAt.column:
		str = "created_at"
	case EventOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EventOrderFieldCreatedAt
	case "updated_at":
		*f = *EventOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid EventOrderField", str)
	}
	return nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	// Value extracts the ordering value from the given Event.
	Value    func(*Event) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) event.OrderOption
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EventOrderField{
		Value: func(_m *Event) (ent.Value, error) {
			return _m.ID, nil
		},
		column: event.FieldID,
		toTerm: event.ByID,
		toCursor: func(_m *Event) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (_m *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// EvidenceEdge is the edge representation of Evidence.
type EvidenceEdge struct {
	Node   *Evidence `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// EvidenceConnection is the connection containing edges to Evidence.
type EvidenceConnection struct {
	Edges      []*EvidenceEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *EvidenceConnection) build(nodes []*Evidence, pager *evidencePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Evidence
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Evidence {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Evidence {
			return nodes[i]
		}
	}
	c.Edges = make([]*EvidenceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EvidenceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EvidencePaginateOption enables pagination customization.
type EvidencePaginateOption func(*evidencePager) error

// WithEvidenceOrder configures pagination ordering.
func WithEvidenceOrder(order []*EvidenceOrder) EvidencePaginateOption {
	return func(pager *evidencePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithEvidenceFilter configures pagination filter.
func WithEvidenceFilter(filter func(*EvidenceQuery) (*EvidenceQuery, error)) EvidencePaginateOption {
	return func(pager *evidencePager) error {
		if filter == nil {
			return errors.New("EvidenceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type evidencePager struct {
	reverse bool
	order   []*EvidenceOrder
	filter  func(*EvidenceQuery) (*EvidenceQuery, error)
}

func newEvidencePager(opts []EvidencePaginateOption, reverse bool) (*evidencePager, error) {
	pager := &evidencePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *evidencePager) applyFilter(query *EvidenceQuery) (*EvidenceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *evidencePager) toCursor(_m *Evidence) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *evidencePager) applyCursors(query *EvidenceQuery, after, before *Cursor) (*EvidenceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultEvidenceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *evidencePager) applyOrder(query *EvidenceQuery) *EvidenceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultEvidenceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultEvidenceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *evidencePager) orderExpr(query *EvidenceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultEvidenceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Evidence.
func (_m *EvidenceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EvidencePaginateOption,
) (*EvidenceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEvidencePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &EvidenceConnection{Edges: []*EvidenceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EvidenceOrderFieldCreatedAt orders Evidence by created_at.
	EvidenceOrderFieldCreatedAt = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: evidence.FieldCreatedAt,
		toTerm: evidence.ByCreatedAt,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// EvidenceOrderFieldUpdatedAt orders Evidence by updated_at.
	EvidenceOrderFieldUpdatedAt = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: evidence.FieldUpdatedAt,
		toTerm: evidence.ByUpdatedAt,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// EvidenceOrderFieldName orders Evidence by name.
	EvidenceOrderFieldName = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.Name, nil
		},
		column: evidence.FieldName,
		toTerm: evidence.ByName,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// EvidenceOrderFieldCreationDate orders Evidence by creation_date.
	EvidenceOrderFieldCreationDate = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.CreationDate, nil
		},
		column: evidence.FieldCreationDate,
		toTerm: evidence.ByCreationDate,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreationDate,
			}
		},
	}
	// EvidenceOrderFieldRenewalDate orders Evidence by renewal_date.
	EvidenceOrderFieldRenewalDate = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.RenewalDate, nil
		},
		column: evidence.FieldRenewalDate,
		toTerm: evidence.ByRenewalDate,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RenewalDate,
			}
		},
	}
	// EvidenceOrderFieldStatus orders Evidence by status.
	EvidenceOrderFieldStatus = &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.Status, nil
		},
		column: evidence.FieldStatus,
		toTerm: evidence.ByStatus,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EvidenceOrderField) String() string {
	var str string
	switch f.column {
	case EvidenceOrderFieldCreatedAt.column:
		str = "created_at"
	case EvidenceOrderFieldUpdatedAt.column:
		str = "updated_at"
	case EvidenceOrderFieldName.column:
		str = "name"
	case EvidenceOrderFieldCreationDate.column:
		str = "creation_date"
	case EvidenceOrderFieldRenewalDate.column:
		str = "renewal_date"
	case EvidenceOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EvidenceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EvidenceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EvidenceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EvidenceOrderFieldCreatedAt
	case "updated_at":
		*f = *EvidenceOrderFieldUpdatedAt
	case "name":
		*f = *EvidenceOrderFieldName
	case "creation_date":
		*f = *EvidenceOrderFieldCreationDate
	case "renewal_date":
		*f = *EvidenceOrderFieldRenewalDate
	case "STATUS":
		*f = *EvidenceOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid EvidenceOrderField", str)
	}
	return nil
}

// EvidenceOrderField defines the ordering field of Evidence.
type EvidenceOrderField struct {
	// Value extracts the ordering value from the given Evidence.
	Value    func(*Evidence) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) evidence.OrderOption
	toCursor func(*Evidence) Cursor
}

// EvidenceOrder defines the ordering of Evidence.
type EvidenceOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *EvidenceOrderField `json:"field"`
}

// DefaultEvidenceOrder is the default ordering of Evidence.
var DefaultEvidenceOrder = &EvidenceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EvidenceOrderField{
		Value: func(_m *Evidence) (ent.Value, error) {
			return _m.ID, nil
		},
		column: evidence.FieldID,
		toTerm: evidence.ByID,
		toCursor: func(_m *Evidence) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Evidence into EvidenceEdge.
func (_m *Evidence) ToEdge(order *EvidenceOrder) *EvidenceEdge {
	if order == nil {
		order = DefaultEvidenceOrder
	}
	return &EvidenceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ExportEdge is the edge representation of Export.
type ExportEdge struct {
	Node   *Export `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ExportConnection is the connection containing edges to Export.
type ExportConnection struct {
	Edges      []*ExportEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ExportConnection) build(nodes []*Export, pager *exportPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Export
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Export {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Export {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExportEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExportEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExportPaginateOption enables pagination customization.
type ExportPaginateOption func(*exportPager) error

// WithExportOrder configures pagination ordering.
func WithExportOrder(order []*ExportOrder) ExportPaginateOption {
	return func(pager *exportPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithExportFilter configures pagination filter.
func WithExportFilter(filter func(*ExportQuery) (*ExportQuery, error)) ExportPaginateOption {
	return func(pager *exportPager) error {
		if filter == nil {
			return errors.New("ExportQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exportPager struct {
	reverse bool
	order   []*ExportOrder
	filter  func(*ExportQuery) (*ExportQuery, error)
}

func newExportPager(opts []ExportPaginateOption, reverse bool) (*exportPager, error) {
	pager := &exportPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *exportPager) applyFilter(query *ExportQuery) (*ExportQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exportPager) toCursor(_m *Export) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *exportPager) applyCursors(query *ExportQuery, after, before *Cursor) (*ExportQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultExportOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *exportPager) applyOrder(query *ExportQuery) *ExportQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultExportOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultExportOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *exportPager) orderExpr(query *ExportQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultExportOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Export.
func (_m *ExportQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExportPaginateOption,
) (*ExportConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExportPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ExportConnection{Edges: []*ExportEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ExportOrderFieldCreatedAt orders Export by created_at.
	ExportOrderFieldCreatedAt = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: export.FieldCreatedAt,
		toTerm: export.ByCreatedAt,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ExportOrderFieldUpdatedAt orders Export by updated_at.
	ExportOrderFieldUpdatedAt = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: export.FieldUpdatedAt,
		toTerm: export.ByUpdatedAt,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ExportOrderFieldExportType orders Export by export_type.
	ExportOrderFieldExportType = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.ExportType, nil
		},
		column: export.FieldExportType,
		toTerm: export.ByExportType,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExportType,
			}
		},
	}
	// ExportOrderFieldFormat orders Export by format.
	ExportOrderFieldFormat = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.Format, nil
		},
		column: export.FieldFormat,
		toTerm: export.ByFormat,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Format,
			}
		},
	}
	// ExportOrderFieldStatus orders Export by status.
	ExportOrderFieldStatus = &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.Status, nil
		},
		column: export.FieldStatus,
		toTerm: export.ByStatus,
		toCursor: func(_m *Export) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ExportOrderField) String() string {
	var str string
	switch f.column {
	case ExportOrderFieldCreatedAt.column:
		str = "created_at"
	case ExportOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ExportOrderFieldExportType.column:
		str = "export_type"
	case ExportOrderFieldFormat.column:
		str = "format"
	case ExportOrderFieldStatus.column:
		str = "status"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ExportOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ExportOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ExportOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ExportOrderFieldCreatedAt
	case "updated_at":
		*f = *ExportOrderFieldUpdatedAt
	case "export_type":
		*f = *ExportOrderFieldExportType
	case "format":
		*f = *ExportOrderFieldFormat
	case "status":
		*f = *ExportOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ExportOrderField", str)
	}
	return nil
}

// ExportOrderField defines the ordering field of Export.
type ExportOrderField struct {
	// Value extracts the ordering value from the given Export.
	Value    func(*Export) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) export.OrderOption
	toCursor func(*Export) Cursor
}

// ExportOrder defines the ordering of Export.
type ExportOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ExportOrderField `json:"field"`
}

// DefaultExportOrder is the default ordering of Export.
var DefaultExportOrder = &ExportOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExportOrderField{
		Value: func(_m *Export) (ent.Value, error) {
			return _m.ID, nil
		},
		column: export.FieldID,
		toTerm: export.ByID,
		toCursor: func(_m *Export) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Export into ExportEdge.
func (_m *Export) ToEdge(order *ExportOrder) *ExportEdge {
	if order == nil {
		order = DefaultExportOrder
	}
	return &ExportEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order []*FileOrder) FilePaginateOption {
	return func(pager *filePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   []*FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(_m *File) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFileOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFileOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (_m *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FileOrderFieldCreatedAt orders File by created_at.
	FileOrderFieldCreatedAt = &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: file.FieldCreatedAt,
		toTerm: file.ByCreatedAt,
		toCursor: func(_m *File) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FileOrderFieldUpdatedAt orders File by updated_at.
	FileOrderFieldUpdatedAt = &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: file.FieldUpdatedAt,
		toTerm: file.ByUpdatedAt,
		toCursor: func(_m *File) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FileOrderFieldLastAccessedAt orders File by last_accessed_at.
	FileOrderFieldLastAccessedAt = &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastAccessedAt == nil {
				return nil, nil
			}
			return _m.LastAccessedAt, nil
		},
		column: file.FieldLastAccessedAt,
		toTerm: func(opts ...sql.OrderTermOption) file.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return file.ByLastAccessedAt(opts...)
		},
		toCursor: func(_m *File) Cursor {
			if _m.LastAccessedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastAccessedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FileOrderField) String() string {
	var str string
	switch f.column {
	case FileOrderFieldCreatedAt.column:
		str = "created_at"
	case FileOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FileOrderFieldLastAccessedAt.column:
		str = "last_accessed_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FileOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FileOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FileOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FileOrderFieldCreatedAt
	case "updated_at":
		*f = *FileOrderFieldUpdatedAt
	case "last_accessed_at":
		*f = *FileOrderFieldLastAccessedAt
	default:
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(_m *File) (ent.Value, error) {
			return _m.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(_m *File) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (_m *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingEdge is the edge representation of Finding.
type FindingEdge struct {
	Node   *Finding `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FindingConnection is the connection containing edges to Finding.
type FindingConnection struct {
	Edges      []*FindingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *FindingConnection) build(nodes []*Finding, pager *findingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Finding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Finding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Finding {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingPaginateOption enables pagination customization.
type FindingPaginateOption func(*findingPager) error

// WithFindingOrder configures pagination ordering.
func WithFindingOrder(order []*FindingOrder) FindingPaginateOption {
	return func(pager *findingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFindingFilter configures pagination filter.
func WithFindingFilter(filter func(*FindingQuery) (*FindingQuery, error)) FindingPaginateOption {
	return func(pager *findingPager) error {
		if filter == nil {
			return errors.New("FindingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingPager struct {
	reverse bool
	order   []*FindingOrder
	filter  func(*FindingQuery) (*FindingQuery, error)
}

func newFindingPager(opts []FindingPaginateOption, reverse bool) (*findingPager, error) {
	pager := &findingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *findingPager) applyFilter(query *FindingQuery) (*FindingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingPager) toCursor(_m *Finding) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *findingPager) applyCursors(query *FindingQuery, after, before *Cursor) (*FindingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFindingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *findingPager) applyOrder(query *FindingQuery) *FindingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFindingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFindingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *findingPager) orderExpr(query *FindingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFindingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Finding.
func (_m *FindingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingPaginateOption,
) (*FindingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingConnection{Edges: []*FindingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingOrderFieldCreatedAt orders Finding by created_at.
	FindingOrderFieldCreatedAt = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: finding.FieldCreatedAt,
		toTerm: finding.ByCreatedAt,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingOrderFieldUpdatedAt orders Finding by updated_at.
	FindingOrderFieldUpdatedAt = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: finding.FieldUpdatedAt,
		toTerm: finding.ByUpdatedAt,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// FindingOrderFieldExternalID orders Finding by external_id.
	FindingOrderFieldExternalID = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: finding.FieldExternalID,
		toTerm: finding.ByExternalID,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// FindingOrderFieldExternalOwnerID orders Finding by external_owner_id.
	FindingOrderFieldExternalOwnerID = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: finding.FieldExternalOwnerID,
		toTerm: finding.ByExternalOwnerID,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// FindingOrderFieldCategory orders Finding by category.
	FindingOrderFieldCategory = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.Category, nil
		},
		column: finding.FieldCategory,
		toTerm: finding.ByCategory,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// FindingOrderFieldSeverity orders Finding by severity.
	FindingOrderFieldSeverity = &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: finding.FieldSeverity,
		toTerm: finding.BySeverity,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingOrderField) String() string {
	var str string
	switch f.column {
	case FindingOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingOrderFieldUpdatedAt.column:
		str = "updated_at"
	case FindingOrderFieldExternalID.column:
		str = "external_id"
	case FindingOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case FindingOrderFieldCategory.column:
		str = "category"
	case FindingOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FindingOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingOrderFieldUpdatedAt
	case "external_id":
		*f = *FindingOrderFieldExternalID
	case "external_owner_id":
		*f = *FindingOrderFieldExternalOwnerID
	case "category":
		*f = *FindingOrderFieldCategory
	case "severity":
		*f = *FindingOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid FindingOrderField", str)
	}
	return nil
}

// FindingOrderField defines the ordering field of Finding.
type FindingOrderField struct {
	// Value extracts the ordering value from the given Finding.
	Value    func(*Finding) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) finding.OrderOption
	toCursor func(*Finding) Cursor
}

// FindingOrder defines the ordering of Finding.
type FindingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FindingOrderField `json:"field"`
}

// DefaultFindingOrder is the default ordering of Finding.
var DefaultFindingOrder = &FindingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingOrderField{
		Value: func(_m *Finding) (ent.Value, error) {
			return _m.ID, nil
		},
		column: finding.FieldID,
		toTerm: finding.ByID,
		toCursor: func(_m *Finding) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Finding into FindingEdge.
func (_m *Finding) ToEdge(order *FindingOrder) *FindingEdge {
	if order == nil {
		order = DefaultFindingOrder
	}
	return &FindingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// FindingControlEdge is the edge representation of FindingControl.
type FindingControlEdge struct {
	Node   *FindingControl `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// FindingControlConnection is the connection containing edges to FindingControl.
type FindingControlConnection struct {
	Edges      []*FindingControlEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *FindingControlConnection) build(nodes []*FindingControl, pager *findingcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *FindingControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FindingControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FindingControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingControlPaginateOption enables pagination customization.
type FindingControlPaginateOption func(*findingcontrolPager) error

// WithFindingControlOrder configures pagination ordering.
func WithFindingControlOrder(order []*FindingControlOrder) FindingControlPaginateOption {
	return func(pager *findingcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithFindingControlFilter configures pagination filter.
func WithFindingControlFilter(filter func(*FindingControlQuery) (*FindingControlQuery, error)) FindingControlPaginateOption {
	return func(pager *findingcontrolPager) error {
		if filter == nil {
			return errors.New("FindingControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingcontrolPager struct {
	reverse bool
	order   []*FindingControlOrder
	filter  func(*FindingControlQuery) (*FindingControlQuery, error)
}

func newFindingControlPager(opts []FindingControlPaginateOption, reverse bool) (*findingcontrolPager, error) {
	pager := &findingcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *findingcontrolPager) applyFilter(query *FindingControlQuery) (*FindingControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingcontrolPager) toCursor(_m *FindingControl) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *findingcontrolPager) applyCursors(query *FindingControlQuery, after, before *Cursor) (*FindingControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultFindingControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *findingcontrolPager) applyOrder(query *FindingControlQuery) *FindingControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultFindingControlOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultFindingControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *findingcontrolPager) orderExpr(query *FindingControlQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultFindingControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to FindingControl.
func (_m *FindingControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingControlPaginateOption,
) (*FindingControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &FindingControlConnection{Edges: []*FindingControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FindingControlOrderFieldCreatedAt orders FindingControl by created_at.
	FindingControlOrderFieldCreatedAt = &FindingControlOrderField{
		Value: func(_m *FindingControl) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: findingcontrol.FieldCreatedAt,
		toTerm: findingcontrol.ByCreatedAt,
		toCursor: func(_m *FindingControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// FindingControlOrderFieldUpdatedAt orders FindingControl by updated_at.
	FindingControlOrderFieldUpdatedAt = &FindingControlOrderField{
		Value: func(_m *FindingControl) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: findingcontrol.FieldUpdatedAt,
		toTerm: findingcontrol.ByUpdatedAt,
		toCursor: func(_m *FindingControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FindingControlOrderField) String() string {
	var str string
	switch f.column {
	case FindingControlOrderFieldCreatedAt.column:
		str = "created_at"
	case FindingControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FindingControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FindingControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FindingControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *FindingControlOrderFieldCreatedAt
	case "updated_at":
		*f = *FindingControlOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FindingControlOrderField", str)
	}
	return nil
}

// FindingControlOrderField defines the ordering field of FindingControl.
type FindingControlOrderField struct {
	// Value extracts the ordering value from the given FindingControl.
	Value    func(*FindingControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) findingcontrol.OrderOption
	toCursor func(*FindingControl) Cursor
}

// FindingControlOrder defines the ordering of FindingControl.
type FindingControlOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *FindingControlOrderField `json:"field"`
}

// DefaultFindingControlOrder is the default ordering of FindingControl.
var DefaultFindingControlOrder = &FindingControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingControlOrderField{
		Value: func(_m *FindingControl) (ent.Value, error) {
			return _m.ID, nil
		},
		column: findingcontrol.FieldID,
		toTerm: findingcontrol.ByID,
		toCursor: func(_m *FindingControl) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts FindingControl into FindingControlEdge.
func (_m *FindingControl) ToEdge(order *FindingControlOrder) *FindingControlEdge {
	if order == nil {
		order = DefaultFindingControlOrder
	}
	return &FindingControlEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupEdge is the edge representation of Group.
type GroupEdge struct {
	Node   *Group `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GroupConnection is the connection containing edges to Group.
type GroupConnection struct {
	Edges      []*GroupEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *GroupConnection) build(nodes []*Group, pager *groupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Group
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Group {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Group {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupPaginateOption enables pagination customization.
type GroupPaginateOption func(*groupPager) error

// WithGroupOrder configures pagination ordering.
func WithGroupOrder(order []*GroupOrder) GroupPaginateOption {
	return func(pager *groupPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupFilter configures pagination filter.
func WithGroupFilter(filter func(*GroupQuery) (*GroupQuery, error)) GroupPaginateOption {
	return func(pager *groupPager) error {
		if filter == nil {
			return errors.New("GroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupPager struct {
	reverse bool
	order   []*GroupOrder
	filter  func(*GroupQuery) (*GroupQuery, error)
}

func newGroupPager(opts []GroupPaginateOption, reverse bool) (*groupPager, error) {
	pager := &groupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupPager) applyFilter(query *GroupQuery) (*GroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupPager) toCursor(_m *Group) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *groupPager) applyCursors(query *GroupQuery, after, before *Cursor) (*GroupQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupPager) applyOrder(query *GroupQuery) *GroupQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupPager) orderExpr(query *GroupQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Group.
func (_m *GroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupPaginateOption,
) (*GroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupConnection{Edges: []*GroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupOrderFieldCreatedAt orders Group by created_at.
	GroupOrderFieldCreatedAt = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: group.FieldCreatedAt,
		toTerm: group.ByCreatedAt,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupOrderFieldUpdatedAt orders Group by updated_at.
	GroupOrderFieldUpdatedAt = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: group.FieldUpdatedAt,
		toTerm: group.ByUpdatedAt,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupOrderFieldName orders Group by name.
	GroupOrderFieldName = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.Name, nil
		},
		column: group.FieldName,
		toTerm: group.ByName,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// GroupOrderFieldDisplayName orders Group by display_name.
	GroupOrderFieldDisplayName = &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: group.FieldDisplayName,
		toTerm: group.ByDisplayName,
		toCursor: func(_m *Group) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupOrderField) String() string {
	var str string
	switch f.column {
	case GroupOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupOrderFieldName.column:
		str = "name"
	case GroupOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupOrderFieldUpdatedAt
	case "name":
		*f = *GroupOrderFieldName
	case "display_name":
		*f = *GroupOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

// GroupOrderField defines the ordering field of Group.
type GroupOrderField struct {
	// Value extracts the ordering value from the given Group.
	Value    func(*Group) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) group.OrderOption
	toCursor func(*Group) Cursor
}

// GroupOrder defines the ordering of Group.
type GroupOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *GroupOrderField `json:"field"`
}

// DefaultGroupOrder is the default ordering of Group.
var DefaultGroupOrder = &GroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupOrderField{
		Value: func(_m *Group) (ent.Value, error) {
			return _m.ID, nil
		},
		column: group.FieldID,
		toTerm: group.ByID,
		toCursor: func(_m *Group) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Group into GroupEdge.
func (_m *Group) ToEdge(order *GroupOrder) *GroupEdge {
	if order == nil {
		order = DefaultGroupOrder
	}
	return &GroupEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupMembershipEdge is the edge representation of GroupMembership.
type GroupMembershipEdge struct {
	Node   *GroupMembership `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// GroupMembershipConnection is the connection containing edges to GroupMembership.
type GroupMembershipConnection struct {
	Edges      []*GroupMembershipEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *GroupMembershipConnection) build(nodes []*GroupMembership, pager *groupmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipPaginateOption enables pagination customization.
type GroupMembershipPaginateOption func(*groupmembershipPager) error

// WithGroupMembershipOrder configures pagination ordering.
func WithGroupMembershipOrder(order []*GroupMembershipOrder) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupMembershipFilter configures pagination filter.
func WithGroupMembershipFilter(filter func(*GroupMembershipQuery) (*GroupMembershipQuery, error)) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		if filter == nil {
			return errors.New("GroupMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershipPager struct {
	reverse bool
	order   []*GroupMembershipOrder
	filter  func(*GroupMembershipQuery) (*GroupMembershipQuery, error)
}

func newGroupMembershipPager(opts []GroupMembershipPaginateOption, reverse bool) (*groupmembershipPager, error) {
	pager := &groupmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupmembershipPager) applyFilter(query *GroupMembershipQuery) (*GroupMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershipPager) toCursor(_m *GroupMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *groupmembershipPager) applyCursors(query *GroupMembershipQuery, after, before *Cursor) (*GroupMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupmembershipPager) applyOrder(query *GroupMembershipQuery) *GroupMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupmembershipPager) orderExpr(query *GroupMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembership.
func (_m *GroupMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipPaginateOption,
) (*GroupMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupMembershipConnection{Edges: []*GroupMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupMembershipOrderFieldCreatedAt orders GroupMembership by created_at.
	GroupMembershipOrderFieldCreatedAt = &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupmembership.FieldCreatedAt,
		toTerm: groupmembership.ByCreatedAt,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupMembershipOrderFieldUpdatedAt orders GroupMembership by updated_at.
	GroupMembershipOrderFieldUpdatedAt = &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupmembership.FieldUpdatedAt,
		toTerm: groupmembership.ByUpdatedAt,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// GroupMembershipOrderFieldRole orders GroupMembership by role.
	GroupMembershipOrderFieldRole = &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.Role, nil
		},
		column: groupmembership.FieldRole,
		toTerm: groupmembership.ByRole,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupMembershipOrderField) String() string {
	var str string
	switch f.column {
	case GroupMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case GroupMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *GroupMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid GroupMembershipOrderField", str)
	}
	return nil
}

// GroupMembershipOrderField defines the ordering field of GroupMembership.
type GroupMembershipOrderField struct {
	// Value extracts the ordering value from the given GroupMembership.
	Value    func(*GroupMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembership.OrderOption
	toCursor func(*GroupMembership) Cursor
}

// GroupMembershipOrder defines the ordering of GroupMembership.
type GroupMembershipOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *GroupMembershipOrderField `json:"field"`
}

// DefaultGroupMembershipOrder is the default ordering of GroupMembership.
var DefaultGroupMembershipOrder = &GroupMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipOrderField{
		Value: func(_m *GroupMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupmembership.FieldID,
		toTerm: groupmembership.ByID,
		toCursor: func(_m *GroupMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupMembership into GroupMembershipEdge.
func (_m *GroupMembership) ToEdge(order *GroupMembershipOrder) *GroupMembershipEdge {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	return &GroupMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// GroupSettingEdge is the edge representation of GroupSetting.
type GroupSettingEdge struct {
	Node   *GroupSetting `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// GroupSettingConnection is the connection containing edges to GroupSetting.
type GroupSettingConnection struct {
	Edges      []*GroupSettingEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *GroupSettingConnection) build(nodes []*GroupSetting, pager *groupsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *GroupSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingPaginateOption enables pagination customization.
type GroupSettingPaginateOption func(*groupsettingPager) error

// WithGroupSettingOrder configures pagination ordering.
func WithGroupSettingOrder(order []*GroupSettingOrder) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithGroupSettingFilter configures pagination filter.
func WithGroupSettingFilter(filter func(*GroupSettingQuery) (*GroupSettingQuery, error)) GroupSettingPaginateOption {
	return func(pager *groupsettingPager) error {
		if filter == nil {
			return errors.New("GroupSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettingPager struct {
	reverse bool
	order   []*GroupSettingOrder
	filter  func(*GroupSettingQuery) (*GroupSettingQuery, error)
}

func newGroupSettingPager(opts []GroupSettingPaginateOption, reverse bool) (*groupsettingPager, error) {
	pager := &groupsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *groupsettingPager) applyFilter(query *GroupSettingQuery) (*GroupSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettingPager) toCursor(_m *GroupSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *groupsettingPager) applyCursors(query *GroupSettingQuery, after, before *Cursor) (*GroupSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultGroupSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *groupsettingPager) applyOrder(query *GroupSettingQuery) *GroupSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultGroupSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultGroupSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *groupsettingPager) orderExpr(query *GroupSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultGroupSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSetting.
func (_m *GroupSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingPaginateOption,
) (*GroupSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &GroupSettingConnection{Edges: []*GroupSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GroupSettingOrderFieldCreatedAt orders GroupSetting by created_at.
	GroupSettingOrderFieldCreatedAt = &GroupSettingOrderField{
		Value: func(_m *GroupSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: groupsetting.FieldCreatedAt,
		toTerm: groupsetting.ByCreatedAt,
		toCursor: func(_m *GroupSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// GroupSettingOrderFieldUpdatedAt orders GroupSetting by updated_at.
	GroupSettingOrderFieldUpdatedAt = &GroupSettingOrderField{
		Value: func(_m *GroupSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: groupsetting.FieldUpdatedAt,
		toTerm: groupsetting.ByUpdatedAt,
		toCursor: func(_m *GroupSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GroupSettingOrderField) String() string {
	var str string
	switch f.column {
	case GroupSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case GroupSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GroupSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GroupSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GroupSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *GroupSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *GroupSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid GroupSettingOrderField", str)
	}
	return nil
}

// GroupSettingOrderField defines the ordering field of GroupSetting.
type GroupSettingOrderField struct {
	// Value extracts the ordering value from the given GroupSetting.
	Value    func(*GroupSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsetting.OrderOption
	toCursor func(*GroupSetting) Cursor
}

// GroupSettingOrder defines the ordering of GroupSetting.
type GroupSettingOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *GroupSettingOrderField `json:"field"`
}

// DefaultGroupSettingOrder is the default ordering of GroupSetting.
var DefaultGroupSettingOrder = &GroupSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingOrderField{
		Value: func(_m *GroupSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: groupsetting.FieldID,
		toTerm: groupsetting.ByID,
		toCursor: func(_m *GroupSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts GroupSetting into GroupSettingEdge.
func (_m *GroupSetting) ToEdge(order *GroupSettingOrder) *GroupSettingEdge {
	if order == nil {
		order = DefaultGroupSettingOrder
	}
	return &GroupSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// HushEdge is the edge representation of Hush.
type HushEdge struct {
	Node   *Hush  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HushConnection is the connection containing edges to Hush.
type HushConnection struct {
	Edges      []*HushEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *HushConnection) build(nodes []*Hush, pager *hushPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Hush
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Hush {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Hush {
			return nodes[i]
		}
	}
	c.Edges = make([]*HushEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HushEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HushPaginateOption enables pagination customization.
type HushPaginateOption func(*hushPager) error

// WithHushOrder configures pagination ordering.
func WithHushOrder(order []*HushOrder) HushPaginateOption {
	return func(pager *hushPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithHushFilter configures pagination filter.
func WithHushFilter(filter func(*HushQuery) (*HushQuery, error)) HushPaginateOption {
	return func(pager *hushPager) error {
		if filter == nil {
			return errors.New("HushQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hushPager struct {
	reverse bool
	order   []*HushOrder
	filter  func(*HushQuery) (*HushQuery, error)
}

func newHushPager(opts []HushPaginateOption, reverse bool) (*hushPager, error) {
	pager := &hushPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *hushPager) applyFilter(query *HushQuery) (*HushQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hushPager) toCursor(_m *Hush) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *hushPager) applyCursors(query *HushQuery, after, before *Cursor) (*HushQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultHushOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *hushPager) applyOrder(query *HushQuery) *HushQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultHushOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultHushOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *hushPager) orderExpr(query *HushQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultHushOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Hush.
func (_m *HushQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HushPaginateOption,
) (*HushConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHushPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &HushConnection{Edges: []*HushEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HushOrderFieldCreatedAt orders Hush by created_at.
	HushOrderFieldCreatedAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: hush.FieldCreatedAt,
		toTerm: hush.ByCreatedAt,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// HushOrderFieldUpdatedAt orders Hush by updated_at.
	HushOrderFieldUpdatedAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: hush.FieldUpdatedAt,
		toTerm: hush.ByUpdatedAt,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// HushOrderFieldName orders Hush by name.
	HushOrderFieldName = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.Name, nil
		},
		column: hush.FieldName,
		toTerm: hush.ByName,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// HushOrderFieldKind orders Hush by kind.
	HushOrderFieldKind = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: hush.FieldKind,
		toTerm: hush.ByKind,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// HushOrderFieldLastUsedAt orders Hush by last_used_at.
	HushOrderFieldLastUsedAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: hush.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) hush.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hush.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *Hush) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// HushOrderFieldExpiresAt orders Hush by expires_at.
	HushOrderFieldExpiresAt = &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: hush.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) hush.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return hush.ByExpiresAt(opts...)
		},
		toCursor: func(_m *Hush) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HushOrderField) String() string {
	var str string
	switch f.column {
	case HushOrderFieldCreatedAt.column:
		str = "created_at"
	case HushOrderFieldUpdatedAt.column:
		str = "updated_at"
	case HushOrderFieldName.column:
		str = "name"
	case HushOrderFieldKind.column:
		str = "kind"
	case HushOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case HushOrderFieldExpiresAt.column:
		str = "expires_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HushOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HushOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HushOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HushOrderFieldCreatedAt
	case "updated_at":
		*f = *HushOrderFieldUpdatedAt
	case "name":
		*f = *HushOrderFieldName
	case "kind":
		*f = *HushOrderFieldKind
	case "last_used_at":
		*f = *HushOrderFieldLastUsedAt
	case "expires_at":
		*f = *HushOrderFieldExpiresAt
	default:
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

// HushOrderField defines the ordering field of Hush.
type HushOrderField struct {
	// Value extracts the ordering value from the given Hush.
	Value    func(*Hush) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hush.OrderOption
	toCursor func(*Hush) Cursor
}

// HushOrder defines the ordering of Hush.
type HushOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HushOrderField `json:"field"`
}

// DefaultHushOrder is the default ordering of Hush.
var DefaultHushOrder = &HushOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HushOrderField{
		Value: func(_m *Hush) (ent.Value, error) {
			return _m.ID, nil
		},
		column: hush.FieldID,
		toTerm: hush.ByID,
		toCursor: func(_m *Hush) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Hush into HushEdge.
func (_m *Hush) ToEdge(order *HushOrder) *HushEdge {
	if order == nil {
		order = DefaultHushOrder
	}
	return &HushEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// IntegrationEdge is the edge representation of Integration.
type IntegrationEdge struct {
	Node   *Integration `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// IntegrationConnection is the connection containing edges to Integration.
type IntegrationConnection struct {
	Edges      []*IntegrationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *IntegrationConnection) build(nodes []*Integration, pager *integrationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Integration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Integration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Integration {
			return nodes[i]
		}
	}
	c.Edges = make([]*IntegrationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IntegrationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IntegrationPaginateOption enables pagination customization.
type IntegrationPaginateOption func(*integrationPager) error

// WithIntegrationOrder configures pagination ordering.
func WithIntegrationOrder(order []*IntegrationOrder) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithIntegrationFilter configures pagination filter.
func WithIntegrationFilter(filter func(*IntegrationQuery) (*IntegrationQuery, error)) IntegrationPaginateOption {
	return func(pager *integrationPager) error {
		if filter == nil {
			return errors.New("IntegrationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type integrationPager struct {
	reverse bool
	order   []*IntegrationOrder
	filter  func(*IntegrationQuery) (*IntegrationQuery, error)
}

func newIntegrationPager(opts []IntegrationPaginateOption, reverse bool) (*integrationPager, error) {
	pager := &integrationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *integrationPager) applyFilter(query *IntegrationQuery) (*IntegrationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *integrationPager) toCursor(_m *Integration) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *integrationPager) applyCursors(query *IntegrationQuery, after, before *Cursor) (*IntegrationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultIntegrationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *integrationPager) applyOrder(query *IntegrationQuery) *IntegrationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultIntegrationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultIntegrationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *integrationPager) orderExpr(query *IntegrationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultIntegrationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Integration.
func (_m *IntegrationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IntegrationPaginateOption,
) (*IntegrationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIntegrationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &IntegrationConnection{Edges: []*IntegrationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IntegrationOrderFieldCreatedAt orders Integration by created_at.
	IntegrationOrderFieldCreatedAt = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: integration.FieldCreatedAt,
		toTerm: integration.ByCreatedAt,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// IntegrationOrderFieldUpdatedAt orders Integration by updated_at.
	IntegrationOrderFieldUpdatedAt = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: integration.FieldUpdatedAt,
		toTerm: integration.ByUpdatedAt,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// IntegrationOrderFieldName orders Integration by name.
	IntegrationOrderFieldName = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.Name, nil
		},
		column: integration.FieldName,
		toTerm: integration.ByName,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// IntegrationOrderFieldKind orders Integration by kind.
	IntegrationOrderFieldKind = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: integration.FieldKind,
		toTerm: integration.ByKind,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
	// IntegrationOrderFieldIntegrationType orders Integration by integration_type.
	IntegrationOrderFieldIntegrationType = &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.IntegrationType, nil
		},
		column: integration.FieldIntegrationType,
		toTerm: integration.ByIntegrationType,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IntegrationType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IntegrationOrderField) String() string {
	var str string
	switch f.column {
	case IntegrationOrderFieldCreatedAt.column:
		str = "created_at"
	case IntegrationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case IntegrationOrderFieldName.column:
		str = "name"
	case IntegrationOrderFieldKind.column:
		str = "kind"
	case IntegrationOrderFieldIntegrationType.column:
		str = "integration_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IntegrationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IntegrationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *IntegrationOrderFieldCreatedAt
	case "updated_at":
		*f = *IntegrationOrderFieldUpdatedAt
	case "name":
		*f = *IntegrationOrderFieldName
	case "kind":
		*f = *IntegrationOrderFieldKind
	case "integration_type":
		*f = *IntegrationOrderFieldIntegrationType
	default:
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

// IntegrationOrderField defines the ordering field of Integration.
type IntegrationOrderField struct {
	// Value extracts the ordering value from the given Integration.
	Value    func(*Integration) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) integration.OrderOption
	toCursor func(*Integration) Cursor
}

// IntegrationOrder defines the ordering of Integration.
type IntegrationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *IntegrationOrderField `json:"field"`
}

// DefaultIntegrationOrder is the default ordering of Integration.
var DefaultIntegrationOrder = &IntegrationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IntegrationOrderField{
		Value: func(_m *Integration) (ent.Value, error) {
			return _m.ID, nil
		},
		column: integration.FieldID,
		toTerm: integration.ByID,
		toCursor: func(_m *Integration) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Integration into IntegrationEdge.
func (_m *Integration) ToEdge(order *IntegrationOrder) *IntegrationEdge {
	if order == nil {
		order = DefaultIntegrationOrder
	}
	return &IntegrationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// InternalPolicyEdge is the edge representation of InternalPolicy.
type InternalPolicyEdge struct {
	Node   *InternalPolicy `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// InternalPolicyConnection is the connection containing edges to InternalPolicy.
type InternalPolicyConnection struct {
	Edges      []*InternalPolicyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *InternalPolicyConnection) build(nodes []*InternalPolicy, pager *internalpolicyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *InternalPolicy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InternalPolicy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InternalPolicy {
			return nodes[i]
		}
	}
	c.Edges = make([]*InternalPolicyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InternalPolicyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InternalPolicyPaginateOption enables pagination customization.
type InternalPolicyPaginateOption func(*internalpolicyPager) error

// WithInternalPolicyOrder configures pagination ordering.
func WithInternalPolicyOrder(order []*InternalPolicyOrder) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInternalPolicyFilter configures pagination filter.
func WithInternalPolicyFilter(filter func(*InternalPolicyQuery) (*InternalPolicyQuery, error)) InternalPolicyPaginateOption {
	return func(pager *internalpolicyPager) error {
		if filter == nil {
			return errors.New("InternalPolicyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type internalpolicyPager struct {
	reverse bool
	order   []*InternalPolicyOrder
	filter  func(*InternalPolicyQuery) (*InternalPolicyQuery, error)
}

func newInternalPolicyPager(opts []InternalPolicyPaginateOption, reverse bool) (*internalpolicyPager, error) {
	pager := &internalpolicyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *internalpolicyPager) applyFilter(query *InternalPolicyQuery) (*InternalPolicyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *internalpolicyPager) toCursor(_m *InternalPolicy) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *internalpolicyPager) applyCursors(query *InternalPolicyQuery, after, before *Cursor) (*InternalPolicyQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInternalPolicyOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *internalpolicyPager) applyOrder(query *InternalPolicyQuery) *InternalPolicyQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInternalPolicyOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInternalPolicyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *internalpolicyPager) orderExpr(query *InternalPolicyQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInternalPolicyOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to InternalPolicy.
func (_m *InternalPolicyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InternalPolicyPaginateOption,
) (*InternalPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInternalPolicyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &InternalPolicyConnection{Edges: []*InternalPolicyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InternalPolicyOrderFieldCreatedAt orders InternalPolicy by created_at.
	InternalPolicyOrderFieldCreatedAt = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: internalpolicy.FieldCreatedAt,
		toTerm: internalpolicy.ByCreatedAt,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// InternalPolicyOrderFieldUpdatedAt orders InternalPolicy by updated_at.
	InternalPolicyOrderFieldUpdatedAt = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: internalpolicy.FieldUpdatedAt,
		toTerm: internalpolicy.ByUpdatedAt,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// InternalPolicyOrderFieldRevision orders InternalPolicy by revision.
	InternalPolicyOrderFieldRevision = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: internalpolicy.FieldRevision,
		toTerm: internalpolicy.ByRevision,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// InternalPolicyOrderFieldName orders InternalPolicy by name.
	InternalPolicyOrderFieldName = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.Name, nil
		},
		column: internalpolicy.FieldName,
		toTerm: internalpolicy.ByName,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// InternalPolicyOrderFieldStatus orders InternalPolicy by status.
	InternalPolicyOrderFieldStatus = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.Status, nil
		},
		column: internalpolicy.FieldStatus,
		toTerm: internalpolicy.ByStatus,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// InternalPolicyOrderFieldReviewDue orders InternalPolicy by review_due.
	InternalPolicyOrderFieldReviewDue = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: internalpolicy.FieldReviewDue,
		toTerm: internalpolicy.ByReviewDue,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// InternalPolicyOrderFieldReviewFrequency orders InternalPolicy by review_frequency.
	InternalPolicyOrderFieldReviewFrequency = &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: internalpolicy.FieldReviewFrequency,
		toTerm: internalpolicy.ByReviewFrequency,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InternalPolicyOrderField) String() string {
	var str string
	switch f.column {
	case InternalPolicyOrderFieldCreatedAt.column:
		str = "created_at"
	case InternalPolicyOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InternalPolicyOrderFieldRevision.column:
		str = "revision"
	case InternalPolicyOrderFieldName.column:
		str = "name"
	case InternalPolicyOrderFieldStatus.column:
		str = "STATUS"
	case InternalPolicyOrderFieldReviewDue.column:
		str = "review_due"
	case InternalPolicyOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InternalPolicyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InternalPolicyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InternalPolicyOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *InternalPolicyOrderFieldCreatedAt
	case "updated_at":
		*f = *InternalPolicyOrderFieldUpdatedAt
	case "revision":
		*f = *InternalPolicyOrderFieldRevision
	case "name":
		*f = *InternalPolicyOrderFieldName
	case "STATUS":
		*f = *InternalPolicyOrderFieldStatus
	case "review_due":
		*f = *InternalPolicyOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *InternalPolicyOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid InternalPolicyOrderField", str)
	}
	return nil
}

// InternalPolicyOrderField defines the ordering field of InternalPolicy.
type InternalPolicyOrderField struct {
	// Value extracts the ordering value from the given InternalPolicy.
	Value    func(*InternalPolicy) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) internalpolicy.OrderOption
	toCursor func(*InternalPolicy) Cursor
}

// InternalPolicyOrder defines the ordering of InternalPolicy.
type InternalPolicyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *InternalPolicyOrderField `json:"field"`
}

// DefaultInternalPolicyOrder is the default ordering of InternalPolicy.
var DefaultInternalPolicyOrder = &InternalPolicyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InternalPolicyOrderField{
		Value: func(_m *InternalPolicy) (ent.Value, error) {
			return _m.ID, nil
		},
		column: internalpolicy.FieldID,
		toTerm: internalpolicy.ByID,
		toCursor: func(_m *InternalPolicy) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts InternalPolicy into InternalPolicyEdge.
func (_m *InternalPolicy) ToEdge(order *InternalPolicyOrder) *InternalPolicyEdge {
	if order == nil {
		order = DefaultInternalPolicyOrder
	}
	return &InternalPolicyEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// InviteEdge is the edge representation of Invite.
type InviteEdge struct {
	Node   *Invite `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// InviteConnection is the connection containing edges to Invite.
type InviteConnection struct {
	Edges      []*InviteEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *InviteConnection) build(nodes []*Invite, pager *invitePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Invite
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Invite {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Invite {
			return nodes[i]
		}
	}
	c.Edges = make([]*InviteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InviteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InvitePaginateOption enables pagination customization.
type InvitePaginateOption func(*invitePager) error

// WithInviteOrder configures pagination ordering.
func WithInviteOrder(order []*InviteOrder) InvitePaginateOption {
	return func(pager *invitePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithInviteFilter configures pagination filter.
func WithInviteFilter(filter func(*InviteQuery) (*InviteQuery, error)) InvitePaginateOption {
	return func(pager *invitePager) error {
		if filter == nil {
			return errors.New("InviteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type invitePager struct {
	reverse bool
	order   []*InviteOrder
	filter  func(*InviteQuery) (*InviteQuery, error)
}

func newInvitePager(opts []InvitePaginateOption, reverse bool) (*invitePager, error) {
	pager := &invitePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *invitePager) applyFilter(query *InviteQuery) (*InviteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *invitePager) toCursor(_m *Invite) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *invitePager) applyCursors(query *InviteQuery, after, before *Cursor) (*InviteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultInviteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *invitePager) applyOrder(query *InviteQuery) *InviteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultInviteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultInviteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *invitePager) orderExpr(query *InviteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultInviteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Invite.
func (_m *InviteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InvitePaginateOption,
) (*InviteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInvitePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &InviteConnection{Edges: []*InviteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InviteOrderFieldCreatedAt orders Invite by created_at.
	InviteOrderFieldCreatedAt = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: invite.FieldCreatedAt,
		toTerm: invite.ByCreatedAt,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// InviteOrderFieldUpdatedAt orders Invite by updated_at.
	InviteOrderFieldUpdatedAt = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: invite.FieldUpdatedAt,
		toTerm: invite.ByUpdatedAt,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// InviteOrderFieldExpires orders Invite by expires.
	InviteOrderFieldExpires = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.Expires, nil
		},
		column: invite.FieldExpires,
		toTerm: invite.ByExpires,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Expires,
			}
		},
	}
	// InviteOrderFieldStatus orders Invite by status.
	InviteOrderFieldStatus = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.Status, nil
		},
		column: invite.FieldStatus,
		toTerm: invite.ByStatus,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// InviteOrderFieldSendAttempts orders Invite by send_attempts.
	InviteOrderFieldSendAttempts = &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: invite.FieldSendAttempts,
		toTerm: invite.BySendAttempts,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InviteOrderField) String() string {
	var str string
	switch f.column {
	case InviteOrderFieldCreatedAt.column:
		str = "created_at"
	case InviteOrderFieldUpdatedAt.column:
		str = "updated_at"
	case InviteOrderFieldExpires.column:
		str = "expires"
	case InviteOrderFieldStatus.column:
		str = "STATUS"
	case InviteOrderFieldSendAttempts.column:
		str = "send_attempts"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InviteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InviteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InviteOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *InviteOrderFieldCreatedAt
	case "updated_at":
		*f = *InviteOrderFieldUpdatedAt
	case "expires":
		*f = *InviteOrderFieldExpires
	case "STATUS":
		*f = *InviteOrderFieldStatus
	case "send_attempts":
		*f = *InviteOrderFieldSendAttempts
	default:
		return fmt.Errorf("%s is not a valid InviteOrderField", str)
	}
	return nil
}

// InviteOrderField defines the ordering field of Invite.
type InviteOrderField struct {
	// Value extracts the ordering value from the given Invite.
	Value    func(*Invite) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) invite.OrderOption
	toCursor func(*Invite) Cursor
}

// InviteOrder defines the ordering of Invite.
type InviteOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *InviteOrderField `json:"field"`
}

// DefaultInviteOrder is the default ordering of Invite.
var DefaultInviteOrder = &InviteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InviteOrderField{
		Value: func(_m *Invite) (ent.Value, error) {
			return _m.ID, nil
		},
		column: invite.FieldID,
		toTerm: invite.ByID,
		toCursor: func(_m *Invite) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Invite into InviteEdge.
func (_m *Invite) ToEdge(order *InviteOrder) *InviteEdge {
	if order == nil {
		order = DefaultInviteOrder
	}
	return &InviteEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobResultEdge is the edge representation of JobResult.
type JobResultEdge struct {
	Node   *JobResult `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobResultConnection is the connection containing edges to JobResult.
type JobResultConnection struct {
	Edges      []*JobResultEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobResultConnection) build(nodes []*JobResult, pager *jobresultPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobResult
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobResult {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobResult {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobResultEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobResultEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobResultPaginateOption enables pagination customization.
type JobResultPaginateOption func(*jobresultPager) error

// WithJobResultOrder configures pagination ordering.
func WithJobResultOrder(order []*JobResultOrder) JobResultPaginateOption {
	return func(pager *jobresultPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobResultFilter configures pagination filter.
func WithJobResultFilter(filter func(*JobResultQuery) (*JobResultQuery, error)) JobResultPaginateOption {
	return func(pager *jobresultPager) error {
		if filter == nil {
			return errors.New("JobResultQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobresultPager struct {
	reverse bool
	order   []*JobResultOrder
	filter  func(*JobResultQuery) (*JobResultQuery, error)
}

func newJobResultPager(opts []JobResultPaginateOption, reverse bool) (*jobresultPager, error) {
	pager := &jobresultPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobresultPager) applyFilter(query *JobResultQuery) (*JobResultQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobresultPager) toCursor(_m *JobResult) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobresultPager) applyCursors(query *JobResultQuery, after, before *Cursor) (*JobResultQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobResultOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobresultPager) applyOrder(query *JobResultQuery) *JobResultQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobResultOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobResultOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobresultPager) orderExpr(query *JobResultQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobResultOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobResult.
func (_m *JobResultQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobResultPaginateOption,
) (*JobResultConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobResultPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobResultConnection{Edges: []*JobResultEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobResultOrderFieldCreatedAt orders JobResult by created_at.
	JobResultOrderFieldCreatedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobresult.FieldCreatedAt,
		toTerm: jobresult.ByCreatedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobResultOrderFieldUpdatedAt orders JobResult by updated_at.
	JobResultOrderFieldUpdatedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobresult.FieldUpdatedAt,
		toTerm: jobresult.ByUpdatedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobResultOrderFieldStatus orders JobResult by status.
	JobResultOrderFieldStatus = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.Status, nil
		},
		column: jobresult.FieldStatus,
		toTerm: jobresult.ByStatus,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// JobResultOrderFieldExitCode orders JobResult by exit_code.
	JobResultOrderFieldExitCode = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExitCode == nil {
				return nil, nil
			}
			return _m.ExitCode, nil
		},
		column: jobresult.FieldExitCode,
		toTerm: func(opts ...sql.OrderTermOption) jobresult.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobresult.ByExitCode(opts...)
		},
		toCursor: func(_m *JobResult) Cursor {
			if _m.ExitCode == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExitCode,
			}
		},
	}
	// JobResultOrderFieldFinishedAt orders JobResult by finished_at.
	JobResultOrderFieldFinishedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.FinishedAt, nil
		},
		column: jobresult.FieldFinishedAt,
		toTerm: jobresult.ByFinishedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FinishedAt,
			}
		},
	}
	// JobResultOrderFieldStartedAt orders JobResult by started_at.
	JobResultOrderFieldStartedAt = &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.StartedAt, nil
		},
		column: jobresult.FieldStartedAt,
		toTerm: jobresult.ByStartedAt,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobResultOrderField) String() string {
	var str string
	switch f.column {
	case JobResultOrderFieldCreatedAt.column:
		str = "created_at"
	case JobResultOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobResultOrderFieldStatus.column:
		str = "STATUS"
	case JobResultOrderFieldExitCode.column:
		str = "exit_code"
	case JobResultOrderFieldFinishedAt.column:
		str = "finished_at"
	case JobResultOrderFieldStartedAt.column:
		str = "started_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobResultOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobResultOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobResultOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobResultOrderFieldCreatedAt
	case "updated_at":
		*f = *JobResultOrderFieldUpdatedAt
	case "STATUS":
		*f = *JobResultOrderFieldStatus
	case "exit_code":
		*f = *JobResultOrderFieldExitCode
	case "finished_at":
		*f = *JobResultOrderFieldFinishedAt
	case "started_at":
		*f = *JobResultOrderFieldStartedAt
	default:
		return fmt.Errorf("%s is not a valid JobResultOrderField", str)
	}
	return nil
}

// JobResultOrderField defines the ordering field of JobResult.
type JobResultOrderField struct {
	// Value extracts the ordering value from the given JobResult.
	Value    func(*JobResult) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobresult.OrderOption
	toCursor func(*JobResult) Cursor
}

// JobResultOrder defines the ordering of JobResult.
type JobResultOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobResultOrderField `json:"field"`
}

// DefaultJobResultOrder is the default ordering of JobResult.
var DefaultJobResultOrder = &JobResultOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobResultOrderField{
		Value: func(_m *JobResult) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobresult.FieldID,
		toTerm: jobresult.ByID,
		toCursor: func(_m *JobResult) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobResult into JobResultEdge.
func (_m *JobResult) ToEdge(order *JobResultOrder) *JobResultEdge {
	if order == nil {
		order = DefaultJobResultOrder
	}
	return &JobResultEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRunnerEdge is the edge representation of JobRunner.
type JobRunnerEdge struct {
	Node   *JobRunner `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobRunnerConnection is the connection containing edges to JobRunner.
type JobRunnerConnection struct {
	Edges      []*JobRunnerEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobRunnerConnection) build(nodes []*JobRunner, pager *jobrunnerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunner {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerPaginateOption enables pagination customization.
type JobRunnerPaginateOption func(*jobrunnerPager) error

// WithJobRunnerOrder configures pagination ordering.
func WithJobRunnerOrder(order []*JobRunnerOrder) JobRunnerPaginateOption {
	return func(pager *jobrunnerPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerFilter configures pagination filter.
func WithJobRunnerFilter(filter func(*JobRunnerQuery) (*JobRunnerQuery, error)) JobRunnerPaginateOption {
	return func(pager *jobrunnerPager) error {
		if filter == nil {
			return errors.New("JobRunnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnerPager struct {
	reverse bool
	order   []*JobRunnerOrder
	filter  func(*JobRunnerQuery) (*JobRunnerQuery, error)
}

func newJobRunnerPager(opts []JobRunnerPaginateOption, reverse bool) (*jobrunnerPager, error) {
	pager := &jobrunnerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnerPager) applyFilter(query *JobRunnerQuery) (*JobRunnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnerPager) toCursor(_m *JobRunner) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobrunnerPager) applyCursors(query *JobRunnerQuery, after, before *Cursor) (*JobRunnerQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnerPager) applyOrder(query *JobRunnerQuery) *JobRunnerQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnerPager) orderExpr(query *JobRunnerQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunner.
func (_m *JobRunnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerPaginateOption,
) (*JobRunnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRunnerConnection{Edges: []*JobRunnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerOrderFieldCreatedAt orders JobRunner by created_at.
	JobRunnerOrderFieldCreatedAt = &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobrunner.FieldCreatedAt,
		toTerm: jobrunner.ByCreatedAt,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobRunnerOrderFieldUpdatedAt orders JobRunner by updated_at.
	JobRunnerOrderFieldUpdatedAt = &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobrunner.FieldUpdatedAt,
		toTerm: jobrunner.ByUpdatedAt,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobRunnerOrderFieldName orders JobRunner by name.
	JobRunnerOrderFieldName = &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.Name, nil
		},
		column: jobrunner.FieldName,
		toTerm: jobrunner.ByName,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerOrderFieldUpdatedAt
	case "name":
		*f = *JobRunnerOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid JobRunnerOrderField", str)
	}
	return nil
}

// JobRunnerOrderField defines the ordering field of JobRunner.
type JobRunnerOrderField struct {
	// Value extracts the ordering value from the given JobRunner.
	Value    func(*JobRunner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunner.OrderOption
	toCursor func(*JobRunner) Cursor
}

// JobRunnerOrder defines the ordering of JobRunner.
type JobRunnerOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobRunnerOrderField `json:"field"`
}

// DefaultJobRunnerOrder is the default ordering of JobRunner.
var DefaultJobRunnerOrder = &JobRunnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerOrderField{
		Value: func(_m *JobRunner) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrunner.FieldID,
		toTerm: jobrunner.ByID,
		toCursor: func(_m *JobRunner) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRunner into JobRunnerEdge.
func (_m *JobRunner) ToEdge(order *JobRunnerOrder) *JobRunnerEdge {
	if order == nil {
		order = DefaultJobRunnerOrder
	}
	return &JobRunnerEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRunnerRegistrationTokenEdge is the edge representation of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenEdge struct {
	Node   *JobRunnerRegistrationToken `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// JobRunnerRegistrationTokenConnection is the connection containing edges to JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenConnection struct {
	Edges      []*JobRunnerRegistrationTokenEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *JobRunnerRegistrationTokenConnection) build(nodes []*JobRunnerRegistrationToken, pager *jobrunnerregistrationtokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunnerRegistrationToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunnerRegistrationToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunnerRegistrationToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerRegistrationTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerRegistrationTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerRegistrationTokenPaginateOption enables pagination customization.
type JobRunnerRegistrationTokenPaginateOption func(*jobrunnerregistrationtokenPager) error

// WithJobRunnerRegistrationTokenOrder configures pagination ordering.
func WithJobRunnerRegistrationTokenOrder(order []*JobRunnerRegistrationTokenOrder) JobRunnerRegistrationTokenPaginateOption {
	return func(pager *jobrunnerregistrationtokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerRegistrationTokenFilter configures pagination filter.
func WithJobRunnerRegistrationTokenFilter(filter func(*JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error)) JobRunnerRegistrationTokenPaginateOption {
	return func(pager *jobrunnerregistrationtokenPager) error {
		if filter == nil {
			return errors.New("JobRunnerRegistrationTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnerregistrationtokenPager struct {
	reverse bool
	order   []*JobRunnerRegistrationTokenOrder
	filter  func(*JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error)
}

func newJobRunnerRegistrationTokenPager(opts []JobRunnerRegistrationTokenPaginateOption, reverse bool) (*jobrunnerregistrationtokenPager, error) {
	pager := &jobrunnerregistrationtokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnerregistrationtokenPager) applyFilter(query *JobRunnerRegistrationTokenQuery) (*JobRunnerRegistrationTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnerregistrationtokenPager) toCursor(_m *JobRunnerRegistrationToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobrunnerregistrationtokenPager) applyCursors(query *JobRunnerRegistrationTokenQuery, after, before *Cursor) (*JobRunnerRegistrationTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerRegistrationTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnerregistrationtokenPager) applyOrder(query *JobRunnerRegistrationTokenQuery) *JobRunnerRegistrationTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerRegistrationTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerRegistrationTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnerregistrationtokenPager) orderExpr(query *JobRunnerRegistrationTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerRegistrationTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunnerRegistrationToken.
func (_m *JobRunnerRegistrationTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerRegistrationTokenPaginateOption,
) (*JobRunnerRegistrationTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerRegistrationTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRunnerRegistrationTokenConnection{Edges: []*JobRunnerRegistrationTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerRegistrationTokenOrderFieldCreatedAt orders JobRunnerRegistrationToken by created_at.
	JobRunnerRegistrationTokenOrderFieldCreatedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldCreatedAt,
		toTerm: jobrunnerregistrationtoken.ByCreatedAt,
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobRunnerRegistrationTokenOrderFieldUpdatedAt orders JobRunnerRegistrationToken by updated_at.
	JobRunnerRegistrationTokenOrderFieldUpdatedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldUpdatedAt,
		toTerm: jobrunnerregistrationtoken.ByUpdatedAt,
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobRunnerRegistrationTokenOrderFieldLastUsedAt orders JobRunnerRegistrationToken by last_used_at.
	JobRunnerRegistrationTokenOrderFieldLastUsedAt = &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: jobrunnerregistrationtoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnerregistrationtoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnerregistrationtoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerRegistrationTokenOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerRegistrationTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerRegistrationTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerRegistrationTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerRegistrationTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerRegistrationTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerRegistrationTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerRegistrationTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerRegistrationTokenOrderFieldUpdatedAt
	case "last_used_at":
		*f = *JobRunnerRegistrationTokenOrderFieldLastUsedAt
	default:
		return fmt.Errorf("%s is not a valid JobRunnerRegistrationTokenOrderField", str)
	}
	return nil
}

// JobRunnerRegistrationTokenOrderField defines the ordering field of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenOrderField struct {
	// Value extracts the ordering value from the given JobRunnerRegistrationToken.
	Value    func(*JobRunnerRegistrationToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunnerregistrationtoken.OrderOption
	toCursor func(*JobRunnerRegistrationToken) Cursor
}

// JobRunnerRegistrationTokenOrder defines the ordering of JobRunnerRegistrationToken.
type JobRunnerRegistrationTokenOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *JobRunnerRegistrationTokenOrderField `json:"field"`
}

// DefaultJobRunnerRegistrationTokenOrder is the default ordering of JobRunnerRegistrationToken.
var DefaultJobRunnerRegistrationTokenOrder = &JobRunnerRegistrationTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerRegistrationTokenOrderField{
		Value: func(_m *JobRunnerRegistrationToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrunnerregistrationtoken.FieldID,
		toTerm: jobrunnerregistrationtoken.ByID,
		toCursor: func(_m *JobRunnerRegistrationToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRunnerRegistrationToken into JobRunnerRegistrationTokenEdge.
func (_m *JobRunnerRegistrationToken) ToEdge(order *JobRunnerRegistrationTokenOrder) *JobRunnerRegistrationTokenEdge {
	if order == nil {
		order = DefaultJobRunnerRegistrationTokenOrder
	}
	return &JobRunnerRegistrationTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRunnerTokenEdge is the edge representation of JobRunnerToken.
type JobRunnerTokenEdge struct {
	Node   *JobRunnerToken `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// JobRunnerTokenConnection is the connection containing edges to JobRunnerToken.
type JobRunnerTokenConnection struct {
	Edges      []*JobRunnerTokenEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *JobRunnerTokenConnection) build(nodes []*JobRunnerToken, pager *jobrunnertokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobRunnerToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRunnerToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRunnerToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRunnerTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRunnerTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRunnerTokenPaginateOption enables pagination customization.
type JobRunnerTokenPaginateOption func(*jobrunnertokenPager) error

// WithJobRunnerTokenOrder configures pagination ordering.
func WithJobRunnerTokenOrder(order []*JobRunnerTokenOrder) JobRunnerTokenPaginateOption {
	return func(pager *jobrunnertokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobRunnerTokenFilter configures pagination filter.
func WithJobRunnerTokenFilter(filter func(*JobRunnerTokenQuery) (*JobRunnerTokenQuery, error)) JobRunnerTokenPaginateOption {
	return func(pager *jobrunnertokenPager) error {
		if filter == nil {
			return errors.New("JobRunnerTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrunnertokenPager struct {
	reverse bool
	order   []*JobRunnerTokenOrder
	filter  func(*JobRunnerTokenQuery) (*JobRunnerTokenQuery, error)
}

func newJobRunnerTokenPager(opts []JobRunnerTokenPaginateOption, reverse bool) (*jobrunnertokenPager, error) {
	pager := &jobrunnertokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobrunnertokenPager) applyFilter(query *JobRunnerTokenQuery) (*JobRunnerTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrunnertokenPager) toCursor(_m *JobRunnerToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobrunnertokenPager) applyCursors(query *JobRunnerTokenQuery, after, before *Cursor) (*JobRunnerTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobRunnerTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobrunnertokenPager) applyOrder(query *JobRunnerTokenQuery) *JobRunnerTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobRunnerTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobRunnerTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobrunnertokenPager) orderExpr(query *JobRunnerTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobRunnerTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRunnerToken.
func (_m *JobRunnerTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRunnerTokenPaginateOption,
) (*JobRunnerTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRunnerTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRunnerTokenConnection{Edges: []*JobRunnerTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobRunnerTokenOrderFieldCreatedAt orders JobRunnerToken by created_at.
	JobRunnerTokenOrderFieldCreatedAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobrunnertoken.FieldCreatedAt,
		toTerm: jobrunnertoken.ByCreatedAt,
		toCursor: func(_m *JobRunnerToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldUpdatedAt orders JobRunnerToken by updated_at.
	JobRunnerTokenOrderFieldUpdatedAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobrunnertoken.FieldUpdatedAt,
		toTerm: jobrunnertoken.ByUpdatedAt,
		toCursor: func(_m *JobRunnerToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldExpiresAt orders JobRunnerToken by expires_at.
	JobRunnerTokenOrderFieldExpiresAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: jobrunnertoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnertoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnertoken.ByExpiresAt(opts...)
		},
		toCursor: func(_m *JobRunnerToken) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// JobRunnerTokenOrderFieldLastUsedAt orders JobRunnerToken by last_used_at.
	JobRunnerTokenOrderFieldLastUsedAt = &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: jobrunnertoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) jobrunnertoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return jobrunnertoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *JobRunnerToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobRunnerTokenOrderField) String() string {
	var str string
	switch f.column {
	case JobRunnerTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case JobRunnerTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobRunnerTokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case JobRunnerTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobRunnerTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobRunnerTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobRunnerTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobRunnerTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *JobRunnerTokenOrderFieldUpdatedAt
	case "expires_at":
		*f = *JobRunnerTokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *JobRunnerTokenOrderFieldLastUsedAt
	default:
		return fmt.Errorf("%s is not a valid JobRunnerTokenOrderField", str)
	}
	return nil
}

// JobRunnerTokenOrderField defines the ordering field of JobRunnerToken.
type JobRunnerTokenOrderField struct {
	// Value extracts the ordering value from the given JobRunnerToken.
	Value    func(*JobRunnerToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrunnertoken.OrderOption
	toCursor func(*JobRunnerToken) Cursor
}

// JobRunnerTokenOrder defines the ordering of JobRunnerToken.
type JobRunnerTokenOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *JobRunnerTokenOrderField `json:"field"`
}

// DefaultJobRunnerTokenOrder is the default ordering of JobRunnerToken.
var DefaultJobRunnerTokenOrder = &JobRunnerTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRunnerTokenOrderField{
		Value: func(_m *JobRunnerToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrunnertoken.FieldID,
		toTerm: jobrunnertoken.ByID,
		toCursor: func(_m *JobRunnerToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRunnerToken into JobRunnerTokenEdge.
func (_m *JobRunnerToken) ToEdge(order *JobRunnerTokenOrder) *JobRunnerTokenEdge {
	if order == nil {
		order = DefaultJobRunnerTokenOrder
	}
	return &JobRunnerTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobTemplateEdge is the edge representation of JobTemplate.
type JobTemplateEdge struct {
	Node   *JobTemplate `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobTemplateConnection is the connection containing edges to JobTemplate.
type JobTemplateConnection struct {
	Edges      []*JobTemplateEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobTemplateConnection) build(nodes []*JobTemplate, pager *jobtemplatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *JobTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobTemplate {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobTemplatePaginateOption enables pagination customization.
type JobTemplatePaginateOption func(*jobtemplatePager) error

// WithJobTemplateOrder configures pagination ordering.
func WithJobTemplateOrder(order []*JobTemplateOrder) JobTemplatePaginateOption {
	return func(pager *jobtemplatePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithJobTemplateFilter configures pagination filter.
func WithJobTemplateFilter(filter func(*JobTemplateQuery) (*JobTemplateQuery, error)) JobTemplatePaginateOption {
	return func(pager *jobtemplatePager) error {
		if filter == nil {
			return errors.New("JobTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobtemplatePager struct {
	reverse bool
	order   []*JobTemplateOrder
	filter  func(*JobTemplateQuery) (*JobTemplateQuery, error)
}

func newJobTemplatePager(opts []JobTemplatePaginateOption, reverse bool) (*jobtemplatePager, error) {
	pager := &jobtemplatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *jobtemplatePager) applyFilter(query *JobTemplateQuery) (*JobTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobtemplatePager) toCursor(_m *JobTemplate) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *jobtemplatePager) applyCursors(query *JobTemplateQuery, after, before *Cursor) (*JobTemplateQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultJobTemplateOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *jobtemplatePager) applyOrder(query *JobTemplateQuery) *JobTemplateQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultJobTemplateOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultJobTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *jobtemplatePager) orderExpr(query *JobTemplateQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultJobTemplateOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobTemplate.
func (_m *JobTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobTemplatePaginateOption,
) (*JobTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobTemplateConnection{Edges: []*JobTemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobTemplateOrderFieldCreatedAt orders JobTemplate by created_at.
	JobTemplateOrderFieldCreatedAt = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: jobtemplate.FieldCreatedAt,
		toTerm: jobtemplate.ByCreatedAt,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// JobTemplateOrderFieldUpdatedAt orders JobTemplate by updated_at.
	JobTemplateOrderFieldUpdatedAt = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: jobtemplate.FieldUpdatedAt,
		toTerm: jobtemplate.ByUpdatedAt,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// JobTemplateOrderFieldTitle orders JobTemplate by title.
	JobTemplateOrderFieldTitle = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.Title, nil
		},
		column: jobtemplate.FieldTitle,
		toTerm: jobtemplate.ByTitle,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// JobTemplateOrderFieldPlatform orders JobTemplate by platform.
	JobTemplateOrderFieldPlatform = &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.Platform, nil
		},
		column: jobtemplate.FieldPlatform,
		toTerm: jobtemplate.ByPlatform,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Platform,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobTemplateOrderField) String() string {
	var str string
	switch f.column {
	case JobTemplateOrderFieldCreatedAt.column:
		str = "created_at"
	case JobTemplateOrderFieldUpdatedAt.column:
		str = "updated_at"
	case JobTemplateOrderFieldTitle.column:
		str = "title"
	case JobTemplateOrderFieldPlatform.column:
		str = "PLATFORM"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobTemplateOrderFieldCreatedAt
	case "updated_at":
		*f = *JobTemplateOrderFieldUpdatedAt
	case "title":
		*f = *JobTemplateOrderFieldTitle
	case "PLATFORM":
		*f = *JobTemplateOrderFieldPlatform
	default:
		return fmt.Errorf("%s is not a valid JobTemplateOrderField", str)
	}
	return nil
}

// JobTemplateOrderField defines the ordering field of JobTemplate.
type JobTemplateOrderField struct {
	// Value extracts the ordering value from the given JobTemplate.
	Value    func(*JobTemplate) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobtemplate.OrderOption
	toCursor func(*JobTemplate) Cursor
}

// JobTemplateOrder defines the ordering of JobTemplate.
type JobTemplateOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobTemplateOrderField `json:"field"`
}

// DefaultJobTemplateOrder is the default ordering of JobTemplate.
var DefaultJobTemplateOrder = &JobTemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobTemplateOrderField{
		Value: func(_m *JobTemplate) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobtemplate.FieldID,
		toTerm: jobtemplate.ByID,
		toCursor: func(_m *JobTemplate) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobTemplate into JobTemplateEdge.
func (_m *JobTemplate) ToEdge(order *JobTemplateOrder) *JobTemplateEdge {
	if order == nil {
		order = DefaultJobTemplateOrder
	}
	return &JobTemplateEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappableDomainEdge is the edge representation of MappableDomain.
type MappableDomainEdge struct {
	Node   *MappableDomain `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// MappableDomainConnection is the connection containing edges to MappableDomain.
type MappableDomainConnection struct {
	Edges      []*MappableDomainEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *MappableDomainConnection) build(nodes []*MappableDomain, pager *mappabledomainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappableDomain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappableDomain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappableDomain {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappableDomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappableDomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappableDomainPaginateOption enables pagination customization.
type MappableDomainPaginateOption func(*mappabledomainPager) error

// WithMappableDomainOrder configures pagination ordering.
func WithMappableDomainOrder(order []*MappableDomainOrder) MappableDomainPaginateOption {
	return func(pager *mappabledomainPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMappableDomainFilter configures pagination filter.
func WithMappableDomainFilter(filter func(*MappableDomainQuery) (*MappableDomainQuery, error)) MappableDomainPaginateOption {
	return func(pager *mappabledomainPager) error {
		if filter == nil {
			return errors.New("MappableDomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappabledomainPager struct {
	reverse bool
	order   []*MappableDomainOrder
	filter  func(*MappableDomainQuery) (*MappableDomainQuery, error)
}

func newMappableDomainPager(opts []MappableDomainPaginateOption, reverse bool) (*mappabledomainPager, error) {
	pager := &mappabledomainPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mappabledomainPager) applyFilter(query *MappableDomainQuery) (*MappableDomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappabledomainPager) toCursor(_m *MappableDomain) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *mappabledomainPager) applyCursors(query *MappableDomainQuery, after, before *Cursor) (*MappableDomainQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMappableDomainOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *mappabledomainPager) applyOrder(query *MappableDomainQuery) *MappableDomainQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMappableDomainOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMappableDomainOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mappabledomainPager) orderExpr(query *MappableDomainQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMappableDomainOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappableDomain.
func (_m *MappableDomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappableDomainPaginateOption,
) (*MappableDomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappableDomainPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappableDomainConnection{Edges: []*MappableDomainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappableDomainOrderFieldCreatedAt orders MappableDomain by created_at.
	MappableDomainOrderFieldCreatedAt = &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappabledomain.FieldCreatedAt,
		toTerm: mappabledomain.ByCreatedAt,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappableDomainOrderFieldUpdatedAt orders MappableDomain by updated_at.
	MappableDomainOrderFieldUpdatedAt = &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappabledomain.FieldUpdatedAt,
		toTerm: mappabledomain.ByUpdatedAt,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappableDomainOrderFieldName orders MappableDomain by name.
	MappableDomainOrderFieldName = &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.Name, nil
		},
		column: mappabledomain.FieldName,
		toTerm: mappabledomain.ByName,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappableDomainOrderField) String() string {
	var str string
	switch f.column {
	case MappableDomainOrderFieldCreatedAt.column:
		str = "created_at"
	case MappableDomainOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappableDomainOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappableDomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappableDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappableDomainOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *MappableDomainOrderFieldCreatedAt
	case "updated_at":
		*f = *MappableDomainOrderFieldUpdatedAt
	case "name":
		*f = *MappableDomainOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid MappableDomainOrderField", str)
	}
	return nil
}

// MappableDomainOrderField defines the ordering field of MappableDomain.
type MappableDomainOrderField struct {
	// Value extracts the ordering value from the given MappableDomain.
	Value    func(*MappableDomain) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappabledomain.OrderOption
	toCursor func(*MappableDomain) Cursor
}

// MappableDomainOrder defines the ordering of MappableDomain.
type MappableDomainOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *MappableDomainOrderField `json:"field"`
}

// DefaultMappableDomainOrder is the default ordering of MappableDomain.
var DefaultMappableDomainOrder = &MappableDomainOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappableDomainOrderField{
		Value: func(_m *MappableDomain) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappabledomain.FieldID,
		toTerm: mappabledomain.ByID,
		toCursor: func(_m *MappableDomain) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappableDomain into MappableDomainEdge.
func (_m *MappableDomain) ToEdge(order *MappableDomainOrder) *MappableDomainEdge {
	if order == nil {
		order = DefaultMappableDomainOrder
	}
	return &MappableDomainEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// MappedControlEdge is the edge representation of MappedControl.
type MappedControlEdge struct {
	Node   *MappedControl `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// MappedControlConnection is the connection containing edges to MappedControl.
type MappedControlConnection struct {
	Edges      []*MappedControlEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *MappedControlConnection) build(nodes []*MappedControl, pager *mappedcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *MappedControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MappedControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MappedControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*MappedControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MappedControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MappedControlPaginateOption enables pagination customization.
type MappedControlPaginateOption func(*mappedcontrolPager) error

// WithMappedControlOrder configures pagination ordering.
func WithMappedControlOrder(order []*MappedControlOrder) MappedControlPaginateOption {
	return func(pager *mappedcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithMappedControlFilter configures pagination filter.
func WithMappedControlFilter(filter func(*MappedControlQuery) (*MappedControlQuery, error)) MappedControlPaginateOption {
	return func(pager *mappedcontrolPager) error {
		if filter == nil {
			return errors.New("MappedControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mappedcontrolPager struct {
	reverse bool
	order   []*MappedControlOrder
	filter  func(*MappedControlQuery) (*MappedControlQuery, error)
}

func newMappedControlPager(opts []MappedControlPaginateOption, reverse bool) (*mappedcontrolPager, error) {
	pager := &mappedcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *mappedcontrolPager) applyFilter(query *MappedControlQuery) (*MappedControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mappedcontrolPager) toCursor(_m *MappedControl) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *mappedcontrolPager) applyCursors(query *MappedControlQuery, after, before *Cursor) (*MappedControlQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultMappedControlOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *mappedcontrolPager) applyOrder(query *MappedControlQuery) *MappedControlQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultMappedControlOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultMappedControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *mappedcontrolPager) orderExpr(query *MappedControlQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultMappedControlOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to MappedControl.
func (_m *MappedControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MappedControlPaginateOption,
) (*MappedControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMappedControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &MappedControlConnection{Edges: []*MappedControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MappedControlOrderFieldCreatedAt orders MappedControl by created_at.
	MappedControlOrderFieldCreatedAt = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: mappedcontrol.FieldCreatedAt,
		toTerm: mappedcontrol.ByCreatedAt,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// MappedControlOrderFieldUpdatedAt orders MappedControl by updated_at.
	MappedControlOrderFieldUpdatedAt = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: mappedcontrol.FieldUpdatedAt,
		toTerm: mappedcontrol.ByUpdatedAt,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// MappedControlOrderFieldMappingType orders MappedControl by mapping_type.
	MappedControlOrderFieldMappingType = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.MappingType, nil
		},
		column: mappedcontrol.FieldMappingType,
		toTerm: mappedcontrol.ByMappingType,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.MappingType,
			}
		},
	}
	// MappedControlOrderFieldSource orders MappedControl by source.
	MappedControlOrderFieldSource = &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.Source, nil
		},
		column: mappedcontrol.FieldSource,
		toTerm: mappedcontrol.BySource,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MappedControlOrderField) String() string {
	var str string
	switch f.column {
	case MappedControlOrderFieldCreatedAt.column:
		str = "created_at"
	case MappedControlOrderFieldUpdatedAt.column:
		str = "updated_at"
	case MappedControlOrderFieldMappingType.column:
		str = "MAPPING_TYPE"
	case MappedControlOrderFieldSource.column:
		str = "SOURCE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MappedControlOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MappedControlOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MappedControlOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *MappedControlOrderFieldCreatedAt
	case "updated_at":
		*f = *MappedControlOrderFieldUpdatedAt
	case "MAPPING_TYPE":
		*f = *MappedControlOrderFieldMappingType
	case "SOURCE":
		*f = *MappedControlOrderFieldSource
	default:
		return fmt.Errorf("%s is not a valid MappedControlOrderField", str)
	}
	return nil
}

// MappedControlOrderField defines the ordering field of MappedControl.
type MappedControlOrderField struct {
	// Value extracts the ordering value from the given MappedControl.
	Value    func(*MappedControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mappedcontrol.OrderOption
	toCursor func(*MappedControl) Cursor
}

// MappedControlOrder defines the ordering of MappedControl.
type MappedControlOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *MappedControlOrderField `json:"field"`
}

// DefaultMappedControlOrder is the default ordering of MappedControl.
var DefaultMappedControlOrder = &MappedControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MappedControlOrderField{
		Value: func(_m *MappedControl) (ent.Value, error) {
			return _m.ID, nil
		},
		column: mappedcontrol.FieldID,
		toTerm: mappedcontrol.ByID,
		toCursor: func(_m *MappedControl) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts MappedControl into MappedControlEdge.
func (_m *MappedControl) ToEdge(order *MappedControlOrder) *MappedControlEdge {
	if order == nil {
		order = DefaultMappedControlOrder
	}
	return &MappedControlEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NarrativeEdge is the edge representation of Narrative.
type NarrativeEdge struct {
	Node   *Narrative `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// NarrativeConnection is the connection containing edges to Narrative.
type NarrativeConnection struct {
	Edges      []*NarrativeEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *NarrativeConnection) build(nodes []*Narrative, pager *narrativePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Narrative
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Narrative {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Narrative {
			return nodes[i]
		}
	}
	c.Edges = make([]*NarrativeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NarrativeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NarrativePaginateOption enables pagination customization.
type NarrativePaginateOption func(*narrativePager) error

// WithNarrativeOrder configures pagination ordering.
func WithNarrativeOrder(order []*NarrativeOrder) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNarrativeFilter configures pagination filter.
func WithNarrativeFilter(filter func(*NarrativeQuery) (*NarrativeQuery, error)) NarrativePaginateOption {
	return func(pager *narrativePager) error {
		if filter == nil {
			return errors.New("NarrativeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type narrativePager struct {
	reverse bool
	order   []*NarrativeOrder
	filter  func(*NarrativeQuery) (*NarrativeQuery, error)
}

func newNarrativePager(opts []NarrativePaginateOption, reverse bool) (*narrativePager, error) {
	pager := &narrativePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *narrativePager) applyFilter(query *NarrativeQuery) (*NarrativeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *narrativePager) toCursor(_m *Narrative) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *narrativePager) applyCursors(query *NarrativeQuery, after, before *Cursor) (*NarrativeQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNarrativeOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *narrativePager) applyOrder(query *NarrativeQuery) *NarrativeQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNarrativeOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNarrativeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *narrativePager) orderExpr(query *NarrativeQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNarrativeOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Narrative.
func (_m *NarrativeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NarrativePaginateOption,
) (*NarrativeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNarrativePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NarrativeConnection{Edges: []*NarrativeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NarrativeOrderFieldCreatedAt orders Narrative by created_at.
	NarrativeOrderFieldCreatedAt = &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: narrative.FieldCreatedAt,
		toTerm: narrative.ByCreatedAt,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NarrativeOrderFieldUpdatedAt orders Narrative by updated_at.
	NarrativeOrderFieldUpdatedAt = &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: narrative.FieldUpdatedAt,
		toTerm: narrative.ByUpdatedAt,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// NarrativeOrderFieldName orders Narrative by name.
	NarrativeOrderFieldName = &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.Name, nil
		},
		column: narrative.FieldName,
		toTerm: narrative.ByName,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NarrativeOrderField) String() string {
	var str string
	switch f.column {
	case NarrativeOrderFieldCreatedAt.column:
		str = "created_at"
	case NarrativeOrderFieldUpdatedAt.column:
		str = "updated_at"
	case NarrativeOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NarrativeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NarrativeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NarrativeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NarrativeOrderFieldCreatedAt
	case "updated_at":
		*f = *NarrativeOrderFieldUpdatedAt
	case "name":
		*f = *NarrativeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NarrativeOrderField", str)
	}
	return nil
}

// NarrativeOrderField defines the ordering field of Narrative.
type NarrativeOrderField struct {
	// Value extracts the ordering value from the given Narrative.
	Value    func(*Narrative) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) narrative.OrderOption
	toCursor func(*Narrative) Cursor
}

// NarrativeOrder defines the ordering of Narrative.
type NarrativeOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *NarrativeOrderField `json:"field"`
}

// DefaultNarrativeOrder is the default ordering of Narrative.
var DefaultNarrativeOrder = &NarrativeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NarrativeOrderField{
		Value: func(_m *Narrative) (ent.Value, error) {
			return _m.ID, nil
		},
		column: narrative.FieldID,
		toTerm: narrative.ByID,
		toCursor: func(_m *Narrative) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Narrative into NarrativeEdge.
func (_m *Narrative) ToEdge(order *NarrativeOrder) *NarrativeEdge {
	if order == nil {
		order = DefaultNarrativeOrder
	}
	return &NarrativeEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NoteEdge is the edge representation of Note.
type NoteEdge struct {
	Node   *Note  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// NoteConnection is the connection containing edges to Note.
type NoteConnection struct {
	Edges      []*NoteEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *NoteConnection) build(nodes []*Note, pager *notePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Note
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Note {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Note {
			return nodes[i]
		}
	}
	c.Edges = make([]*NoteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NoteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotePaginateOption enables pagination customization.
type NotePaginateOption func(*notePager) error

// WithNoteOrder configures pagination ordering.
func WithNoteOrder(order []*NoteOrder) NotePaginateOption {
	return func(pager *notePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithNoteFilter configures pagination filter.
func WithNoteFilter(filter func(*NoteQuery) (*NoteQuery, error)) NotePaginateOption {
	return func(pager *notePager) error {
		if filter == nil {
			return errors.New("NoteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notePager struct {
	reverse bool
	order   []*NoteOrder
	filter  func(*NoteQuery) (*NoteQuery, error)
}

func newNotePager(opts []NotePaginateOption, reverse bool) (*notePager, error) {
	pager := &notePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *notePager) applyFilter(query *NoteQuery) (*NoteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notePager) toCursor(_m *Note) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *notePager) applyCursors(query *NoteQuery, after, before *Cursor) (*NoteQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultNoteOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *notePager) applyOrder(query *NoteQuery) *NoteQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultNoteOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultNoteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *notePager) orderExpr(query *NoteQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultNoteOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Note.
func (_m *NoteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotePaginateOption,
) (*NoteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NoteConnection{Edges: []*NoteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NoteOrderFieldCreatedAt orders Note by created_at.
	NoteOrderFieldCreatedAt = &NoteOrderField{
		Value: func(_m *Note) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: note.FieldCreatedAt,
		toTerm: note.ByCreatedAt,
		toCursor: func(_m *Note) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NoteOrderFieldUpdatedAt orders Note by updated_at.
	NoteOrderFieldUpdatedAt = &NoteOrderField{
		Value: func(_m *Note) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: note.FieldUpdatedAt,
		toTerm: note.ByUpdatedAt,
		toCursor: func(_m *Note) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NoteOrderField) String() string {
	var str string
	switch f.column {
	case NoteOrderFieldCreatedAt.column:
		str = "created_at"
	case NoteOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NoteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NoteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NoteOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NoteOrderFieldCreatedAt
	case "updated_at":
		*f = *NoteOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NoteOrderField", str)
	}
	return nil
}

// NoteOrderField defines the ordering field of Note.
type NoteOrderField struct {
	// Value extracts the ordering value from the given Note.
	Value    func(*Note) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) note.OrderOption
	toCursor func(*Note) Cursor
}

// NoteOrder defines the ordering of Note.
type NoteOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *NoteOrderField `json:"field"`
}

// DefaultNoteOrder is the default ordering of Note.
var DefaultNoteOrder = &NoteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NoteOrderField{
		Value: func(_m *Note) (ent.Value, error) {
			return _m.ID, nil
		},
		column: note.FieldID,
		toTerm: note.ByID,
		toCursor: func(_m *Note) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Note into NoteEdge.
func (_m *Note) ToEdge(order *NoteOrder) *NoteEdge {
	if order == nil {
		order = DefaultNoteOrder
	}
	return &NoteEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// NotificationEdge is the edge representation of Notification.
type NotificationEdge struct {
	Node   *Notification `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// NotificationConnection is the connection containing edges to Notification.
type NotificationConnection struct {
	Edges      []*NotificationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *NotificationConnection) build(nodes []*Notification, pager *notificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Notification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Notification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Notification {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationPaginateOption enables pagination customization.
type NotificationPaginateOption func(*notificationPager) error

// WithNotificationOrder configures pagination ordering.
func WithNotificationOrder(order *NotificationOrder) NotificationPaginateOption {
	if order == nil {
		order = DefaultNotificationOrder
	}
	o := *order
	return func(pager *notificationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotificationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotificationFilter configures pagination filter.
func WithNotificationFilter(filter func(*NotificationQuery) (*NotificationQuery, error)) NotificationPaginateOption {
	return func(pager *notificationPager) error {
		if filter == nil {
			return errors.New("NotificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationPager struct {
	reverse bool
	order   *NotificationOrder
	filter  func(*NotificationQuery) (*NotificationQuery, error)
}

func newNotificationPager(opts []NotificationPaginateOption, reverse bool) (*notificationPager, error) {
	pager := &notificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotificationOrder
	}
	return pager, nil
}

func (p *notificationPager) applyFilter(query *NotificationQuery) (*NotificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationPager) toCursor(_m *Notification) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *notificationPager) applyCursors(query *NotificationQuery, after, before *Cursor) (*NotificationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNotificationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notificationPager) applyOrder(query *NotificationQuery) *NotificationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNotificationOrder.Field {
		query = query.Order(DefaultNotificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notificationPager) orderExpr(query *NotificationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotificationOrder.Field {
			b.Comma().Ident(DefaultNotificationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Notification.
func (_m *NotificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationPaginateOption,
) (*NotificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &NotificationConnection{Edges: []*NotificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotificationOrderFieldCreatedAt orders Notification by created_at.
	NotificationOrderFieldCreatedAt = &NotificationOrderField{
		Value: func(_m *Notification) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: notification.FieldCreatedAt,
		toTerm: notification.ByCreatedAt,
		toCursor: func(_m *Notification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// NotificationOrderFieldUpdatedAt orders Notification by updated_at.
	NotificationOrderFieldUpdatedAt = &NotificationOrderField{
		Value: func(_m *Notification) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: notification.FieldUpdatedAt,
		toTerm: notification.ByUpdatedAt,
		toCursor: func(_m *Notification) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotificationOrderField) String() string {
	var str string
	switch f.column {
	case NotificationOrderFieldCreatedAt.column:
		str = "created_at"
	case NotificationOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotificationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotificationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotificationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *NotificationOrderFieldCreatedAt
	case "updated_at":
		*f = *NotificationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid NotificationOrderField", str)
	}
	return nil
}

// NotificationOrderField defines the ordering field of Notification.
type NotificationOrderField struct {
	// Value extracts the ordering value from the given Notification.
	Value    func(*Notification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notification.OrderOption
	toCursor func(*Notification) Cursor
}

// NotificationOrder defines the ordering of Notification.
type NotificationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *NotificationOrderField `json:"field"`
}

// DefaultNotificationOrder is the default ordering of Notification.
var DefaultNotificationOrder = &NotificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotificationOrderField{
		Value: func(_m *Notification) (ent.Value, error) {
			return _m.ID, nil
		},
		column: notification.FieldID,
		toTerm: notification.ByID,
		toCursor: func(_m *Notification) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Notification into NotificationEdge.
func (_m *Notification) ToEdge(order *NotificationOrder) *NotificationEdge {
	if order == nil {
		order = DefaultNotificationOrder
	}
	return &NotificationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OnboardingEdge is the edge representation of Onboarding.
type OnboardingEdge struct {
	Node   *Onboarding `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// OnboardingConnection is the connection containing edges to Onboarding.
type OnboardingConnection struct {
	Edges      []*OnboardingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *OnboardingConnection) build(nodes []*Onboarding, pager *onboardingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Onboarding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Onboarding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Onboarding {
			return nodes[i]
		}
	}
	c.Edges = make([]*OnboardingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OnboardingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OnboardingPaginateOption enables pagination customization.
type OnboardingPaginateOption func(*onboardingPager) error

// WithOnboardingOrder configures pagination ordering.
func WithOnboardingOrder(order *OnboardingOrder) OnboardingPaginateOption {
	if order == nil {
		order = DefaultOnboardingOrder
	}
	o := *order
	return func(pager *onboardingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOnboardingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOnboardingFilter configures pagination filter.
func WithOnboardingFilter(filter func(*OnboardingQuery) (*OnboardingQuery, error)) OnboardingPaginateOption {
	return func(pager *onboardingPager) error {
		if filter == nil {
			return errors.New("OnboardingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type onboardingPager struct {
	reverse bool
	order   *OnboardingOrder
	filter  func(*OnboardingQuery) (*OnboardingQuery, error)
}

func newOnboardingPager(opts []OnboardingPaginateOption, reverse bool) (*onboardingPager, error) {
	pager := &onboardingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOnboardingOrder
	}
	return pager, nil
}

func (p *onboardingPager) applyFilter(query *OnboardingQuery) (*OnboardingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *onboardingPager) toCursor(_m *Onboarding) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *onboardingPager) applyCursors(query *OnboardingQuery, after, before *Cursor) (*OnboardingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOnboardingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *onboardingPager) applyOrder(query *OnboardingQuery) *OnboardingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOnboardingOrder.Field {
		query = query.Order(DefaultOnboardingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *onboardingPager) orderExpr(query *OnboardingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOnboardingOrder.Field {
			b.Comma().Ident(DefaultOnboardingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Onboarding.
func (_m *OnboardingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OnboardingPaginateOption,
) (*OnboardingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOnboardingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OnboardingConnection{Edges: []*OnboardingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OnboardingOrderField defines the ordering field of Onboarding.
type OnboardingOrderField struct {
	// Value extracts the ordering value from the given Onboarding.
	Value    func(*Onboarding) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) onboarding.OrderOption
	toCursor func(*Onboarding) Cursor
}

// OnboardingOrder defines the ordering of Onboarding.
type OnboardingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *OnboardingOrderField `json:"field"`
}

// DefaultOnboardingOrder is the default ordering of Onboarding.
var DefaultOnboardingOrder = &OnboardingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OnboardingOrderField{
		Value: func(_m *Onboarding) (ent.Value, error) {
			return _m.ID, nil
		},
		column: onboarding.FieldID,
		toTerm: onboarding.ByID,
		toCursor: func(_m *Onboarding) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Onboarding into OnboardingEdge.
func (_m *Onboarding) ToEdge(order *OnboardingOrder) *OnboardingEdge {
	if order == nil {
		order = DefaultOnboardingOrder
	}
	return &OnboardingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgMembershipEdge is the edge representation of OrgMembership.
type OrgMembershipEdge struct {
	Node   *OrgMembership `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// OrgMembershipConnection is the connection containing edges to OrgMembership.
type OrgMembershipConnection struct {
	Edges      []*OrgMembershipEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *OrgMembershipConnection) build(nodes []*OrgMembership, pager *orgmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgMembershipPaginateOption enables pagination customization.
type OrgMembershipPaginateOption func(*orgmembershipPager) error

// WithOrgMembershipOrder configures pagination ordering.
func WithOrgMembershipOrder(order []*OrgMembershipOrder) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrgMembershipFilter configures pagination filter.
func WithOrgMembershipFilter(filter func(*OrgMembershipQuery) (*OrgMembershipQuery, error)) OrgMembershipPaginateOption {
	return func(pager *orgmembershipPager) error {
		if filter == nil {
			return errors.New("OrgMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgmembershipPager struct {
	reverse bool
	order   []*OrgMembershipOrder
	filter  func(*OrgMembershipQuery) (*OrgMembershipQuery, error)
}

func newOrgMembershipPager(opts []OrgMembershipPaginateOption, reverse bool) (*orgmembershipPager, error) {
	pager := &orgmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *orgmembershipPager) applyFilter(query *OrgMembershipQuery) (*OrgMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgmembershipPager) toCursor(_m *OrgMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *orgmembershipPager) applyCursors(query *OrgMembershipQuery, after, before *Cursor) (*OrgMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrgMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *orgmembershipPager) applyOrder(query *OrgMembershipQuery) *OrgMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrgMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrgMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *orgmembershipPager) orderExpr(query *OrgMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrgMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgMembership.
func (_m *OrgMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgMembershipPaginateOption,
) (*OrgMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgMembershipConnection{Edges: []*OrgMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgMembershipOrderFieldCreatedAt orders OrgMembership by created_at.
	OrgMembershipOrderFieldCreatedAt = &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgmembership.FieldCreatedAt,
		toTerm: orgmembership.ByCreatedAt,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgMembershipOrderFieldUpdatedAt orders OrgMembership by updated_at.
	OrgMembershipOrderFieldUpdatedAt = &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgmembership.FieldUpdatedAt,
		toTerm: orgmembership.ByUpdatedAt,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgMembershipOrderFieldRole orders OrgMembership by role.
	OrgMembershipOrderFieldRole = &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.Role, nil
		},
		column: orgmembership.FieldRole,
		toTerm: orgmembership.ByRole,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgMembershipOrderField) String() string {
	var str string
	switch f.column {
	case OrgMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrgMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *OrgMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid OrgMembershipOrderField", str)
	}
	return nil
}

// OrgMembershipOrderField defines the ordering field of OrgMembership.
type OrgMembershipOrderField struct {
	// Value extracts the ordering value from the given OrgMembership.
	Value    func(*OrgMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgmembership.OrderOption
	toCursor func(*OrgMembership) Cursor
}

// OrgMembershipOrder defines the ordering of OrgMembership.
type OrgMembershipOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *OrgMembershipOrderField `json:"field"`
}

// DefaultOrgMembershipOrder is the default ordering of OrgMembership.
var DefaultOrgMembershipOrder = &OrgMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgMembershipOrderField{
		Value: func(_m *OrgMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgmembership.FieldID,
		toTerm: orgmembership.ByID,
		toCursor: func(_m *OrgMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgMembership into OrgMembershipEdge.
func (_m *OrgMembership) ToEdge(order *OrgMembershipOrder) *OrgMembershipEdge {
	if order == nil {
		order = DefaultOrgMembershipOrder
	}
	return &OrgMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrgSubscriptionEdge is the edge representation of OrgSubscription.
type OrgSubscriptionEdge struct {
	Node   *OrgSubscription `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// OrgSubscriptionConnection is the connection containing edges to OrgSubscription.
type OrgSubscriptionConnection struct {
	Edges      []*OrgSubscriptionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *OrgSubscriptionConnection) build(nodes []*OrgSubscription, pager *orgsubscriptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrgSubscription
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgSubscription {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgSubscription {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgSubscriptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgSubscriptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgSubscriptionPaginateOption enables pagination customization.
type OrgSubscriptionPaginateOption func(*orgsubscriptionPager) error

// WithOrgSubscriptionOrder configures pagination ordering.
func WithOrgSubscriptionOrder(order *OrgSubscriptionOrder) OrgSubscriptionPaginateOption {
	if order == nil {
		order = DefaultOrgSubscriptionOrder
	}
	o := *order
	return func(pager *orgsubscriptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgSubscriptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgSubscriptionFilter configures pagination filter.
func WithOrgSubscriptionFilter(filter func(*OrgSubscriptionQuery) (*OrgSubscriptionQuery, error)) OrgSubscriptionPaginateOption {
	return func(pager *orgsubscriptionPager) error {
		if filter == nil {
			return errors.New("OrgSubscriptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgsubscriptionPager struct {
	reverse bool
	order   *OrgSubscriptionOrder
	filter  func(*OrgSubscriptionQuery) (*OrgSubscriptionQuery, error)
}

func newOrgSubscriptionPager(opts []OrgSubscriptionPaginateOption, reverse bool) (*orgsubscriptionPager, error) {
	pager := &orgsubscriptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgSubscriptionOrder
	}
	return pager, nil
}

func (p *orgsubscriptionPager) applyFilter(query *OrgSubscriptionQuery) (*OrgSubscriptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgsubscriptionPager) toCursor(_m *OrgSubscription) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *orgsubscriptionPager) applyCursors(query *OrgSubscriptionQuery, after, before *Cursor) (*OrgSubscriptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgSubscriptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgsubscriptionPager) applyOrder(query *OrgSubscriptionQuery) *OrgSubscriptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgSubscriptionOrder.Field {
		query = query.Order(DefaultOrgSubscriptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgsubscriptionPager) orderExpr(query *OrgSubscriptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgSubscriptionOrder.Field {
			b.Comma().Ident(DefaultOrgSubscriptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgSubscription.
func (_m *OrgSubscriptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgSubscriptionPaginateOption,
) (*OrgSubscriptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgSubscriptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrgSubscriptionConnection{Edges: []*OrgSubscriptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrgSubscriptionOrderFieldCreatedAt orders OrgSubscription by created_at.
	OrgSubscriptionOrderFieldCreatedAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: orgsubscription.FieldCreatedAt,
		toTerm: orgsubscription.ByCreatedAt,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldUpdatedAt orders OrgSubscription by updated_at.
	OrgSubscriptionOrderFieldUpdatedAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: orgsubscription.FieldUpdatedAt,
		toTerm: orgsubscription.ByUpdatedAt,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldStripeSubscriptionStatus orders OrgSubscription by stripe_subscription_status.
	OrgSubscriptionOrderFieldStripeSubscriptionStatus = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.StripeSubscriptionStatus, nil
		},
		column: orgsubscription.FieldStripeSubscriptionStatus,
		toTerm: orgsubscription.ByStripeSubscriptionStatus,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StripeSubscriptionStatus,
			}
		},
	}
	// OrgSubscriptionOrderFieldActive orders OrgSubscription by active.
	OrgSubscriptionOrderFieldActive = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.Active, nil
		},
		column: orgsubscription.FieldActive,
		toTerm: orgsubscription.ByActive,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// OrgSubscriptionOrderFieldExpiresAt orders OrgSubscription by expires_at.
	OrgSubscriptionOrderFieldExpiresAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: orgsubscription.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscription) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldTrialExpiresAt orders OrgSubscription by trial_expires_at.
	OrgSubscriptionOrderFieldTrialExpiresAt = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if _m.TrialExpiresAt == nil {
				return nil, nil
			}
			return _m.TrialExpiresAt, nil
		},
		column: orgsubscription.FieldTrialExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByTrialExpiresAt(opts...)
		},
		toCursor: func(_m *OrgSubscription) Cursor {
			if _m.TrialExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.TrialExpiresAt,
			}
		},
	}
	// OrgSubscriptionOrderFieldDaysUntilDue orders OrgSubscription by days_until_due.
	OrgSubscriptionOrderFieldDaysUntilDue = &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			// allow for nil values for fields
			if _m.DaysUntilDue == nil {
				return nil, nil
			}
			return _m.DaysUntilDue, nil
		},
		column: orgsubscription.FieldDaysUntilDue,
		toTerm: func(opts ...sql.OrderTermOption) orgsubscription.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return orgsubscription.ByDaysUntilDue(opts...)
		},
		toCursor: func(_m *OrgSubscription) Cursor {
			if _m.DaysUntilDue == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.DaysUntilDue,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrgSubscriptionOrderField) String() string {
	var str string
	switch f.column {
	case OrgSubscriptionOrderFieldCreatedAt.column:
		str = "created_at"
	case OrgSubscriptionOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrgSubscriptionOrderFieldStripeSubscriptionStatus.column:
		str = "stripe_subscription_status"
	case OrgSubscriptionOrderFieldActive.column:
		str = "active"
	case OrgSubscriptionOrderFieldExpiresAt.column:
		str = "expires_at"
	case OrgSubscriptionOrderFieldTrialExpiresAt.column:
		str = "trial_expires_at"
	case OrgSubscriptionOrderFieldDaysUntilDue.column:
		str = "days_until_due"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrgSubscriptionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrgSubscriptionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrgSubscriptionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrgSubscriptionOrderFieldCreatedAt
	case "updated_at":
		*f = *OrgSubscriptionOrderFieldUpdatedAt
	case "stripe_subscription_status":
		*f = *OrgSubscriptionOrderFieldStripeSubscriptionStatus
	case "active":
		*f = *OrgSubscriptionOrderFieldActive
	case "expires_at":
		*f = *OrgSubscriptionOrderFieldExpiresAt
	case "trial_expires_at":
		*f = *OrgSubscriptionOrderFieldTrialExpiresAt
	case "days_until_due":
		*f = *OrgSubscriptionOrderFieldDaysUntilDue
	default:
		return fmt.Errorf("%s is not a valid OrgSubscriptionOrderField", str)
	}
	return nil
}

// OrgSubscriptionOrderField defines the ordering field of OrgSubscription.
type OrgSubscriptionOrderField struct {
	// Value extracts the ordering value from the given OrgSubscription.
	Value    func(*OrgSubscription) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgsubscription.OrderOption
	toCursor func(*OrgSubscription) Cursor
}

// OrgSubscriptionOrder defines the ordering of OrgSubscription.
type OrgSubscriptionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *OrgSubscriptionOrderField `json:"field"`
}

// DefaultOrgSubscriptionOrder is the default ordering of OrgSubscription.
var DefaultOrgSubscriptionOrder = &OrgSubscriptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgSubscriptionOrderField{
		Value: func(_m *OrgSubscription) (ent.Value, error) {
			return _m.ID, nil
		},
		column: orgsubscription.FieldID,
		toTerm: orgsubscription.ByID,
		toCursor: func(_m *OrgSubscription) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrgSubscription into OrgSubscriptionEdge.
func (_m *OrgSubscription) ToEdge(order *OrgSubscriptionOrder) *OrgSubscriptionEdge {
	if order == nil {
		order = DefaultOrgSubscriptionOrder
	}
	return &OrgSubscriptionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order []*OrganizationOrder) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   []*OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(_m *Organization) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (_m *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationOrderFieldCreatedAt orders Organization by created_at.
	OrganizationOrderFieldCreatedAt = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organization.FieldCreatedAt,
		toTerm: organization.ByCreatedAt,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationOrderFieldUpdatedAt orders Organization by updated_at.
	OrganizationOrderFieldUpdatedAt = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organization.FieldUpdatedAt,
		toTerm: organization.ByUpdatedAt,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// OrganizationOrderFieldName orders Organization by name.
	OrganizationOrderFieldName = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.Name, nil
		},
		column: organization.FieldName,
		toTerm: organization.ByName,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// OrganizationOrderFieldDisplayName orders Organization by display_name.
	OrganizationOrderFieldDisplayName = &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: organization.FieldDisplayName,
		toTerm: organization.ByDisplayName,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case OrganizationOrderFieldName.column:
		str = "name"
	case OrganizationOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrganizationOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationOrderFieldUpdatedAt
	case "name":
		*f = *OrganizationOrderFieldName
	case "display_name":
		*f = *OrganizationOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(_m *Organization) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(_m *Organization) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (_m *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// OrganizationSettingEdge is the edge representation of OrganizationSetting.
type OrganizationSettingEdge struct {
	Node   *OrganizationSetting `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// OrganizationSettingConnection is the connection containing edges to OrganizationSetting.
type OrganizationSettingConnection struct {
	Edges      []*OrganizationSettingEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *OrganizationSettingConnection) build(nodes []*OrganizationSetting, pager *organizationsettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *OrganizationSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrganizationSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationSettingPaginateOption enables pagination customization.
type OrganizationSettingPaginateOption func(*organizationsettingPager) error

// WithOrganizationSettingOrder configures pagination ordering.
func WithOrganizationSettingOrder(order []*OrganizationSettingOrder) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithOrganizationSettingFilter configures pagination filter.
func WithOrganizationSettingFilter(filter func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)) OrganizationSettingPaginateOption {
	return func(pager *organizationsettingPager) error {
		if filter == nil {
			return errors.New("OrganizationSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationsettingPager struct {
	reverse bool
	order   []*OrganizationSettingOrder
	filter  func(*OrganizationSettingQuery) (*OrganizationSettingQuery, error)
}

func newOrganizationSettingPager(opts []OrganizationSettingPaginateOption, reverse bool) (*organizationsettingPager, error) {
	pager := &organizationsettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *organizationsettingPager) applyFilter(query *OrganizationSettingQuery) (*OrganizationSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationsettingPager) toCursor(_m *OrganizationSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *organizationsettingPager) applyCursors(query *OrganizationSettingQuery, after, before *Cursor) (*OrganizationSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultOrganizationSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *organizationsettingPager) applyOrder(query *OrganizationSettingQuery) *OrganizationSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultOrganizationSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultOrganizationSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *organizationsettingPager) orderExpr(query *OrganizationSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultOrganizationSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrganizationSetting.
func (_m *OrganizationSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationSettingPaginateOption,
) (*OrganizationSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &OrganizationSettingConnection{Edges: []*OrganizationSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrganizationSettingOrderFieldCreatedAt orders OrganizationSetting by created_at.
	OrganizationSettingOrderFieldCreatedAt = &OrganizationSettingOrderField{
		Value: func(_m *OrganizationSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: organizationsetting.FieldCreatedAt,
		toTerm: organizationsetting.ByCreatedAt,
		toCursor: func(_m *OrganizationSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// OrganizationSettingOrderFieldUpdatedAt orders OrganizationSetting by updated_at.
	OrganizationSettingOrderFieldUpdatedAt = &OrganizationSettingOrderField{
		Value: func(_m *OrganizationSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: organizationsetting.FieldUpdatedAt,
		toTerm: organizationsetting.ByUpdatedAt,
		toCursor: func(_m *OrganizationSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationSettingOrderField) String() string {
	var str string
	switch f.column {
	case OrganizationSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case OrganizationSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OrganizationSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *OrganizationSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OrganizationSettingOrderField", str)
	}
	return nil
}

// OrganizationSettingOrderField defines the ordering field of OrganizationSetting.
type OrganizationSettingOrderField struct {
	// Value extracts the ordering value from the given OrganizationSetting.
	Value    func(*OrganizationSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organizationsetting.OrderOption
	toCursor func(*OrganizationSetting) Cursor
}

// OrganizationSettingOrder defines the ordering of OrganizationSetting.
type OrganizationSettingOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *OrganizationSettingOrderField `json:"field"`
}

// DefaultOrganizationSettingOrder is the default ordering of OrganizationSetting.
var DefaultOrganizationSettingOrder = &OrganizationSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationSettingOrderField{
		Value: func(_m *OrganizationSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: organizationsetting.FieldID,
		toTerm: organizationsetting.ByID,
		toCursor: func(_m *OrganizationSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts OrganizationSetting into OrganizationSettingEdge.
func (_m *OrganizationSetting) ToEdge(order *OrganizationSettingOrder) *OrganizationSettingEdge {
	if order == nil {
		order = DefaultOrganizationSettingOrder
	}
	return &OrganizationSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// PersonalAccessTokenEdge is the edge representation of PersonalAccessToken.
type PersonalAccessTokenEdge struct {
	Node   *PersonalAccessToken `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// PersonalAccessTokenConnection is the connection containing edges to PersonalAccessToken.
type PersonalAccessTokenConnection struct {
	Edges      []*PersonalAccessTokenEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *PersonalAccessTokenConnection) build(nodes []*PersonalAccessToken, pager *personalaccesstokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *PersonalAccessToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PersonalAccessToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*PersonalAccessTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PersonalAccessTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PersonalAccessTokenPaginateOption enables pagination customization.
type PersonalAccessTokenPaginateOption func(*personalaccesstokenPager) error

// WithPersonalAccessTokenOrder configures pagination ordering.
func WithPersonalAccessTokenOrder(order []*PersonalAccessTokenOrder) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPersonalAccessTokenFilter configures pagination filter.
func WithPersonalAccessTokenFilter(filter func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)) PersonalAccessTokenPaginateOption {
	return func(pager *personalaccesstokenPager) error {
		if filter == nil {
			return errors.New("PersonalAccessTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type personalaccesstokenPager struct {
	reverse bool
	order   []*PersonalAccessTokenOrder
	filter  func(*PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error)
}

func newPersonalAccessTokenPager(opts []PersonalAccessTokenPaginateOption, reverse bool) (*personalaccesstokenPager, error) {
	pager := &personalaccesstokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *personalaccesstokenPager) applyFilter(query *PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *personalaccesstokenPager) toCursor(_m *PersonalAccessToken) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *personalaccesstokenPager) applyCursors(query *PersonalAccessTokenQuery, after, before *Cursor) (*PersonalAccessTokenQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPersonalAccessTokenOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *personalaccesstokenPager) applyOrder(query *PersonalAccessTokenQuery) *PersonalAccessTokenQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPersonalAccessTokenOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPersonalAccessTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *personalaccesstokenPager) orderExpr(query *PersonalAccessTokenQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPersonalAccessTokenOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to PersonalAccessToken.
func (_m *PersonalAccessTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PersonalAccessTokenPaginateOption,
) (*PersonalAccessTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPersonalAccessTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &PersonalAccessTokenConnection{Edges: []*PersonalAccessTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PersonalAccessTokenOrderFieldCreatedAt orders PersonalAccessToken by created_at.
	PersonalAccessTokenOrderFieldCreatedAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: personalaccesstoken.FieldCreatedAt,
		toTerm: personalaccesstoken.ByCreatedAt,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldUpdatedAt orders PersonalAccessToken by updated_at.
	PersonalAccessTokenOrderFieldUpdatedAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: personalaccesstoken.FieldUpdatedAt,
		toTerm: personalaccesstoken.ByUpdatedAt,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldName orders PersonalAccessToken by name.
	PersonalAccessTokenOrderFieldName = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.Name, nil
		},
		column: personalaccesstoken.FieldName,
		toTerm: personalaccesstoken.ByName,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// PersonalAccessTokenOrderFieldExpiresAt orders PersonalAccessToken by expires_at.
	PersonalAccessTokenOrderFieldExpiresAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ExpiresAt == nil {
				return nil, nil
			}
			return _m.ExpiresAt, nil
		},
		column: personalaccesstoken.FieldExpiresAt,
		toTerm: func(opts ...sql.OrderTermOption) personalaccesstoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return personalaccesstoken.ByExpiresAt(opts...)
		},
		toCursor: func(_m *PersonalAccessToken) Cursor {
			if _m.ExpiresAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExpiresAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldLastUsedAt orders PersonalAccessToken by last_used_at.
	PersonalAccessTokenOrderFieldLastUsedAt = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			// allow for nil values for fields
			if _m.LastUsedAt == nil {
				return nil, nil
			}
			return _m.LastUsedAt, nil
		},
		column: personalaccesstoken.FieldLastUsedAt,
		toTerm: func(opts ...sql.OrderTermOption) personalaccesstoken.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return personalaccesstoken.ByLastUsedAt(opts...)
		},
		toCursor: func(_m *PersonalAccessToken) Cursor {
			if _m.LastUsedAt == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastUsedAt,
			}
		},
	}
	// PersonalAccessTokenOrderFieldIsActive orders PersonalAccessToken by is_active.
	PersonalAccessTokenOrderFieldIsActive = &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.IsActive, nil
		},
		column: personalaccesstoken.FieldIsActive,
		toTerm: personalaccesstoken.ByIsActive,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.IsActive,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PersonalAccessTokenOrderField) String() string {
	var str string
	switch f.column {
	case PersonalAccessTokenOrderFieldCreatedAt.column:
		str = "created_at"
	case PersonalAccessTokenOrderFieldUpdatedAt.column:
		str = "updated_at"
	case PersonalAccessTokenOrderFieldName.column:
		str = "name"
	case PersonalAccessTokenOrderFieldExpiresAt.column:
		str = "expires_at"
	case PersonalAccessTokenOrderFieldLastUsedAt.column:
		str = "last_used_at"
	case PersonalAccessTokenOrderFieldIsActive.column:
		str = "is_active"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PersonalAccessTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PersonalAccessTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PersonalAccessTokenOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *PersonalAccessTokenOrderFieldCreatedAt
	case "updated_at":
		*f = *PersonalAccessTokenOrderFieldUpdatedAt
	case "name":
		*f = *PersonalAccessTokenOrderFieldName
	case "expires_at":
		*f = *PersonalAccessTokenOrderFieldExpiresAt
	case "last_used_at":
		*f = *PersonalAccessTokenOrderFieldLastUsedAt
	case "is_active":
		*f = *PersonalAccessTokenOrderFieldIsActive
	default:
		return fmt.Errorf("%s is not a valid PersonalAccessTokenOrderField", str)
	}
	return nil
}

// PersonalAccessTokenOrderField defines the ordering field of PersonalAccessToken.
type PersonalAccessTokenOrderField struct {
	// Value extracts the ordering value from the given PersonalAccessToken.
	Value    func(*PersonalAccessToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) personalaccesstoken.OrderOption
	toCursor func(*PersonalAccessToken) Cursor
}

// PersonalAccessTokenOrder defines the ordering of PersonalAccessToken.
type PersonalAccessTokenOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *PersonalAccessTokenOrderField `json:"field"`
}

// DefaultPersonalAccessTokenOrder is the default ordering of PersonalAccessToken.
var DefaultPersonalAccessTokenOrder = &PersonalAccessTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PersonalAccessTokenOrderField{
		Value: func(_m *PersonalAccessToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: personalaccesstoken.FieldID,
		toTerm: personalaccesstoken.ByID,
		toCursor: func(_m *PersonalAccessToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts PersonalAccessToken into PersonalAccessTokenEdge.
func (_m *PersonalAccessToken) ToEdge(order *PersonalAccessTokenOrder) *PersonalAccessTokenEdge {
	if order == nil {
		order = DefaultPersonalAccessTokenOrder
	}
	return &PersonalAccessTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProcedureEdge is the edge representation of Procedure.
type ProcedureEdge struct {
	Node   *Procedure `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ProcedureConnection is the connection containing edges to Procedure.
type ProcedureConnection struct {
	Edges      []*ProcedureEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ProcedureConnection) build(nodes []*Procedure, pager *procedurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Procedure
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Procedure {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Procedure {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcedureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcedureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcedurePaginateOption enables pagination customization.
type ProcedurePaginateOption func(*procedurePager) error

// WithProcedureOrder configures pagination ordering.
func WithProcedureOrder(order []*ProcedureOrder) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProcedureFilter configures pagination filter.
func WithProcedureFilter(filter func(*ProcedureQuery) (*ProcedureQuery, error)) ProcedurePaginateOption {
	return func(pager *procedurePager) error {
		if filter == nil {
			return errors.New("ProcedureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procedurePager struct {
	reverse bool
	order   []*ProcedureOrder
	filter  func(*ProcedureQuery) (*ProcedureQuery, error)
}

func newProcedurePager(opts []ProcedurePaginateOption, reverse bool) (*procedurePager, error) {
	pager := &procedurePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *procedurePager) applyFilter(query *ProcedureQuery) (*ProcedureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procedurePager) toCursor(_m *Procedure) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *procedurePager) applyCursors(query *ProcedureQuery, after, before *Cursor) (*ProcedureQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProcedureOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *procedurePager) applyOrder(query *ProcedureQuery) *ProcedureQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProcedureOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProcedureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *procedurePager) orderExpr(query *ProcedureQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProcedureOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Procedure.
func (_m *ProcedureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcedurePaginateOption,
) (*ProcedureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcedurePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProcedureConnection{Edges: []*ProcedureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcedureOrderFieldCreatedAt orders Procedure by created_at.
	ProcedureOrderFieldCreatedAt = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: procedure.FieldCreatedAt,
		toTerm: procedure.ByCreatedAt,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProcedureOrderFieldUpdatedAt orders Procedure by updated_at.
	ProcedureOrderFieldUpdatedAt = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: procedure.FieldUpdatedAt,
		toTerm: procedure.ByUpdatedAt,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProcedureOrderFieldRevision orders Procedure by revision.
	ProcedureOrderFieldRevision = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: procedure.FieldRevision,
		toTerm: procedure.ByRevision,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// ProcedureOrderFieldName orders Procedure by name.
	ProcedureOrderFieldName = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.Name, nil
		},
		column: procedure.FieldName,
		toTerm: procedure.ByName,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProcedureOrderFieldStatus orders Procedure by status.
	ProcedureOrderFieldStatus = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.Status, nil
		},
		column: procedure.FieldStatus,
		toTerm: procedure.ByStatus,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProcedureOrderFieldReviewDue orders Procedure by review_due.
	ProcedureOrderFieldReviewDue = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.ReviewDue, nil
		},
		column: procedure.FieldReviewDue,
		toTerm: procedure.ByReviewDue,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewDue,
			}
		},
	}
	// ProcedureOrderFieldReviewFrequency orders Procedure by review_frequency.
	ProcedureOrderFieldReviewFrequency = &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.ReviewFrequency, nil
		},
		column: procedure.FieldReviewFrequency,
		toTerm: procedure.ByReviewFrequency,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReviewFrequency,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcedureOrderField) String() string {
	var str string
	switch f.column {
	case ProcedureOrderFieldCreatedAt.column:
		str = "created_at"
	case ProcedureOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProcedureOrderFieldRevision.column:
		str = "revision"
	case ProcedureOrderFieldName.column:
		str = "name"
	case ProcedureOrderFieldStatus.column:
		str = "STATUS"
	case ProcedureOrderFieldReviewDue.column:
		str = "review_due"
	case ProcedureOrderFieldReviewFrequency.column:
		str = "REVIEW_FREQUENCY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcedureOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcedureOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcedureOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProcedureOrderFieldCreatedAt
	case "updated_at":
		*f = *ProcedureOrderFieldUpdatedAt
	case "revision":
		*f = *ProcedureOrderFieldRevision
	case "name":
		*f = *ProcedureOrderFieldName
	case "STATUS":
		*f = *ProcedureOrderFieldStatus
	case "review_due":
		*f = *ProcedureOrderFieldReviewDue
	case "REVIEW_FREQUENCY":
		*f = *ProcedureOrderFieldReviewFrequency
	default:
		return fmt.Errorf("%s is not a valid ProcedureOrderField", str)
	}
	return nil
}

// ProcedureOrderField defines the ordering field of Procedure.
type ProcedureOrderField struct {
	// Value extracts the ordering value from the given Procedure.
	Value    func(*Procedure) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procedure.OrderOption
	toCursor func(*Procedure) Cursor
}

// ProcedureOrder defines the ordering of Procedure.
type ProcedureOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ProcedureOrderField `json:"field"`
}

// DefaultProcedureOrder is the default ordering of Procedure.
var DefaultProcedureOrder = &ProcedureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcedureOrderField{
		Value: func(_m *Procedure) (ent.Value, error) {
			return _m.ID, nil
		},
		column: procedure.FieldID,
		toTerm: procedure.ByID,
		toCursor: func(_m *Procedure) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Procedure into ProcedureEdge.
func (_m *Procedure) ToEdge(order *ProcedureOrder) *ProcedureEdge {
	if order == nil {
		order = DefaultProcedureOrder
	}
	return &ProcedureEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramEdge is the edge representation of Program.
type ProgramEdge struct {
	Node   *Program `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProgramConnection is the connection containing edges to Program.
type ProgramConnection struct {
	Edges      []*ProgramEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProgramConnection) build(nodes []*Program, pager *programPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Program
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Program {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Program {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramPaginateOption enables pagination customization.
type ProgramPaginateOption func(*programPager) error

// WithProgramOrder configures pagination ordering.
func WithProgramOrder(order []*ProgramOrder) ProgramPaginateOption {
	return func(pager *programPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProgramFilter configures pagination filter.
func WithProgramFilter(filter func(*ProgramQuery) (*ProgramQuery, error)) ProgramPaginateOption {
	return func(pager *programPager) error {
		if filter == nil {
			return errors.New("ProgramQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programPager struct {
	reverse bool
	order   []*ProgramOrder
	filter  func(*ProgramQuery) (*ProgramQuery, error)
}

func newProgramPager(opts []ProgramPaginateOption, reverse bool) (*programPager, error) {
	pager := &programPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *programPager) applyFilter(query *ProgramQuery) (*ProgramQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programPager) toCursor(_m *Program) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *programPager) applyCursors(query *ProgramQuery, after, before *Cursor) (*ProgramQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProgramOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *programPager) applyOrder(query *ProgramQuery) *ProgramQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProgramOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProgramOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *programPager) orderExpr(query *ProgramQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProgramOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Program.
func (_m *ProgramQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramPaginateOption,
) (*ProgramConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramConnection{Edges: []*ProgramEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramOrderFieldCreatedAt orders Program by created_at.
	ProgramOrderFieldCreatedAt = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: program.FieldCreatedAt,
		toTerm: program.ByCreatedAt,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramOrderFieldUpdatedAt orders Program by updated_at.
	ProgramOrderFieldUpdatedAt = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: program.FieldUpdatedAt,
		toTerm: program.ByUpdatedAt,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramOrderFieldName orders Program by name.
	ProgramOrderFieldName = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.Name, nil
		},
		column: program.FieldName,
		toTerm: program.ByName,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// ProgramOrderFieldStatus orders Program by status.
	ProgramOrderFieldStatus = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.Status, nil
		},
		column: program.FieldStatus,
		toTerm: program.ByStatus,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// ProgramOrderFieldProgramType orders Program by program_type.
	ProgramOrderFieldProgramType = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.ProgramType, nil
		},
		column: program.FieldProgramType,
		toTerm: program.ByProgramType,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ProgramType,
			}
		},
	}
	// ProgramOrderFieldFrameworkName orders Program by framework_name.
	ProgramOrderFieldFrameworkName = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.FrameworkName, nil
		},
		column: program.FieldFrameworkName,
		toTerm: program.ByFrameworkName,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FrameworkName,
			}
		},
	}
	// ProgramOrderFieldStartDate orders Program by start_date.
	ProgramOrderFieldStartDate = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.StartDate, nil
		},
		column: program.FieldStartDate,
		toTerm: program.ByStartDate,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StartDate,
			}
		},
	}
	// ProgramOrderFieldEndDate orders Program by end_date.
	ProgramOrderFieldEndDate = &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.EndDate, nil
		},
		column: program.FieldEndDate,
		toTerm: program.ByEndDate,
		toCursor: func(_m *Program) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramOrderField) String() string {
	var str string
	switch f.column {
	case ProgramOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramOrderFieldName.column:
		str = "name"
	case ProgramOrderFieldStatus.column:
		str = "STATUS"
	case ProgramOrderFieldProgramType.column:
		str = "PROGRAM_TYPE"
	case ProgramOrderFieldFrameworkName.column:
		str = "framework"
	case ProgramOrderFieldStartDate.column:
		str = "start_date"
	case ProgramOrderFieldEndDate.column:
		str = "end_date"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProgramOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramOrderFieldUpdatedAt
	case "name":
		*f = *ProgramOrderFieldName
	case "STATUS":
		*f = *ProgramOrderFieldStatus
	case "PROGRAM_TYPE":
		*f = *ProgramOrderFieldProgramType
	case "framework":
		*f = *ProgramOrderFieldFrameworkName
	case "start_date":
		*f = *ProgramOrderFieldStartDate
	case "end_date":
		*f = *ProgramOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid ProgramOrderField", str)
	}
	return nil
}

// ProgramOrderField defines the ordering field of Program.
type ProgramOrderField struct {
	// Value extracts the ordering value from the given Program.
	Value    func(*Program) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) program.OrderOption
	toCursor func(*Program) Cursor
}

// ProgramOrder defines the ordering of Program.
type ProgramOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProgramOrderField `json:"field"`
}

// DefaultProgramOrder is the default ordering of Program.
var DefaultProgramOrder = &ProgramOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramOrderField{
		Value: func(_m *Program) (ent.Value, error) {
			return _m.ID, nil
		},
		column: program.FieldID,
		toTerm: program.ByID,
		toCursor: func(_m *Program) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Program into ProgramEdge.
func (_m *Program) ToEdge(order *ProgramOrder) *ProgramEdge {
	if order == nil {
		order = DefaultProgramOrder
	}
	return &ProgramEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ProgramMembershipEdge is the edge representation of ProgramMembership.
type ProgramMembershipEdge struct {
	Node   *ProgramMembership `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ProgramMembershipConnection is the connection containing edges to ProgramMembership.
type ProgramMembershipConnection struct {
	Edges      []*ProgramMembershipEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ProgramMembershipConnection) build(nodes []*ProgramMembership, pager *programmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ProgramMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProgramMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProgramMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProgramMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProgramMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProgramMembershipPaginateOption enables pagination customization.
type ProgramMembershipPaginateOption func(*programmembershipPager) error

// WithProgramMembershipOrder configures pagination ordering.
func WithProgramMembershipOrder(order []*ProgramMembershipOrder) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithProgramMembershipFilter configures pagination filter.
func WithProgramMembershipFilter(filter func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)) ProgramMembershipPaginateOption {
	return func(pager *programmembershipPager) error {
		if filter == nil {
			return errors.New("ProgramMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type programmembershipPager struct {
	reverse bool
	order   []*ProgramMembershipOrder
	filter  func(*ProgramMembershipQuery) (*ProgramMembershipQuery, error)
}

func newProgramMembershipPager(opts []ProgramMembershipPaginateOption, reverse bool) (*programmembershipPager, error) {
	pager := &programmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *programmembershipPager) applyFilter(query *ProgramMembershipQuery) (*ProgramMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *programmembershipPager) toCursor(_m *ProgramMembership) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *programmembershipPager) applyCursors(query *ProgramMembershipQuery, after, before *Cursor) (*ProgramMembershipQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultProgramMembershipOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *programmembershipPager) applyOrder(query *ProgramMembershipQuery) *ProgramMembershipQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultProgramMembershipOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultProgramMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *programmembershipPager) orderExpr(query *ProgramMembershipQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultProgramMembershipOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProgramMembership.
func (_m *ProgramMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProgramMembershipPaginateOption,
) (*ProgramMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProgramMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ProgramMembershipConnection{Edges: []*ProgramMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProgramMembershipOrderFieldCreatedAt orders ProgramMembership by created_at.
	ProgramMembershipOrderFieldCreatedAt = &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: programmembership.FieldCreatedAt,
		toTerm: programmembership.ByCreatedAt,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ProgramMembershipOrderFieldUpdatedAt orders ProgramMembership by updated_at.
	ProgramMembershipOrderFieldUpdatedAt = &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: programmembership.FieldUpdatedAt,
		toTerm: programmembership.ByUpdatedAt,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ProgramMembershipOrderFieldRole orders ProgramMembership by role.
	ProgramMembershipOrderFieldRole = &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.Role, nil
		},
		column: programmembership.FieldRole,
		toTerm: programmembership.ByRole,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Role,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProgramMembershipOrderField) String() string {
	var str string
	switch f.column {
	case ProgramMembershipOrderFieldCreatedAt.column:
		str = "created_at"
	case ProgramMembershipOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ProgramMembershipOrderFieldRole.column:
		str = "ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProgramMembershipOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProgramMembershipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProgramMembershipOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ProgramMembershipOrderFieldCreatedAt
	case "updated_at":
		*f = *ProgramMembershipOrderFieldUpdatedAt
	case "ROLE":
		*f = *ProgramMembershipOrderFieldRole
	default:
		return fmt.Errorf("%s is not a valid ProgramMembershipOrderField", str)
	}
	return nil
}

// ProgramMembershipOrderField defines the ordering field of ProgramMembership.
type ProgramMembershipOrderField struct {
	// Value extracts the ordering value from the given ProgramMembership.
	Value    func(*ProgramMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) programmembership.OrderOption
	toCursor func(*ProgramMembership) Cursor
}

// ProgramMembershipOrder defines the ordering of ProgramMembership.
type ProgramMembershipOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ProgramMembershipOrderField `json:"field"`
}

// DefaultProgramMembershipOrder is the default ordering of ProgramMembership.
var DefaultProgramMembershipOrder = &ProgramMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProgramMembershipOrderField{
		Value: func(_m *ProgramMembership) (ent.Value, error) {
			return _m.ID, nil
		},
		column: programmembership.FieldID,
		toTerm: programmembership.ByID,
		toCursor: func(_m *ProgramMembership) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ProgramMembership into ProgramMembershipEdge.
func (_m *ProgramMembership) ToEdge(order *ProgramMembershipOrder) *ProgramMembershipEdge {
	if order == nil {
		order = DefaultProgramMembershipOrder
	}
	return &ProgramMembershipEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RemediationEdge is the edge representation of Remediation.
type RemediationEdge struct {
	Node   *Remediation `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// RemediationConnection is the connection containing edges to Remediation.
type RemediationConnection struct {
	Edges      []*RemediationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *RemediationConnection) build(nodes []*Remediation, pager *remediationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Remediation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Remediation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Remediation {
			return nodes[i]
		}
	}
	c.Edges = make([]*RemediationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RemediationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RemediationPaginateOption enables pagination customization.
type RemediationPaginateOption func(*remediationPager) error

// WithRemediationOrder configures pagination ordering.
func WithRemediationOrder(order []*RemediationOrder) RemediationPaginateOption {
	return func(pager *remediationPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRemediationFilter configures pagination filter.
func WithRemediationFilter(filter func(*RemediationQuery) (*RemediationQuery, error)) RemediationPaginateOption {
	return func(pager *remediationPager) error {
		if filter == nil {
			return errors.New("RemediationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type remediationPager struct {
	reverse bool
	order   []*RemediationOrder
	filter  func(*RemediationQuery) (*RemediationQuery, error)
}

func newRemediationPager(opts []RemediationPaginateOption, reverse bool) (*remediationPager, error) {
	pager := &remediationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *remediationPager) applyFilter(query *RemediationQuery) (*RemediationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *remediationPager) toCursor(_m *Remediation) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *remediationPager) applyCursors(query *RemediationQuery, after, before *Cursor) (*RemediationQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRemediationOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *remediationPager) applyOrder(query *RemediationQuery) *RemediationQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRemediationOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRemediationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *remediationPager) orderExpr(query *RemediationQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRemediationOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Remediation.
func (_m *RemediationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RemediationPaginateOption,
) (*RemediationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRemediationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RemediationConnection{Edges: []*RemediationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RemediationOrderFieldCreatedAt orders Remediation by created_at.
	RemediationOrderFieldCreatedAt = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: remediation.FieldCreatedAt,
		toTerm: remediation.ByCreatedAt,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RemediationOrderFieldUpdatedAt orders Remediation by updated_at.
	RemediationOrderFieldUpdatedAt = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: remediation.FieldUpdatedAt,
		toTerm: remediation.ByUpdatedAt,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RemediationOrderFieldExternalID orders Remediation by external_id.
	RemediationOrderFieldExternalID = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: remediation.FieldExternalID,
		toTerm: remediation.ByExternalID,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// RemediationOrderFieldExternalOwnerID orders Remediation by external_owner_id.
	RemediationOrderFieldExternalOwnerID = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: remediation.FieldExternalOwnerID,
		toTerm: remediation.ByExternalOwnerID,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// RemediationOrderFieldTitle orders Remediation by title.
	RemediationOrderFieldTitle = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.Title, nil
		},
		column: remediation.FieldTitle,
		toTerm: remediation.ByTitle,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// RemediationOrderFieldState orders Remediation by state.
	RemediationOrderFieldState = &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.State, nil
		},
		column: remediation.FieldState,
		toTerm: remediation.ByState,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RemediationOrderField) String() string {
	var str string
	switch f.column {
	case RemediationOrderFieldCreatedAt.column:
		str = "created_at"
	case RemediationOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RemediationOrderFieldExternalID.column:
		str = "external_id"
	case RemediationOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case RemediationOrderFieldTitle.column:
		str = "title"
	case RemediationOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RemediationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RemediationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RemediationOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RemediationOrderFieldCreatedAt
	case "updated_at":
		*f = *RemediationOrderFieldUpdatedAt
	case "external_id":
		*f = *RemediationOrderFieldExternalID
	case "external_owner_id":
		*f = *RemediationOrderFieldExternalOwnerID
	case "title":
		*f = *RemediationOrderFieldTitle
	case "state":
		*f = *RemediationOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid RemediationOrderField", str)
	}
	return nil
}

// RemediationOrderField defines the ordering field of Remediation.
type RemediationOrderField struct {
	// Value extracts the ordering value from the given Remediation.
	Value    func(*Remediation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) remediation.OrderOption
	toCursor func(*Remediation) Cursor
}

// RemediationOrder defines the ordering of Remediation.
type RemediationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *RemediationOrderField `json:"field"`
}

// DefaultRemediationOrder is the default ordering of Remediation.
var DefaultRemediationOrder = &RemediationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RemediationOrderField{
		Value: func(_m *Remediation) (ent.Value, error) {
			return _m.ID, nil
		},
		column: remediation.FieldID,
		toTerm: remediation.ByID,
		toCursor: func(_m *Remediation) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Remediation into RemediationEdge.
func (_m *Remediation) ToEdge(order *RemediationOrder) *RemediationEdge {
	if order == nil {
		order = DefaultRemediationOrder
	}
	return &RemediationEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ReviewEdge is the edge representation of Review.
type ReviewEdge struct {
	Node   *Review `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ReviewConnection is the connection containing edges to Review.
type ReviewConnection struct {
	Edges      []*ReviewEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ReviewConnection) build(nodes []*Review, pager *reviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Review
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Review {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Review {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReviewPaginateOption enables pagination customization.
type ReviewPaginateOption func(*reviewPager) error

// WithReviewOrder configures pagination ordering.
func WithReviewOrder(order []*ReviewOrder) ReviewPaginateOption {
	return func(pager *reviewPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithReviewFilter configures pagination filter.
func WithReviewFilter(filter func(*ReviewQuery) (*ReviewQuery, error)) ReviewPaginateOption {
	return func(pager *reviewPager) error {
		if filter == nil {
			return errors.New("ReviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reviewPager struct {
	reverse bool
	order   []*ReviewOrder
	filter  func(*ReviewQuery) (*ReviewQuery, error)
}

func newReviewPager(opts []ReviewPaginateOption, reverse bool) (*reviewPager, error) {
	pager := &reviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *reviewPager) applyFilter(query *ReviewQuery) (*ReviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reviewPager) toCursor(_m *Review) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *reviewPager) applyCursors(query *ReviewQuery, after, before *Cursor) (*ReviewQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultReviewOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *reviewPager) applyOrder(query *ReviewQuery) *ReviewQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultReviewOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultReviewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *reviewPager) orderExpr(query *ReviewQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultReviewOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Review.
func (_m *ReviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReviewPaginateOption,
) (*ReviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReviewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ReviewConnection{Edges: []*ReviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReviewOrderFieldCreatedAt orders Review by created_at.
	ReviewOrderFieldCreatedAt = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: review.FieldCreatedAt,
		toTerm: review.ByCreatedAt,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ReviewOrderFieldUpdatedAt orders Review by updated_at.
	ReviewOrderFieldUpdatedAt = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: review.FieldUpdatedAt,
		toTerm: review.ByUpdatedAt,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ReviewOrderFieldExternalID orders Review by external_id.
	ReviewOrderFieldExternalID = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: review.FieldExternalID,
		toTerm: review.ByExternalID,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// ReviewOrderFieldExternalOwnerID orders Review by external_owner_id.
	ReviewOrderFieldExternalOwnerID = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: review.FieldExternalOwnerID,
		toTerm: review.ByExternalOwnerID,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// ReviewOrderFieldTitle orders Review by title.
	ReviewOrderFieldTitle = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.Title, nil
		},
		column: review.FieldTitle,
		toTerm: review.ByTitle,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// ReviewOrderFieldState orders Review by state.
	ReviewOrderFieldState = &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.State, nil
		},
		column: review.FieldState,
		toTerm: review.ByState,
		toCursor: func(_m *Review) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.State,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReviewOrderField) String() string {
	var str string
	switch f.column {
	case ReviewOrderFieldCreatedAt.column:
		str = "created_at"
	case ReviewOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ReviewOrderFieldExternalID.column:
		str = "external_id"
	case ReviewOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case ReviewOrderFieldTitle.column:
		str = "title"
	case ReviewOrderFieldState.column:
		str = "state"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReviewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReviewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReviewOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ReviewOrderFieldCreatedAt
	case "updated_at":
		*f = *ReviewOrderFieldUpdatedAt
	case "external_id":
		*f = *ReviewOrderFieldExternalID
	case "external_owner_id":
		*f = *ReviewOrderFieldExternalOwnerID
	case "title":
		*f = *ReviewOrderFieldTitle
	case "state":
		*f = *ReviewOrderFieldState
	default:
		return fmt.Errorf("%s is not a valid ReviewOrderField", str)
	}
	return nil
}

// ReviewOrderField defines the ordering field of Review.
type ReviewOrderField struct {
	// Value extracts the ordering value from the given Review.
	Value    func(*Review) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) review.OrderOption
	toCursor func(*Review) Cursor
}

// ReviewOrder defines the ordering of Review.
type ReviewOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ReviewOrderField `json:"field"`
}

// DefaultReviewOrder is the default ordering of Review.
var DefaultReviewOrder = &ReviewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReviewOrderField{
		Value: func(_m *Review) (ent.Value, error) {
			return _m.ID, nil
		},
		column: review.FieldID,
		toTerm: review.ByID,
		toCursor: func(_m *Review) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Review into ReviewEdge.
func (_m *Review) ToEdge(order *ReviewOrder) *ReviewEdge {
	if order == nil {
		order = DefaultReviewOrder
	}
	return &ReviewEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// RiskEdge is the edge representation of Risk.
type RiskEdge struct {
	Node   *Risk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RiskConnection is the connection containing edges to Risk.
type RiskConnection struct {
	Edges      []*RiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *RiskConnection) build(nodes []*Risk, pager *riskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Risk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Risk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Risk {
			return nodes[i]
		}
	}
	c.Edges = make([]*RiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RiskPaginateOption enables pagination customization.
type RiskPaginateOption func(*riskPager) error

// WithRiskOrder configures pagination ordering.
func WithRiskOrder(order []*RiskOrder) RiskPaginateOption {
	return func(pager *riskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithRiskFilter configures pagination filter.
func WithRiskFilter(filter func(*RiskQuery) (*RiskQuery, error)) RiskPaginateOption {
	return func(pager *riskPager) error {
		if filter == nil {
			return errors.New("RiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type riskPager struct {
	reverse bool
	order   []*RiskOrder
	filter  func(*RiskQuery) (*RiskQuery, error)
}

func newRiskPager(opts []RiskPaginateOption, reverse bool) (*riskPager, error) {
	pager := &riskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *riskPager) applyFilter(query *RiskQuery) (*RiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *riskPager) toCursor(_m *Risk) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *riskPager) applyCursors(query *RiskQuery, after, before *Cursor) (*RiskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultRiskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *riskPager) applyOrder(query *RiskQuery) *RiskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultRiskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultRiskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *riskPager) orderExpr(query *RiskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultRiskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Risk.
func (_m *RiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RiskPaginateOption,
) (*RiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRiskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &RiskConnection{Edges: []*RiskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RiskOrderFieldCreatedAt orders Risk by created_at.
	RiskOrderFieldCreatedAt = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: risk.FieldCreatedAt,
		toTerm: risk.ByCreatedAt,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// RiskOrderFieldUpdatedAt orders Risk by updated_at.
	RiskOrderFieldUpdatedAt = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: risk.FieldUpdatedAt,
		toTerm: risk.ByUpdatedAt,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// RiskOrderFieldName orders Risk by name.
	RiskOrderFieldName = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Name, nil
		},
		column: risk.FieldName,
		toTerm: risk.ByName,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// RiskOrderFieldStatus orders Risk by status.
	RiskOrderFieldStatus = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Status, nil
		},
		column: risk.FieldStatus,
		toTerm: risk.ByStatus,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// RiskOrderFieldRiskType orders Risk by risk_type.
	RiskOrderFieldRiskType = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.RiskType, nil
		},
		column: risk.FieldRiskType,
		toTerm: risk.ByRiskType,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RiskType,
			}
		},
	}
	// RiskOrderFieldCategory orders Risk by category.
	RiskOrderFieldCategory = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Category, nil
		},
		column: risk.FieldCategory,
		toTerm: risk.ByCategory,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// RiskOrderFieldImpact orders Risk by impact.
	RiskOrderFieldImpact = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Impact, nil
		},
		column: risk.FieldImpact,
		toTerm: risk.ByImpact,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Impact,
			}
		},
	}
	// RiskOrderFieldLikelihood orders Risk by likelihood.
	RiskOrderFieldLikelihood = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Likelihood, nil
		},
		column: risk.FieldLikelihood,
		toTerm: risk.ByLikelihood,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Likelihood,
			}
		},
	}
	// RiskOrderFieldScore orders Risk by score.
	RiskOrderFieldScore = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.Score, nil
		},
		column: risk.FieldScore,
		toTerm: risk.ByScore,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Score,
			}
		},
	}
	// RiskOrderFieldBusinessCosts orders Risk by business_costs.
	RiskOrderFieldBusinessCosts = &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.BusinessCosts, nil
		},
		column: risk.FieldBusinessCosts,
		toTerm: risk.ByBusinessCosts,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.BusinessCosts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RiskOrderField) String() string {
	var str string
	switch f.column {
	case RiskOrderFieldCreatedAt.column:
		str = "created_at"
	case RiskOrderFieldUpdatedAt.column:
		str = "updated_at"
	case RiskOrderFieldName.column:
		str = "name"
	case RiskOrderFieldStatus.column:
		str = "STATUS"
	case RiskOrderFieldRiskType.column:
		str = "risk_type"
	case RiskOrderFieldCategory.column:
		str = "category"
	case RiskOrderFieldImpact.column:
		str = "IMPACT"
	case RiskOrderFieldLikelihood.column:
		str = "LIKELIHOOD"
	case RiskOrderFieldScore.column:
		str = "score"
	case RiskOrderFieldBusinessCosts.column:
		str = "business_costs"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RiskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RiskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RiskOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RiskOrderFieldCreatedAt
	case "updated_at":
		*f = *RiskOrderFieldUpdatedAt
	case "name":
		*f = *RiskOrderFieldName
	case "STATUS":
		*f = *RiskOrderFieldStatus
	case "risk_type":
		*f = *RiskOrderFieldRiskType
	case "category":
		*f = *RiskOrderFieldCategory
	case "IMPACT":
		*f = *RiskOrderFieldImpact
	case "LIKELIHOOD":
		*f = *RiskOrderFieldLikelihood
	case "score":
		*f = *RiskOrderFieldScore
	case "business_costs":
		*f = *RiskOrderFieldBusinessCosts
	default:
		return fmt.Errorf("%s is not a valid RiskOrderField", str)
	}
	return nil
}

// RiskOrderField defines the ordering field of Risk.
type RiskOrderField struct {
	// Value extracts the ordering value from the given Risk.
	Value    func(*Risk) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) risk.OrderOption
	toCursor func(*Risk) Cursor
}

// RiskOrder defines the ordering of Risk.
type RiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RiskOrderField `json:"field"`
}

// DefaultRiskOrder is the default ordering of Risk.
var DefaultRiskOrder = &RiskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RiskOrderField{
		Value: func(_m *Risk) (ent.Value, error) {
			return _m.ID, nil
		},
		column: risk.FieldID,
		toTerm: risk.ByID,
		toCursor: func(_m *Risk) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Risk into RiskEdge.
func (_m *Risk) ToEdge(order *RiskOrder) *RiskEdge {
	if order == nil {
		order = DefaultRiskOrder
	}
	return &RiskEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScanEdge is the edge representation of Scan.
type ScanEdge struct {
	Node   *Scan  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ScanConnection is the connection containing edges to Scan.
type ScanConnection struct {
	Edges      []*ScanEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *ScanConnection) build(nodes []*Scan, pager *scanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Scan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Scan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Scan {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScanPaginateOption enables pagination customization.
type ScanPaginateOption func(*scanPager) error

// WithScanOrder configures pagination ordering.
func WithScanOrder(order []*ScanOrder) ScanPaginateOption {
	return func(pager *scanPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScanFilter configures pagination filter.
func WithScanFilter(filter func(*ScanQuery) (*ScanQuery, error)) ScanPaginateOption {
	return func(pager *scanPager) error {
		if filter == nil {
			return errors.New("ScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scanPager struct {
	reverse bool
	order   []*ScanOrder
	filter  func(*ScanQuery) (*ScanQuery, error)
}

func newScanPager(opts []ScanPaginateOption, reverse bool) (*scanPager, error) {
	pager := &scanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scanPager) applyFilter(query *ScanQuery) (*ScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scanPager) toCursor(_m *Scan) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *scanPager) applyCursors(query *ScanQuery, after, before *Cursor) (*ScanQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScanOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scanPager) applyOrder(query *ScanQuery) *ScanQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScanOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scanPager) orderExpr(query *ScanQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScanOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Scan.
func (_m *ScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScanPaginateOption,
) (*ScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScanConnection{Edges: []*ScanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScanOrderFieldCreatedAt orders Scan by created_at.
	ScanOrderFieldCreatedAt = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scan.FieldCreatedAt,
		toTerm: scan.ByCreatedAt,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScanOrderFieldUpdatedAt orders Scan by updated_at.
	ScanOrderFieldUpdatedAt = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scan.FieldUpdatedAt,
		toTerm: scan.ByUpdatedAt,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// ScanOrderFieldScanType orders Scan by scan_type.
	ScanOrderFieldScanType = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.ScanType, nil
		},
		column: scan.FieldScanType,
		toTerm: scan.ByScanType,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ScanType,
			}
		},
	}
	// ScanOrderFieldStatus orders Scan by status.
	ScanOrderFieldStatus = &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.Status, nil
		},
		column: scan.FieldStatus,
		toTerm: scan.ByStatus,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScanOrderField) String() string {
	var str string
	switch f.column {
	case ScanOrderFieldCreatedAt.column:
		str = "created_at"
	case ScanOrderFieldUpdatedAt.column:
		str = "updated_at"
	case ScanOrderFieldScanType.column:
		str = "SCAN_TYPE"
	case ScanOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScanOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScanOrderFieldCreatedAt
	case "updated_at":
		*f = *ScanOrderFieldUpdatedAt
	case "SCAN_TYPE":
		*f = *ScanOrderFieldScanType
	case "STATUS":
		*f = *ScanOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid ScanOrderField", str)
	}
	return nil
}

// ScanOrderField defines the ordering field of Scan.
type ScanOrderField struct {
	// Value extracts the ordering value from the given Scan.
	Value    func(*Scan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scan.OrderOption
	toCursor func(*Scan) Cursor
}

// ScanOrder defines the ordering of Scan.
type ScanOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ScanOrderField `json:"field"`
}

// DefaultScanOrder is the default ordering of Scan.
var DefaultScanOrder = &ScanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScanOrderField{
		Value: func(_m *Scan) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scan.FieldID,
		toTerm: scan.ByID,
		toCursor: func(_m *Scan) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Scan into ScanEdge.
func (_m *Scan) ToEdge(order *ScanOrder) *ScanEdge {
	if order == nil {
		order = DefaultScanOrder
	}
	return &ScanEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScheduledJobEdge is the edge representation of ScheduledJob.
type ScheduledJobEdge struct {
	Node   *ScheduledJob `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ScheduledJobConnection is the connection containing edges to ScheduledJob.
type ScheduledJobConnection struct {
	Edges      []*ScheduledJobEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ScheduledJobConnection) build(nodes []*ScheduledJob, pager *scheduledjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobPaginateOption enables pagination customization.
type ScheduledJobPaginateOption func(*scheduledjobPager) error

// WithScheduledJobOrder configures pagination ordering.
func WithScheduledJobOrder(order []*ScheduledJobOrder) ScheduledJobPaginateOption {
	return func(pager *scheduledjobPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScheduledJobFilter configures pagination filter.
func WithScheduledJobFilter(filter func(*ScheduledJobQuery) (*ScheduledJobQuery, error)) ScheduledJobPaginateOption {
	return func(pager *scheduledjobPager) error {
		if filter == nil {
			return errors.New("ScheduledJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobPager struct {
	reverse bool
	order   []*ScheduledJobOrder
	filter  func(*ScheduledJobQuery) (*ScheduledJobQuery, error)
}

func newScheduledJobPager(opts []ScheduledJobPaginateOption, reverse bool) (*scheduledjobPager, error) {
	pager := &scheduledjobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scheduledjobPager) applyFilter(query *ScheduledJobQuery) (*ScheduledJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobPager) toCursor(_m *ScheduledJob) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *scheduledjobPager) applyCursors(query *ScheduledJobQuery, after, before *Cursor) (*ScheduledJobQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScheduledJobOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scheduledjobPager) applyOrder(query *ScheduledJobQuery) *ScheduledJobQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScheduledJobOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScheduledJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scheduledjobPager) orderExpr(query *ScheduledJobQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScheduledJobOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJob.
func (_m *ScheduledJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobPaginateOption,
) (*ScheduledJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScheduledJobConnection{Edges: []*ScheduledJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobOrderFieldCreatedAt orders ScheduledJob by created_at.
	ScheduledJobOrderFieldCreatedAt = &ScheduledJobOrderField{
		Value: func(_m *ScheduledJob) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scheduledjob.FieldCreatedAt,
		toTerm: scheduledjob.ByCreatedAt,
		toCursor: func(_m *ScheduledJob) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScheduledJobOrderFieldUpdatedAt orders ScheduledJob by updated_at.
	ScheduledJobOrderFieldUpdatedAt = &ScheduledJobOrderField{
		Value: func(_m *ScheduledJob) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scheduledjob.FieldUpdatedAt,
		toTerm: scheduledjob.ByUpdatedAt,
		toCursor: func(_m *ScheduledJob) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScheduledJobOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobOrderField", str)
	}
	return nil
}

// ScheduledJobOrderField defines the ordering field of ScheduledJob.
type ScheduledJobOrderField struct {
	// Value extracts the ordering value from the given ScheduledJob.
	Value    func(*ScheduledJob) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjob.OrderOption
	toCursor func(*ScheduledJob) Cursor
}

// ScheduledJobOrder defines the ordering of ScheduledJob.
type ScheduledJobOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ScheduledJobOrderField `json:"field"`
}

// DefaultScheduledJobOrder is the default ordering of ScheduledJob.
var DefaultScheduledJobOrder = &ScheduledJobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobOrderField{
		Value: func(_m *ScheduledJob) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scheduledjob.FieldID,
		toTerm: scheduledjob.ByID,
		toCursor: func(_m *ScheduledJob) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScheduledJob into ScheduledJobEdge.
func (_m *ScheduledJob) ToEdge(order *ScheduledJobOrder) *ScheduledJobEdge {
	if order == nil {
		order = DefaultScheduledJobOrder
	}
	return &ScheduledJobEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// ScheduledJobRunEdge is the edge representation of ScheduledJobRun.
type ScheduledJobRunEdge struct {
	Node   *ScheduledJobRun `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ScheduledJobRunConnection is the connection containing edges to ScheduledJobRun.
type ScheduledJobRunConnection struct {
	Edges      []*ScheduledJobRunEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ScheduledJobRunConnection) build(nodes []*ScheduledJobRun, pager *scheduledjobrunPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *ScheduledJobRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ScheduledJobRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ScheduledJobRun {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScheduledJobRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScheduledJobRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScheduledJobRunPaginateOption enables pagination customization.
type ScheduledJobRunPaginateOption func(*scheduledjobrunPager) error

// WithScheduledJobRunOrder configures pagination ordering.
func WithScheduledJobRunOrder(order []*ScheduledJobRunOrder) ScheduledJobRunPaginateOption {
	return func(pager *scheduledjobrunPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithScheduledJobRunFilter configures pagination filter.
func WithScheduledJobRunFilter(filter func(*ScheduledJobRunQuery) (*ScheduledJobRunQuery, error)) ScheduledJobRunPaginateOption {
	return func(pager *scheduledjobrunPager) error {
		if filter == nil {
			return errors.New("ScheduledJobRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scheduledjobrunPager struct {
	reverse bool
	order   []*ScheduledJobRunOrder
	filter  func(*ScheduledJobRunQuery) (*ScheduledJobRunQuery, error)
}

func newScheduledJobRunPager(opts []ScheduledJobRunPaginateOption, reverse bool) (*scheduledjobrunPager, error) {
	pager := &scheduledjobrunPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *scheduledjobrunPager) applyFilter(query *ScheduledJobRunQuery) (*ScheduledJobRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scheduledjobrunPager) toCursor(_m *ScheduledJobRun) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *scheduledjobrunPager) applyCursors(query *ScheduledJobRunQuery, after, before *Cursor) (*ScheduledJobRunQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultScheduledJobRunOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *scheduledjobrunPager) applyOrder(query *ScheduledJobRunQuery) *ScheduledJobRunQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultScheduledJobRunOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultScheduledJobRunOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *scheduledjobrunPager) orderExpr(query *ScheduledJobRunQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultScheduledJobRunOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to ScheduledJobRun.
func (_m *ScheduledJobRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScheduledJobRunPaginateOption,
) (*ScheduledJobRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScheduledJobRunPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &ScheduledJobRunConnection{Edges: []*ScheduledJobRunEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ScheduledJobRunOrderFieldCreatedAt orders ScheduledJobRun by created_at.
	ScheduledJobRunOrderFieldCreatedAt = &ScheduledJobRunOrderField{
		Value: func(_m *ScheduledJobRun) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: scheduledjobrun.FieldCreatedAt,
		toTerm: scheduledjobrun.ByCreatedAt,
		toCursor: func(_m *ScheduledJobRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// ScheduledJobRunOrderFieldUpdatedAt orders ScheduledJobRun by updated_at.
	ScheduledJobRunOrderFieldUpdatedAt = &ScheduledJobRunOrderField{
		Value: func(_m *ScheduledJobRun) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: scheduledjobrun.FieldUpdatedAt,
		toTerm: scheduledjobrun.ByUpdatedAt,
		toCursor: func(_m *ScheduledJobRun) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ScheduledJobRunOrderField) String() string {
	var str string
	switch f.column {
	case ScheduledJobRunOrderFieldCreatedAt.column:
		str = "created_at"
	case ScheduledJobRunOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ScheduledJobRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ScheduledJobRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ScheduledJobRunOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *ScheduledJobRunOrderFieldCreatedAt
	case "updated_at":
		*f = *ScheduledJobRunOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ScheduledJobRunOrderField", str)
	}
	return nil
}

// ScheduledJobRunOrderField defines the ordering field of ScheduledJobRun.
type ScheduledJobRunOrderField struct {
	// Value extracts the ordering value from the given ScheduledJobRun.
	Value    func(*ScheduledJobRun) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) scheduledjobrun.OrderOption
	toCursor func(*ScheduledJobRun) Cursor
}

// ScheduledJobRunOrder defines the ordering of ScheduledJobRun.
type ScheduledJobRunOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ScheduledJobRunOrderField `json:"field"`
}

// DefaultScheduledJobRunOrder is the default ordering of ScheduledJobRun.
var DefaultScheduledJobRunOrder = &ScheduledJobRunOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScheduledJobRunOrderField{
		Value: func(_m *ScheduledJobRun) (ent.Value, error) {
			return _m.ID, nil
		},
		column: scheduledjobrun.FieldID,
		toTerm: scheduledjobrun.ByID,
		toCursor: func(_m *ScheduledJobRun) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts ScheduledJobRun into ScheduledJobRunEdge.
func (_m *ScheduledJobRun) ToEdge(order *ScheduledJobRunOrder) *ScheduledJobRunEdge {
	if order == nil {
		order = DefaultScheduledJobRunOrder
	}
	return &ScheduledJobRunEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// StandardEdge is the edge representation of Standard.
type StandardEdge struct {
	Node   *Standard `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// StandardConnection is the connection containing edges to Standard.
type StandardConnection struct {
	Edges      []*StandardEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *StandardConnection) build(nodes []*Standard, pager *standardPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Standard
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Standard {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Standard {
			return nodes[i]
		}
	}
	c.Edges = make([]*StandardEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StandardEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StandardPaginateOption enables pagination customization.
type StandardPaginateOption func(*standardPager) error

// WithStandardOrder configures pagination ordering.
func WithStandardOrder(order []*StandardOrder) StandardPaginateOption {
	return func(pager *standardPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithStandardFilter configures pagination filter.
func WithStandardFilter(filter func(*StandardQuery) (*StandardQuery, error)) StandardPaginateOption {
	return func(pager *standardPager) error {
		if filter == nil {
			return errors.New("StandardQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type standardPager struct {
	reverse bool
	order   []*StandardOrder
	filter  func(*StandardQuery) (*StandardQuery, error)
}

func newStandardPager(opts []StandardPaginateOption, reverse bool) (*standardPager, error) {
	pager := &standardPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *standardPager) applyFilter(query *StandardQuery) (*StandardQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *standardPager) toCursor(_m *Standard) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *standardPager) applyCursors(query *StandardQuery, after, before *Cursor) (*StandardQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultStandardOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *standardPager) applyOrder(query *StandardQuery) *StandardQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultStandardOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultStandardOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *standardPager) orderExpr(query *StandardQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultStandardOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Standard.
func (_m *StandardQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StandardPaginateOption,
) (*StandardConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStandardPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &StandardConnection{Edges: []*StandardEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StandardOrderFieldCreatedAt orders Standard by created_at.
	StandardOrderFieldCreatedAt = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: standard.FieldCreatedAt,
		toTerm: standard.ByCreatedAt,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// StandardOrderFieldUpdatedAt orders Standard by updated_at.
	StandardOrderFieldUpdatedAt = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: standard.FieldUpdatedAt,
		toTerm: standard.ByUpdatedAt,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// StandardOrderFieldRevision orders Standard by revision.
	StandardOrderFieldRevision = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Revision, nil
		},
		column: standard.FieldRevision,
		toTerm: standard.ByRevision,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Revision,
			}
		},
	}
	// StandardOrderFieldName orders Standard by name.
	StandardOrderFieldName = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Name, nil
		},
		column: standard.FieldName,
		toTerm: standard.ByName,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// StandardOrderFieldShortName orders Standard by short_name.
	StandardOrderFieldShortName = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.ShortName, nil
		},
		column: standard.FieldShortName,
		toTerm: standard.ByShortName,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ShortName,
			}
		},
	}
	// StandardOrderFieldFramework orders Standard by framework.
	StandardOrderFieldFramework = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Framework, nil
		},
		column: standard.FieldFramework,
		toTerm: standard.ByFramework,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Framework,
			}
		},
	}
	// StandardOrderFieldGoverningBody orders Standard by governing_body.
	StandardOrderFieldGoverningBody = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.GoverningBody, nil
		},
		column: standard.FieldGoverningBody,
		toTerm: standard.ByGoverningBody,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.GoverningBody,
			}
		},
	}
	// StandardOrderFieldStatus orders Standard by status.
	StandardOrderFieldStatus = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.Status, nil
		},
		column: standard.FieldStatus,
		toTerm: standard.ByStatus,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// StandardOrderFieldStandardType orders Standard by standard_type.
	StandardOrderFieldStandardType = &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.StandardType, nil
		},
		column: standard.FieldStandardType,
		toTerm: standard.ByStandardType,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.StandardType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StandardOrderField) String() string {
	var str string
	switch f.column {
	case StandardOrderFieldCreatedAt.column:
		str = "created_at"
	case StandardOrderFieldUpdatedAt.column:
		str = "updated_at"
	case StandardOrderFieldRevision.column:
		str = "revision"
	case StandardOrderFieldName.column:
		str = "name"
	case StandardOrderFieldShortName.column:
		str = "short_name"
	case StandardOrderFieldFramework.column:
		str = "framework"
	case StandardOrderFieldGoverningBody.column:
		str = "governing_body"
	case StandardOrderFieldStatus.column:
		str = "STATUS"
	case StandardOrderFieldStandardType.column:
		str = "standard_type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StandardOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StandardOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StandardOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *StandardOrderFieldCreatedAt
	case "updated_at":
		*f = *StandardOrderFieldUpdatedAt
	case "revision":
		*f = *StandardOrderFieldRevision
	case "name":
		*f = *StandardOrderFieldName
	case "short_name":
		*f = *StandardOrderFieldShortName
	case "framework":
		*f = *StandardOrderFieldFramework
	case "governing_body":
		*f = *StandardOrderFieldGoverningBody
	case "STATUS":
		*f = *StandardOrderFieldStatus
	case "standard_type":
		*f = *StandardOrderFieldStandardType
	default:
		return fmt.Errorf("%s is not a valid StandardOrderField", str)
	}
	return nil
}

// StandardOrderField defines the ordering field of Standard.
type StandardOrderField struct {
	// Value extracts the ordering value from the given Standard.
	Value    func(*Standard) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) standard.OrderOption
	toCursor func(*Standard) Cursor
}

// StandardOrder defines the ordering of Standard.
type StandardOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *StandardOrderField `json:"field"`
}

// DefaultStandardOrder is the default ordering of Standard.
var DefaultStandardOrder = &StandardOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StandardOrderField{
		Value: func(_m *Standard) (ent.Value, error) {
			return _m.ID, nil
		},
		column: standard.FieldID,
		toTerm: standard.ByID,
		toCursor: func(_m *Standard) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Standard into StandardEdge.
func (_m *Standard) ToEdge(order *StandardOrder) *StandardEdge {
	if order == nil {
		order = DefaultStandardOrder
	}
	return &StandardEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubcontrolEdge is the edge representation of Subcontrol.
type SubcontrolEdge struct {
	Node   *Subcontrol `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubcontrolConnection is the connection containing edges to Subcontrol.
type SubcontrolConnection struct {
	Edges      []*SubcontrolEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubcontrolConnection) build(nodes []*Subcontrol, pager *subcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subcontrol
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subcontrol {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subcontrol {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubcontrolEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubcontrolEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubcontrolPaginateOption enables pagination customization.
type SubcontrolPaginateOption func(*subcontrolPager) error

// WithSubcontrolOrder configures pagination ordering.
func WithSubcontrolOrder(order []*SubcontrolOrder) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubcontrolFilter configures pagination filter.
func WithSubcontrolFilter(filter func(*SubcontrolQuery) (*SubcontrolQuery, error)) SubcontrolPaginateOption {
	return func(pager *subcontrolPager) error {
		if filter == nil {
			return errors.New("SubcontrolQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subcontrolPager struct {
	reverse bool
	order   []*SubcontrolOrder
	filter  func(*SubcontrolQuery) (*SubcontrolQuery, error)
}

func newSubcontrolPager(opts []SubcontrolPaginateOption, reverse bool) (*subcontrolPager, error) {
	pager := &subcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subcontrolPager) applyFilter(query *SubcontrolQuery) (*SubcontrolQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subcontrolPager) toCursor(_m *Subcontrol) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *subcontrolPager) applyCursors(query *SubcontrolQuery, after, before *Cursor) (*SubcontrolQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubcontrolOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subcontrolPager) applyOrder(query *SubcontrolQuery) *SubcontrolQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubcontrolOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case SubcontrolOrderFieldControlOwnerName.column, SubcontrolOrderFieldDelegateName.column, SubcontrolOrderFieldResponsiblePartyName.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubcontrolOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subcontrolPager) orderExpr(query *SubcontrolQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case SubcontrolOrderFieldControlOwnerName.column, SubcontrolOrderFieldDelegateName.column, SubcontrolOrderFieldResponsiblePartyName.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubcontrolOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subcontrol.
func (_m *SubcontrolQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubcontrolPaginateOption,
) (*SubcontrolConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubcontrolPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubcontrolConnection{Edges: []*SubcontrolEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubcontrolOrderFieldCreatedAt orders Subcontrol by created_at.
	SubcontrolOrderFieldCreatedAt = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subcontrol.FieldCreatedAt,
		toTerm: subcontrol.ByCreatedAt,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubcontrolOrderFieldUpdatedAt orders Subcontrol by updated_at.
	SubcontrolOrderFieldUpdatedAt = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subcontrol.FieldUpdatedAt,
		toTerm: subcontrol.ByUpdatedAt,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubcontrolOrderFieldTitle orders Subcontrol by title.
	SubcontrolOrderFieldTitle = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Title, nil
		},
		column: subcontrol.FieldTitle,
		toTerm: subcontrol.ByTitle,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// SubcontrolOrderFieldStatus orders Subcontrol by status.
	SubcontrolOrderFieldStatus = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Status, nil
		},
		column: subcontrol.FieldStatus,
		toTerm: subcontrol.ByStatus,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// SubcontrolOrderFieldSource orders Subcontrol by source.
	SubcontrolOrderFieldSource = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Source, nil
		},
		column: subcontrol.FieldSource,
		toTerm: subcontrol.BySource,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Source,
			}
		},
	}
	// SubcontrolOrderFieldReferenceFramework orders Subcontrol by reference_framework.
	SubcontrolOrderFieldReferenceFramework = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			// allow for nil values for fields
			if _m.ReferenceFramework == nil {
				return nil, nil
			}
			return _m.ReferenceFramework, nil
		},
		column: subcontrol.FieldReferenceFramework,
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return subcontrol.ByReferenceFramework(opts...)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			if _m.ReferenceFramework == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.ReferenceFramework,
			}
		},
	}
	// SubcontrolOrderFieldControlType orders Subcontrol by control_type.
	SubcontrolOrderFieldControlType = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.ControlType, nil
		},
		column: subcontrol.FieldControlType,
		toTerm: subcontrol.ByControlType,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ControlType,
			}
		},
	}
	// SubcontrolOrderFieldCategory orders Subcontrol by category.
	SubcontrolOrderFieldCategory = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Category, nil
		},
		column: subcontrol.FieldCategory,
		toTerm: subcontrol.ByCategory,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// SubcontrolOrderFieldSubcategory orders Subcontrol by subcategory.
	SubcontrolOrderFieldSubcategory = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Subcategory, nil
		},
		column: subcontrol.FieldSubcategory,
		toTerm: subcontrol.BySubcategory,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Subcategory,
			}
		},
	}
	// SubcontrolOrderFieldRefCode orders Subcontrol by ref_code.
	SubcontrolOrderFieldRefCode = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.RefCode, nil
		},
		column: subcontrol.FieldRefCode,
		toTerm: subcontrol.ByRefCode,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.RefCode,
			}
		},
	}
	// SubcontrolOrderFieldControlOwnerName orders by CONTROL_OWNER_name.
	SubcontrolOrderFieldControlOwnerName = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Value("control_owner_name")
		},
		column: "control_owner_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByControlOwnerField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("control_owner_name"))...,
			)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			cv, _ := _m.Value("control_owner_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// SubcontrolOrderFieldDelegateName orders by DELEGATE_name.
	SubcontrolOrderFieldDelegateName = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Value("delegate_name")
		},
		column: "delegate_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByDelegateField(
				group.FieldName,
				append(opts, sql.OrderSelectAs("delegate_name"))...,
			)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			cv, _ := _m.Value("delegate_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
	// SubcontrolOrderFieldResponsiblePartyName orders by RESPONSIBLE_PARTY_name.
	SubcontrolOrderFieldResponsiblePartyName = &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.Value("responsible_party_name")
		},
		column: "responsible_party_name",
		toTerm: func(opts ...sql.OrderTermOption) subcontrol.OrderOption {
			return subcontrol.ByResponsiblePartyField(
				entity.FieldName,
				append(opts, sql.OrderSelectAs("responsible_party_name"))...,
			)
		},
		toCursor: func(_m *Subcontrol) Cursor {
			cv, _ := _m.Value("responsible_party_name")
			return Cursor{
				ID:    _m.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubcontrolOrderField) String() string {
	var str string
	switch f.column {
	case SubcontrolOrderFieldCreatedAt.column:
		str = "created_at"
	case SubcontrolOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubcontrolOrderFieldTitle.column:
		str = "title"
	case SubcontrolOrderFieldStatus.column:
		str = "STATUS"
	case SubcontrolOrderFieldSource.column:
		str = "SOURCE"
	case SubcontrolOrderFieldReferenceFramework.column:
		str = "REFERENCE_FRAMEWORK"
	case SubcontrolOrderFieldControlType.column:
		str = "CONTROL_TYPE"
	case SubcontrolOrderFieldCategory.column:
		str = "category"
	case SubcontrolOrderFieldSubcategory.column:
		str = "subcategory"
	case SubcontrolOrderFieldRefCode.column:
		str = "ref_code"
	case SubcontrolOrderFieldControlOwnerName.column:
		str = "CONTROL_OWNER_name"
	case SubcontrolOrderFieldDelegateName.column:
		str = "DELEGATE_name"
	case SubcontrolOrderFieldResponsiblePartyName.column:
		str = "RESPONSIBLE_PARTY_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubcontrolOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubcontrolOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubcontrolOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubcontrolOrderFieldCreatedAt
	case "updated_at":
		*f = *SubcontrolOrderFieldUpdatedAt
	case "title":
		*f = *SubcontrolOrderFieldTitle
	case "STATUS":
		*f = *SubcontrolOrderFieldStatus
	case "SOURCE":
		*f = *SubcontrolOrderFieldSource
	case "REFERENCE_FRAMEWORK":
		*f = *SubcontrolOrderFieldReferenceFramework
	case "CONTROL_TYPE":
		*f = *SubcontrolOrderFieldControlType
	case "category":
		*f = *SubcontrolOrderFieldCategory
	case "subcategory":
		*f = *SubcontrolOrderFieldSubcategory
	case "ref_code":
		*f = *SubcontrolOrderFieldRefCode
	case "CONTROL_OWNER_name":
		*f = *SubcontrolOrderFieldControlOwnerName
	case "DELEGATE_name":
		*f = *SubcontrolOrderFieldDelegateName
	case "RESPONSIBLE_PARTY_name":
		*f = *SubcontrolOrderFieldResponsiblePartyName
	default:
		return fmt.Errorf("%s is not a valid SubcontrolOrderField", str)
	}
	return nil
}

// SubcontrolOrderField defines the ordering field of Subcontrol.
type SubcontrolOrderField struct {
	// Value extracts the ordering value from the given Subcontrol.
	Value    func(*Subcontrol) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subcontrol.OrderOption
	toCursor func(*Subcontrol) Cursor
}

// SubcontrolOrder defines the ordering of Subcontrol.
type SubcontrolOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubcontrolOrderField `json:"field"`
}

// DefaultSubcontrolOrder is the default ordering of Subcontrol.
var DefaultSubcontrolOrder = &SubcontrolOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubcontrolOrderField{
		Value: func(_m *Subcontrol) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subcontrol.FieldID,
		toTerm: subcontrol.ByID,
		toCursor: func(_m *Subcontrol) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Subcontrol into SubcontrolEdge.
func (_m *Subcontrol) ToEdge(order *SubcontrolOrder) *SubcontrolEdge {
	if order == nil {
		order = DefaultSubcontrolOrder
	}
	return &SubcontrolEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubprocessorEdge is the edge representation of Subprocessor.
type SubprocessorEdge struct {
	Node   *Subprocessor `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// SubprocessorConnection is the connection containing edges to Subprocessor.
type SubprocessorConnection struct {
	Edges      []*SubprocessorEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *SubprocessorConnection) build(nodes []*Subprocessor, pager *subprocessorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subprocessor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subprocessor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subprocessor {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubprocessorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubprocessorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubprocessorPaginateOption enables pagination customization.
type SubprocessorPaginateOption func(*subprocessorPager) error

// WithSubprocessorOrder configures pagination ordering.
func WithSubprocessorOrder(order []*SubprocessorOrder) SubprocessorPaginateOption {
	return func(pager *subprocessorPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubprocessorFilter configures pagination filter.
func WithSubprocessorFilter(filter func(*SubprocessorQuery) (*SubprocessorQuery, error)) SubprocessorPaginateOption {
	return func(pager *subprocessorPager) error {
		if filter == nil {
			return errors.New("SubprocessorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subprocessorPager struct {
	reverse bool
	order   []*SubprocessorOrder
	filter  func(*SubprocessorQuery) (*SubprocessorQuery, error)
}

func newSubprocessorPager(opts []SubprocessorPaginateOption, reverse bool) (*subprocessorPager, error) {
	pager := &subprocessorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subprocessorPager) applyFilter(query *SubprocessorQuery) (*SubprocessorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subprocessorPager) toCursor(_m *Subprocessor) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *subprocessorPager) applyCursors(query *SubprocessorQuery, after, before *Cursor) (*SubprocessorQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubprocessorOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subprocessorPager) applyOrder(query *SubprocessorQuery) *SubprocessorQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubprocessorOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubprocessorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subprocessorPager) orderExpr(query *SubprocessorQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubprocessorOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subprocessor.
func (_m *SubprocessorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubprocessorPaginateOption,
) (*SubprocessorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubprocessorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubprocessorConnection{Edges: []*SubprocessorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubprocessorOrderFieldCreatedAt orders Subprocessor by created_at.
	SubprocessorOrderFieldCreatedAt = &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subprocessor.FieldCreatedAt,
		toTerm: subprocessor.ByCreatedAt,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubprocessorOrderFieldUpdatedAt orders Subprocessor by updated_at.
	SubprocessorOrderFieldUpdatedAt = &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subprocessor.FieldUpdatedAt,
		toTerm: subprocessor.ByUpdatedAt,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubprocessorOrderFieldName orders Subprocessor by name.
	SubprocessorOrderFieldName = &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.Name, nil
		},
		column: subprocessor.FieldName,
		toTerm: subprocessor.ByName,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubprocessorOrderField) String() string {
	var str string
	switch f.column {
	case SubprocessorOrderFieldCreatedAt.column:
		str = "created_at"
	case SubprocessorOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubprocessorOrderFieldName.column:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubprocessorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubprocessorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubprocessorOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubprocessorOrderFieldCreatedAt
	case "updated_at":
		*f = *SubprocessorOrderFieldUpdatedAt
	case "name":
		*f = *SubprocessorOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid SubprocessorOrderField", str)
	}
	return nil
}

// SubprocessorOrderField defines the ordering field of Subprocessor.
type SubprocessorOrderField struct {
	// Value extracts the ordering value from the given Subprocessor.
	Value    func(*Subprocessor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subprocessor.OrderOption
	toCursor func(*Subprocessor) Cursor
}

// SubprocessorOrder defines the ordering of Subprocessor.
type SubprocessorOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *SubprocessorOrderField `json:"field"`
}

// DefaultSubprocessorOrder is the default ordering of Subprocessor.
var DefaultSubprocessorOrder = &SubprocessorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubprocessorOrderField{
		Value: func(_m *Subprocessor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subprocessor.FieldID,
		toTerm: subprocessor.ByID,
		toCursor: func(_m *Subprocessor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Subprocessor into SubprocessorEdge.
func (_m *Subprocessor) ToEdge(order *SubprocessorOrder) *SubprocessorEdge {
	if order == nil {
		order = DefaultSubprocessorOrder
	}
	return &SubprocessorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// SubscriberEdge is the edge representation of Subscriber.
type SubscriberEdge struct {
	Node   *Subscriber `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SubscriberConnection is the connection containing edges to Subscriber.
type SubscriberConnection struct {
	Edges      []*SubscriberEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SubscriberConnection) build(nodes []*Subscriber, pager *subscriberPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Subscriber
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Subscriber {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Subscriber {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubscriberEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubscriberEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubscriberPaginateOption enables pagination customization.
type SubscriberPaginateOption func(*subscriberPager) error

// WithSubscriberOrder configures pagination ordering.
func WithSubscriberOrder(order []*SubscriberOrder) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSubscriberFilter configures pagination filter.
func WithSubscriberFilter(filter func(*SubscriberQuery) (*SubscriberQuery, error)) SubscriberPaginateOption {
	return func(pager *subscriberPager) error {
		if filter == nil {
			return errors.New("SubscriberQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subscriberPager struct {
	reverse bool
	order   []*SubscriberOrder
	filter  func(*SubscriberQuery) (*SubscriberQuery, error)
}

func newSubscriberPager(opts []SubscriberPaginateOption, reverse bool) (*subscriberPager, error) {
	pager := &subscriberPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *subscriberPager) applyFilter(query *SubscriberQuery) (*SubscriberQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subscriberPager) toCursor(_m *Subscriber) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *subscriberPager) applyCursors(query *SubscriberQuery, after, before *Cursor) (*SubscriberQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSubscriberOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *subscriberPager) applyOrder(query *SubscriberQuery) *SubscriberQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSubscriberOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSubscriberOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *subscriberPager) orderExpr(query *SubscriberQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSubscriberOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Subscriber.
func (_m *SubscriberQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubscriberPaginateOption,
) (*SubscriberConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubscriberPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &SubscriberConnection{Edges: []*SubscriberEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SubscriberOrderFieldCreatedAt orders Subscriber by created_at.
	SubscriberOrderFieldCreatedAt = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: subscriber.FieldCreatedAt,
		toTerm: subscriber.ByCreatedAt,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// SubscriberOrderFieldUpdatedAt orders Subscriber by updated_at.
	SubscriberOrderFieldUpdatedAt = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: subscriber.FieldUpdatedAt,
		toTerm: subscriber.ByUpdatedAt,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// SubscriberOrderFieldEmail orders Subscriber by email.
	SubscriberOrderFieldEmail = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.Email, nil
		},
		column: subscriber.FieldEmail,
		toTerm: subscriber.ByEmail,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Email,
			}
		},
	}
	// SubscriberOrderFieldActive orders Subscriber by active.
	SubscriberOrderFieldActive = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.Active, nil
		},
		column: subscriber.FieldActive,
		toTerm: subscriber.ByActive,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Active,
			}
		},
	}
	// SubscriberOrderFieldUnsubscribed orders Subscriber by unsubscribed.
	SubscriberOrderFieldUnsubscribed = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.Unsubscribed, nil
		},
		column: subscriber.FieldUnsubscribed,
		toTerm: subscriber.ByUnsubscribed,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Unsubscribed,
			}
		},
	}
	// SubscriberOrderFieldSendAttempts orders Subscriber by send_attempts.
	SubscriberOrderFieldSendAttempts = &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.SendAttempts, nil
		},
		column: subscriber.FieldSendAttempts,
		toTerm: subscriber.BySendAttempts,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.SendAttempts,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SubscriberOrderField) String() string {
	var str string
	switch f.column {
	case SubscriberOrderFieldCreatedAt.column:
		str = "created_at"
	case SubscriberOrderFieldUpdatedAt.column:
		str = "updated_at"
	case SubscriberOrderFieldEmail.column:
		str = "email"
	case SubscriberOrderFieldActive.column:
		str = "active"
	case SubscriberOrderFieldUnsubscribed.column:
		str = "unsubscribed"
	case SubscriberOrderFieldSendAttempts.column:
		str = "send_attempts"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SubscriberOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SubscriberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SubscriberOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SubscriberOrderFieldCreatedAt
	case "updated_at":
		*f = *SubscriberOrderFieldUpdatedAt
	case "email":
		*f = *SubscriberOrderFieldEmail
	case "active":
		*f = *SubscriberOrderFieldActive
	case "unsubscribed":
		*f = *SubscriberOrderFieldUnsubscribed
	case "send_attempts":
		*f = *SubscriberOrderFieldSendAttempts
	default:
		return fmt.Errorf("%s is not a valid SubscriberOrderField", str)
	}
	return nil
}

// SubscriberOrderField defines the ordering field of Subscriber.
type SubscriberOrderField struct {
	// Value extracts the ordering value from the given Subscriber.
	Value    func(*Subscriber) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subscriber.OrderOption
	toCursor func(*Subscriber) Cursor
}

// SubscriberOrder defines the ordering of Subscriber.
type SubscriberOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SubscriberOrderField `json:"field"`
}

// DefaultSubscriberOrder is the default ordering of Subscriber.
var DefaultSubscriberOrder = &SubscriberOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubscriberOrderField{
		Value: func(_m *Subscriber) (ent.Value, error) {
			return _m.ID, nil
		},
		column: subscriber.FieldID,
		toTerm: subscriber.ByID,
		toCursor: func(_m *Subscriber) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Subscriber into SubscriberEdge.
func (_m *Subscriber) ToEdge(order *SubscriberOrder) *SubscriberEdge {
	if order == nil {
		order = DefaultSubscriberOrder
	}
	return &SubscriberEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TFASettingEdge is the edge representation of TFASetting.
type TFASettingEdge struct {
	Node   *TFASetting `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// TFASettingConnection is the connection containing edges to TFASetting.
type TFASettingConnection struct {
	Edges      []*TFASettingEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *TFASettingConnection) build(nodes []*TFASetting, pager *tfasettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TFASetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TFASetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TFASetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TFASettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TFASettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TFASettingPaginateOption enables pagination customization.
type TFASettingPaginateOption func(*tfasettingPager) error

// WithTFASettingOrder configures pagination ordering.
func WithTFASettingOrder(order []*TFASettingOrder) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTFASettingFilter configures pagination filter.
func WithTFASettingFilter(filter func(*TFASettingQuery) (*TFASettingQuery, error)) TFASettingPaginateOption {
	return func(pager *tfasettingPager) error {
		if filter == nil {
			return errors.New("TFASettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tfasettingPager struct {
	reverse bool
	order   []*TFASettingOrder
	filter  func(*TFASettingQuery) (*TFASettingQuery, error)
}

func newTFASettingPager(opts []TFASettingPaginateOption, reverse bool) (*tfasettingPager, error) {
	pager := &tfasettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tfasettingPager) applyFilter(query *TFASettingQuery) (*TFASettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tfasettingPager) toCursor(_m *TFASetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *tfasettingPager) applyCursors(query *TFASettingQuery, after, before *Cursor) (*TFASettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTFASettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *tfasettingPager) applyOrder(query *TFASettingQuery) *TFASettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTFASettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTFASettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tfasettingPager) orderExpr(query *TFASettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTFASettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TFASetting.
func (_m *TFASettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TFASettingPaginateOption,
) (*TFASettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTFASettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TFASettingConnection{Edges: []*TFASettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TFASettingOrderFieldCreatedAt orders TFASetting by created_at.
	TFASettingOrderFieldCreatedAt = &TFASettingOrderField{
		Value: func(_m *TFASetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: tfasetting.FieldCreatedAt,
		toTerm: tfasetting.ByCreatedAt,
		toCursor: func(_m *TFASetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TFASettingOrderFieldUpdatedAt orders TFASetting by updated_at.
	TFASettingOrderFieldUpdatedAt = &TFASettingOrderField{
		Value: func(_m *TFASetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: tfasetting.FieldUpdatedAt,
		toTerm: tfasetting.ByUpdatedAt,
		toCursor: func(_m *TFASetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TFASettingOrderField) String() string {
	var str string
	switch f.column {
	case TFASettingOrderFieldCreatedAt.column:
		str = "created_at"
	case TFASettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TFASettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TFASettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TFASettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TFASettingOrderFieldCreatedAt
	case "updated_at":
		*f = *TFASettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TFASettingOrderField", str)
	}
	return nil
}

// TFASettingOrderField defines the ordering field of TFASetting.
type TFASettingOrderField struct {
	// Value extracts the ordering value from the given TFASetting.
	Value    func(*TFASetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tfasetting.OrderOption
	toCursor func(*TFASetting) Cursor
}

// TFASettingOrder defines the ordering of TFASetting.
type TFASettingOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *TFASettingOrderField `json:"field"`
}

// DefaultTFASettingOrder is the default ordering of TFASetting.
var DefaultTFASettingOrder = &TFASettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TFASettingOrderField{
		Value: func(_m *TFASetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: tfasetting.FieldID,
		toTerm: tfasetting.ByID,
		toCursor: func(_m *TFASetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TFASetting into TFASettingEdge.
func (_m *TFASetting) ToEdge(order *TFASettingOrder) *TFASettingEdge {
	if order == nil {
		order = DefaultTFASettingOrder
	}
	return &TFASettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TagDefinitionEdge is the edge representation of TagDefinition.
type TagDefinitionEdge struct {
	Node   *TagDefinition `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// TagDefinitionConnection is the connection containing edges to TagDefinition.
type TagDefinitionConnection struct {
	Edges      []*TagDefinitionEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *TagDefinitionConnection) build(nodes []*TagDefinition, pager *tagdefinitionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TagDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TagDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TagDefinition {
			return nodes[i]
		}
	}
	c.Edges = make([]*TagDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TagDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TagDefinitionPaginateOption enables pagination customization.
type TagDefinitionPaginateOption func(*tagdefinitionPager) error

// WithTagDefinitionOrder configures pagination ordering.
func WithTagDefinitionOrder(order []*TagDefinitionOrder) TagDefinitionPaginateOption {
	return func(pager *tagdefinitionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTagDefinitionFilter configures pagination filter.
func WithTagDefinitionFilter(filter func(*TagDefinitionQuery) (*TagDefinitionQuery, error)) TagDefinitionPaginateOption {
	return func(pager *tagdefinitionPager) error {
		if filter == nil {
			return errors.New("TagDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagdefinitionPager struct {
	reverse bool
	order   []*TagDefinitionOrder
	filter  func(*TagDefinitionQuery) (*TagDefinitionQuery, error)
}

func newTagDefinitionPager(opts []TagDefinitionPaginateOption, reverse bool) (*tagdefinitionPager, error) {
	pager := &tagdefinitionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tagdefinitionPager) applyFilter(query *TagDefinitionQuery) (*TagDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagdefinitionPager) toCursor(_m *TagDefinition) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *tagdefinitionPager) applyCursors(query *TagDefinitionQuery, after, before *Cursor) (*TagDefinitionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTagDefinitionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *tagdefinitionPager) applyOrder(query *TagDefinitionQuery) *TagDefinitionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTagDefinitionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTagDefinitionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tagdefinitionPager) orderExpr(query *TagDefinitionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTagDefinitionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TagDefinition.
func (_m *TagDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagDefinitionPaginateOption,
) (*TagDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagDefinitionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TagDefinitionConnection{Edges: []*TagDefinitionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TagDefinitionOrderFieldCreatedAt orders TagDefinition by created_at.
	TagDefinitionOrderFieldCreatedAt = &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: tagdefinition.FieldCreatedAt,
		toTerm: tagdefinition.ByCreatedAt,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TagDefinitionOrderFieldUpdatedAt orders TagDefinition by updated_at.
	TagDefinitionOrderFieldUpdatedAt = &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: tagdefinition.FieldUpdatedAt,
		toTerm: tagdefinition.ByUpdatedAt,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TagDefinitionOrderFieldName orders TagDefinition by name.
	TagDefinitionOrderFieldName = &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.Name, nil
		},
		column: tagdefinition.FieldName,
		toTerm: tagdefinition.ByName,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// TagDefinitionOrderFieldSlug orders TagDefinition by slug.
	TagDefinitionOrderFieldSlug = &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.Slug, nil
		},
		column: tagdefinition.FieldSlug,
		toTerm: tagdefinition.BySlug,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Slug,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TagDefinitionOrderField) String() string {
	var str string
	switch f.column {
	case TagDefinitionOrderFieldCreatedAt.column:
		str = "created_at"
	case TagDefinitionOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TagDefinitionOrderFieldName.column:
		str = "name"
	case TagDefinitionOrderFieldSlug.column:
		str = "slug"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TagDefinitionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TagDefinitionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TagDefinitionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TagDefinitionOrderFieldCreatedAt
	case "updated_at":
		*f = *TagDefinitionOrderFieldUpdatedAt
	case "name":
		*f = *TagDefinitionOrderFieldName
	case "slug":
		*f = *TagDefinitionOrderFieldSlug
	default:
		return fmt.Errorf("%s is not a valid TagDefinitionOrderField", str)
	}
	return nil
}

// TagDefinitionOrderField defines the ordering field of TagDefinition.
type TagDefinitionOrderField struct {
	// Value extracts the ordering value from the given TagDefinition.
	Value    func(*TagDefinition) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tagdefinition.OrderOption
	toCursor func(*TagDefinition) Cursor
}

// TagDefinitionOrder defines the ordering of TagDefinition.
type TagDefinitionOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *TagDefinitionOrderField `json:"field"`
}

// DefaultTagDefinitionOrder is the default ordering of TagDefinition.
var DefaultTagDefinitionOrder = &TagDefinitionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TagDefinitionOrderField{
		Value: func(_m *TagDefinition) (ent.Value, error) {
			return _m.ID, nil
		},
		column: tagdefinition.FieldID,
		toTerm: tagdefinition.ByID,
		toCursor: func(_m *TagDefinition) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TagDefinition into TagDefinitionEdge.
func (_m *TagDefinition) ToEdge(order *TagDefinitionOrder) *TagDefinitionEdge {
	if order == nil {
		order = DefaultTagDefinitionOrder
	}
	return &TagDefinitionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order []*TaskOrder) TaskPaginateOption {
	return func(pager *taskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   []*TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(_m *Task) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTaskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTaskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (_m *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskOrderFieldCreatedAt orders Task by created_at.
	TaskOrderFieldCreatedAt = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: task.FieldCreatedAt,
		toTerm: task.ByCreatedAt,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TaskOrderFieldUpdatedAt orders Task by updated_at.
	TaskOrderFieldUpdatedAt = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: task.FieldUpdatedAt,
		toTerm: task.ByUpdatedAt,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TaskOrderFieldTitle orders Task by title.
	TaskOrderFieldTitle = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.Title, nil
		},
		column: task.FieldTitle,
		toTerm: task.ByTitle,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Title,
			}
		},
	}
	// TaskOrderFieldStatus orders Task by status.
	TaskOrderFieldStatus = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.Status, nil
		},
		column: task.FieldStatus,
		toTerm: task.ByStatus,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Status,
			}
		},
	}
	// TaskOrderFieldCategory orders Task by category.
	TaskOrderFieldCategory = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.Category, nil
		},
		column: task.FieldCategory,
		toTerm: task.ByCategory,
		toCursor: func(_m *Task) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// TaskOrderFieldDue orders Task by due.
	TaskOrderFieldDue = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Due == nil {
				return nil, nil
			}
			return _m.Due, nil
		},
		column: task.FieldDue,
		toTerm: func(opts ...sql.OrderTermOption) task.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return task.ByDue(opts...)
		},
		toCursor: func(_m *Task) Cursor {
			if _m.Due == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Due,
			}
		},
	}
	// TaskOrderFieldCompleted orders Task by completed.
	TaskOrderFieldCompleted = &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			// allow for nil values for fields
			if _m.Completed == nil {
				return nil, nil
			}
			return _m.Completed, nil
		},
		column: task.FieldCompleted,
		toTerm: func(opts ...sql.OrderTermOption) task.OrderOption {
			opts = append(opts, sql.OrderNullsLast())
			return task.ByCompleted(opts...)
		},
		toCursor: func(_m *Task) Cursor {
			if _m.Completed == nil {
				return Cursor{
					ID:    _m.ID,
					Value: nil, // handle nil values for fields
				}
			}
			return Cursor{
				ID:    _m.ID,
				Value: _m.Completed,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskOrderField) String() string {
	var str string
	switch f.column {
	case TaskOrderFieldCreatedAt.column:
		str = "created_at"
	case TaskOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TaskOrderFieldTitle.column:
		str = "title"
	case TaskOrderFieldStatus.column:
		str = "STATUS"
	case TaskOrderFieldCategory.column:
		str = "category"
	case TaskOrderFieldDue.column:
		str = "due"
	case TaskOrderFieldCompleted.column:
		str = "completed"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TaskOrderFieldCreatedAt
	case "updated_at":
		*f = *TaskOrderFieldUpdatedAt
	case "title":
		*f = *TaskOrderFieldTitle
	case "STATUS":
		*f = *TaskOrderFieldStatus
	case "category":
		*f = *TaskOrderFieldCategory
	case "due":
		*f = *TaskOrderFieldDue
	case "completed":
		*f = *TaskOrderFieldCompleted
	default:
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(_m *Task) (ent.Value, error) {
			return _m.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(_m *Task) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (_m *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TemplateEdge is the edge representation of Template.
type TemplateEdge struct {
	Node   *Template `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TemplateConnection is the connection containing edges to Template.
type TemplateConnection struct {
	Edges      []*TemplateEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *TemplateConnection) build(nodes []*Template, pager *templatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Template
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Template {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Template {
			return nodes[i]
		}
	}
	c.Edges = make([]*TemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TemplatePaginateOption enables pagination customization.
type TemplatePaginateOption func(*templatePager) error

// WithTemplateOrder configures pagination ordering.
func WithTemplateOrder(order []*TemplateOrder) TemplatePaginateOption {
	return func(pager *templatePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTemplateFilter configures pagination filter.
func WithTemplateFilter(filter func(*TemplateQuery) (*TemplateQuery, error)) TemplatePaginateOption {
	return func(pager *templatePager) error {
		if filter == nil {
			return errors.New("TemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type templatePager struct {
	reverse bool
	order   []*TemplateOrder
	filter  func(*TemplateQuery) (*TemplateQuery, error)
}

func newTemplatePager(opts []TemplatePaginateOption, reverse bool) (*templatePager, error) {
	pager := &templatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *templatePager) applyFilter(query *TemplateQuery) (*TemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *templatePager) toCursor(_m *Template) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *templatePager) applyCursors(query *TemplateQuery, after, before *Cursor) (*TemplateQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTemplateOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *templatePager) applyOrder(query *TemplateQuery) *TemplateQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTemplateOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *templatePager) orderExpr(query *TemplateQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTemplateOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Template.
func (_m *TemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TemplatePaginateOption,
) (*TemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TemplateConnection{Edges: []*TemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TemplateOrderFieldCreatedAt orders Template by created_at.
	TemplateOrderFieldCreatedAt = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: template.FieldCreatedAt,
		toTerm: template.ByCreatedAt,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TemplateOrderFieldUpdatedAt orders Template by updated_at.
	TemplateOrderFieldUpdatedAt = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: template.FieldUpdatedAt,
		toTerm: template.ByUpdatedAt,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TemplateOrderFieldName orders Template by name.
	TemplateOrderFieldName = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.Name, nil
		},
		column: template.FieldName,
		toTerm: template.ByName,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
	// TemplateOrderFieldTemplateType orders Template by template_type.
	TemplateOrderFieldTemplateType = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.TemplateType, nil
		},
		column: template.FieldTemplateType,
		toTerm: template.ByTemplateType,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.TemplateType,
			}
		},
	}
	// TemplateOrderFieldKind orders Template by kind.
	TemplateOrderFieldKind = &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.Kind, nil
		},
		column: template.FieldKind,
		toTerm: template.ByKind,
		toCursor: func(_m *Template) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Kind,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TemplateOrderField) String() string {
	var str string
	switch f.column {
	case TemplateOrderFieldCreatedAt.column:
		str = "created_at"
	case TemplateOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TemplateOrderFieldName.column:
		str = "name"
	case TemplateOrderFieldTemplateType.column:
		str = "TEMPLATE_TYPE"
	case TemplateOrderFieldKind.column:
		str = "KIND"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TemplateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TemplateOrderFieldCreatedAt
	case "updated_at":
		*f = *TemplateOrderFieldUpdatedAt
	case "name":
		*f = *TemplateOrderFieldName
	case "TEMPLATE_TYPE":
		*f = *TemplateOrderFieldTemplateType
	case "KIND":
		*f = *TemplateOrderFieldKind
	default:
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

// TemplateOrderField defines the ordering field of Template.
type TemplateOrderField struct {
	// Value extracts the ordering value from the given Template.
	Value    func(*Template) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) template.OrderOption
	toCursor func(*Template) Cursor
}

// TemplateOrder defines the ordering of Template.
type TemplateOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TemplateOrderField `json:"field"`
}

// DefaultTemplateOrder is the default ordering of Template.
var DefaultTemplateOrder = &TemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TemplateOrderField{
		Value: func(_m *Template) (ent.Value, error) {
			return _m.ID, nil
		},
		column: template.FieldID,
		toTerm: template.ByID,
		toCursor: func(_m *Template) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Template into TemplateEdge.
func (_m *Template) ToEdge(order *TemplateOrder) *TemplateEdge {
	if order == nil {
		order = DefaultTemplateOrder
	}
	return &TemplateEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterEdge is the edge representation of TrustCenter.
type TrustCenterEdge struct {
	Node   *TrustCenter `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TrustCenterConnection is the connection containing edges to TrustCenter.
type TrustCenterConnection struct {
	Edges      []*TrustCenterEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TrustCenterConnection) build(nodes []*TrustCenter, pager *trustcenterPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenter {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterPaginateOption enables pagination customization.
type TrustCenterPaginateOption func(*trustcenterPager) error

// WithTrustCenterOrder configures pagination ordering.
func WithTrustCenterOrder(order []*TrustCenterOrder) TrustCenterPaginateOption {
	return func(pager *trustcenterPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterFilter configures pagination filter.
func WithTrustCenterFilter(filter func(*TrustCenterQuery) (*TrustCenterQuery, error)) TrustCenterPaginateOption {
	return func(pager *trustcenterPager) error {
		if filter == nil {
			return errors.New("TrustCenterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterPager struct {
	reverse bool
	order   []*TrustCenterOrder
	filter  func(*TrustCenterQuery) (*TrustCenterQuery, error)
}

func newTrustCenterPager(opts []TrustCenterPaginateOption, reverse bool) (*trustcenterPager, error) {
	pager := &trustcenterPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterPager) applyFilter(query *TrustCenterQuery) (*TrustCenterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterPager) toCursor(_m *TrustCenter) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterPager) applyCursors(query *TrustCenterQuery, after, before *Cursor) (*TrustCenterQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterPager) applyOrder(query *TrustCenterQuery) *TrustCenterQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterPager) orderExpr(query *TrustCenterQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenter.
func (_m *TrustCenterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterPaginateOption,
) (*TrustCenterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterConnection{Edges: []*TrustCenterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterOrderFieldCreatedAt orders TrustCenter by created_at.
	TrustCenterOrderFieldCreatedAt = &TrustCenterOrderField{
		Value: func(_m *TrustCenter) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenter.FieldCreatedAt,
		toTerm: trustcenter.ByCreatedAt,
		toCursor: func(_m *TrustCenter) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterOrderFieldUpdatedAt orders TrustCenter by updated_at.
	TrustCenterOrderFieldUpdatedAt = &TrustCenterOrderField{
		Value: func(_m *TrustCenter) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenter.FieldUpdatedAt,
		toTerm: trustcenter.ByUpdatedAt,
		toCursor: func(_m *TrustCenter) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterOrderField", str)
	}
	return nil
}

// TrustCenterOrderField defines the ordering field of TrustCenter.
type TrustCenterOrderField struct {
	// Value extracts the ordering value from the given TrustCenter.
	Value    func(*TrustCenter) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenter.OrderOption
	toCursor func(*TrustCenter) Cursor
}

// TrustCenterOrder defines the ordering of TrustCenter.
type TrustCenterOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TrustCenterOrderField `json:"field"`
}

// DefaultTrustCenterOrder is the default ordering of TrustCenter.
var DefaultTrustCenterOrder = &TrustCenterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterOrderField{
		Value: func(_m *TrustCenter) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenter.FieldID,
		toTerm: trustcenter.ByID,
		toCursor: func(_m *TrustCenter) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenter into TrustCenterEdge.
func (_m *TrustCenter) ToEdge(order *TrustCenterOrder) *TrustCenterEdge {
	if order == nil {
		order = DefaultTrustCenterOrder
	}
	return &TrustCenterEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterComplianceEdge is the edge representation of TrustCenterCompliance.
type TrustCenterComplianceEdge struct {
	Node   *TrustCenterCompliance `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// TrustCenterComplianceConnection is the connection containing edges to TrustCenterCompliance.
type TrustCenterComplianceConnection struct {
	Edges      []*TrustCenterComplianceEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *TrustCenterComplianceConnection) build(nodes []*TrustCenterCompliance, pager *trustcentercompliancePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterCompliance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterCompliance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterCompliance {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterComplianceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterComplianceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterCompliancePaginateOption enables pagination customization.
type TrustCenterCompliancePaginateOption func(*trustcentercompliancePager) error

// WithTrustCenterComplianceOrder configures pagination ordering.
func WithTrustCenterComplianceOrder(order []*TrustCenterComplianceOrder) TrustCenterCompliancePaginateOption {
	return func(pager *trustcentercompliancePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterComplianceFilter configures pagination filter.
func WithTrustCenterComplianceFilter(filter func(*TrustCenterComplianceQuery) (*TrustCenterComplianceQuery, error)) TrustCenterCompliancePaginateOption {
	return func(pager *trustcentercompliancePager) error {
		if filter == nil {
			return errors.New("TrustCenterComplianceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentercompliancePager struct {
	reverse bool
	order   []*TrustCenterComplianceOrder
	filter  func(*TrustCenterComplianceQuery) (*TrustCenterComplianceQuery, error)
}

func newTrustCenterCompliancePager(opts []TrustCenterCompliancePaginateOption, reverse bool) (*trustcentercompliancePager, error) {
	pager := &trustcentercompliancePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentercompliancePager) applyFilter(query *TrustCenterComplianceQuery) (*TrustCenterComplianceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentercompliancePager) toCursor(_m *TrustCenterCompliance) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcentercompliancePager) applyCursors(query *TrustCenterComplianceQuery, after, before *Cursor) (*TrustCenterComplianceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterComplianceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentercompliancePager) applyOrder(query *TrustCenterComplianceQuery) *TrustCenterComplianceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterComplianceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterComplianceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentercompliancePager) orderExpr(query *TrustCenterComplianceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterComplianceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterCompliance.
func (_m *TrustCenterComplianceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterCompliancePaginateOption,
) (*TrustCenterComplianceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterCompliancePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterComplianceConnection{Edges: []*TrustCenterComplianceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterComplianceOrderFieldCreatedAt orders TrustCenterCompliance by created_at.
	TrustCenterComplianceOrderFieldCreatedAt = &TrustCenterComplianceOrderField{
		Value: func(_m *TrustCenterCompliance) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentercompliance.FieldCreatedAt,
		toTerm: trustcentercompliance.ByCreatedAt,
		toCursor: func(_m *TrustCenterCompliance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterComplianceOrderFieldUpdatedAt orders TrustCenterCompliance by updated_at.
	TrustCenterComplianceOrderFieldUpdatedAt = &TrustCenterComplianceOrderField{
		Value: func(_m *TrustCenterCompliance) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentercompliance.FieldUpdatedAt,
		toTerm: trustcentercompliance.ByUpdatedAt,
		toCursor: func(_m *TrustCenterCompliance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterComplianceOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterComplianceOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterComplianceOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterComplianceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterComplianceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterComplianceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterComplianceOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterComplianceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterComplianceOrderField", str)
	}
	return nil
}

// TrustCenterComplianceOrderField defines the ordering field of TrustCenterCompliance.
type TrustCenterComplianceOrderField struct {
	// Value extracts the ordering value from the given TrustCenterCompliance.
	Value    func(*TrustCenterCompliance) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentercompliance.OrderOption
	toCursor func(*TrustCenterCompliance) Cursor
}

// TrustCenterComplianceOrder defines the ordering of TrustCenterCompliance.
type TrustCenterComplianceOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *TrustCenterComplianceOrderField `json:"field"`
}

// DefaultTrustCenterComplianceOrder is the default ordering of TrustCenterCompliance.
var DefaultTrustCenterComplianceOrder = &TrustCenterComplianceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterComplianceOrderField{
		Value: func(_m *TrustCenterCompliance) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentercompliance.FieldID,
		toTerm: trustcentercompliance.ByID,
		toCursor: func(_m *TrustCenterCompliance) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterCompliance into TrustCenterComplianceEdge.
func (_m *TrustCenterCompliance) ToEdge(order *TrustCenterComplianceOrder) *TrustCenterComplianceEdge {
	if order == nil {
		order = DefaultTrustCenterComplianceOrder
	}
	return &TrustCenterComplianceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterDocEdge is the edge representation of TrustCenterDoc.
type TrustCenterDocEdge struct {
	Node   *TrustCenterDoc `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// TrustCenterDocConnection is the connection containing edges to TrustCenterDoc.
type TrustCenterDocConnection struct {
	Edges      []*TrustCenterDocEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *TrustCenterDocConnection) build(nodes []*TrustCenterDoc, pager *trustcenterdocPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterDoc
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterDoc {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterDoc {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterDocEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterDocEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterDocPaginateOption enables pagination customization.
type TrustCenterDocPaginateOption func(*trustcenterdocPager) error

// WithTrustCenterDocOrder configures pagination ordering.
func WithTrustCenterDocOrder(order []*TrustCenterDocOrder) TrustCenterDocPaginateOption {
	return func(pager *trustcenterdocPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterDocFilter configures pagination filter.
func WithTrustCenterDocFilter(filter func(*TrustCenterDocQuery) (*TrustCenterDocQuery, error)) TrustCenterDocPaginateOption {
	return func(pager *trustcenterdocPager) error {
		if filter == nil {
			return errors.New("TrustCenterDocQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterdocPager struct {
	reverse bool
	order   []*TrustCenterDocOrder
	filter  func(*TrustCenterDocQuery) (*TrustCenterDocQuery, error)
}

func newTrustCenterDocPager(opts []TrustCenterDocPaginateOption, reverse bool) (*trustcenterdocPager, error) {
	pager := &trustcenterdocPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterdocPager) applyFilter(query *TrustCenterDocQuery) (*TrustCenterDocQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterdocPager) toCursor(_m *TrustCenterDoc) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterdocPager) applyCursors(query *TrustCenterDocQuery, after, before *Cursor) (*TrustCenterDocQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterDocOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterdocPager) applyOrder(query *TrustCenterDocQuery) *TrustCenterDocQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterDocOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterDocOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterdocPager) orderExpr(query *TrustCenterDocQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterDocOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterDoc.
func (_m *TrustCenterDocQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterDocPaginateOption,
) (*TrustCenterDocConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterDocPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterDocConnection{Edges: []*TrustCenterDocEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterDocOrderFieldCreatedAt orders TrustCenterDoc by created_at.
	TrustCenterDocOrderFieldCreatedAt = &TrustCenterDocOrderField{
		Value: func(_m *TrustCenterDoc) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterdoc.FieldCreatedAt,
		toTerm: trustcenterdoc.ByCreatedAt,
		toCursor: func(_m *TrustCenterDoc) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterDocOrderFieldUpdatedAt orders TrustCenterDoc by updated_at.
	TrustCenterDocOrderFieldUpdatedAt = &TrustCenterDocOrderField{
		Value: func(_m *TrustCenterDoc) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterdoc.FieldUpdatedAt,
		toTerm: trustcenterdoc.ByUpdatedAt,
		toCursor: func(_m *TrustCenterDoc) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterDocOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterDocOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterDocOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterDocOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterDocOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterDocOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterDocOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterDocOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterDocOrderField", str)
	}
	return nil
}

// TrustCenterDocOrderField defines the ordering field of TrustCenterDoc.
type TrustCenterDocOrderField struct {
	// Value extracts the ordering value from the given TrustCenterDoc.
	Value    func(*TrustCenterDoc) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterdoc.OrderOption
	toCursor func(*TrustCenterDoc) Cursor
}

// TrustCenterDocOrder defines the ordering of TrustCenterDoc.
type TrustCenterDocOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *TrustCenterDocOrderField `json:"field"`
}

// DefaultTrustCenterDocOrder is the default ordering of TrustCenterDoc.
var DefaultTrustCenterDocOrder = &TrustCenterDocOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterDocOrderField{
		Value: func(_m *TrustCenterDoc) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterdoc.FieldID,
		toTerm: trustcenterdoc.ByID,
		toCursor: func(_m *TrustCenterDoc) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterDoc into TrustCenterDocEdge.
func (_m *TrustCenterDoc) ToEdge(order *TrustCenterDocOrder) *TrustCenterDocEdge {
	if order == nil {
		order = DefaultTrustCenterDocOrder
	}
	return &TrustCenterDocEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSettingEdge is the edge representation of TrustCenterSetting.
type TrustCenterSettingEdge struct {
	Node   *TrustCenterSetting `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// TrustCenterSettingConnection is the connection containing edges to TrustCenterSetting.
type TrustCenterSettingConnection struct {
	Edges      []*TrustCenterSettingEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *TrustCenterSettingConnection) build(nodes []*TrustCenterSetting, pager *trustcentersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSettingPaginateOption enables pagination customization.
type TrustCenterSettingPaginateOption func(*trustcentersettingPager) error

// WithTrustCenterSettingOrder configures pagination ordering.
func WithTrustCenterSettingOrder(order []*TrustCenterSettingOrder) TrustCenterSettingPaginateOption {
	return func(pager *trustcentersettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterSettingFilter configures pagination filter.
func WithTrustCenterSettingFilter(filter func(*TrustCenterSettingQuery) (*TrustCenterSettingQuery, error)) TrustCenterSettingPaginateOption {
	return func(pager *trustcentersettingPager) error {
		if filter == nil {
			return errors.New("TrustCenterSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersettingPager struct {
	reverse bool
	order   []*TrustCenterSettingOrder
	filter  func(*TrustCenterSettingQuery) (*TrustCenterSettingQuery, error)
}

func newTrustCenterSettingPager(opts []TrustCenterSettingPaginateOption, reverse bool) (*trustcentersettingPager, error) {
	pager := &trustcentersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentersettingPager) applyFilter(query *TrustCenterSettingQuery) (*TrustCenterSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersettingPager) toCursor(_m *TrustCenterSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcentersettingPager) applyCursors(query *TrustCenterSettingQuery, after, before *Cursor) (*TrustCenterSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentersettingPager) applyOrder(query *TrustCenterSettingQuery) *TrustCenterSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentersettingPager) orderExpr(query *TrustCenterSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSetting.
func (_m *TrustCenterSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSettingPaginateOption,
) (*TrustCenterSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSettingConnection{Edges: []*TrustCenterSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSettingOrderFieldCreatedAt orders TrustCenterSetting by created_at.
	TrustCenterSettingOrderFieldCreatedAt = &TrustCenterSettingOrderField{
		Value: func(_m *TrustCenterSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersetting.FieldCreatedAt,
		toTerm: trustcentersetting.ByCreatedAt,
		toCursor: func(_m *TrustCenterSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSettingOrderFieldUpdatedAt orders TrustCenterSetting by updated_at.
	TrustCenterSettingOrderFieldUpdatedAt = &TrustCenterSettingOrderField{
		Value: func(_m *TrustCenterSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersetting.FieldUpdatedAt,
		toTerm: trustcentersetting.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSettingOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSettingOrderField", str)
	}
	return nil
}

// TrustCenterSettingOrderField defines the ordering field of TrustCenterSetting.
type TrustCenterSettingOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSetting.
	Value    func(*TrustCenterSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersetting.OrderOption
	toCursor func(*TrustCenterSetting) Cursor
}

// TrustCenterSettingOrder defines the ordering of TrustCenterSetting.
type TrustCenterSettingOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *TrustCenterSettingOrderField `json:"field"`
}

// DefaultTrustCenterSettingOrder is the default ordering of TrustCenterSetting.
var DefaultTrustCenterSettingOrder = &TrustCenterSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSettingOrderField{
		Value: func(_m *TrustCenterSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersetting.FieldID,
		toTerm: trustcentersetting.ByID,
		toCursor: func(_m *TrustCenterSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSetting into TrustCenterSettingEdge.
func (_m *TrustCenterSetting) ToEdge(order *TrustCenterSettingOrder) *TrustCenterSettingEdge {
	if order == nil {
		order = DefaultTrustCenterSettingOrder
	}
	return &TrustCenterSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterSubprocessorEdge is the edge representation of TrustCenterSubprocessor.
type TrustCenterSubprocessorEdge struct {
	Node   *TrustCenterSubprocessor `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// TrustCenterSubprocessorConnection is the connection containing edges to TrustCenterSubprocessor.
type TrustCenterSubprocessorConnection struct {
	Edges      []*TrustCenterSubprocessorEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *TrustCenterSubprocessorConnection) build(nodes []*TrustCenterSubprocessor, pager *trustcentersubprocessorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterSubprocessor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterSubprocessor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterSubprocessor {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterSubprocessorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterSubprocessorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterSubprocessorPaginateOption enables pagination customization.
type TrustCenterSubprocessorPaginateOption func(*trustcentersubprocessorPager) error

// WithTrustCenterSubprocessorOrder configures pagination ordering.
func WithTrustCenterSubprocessorOrder(order []*TrustCenterSubprocessorOrder) TrustCenterSubprocessorPaginateOption {
	return func(pager *trustcentersubprocessorPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterSubprocessorFilter configures pagination filter.
func WithTrustCenterSubprocessorFilter(filter func(*TrustCenterSubprocessorQuery) (*TrustCenterSubprocessorQuery, error)) TrustCenterSubprocessorPaginateOption {
	return func(pager *trustcentersubprocessorPager) error {
		if filter == nil {
			return errors.New("TrustCenterSubprocessorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcentersubprocessorPager struct {
	reverse bool
	order   []*TrustCenterSubprocessorOrder
	filter  func(*TrustCenterSubprocessorQuery) (*TrustCenterSubprocessorQuery, error)
}

func newTrustCenterSubprocessorPager(opts []TrustCenterSubprocessorPaginateOption, reverse bool) (*trustcentersubprocessorPager, error) {
	pager := &trustcentersubprocessorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcentersubprocessorPager) applyFilter(query *TrustCenterSubprocessorQuery) (*TrustCenterSubprocessorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcentersubprocessorPager) toCursor(_m *TrustCenterSubprocessor) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcentersubprocessorPager) applyCursors(query *TrustCenterSubprocessorQuery, after, before *Cursor) (*TrustCenterSubprocessorQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterSubprocessorOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcentersubprocessorPager) applyOrder(query *TrustCenterSubprocessorQuery) *TrustCenterSubprocessorQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterSubprocessorOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterSubprocessorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcentersubprocessorPager) orderExpr(query *TrustCenterSubprocessorQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterSubprocessorOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterSubprocessor.
func (_m *TrustCenterSubprocessorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterSubprocessorPaginateOption,
) (*TrustCenterSubprocessorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterSubprocessorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterSubprocessorConnection{Edges: []*TrustCenterSubprocessorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterSubprocessorOrderFieldCreatedAt orders TrustCenterSubprocessor by created_at.
	TrustCenterSubprocessorOrderFieldCreatedAt = &TrustCenterSubprocessorOrderField{
		Value: func(_m *TrustCenterSubprocessor) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcentersubprocessor.FieldCreatedAt,
		toTerm: trustcentersubprocessor.ByCreatedAt,
		toCursor: func(_m *TrustCenterSubprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterSubprocessorOrderFieldUpdatedAt orders TrustCenterSubprocessor by updated_at.
	TrustCenterSubprocessorOrderFieldUpdatedAt = &TrustCenterSubprocessorOrderField{
		Value: func(_m *TrustCenterSubprocessor) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcentersubprocessor.FieldUpdatedAt,
		toTerm: trustcentersubprocessor.ByUpdatedAt,
		toCursor: func(_m *TrustCenterSubprocessor) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterSubprocessorOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterSubprocessorOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterSubprocessorOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterSubprocessorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterSubprocessorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterSubprocessorOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterSubprocessorOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterSubprocessorOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterSubprocessorOrderField", str)
	}
	return nil
}

// TrustCenterSubprocessorOrderField defines the ordering field of TrustCenterSubprocessor.
type TrustCenterSubprocessorOrderField struct {
	// Value extracts the ordering value from the given TrustCenterSubprocessor.
	Value    func(*TrustCenterSubprocessor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcentersubprocessor.OrderOption
	toCursor func(*TrustCenterSubprocessor) Cursor
}

// TrustCenterSubprocessorOrder defines the ordering of TrustCenterSubprocessor.
type TrustCenterSubprocessorOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *TrustCenterSubprocessorOrderField `json:"field"`
}

// DefaultTrustCenterSubprocessorOrder is the default ordering of TrustCenterSubprocessor.
var DefaultTrustCenterSubprocessorOrder = &TrustCenterSubprocessorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterSubprocessorOrderField{
		Value: func(_m *TrustCenterSubprocessor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcentersubprocessor.FieldID,
		toTerm: trustcentersubprocessor.ByID,
		toCursor: func(_m *TrustCenterSubprocessor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterSubprocessor into TrustCenterSubprocessorEdge.
func (_m *TrustCenterSubprocessor) ToEdge(order *TrustCenterSubprocessorOrder) *TrustCenterSubprocessorEdge {
	if order == nil {
		order = DefaultTrustCenterSubprocessorOrder
	}
	return &TrustCenterSubprocessorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustCenterWatermarkConfigEdge is the edge representation of TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigEdge struct {
	Node   *TrustCenterWatermarkConfig `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// TrustCenterWatermarkConfigConnection is the connection containing edges to TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigConnection struct {
	Edges      []*TrustCenterWatermarkConfigEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *TrustCenterWatermarkConfigConnection) build(nodes []*TrustCenterWatermarkConfig, pager *trustcenterwatermarkconfigPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustCenterWatermarkConfig
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustCenterWatermarkConfig {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustCenterWatermarkConfig {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustCenterWatermarkConfigEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustCenterWatermarkConfigEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustCenterWatermarkConfigPaginateOption enables pagination customization.
type TrustCenterWatermarkConfigPaginateOption func(*trustcenterwatermarkconfigPager) error

// WithTrustCenterWatermarkConfigOrder configures pagination ordering.
func WithTrustCenterWatermarkConfigOrder(order []*TrustCenterWatermarkConfigOrder) TrustCenterWatermarkConfigPaginateOption {
	return func(pager *trustcenterwatermarkconfigPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustCenterWatermarkConfigFilter configures pagination filter.
func WithTrustCenterWatermarkConfigFilter(filter func(*TrustCenterWatermarkConfigQuery) (*TrustCenterWatermarkConfigQuery, error)) TrustCenterWatermarkConfigPaginateOption {
	return func(pager *trustcenterwatermarkconfigPager) error {
		if filter == nil {
			return errors.New("TrustCenterWatermarkConfigQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterwatermarkconfigPager struct {
	reverse bool
	order   []*TrustCenterWatermarkConfigOrder
	filter  func(*TrustCenterWatermarkConfigQuery) (*TrustCenterWatermarkConfigQuery, error)
}

func newTrustCenterWatermarkConfigPager(opts []TrustCenterWatermarkConfigPaginateOption, reverse bool) (*trustcenterwatermarkconfigPager, error) {
	pager := &trustcenterwatermarkconfigPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterwatermarkconfigPager) applyFilter(query *TrustCenterWatermarkConfigQuery) (*TrustCenterWatermarkConfigQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterwatermarkconfigPager) toCursor(_m *TrustCenterWatermarkConfig) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterwatermarkconfigPager) applyCursors(query *TrustCenterWatermarkConfigQuery, after, before *Cursor) (*TrustCenterWatermarkConfigQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustCenterWatermarkConfigOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterwatermarkconfigPager) applyOrder(query *TrustCenterWatermarkConfigQuery) *TrustCenterWatermarkConfigQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustCenterWatermarkConfigOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustCenterWatermarkConfigOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterwatermarkconfigPager) orderExpr(query *TrustCenterWatermarkConfigQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustCenterWatermarkConfigOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustCenterWatermarkConfig.
func (_m *TrustCenterWatermarkConfigQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustCenterWatermarkConfigPaginateOption,
) (*TrustCenterWatermarkConfigConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustCenterWatermarkConfigPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustCenterWatermarkConfigConnection{Edges: []*TrustCenterWatermarkConfigEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustCenterWatermarkConfigOrderFieldCreatedAt orders TrustCenterWatermarkConfig by created_at.
	TrustCenterWatermarkConfigOrderFieldCreatedAt = &TrustCenterWatermarkConfigOrderField{
		Value: func(_m *TrustCenterWatermarkConfig) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterwatermarkconfig.FieldCreatedAt,
		toTerm: trustcenterwatermarkconfig.ByCreatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfig) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustCenterWatermarkConfigOrderFieldUpdatedAt orders TrustCenterWatermarkConfig by updated_at.
	TrustCenterWatermarkConfigOrderFieldUpdatedAt = &TrustCenterWatermarkConfigOrderField{
		Value: func(_m *TrustCenterWatermarkConfig) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterwatermarkconfig.FieldUpdatedAt,
		toTerm: trustcenterwatermarkconfig.ByUpdatedAt,
		toCursor: func(_m *TrustCenterWatermarkConfig) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustCenterWatermarkConfigOrderField) String() string {
	var str string
	switch f.column {
	case TrustCenterWatermarkConfigOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustCenterWatermarkConfigOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustCenterWatermarkConfigOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustCenterWatermarkConfigOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustCenterWatermarkConfigOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustCenterWatermarkConfigOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustCenterWatermarkConfigOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid TrustCenterWatermarkConfigOrderField", str)
	}
	return nil
}

// TrustCenterWatermarkConfigOrderField defines the ordering field of TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigOrderField struct {
	// Value extracts the ordering value from the given TrustCenterWatermarkConfig.
	Value    func(*TrustCenterWatermarkConfig) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterwatermarkconfig.OrderOption
	toCursor func(*TrustCenterWatermarkConfig) Cursor
}

// TrustCenterWatermarkConfigOrder defines the ordering of TrustCenterWatermarkConfig.
type TrustCenterWatermarkConfigOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *TrustCenterWatermarkConfigOrderField `json:"field"`
}

// DefaultTrustCenterWatermarkConfigOrder is the default ordering of TrustCenterWatermarkConfig.
var DefaultTrustCenterWatermarkConfigOrder = &TrustCenterWatermarkConfigOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustCenterWatermarkConfigOrderField{
		Value: func(_m *TrustCenterWatermarkConfig) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterwatermarkconfig.FieldID,
		toTerm: trustcenterwatermarkconfig.ByID,
		toCursor: func(_m *TrustCenterWatermarkConfig) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustCenterWatermarkConfig into TrustCenterWatermarkConfigEdge.
func (_m *TrustCenterWatermarkConfig) ToEdge(order *TrustCenterWatermarkConfigOrder) *TrustCenterWatermarkConfigEdge {
	if order == nil {
		order = DefaultTrustCenterWatermarkConfigOrder
	}
	return &TrustCenterWatermarkConfigEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// TrustcenterEntityEdge is the edge representation of TrustcenterEntity.
type TrustcenterEntityEdge struct {
	Node   *TrustcenterEntity `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// TrustcenterEntityConnection is the connection containing edges to TrustcenterEntity.
type TrustcenterEntityConnection struct {
	Edges      []*TrustcenterEntityEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *TrustcenterEntityConnection) build(nodes []*TrustcenterEntity, pager *trustcenterentityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *TrustcenterEntity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrustcenterEntity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrustcenterEntity {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrustcenterEntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrustcenterEntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrustcenterEntityPaginateOption enables pagination customization.
type TrustcenterEntityPaginateOption func(*trustcenterentityPager) error

// WithTrustcenterEntityOrder configures pagination ordering.
func WithTrustcenterEntityOrder(order []*TrustcenterEntityOrder) TrustcenterEntityPaginateOption {
	return func(pager *trustcenterentityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTrustcenterEntityFilter configures pagination filter.
func WithTrustcenterEntityFilter(filter func(*TrustcenterEntityQuery) (*TrustcenterEntityQuery, error)) TrustcenterEntityPaginateOption {
	return func(pager *trustcenterentityPager) error {
		if filter == nil {
			return errors.New("TrustcenterEntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trustcenterentityPager struct {
	reverse bool
	order   []*TrustcenterEntityOrder
	filter  func(*TrustcenterEntityQuery) (*TrustcenterEntityQuery, error)
}

func newTrustcenterEntityPager(opts []TrustcenterEntityPaginateOption, reverse bool) (*trustcenterentityPager, error) {
	pager := &trustcenterentityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *trustcenterentityPager) applyFilter(query *TrustcenterEntityQuery) (*TrustcenterEntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trustcenterentityPager) toCursor(_m *TrustcenterEntity) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *trustcenterentityPager) applyCursors(query *TrustcenterEntityQuery, after, before *Cursor) (*TrustcenterEntityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTrustcenterEntityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *trustcenterentityPager) applyOrder(query *TrustcenterEntityQuery) *TrustcenterEntityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTrustcenterEntityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTrustcenterEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *trustcenterentityPager) orderExpr(query *TrustcenterEntityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTrustcenterEntityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrustcenterEntity.
func (_m *TrustcenterEntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrustcenterEntityPaginateOption,
) (*TrustcenterEntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrustcenterEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &TrustcenterEntityConnection{Edges: []*TrustcenterEntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrustcenterEntityOrderFieldCreatedAt orders TrustcenterEntity by created_at.
	TrustcenterEntityOrderFieldCreatedAt = &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: trustcenterentity.FieldCreatedAt,
		toTerm: trustcenterentity.ByCreatedAt,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// TrustcenterEntityOrderFieldUpdatedAt orders TrustcenterEntity by updated_at.
	TrustcenterEntityOrderFieldUpdatedAt = &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: trustcenterentity.FieldUpdatedAt,
		toTerm: trustcenterentity.ByUpdatedAt,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// TrustcenterEntityOrderFieldName orders TrustcenterEntity by name.
	TrustcenterEntityOrderFieldName = &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.Name, nil
		},
		column: trustcenterentity.FieldName,
		toTerm: trustcenterentity.ByName,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrustcenterEntityOrderField) String() string {
	var str string
	switch f.column {
	case TrustcenterEntityOrderFieldCreatedAt.column:
		str = "created_at"
	case TrustcenterEntityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case TrustcenterEntityOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrustcenterEntityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrustcenterEntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrustcenterEntityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *TrustcenterEntityOrderFieldCreatedAt
	case "updated_at":
		*f = *TrustcenterEntityOrderFieldUpdatedAt
	case "NAME":
		*f = *TrustcenterEntityOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TrustcenterEntityOrderField", str)
	}
	return nil
}

// TrustcenterEntityOrderField defines the ordering field of TrustcenterEntity.
type TrustcenterEntityOrderField struct {
	// Value extracts the ordering value from the given TrustcenterEntity.
	Value    func(*TrustcenterEntity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trustcenterentity.OrderOption
	toCursor func(*TrustcenterEntity) Cursor
}

// TrustcenterEntityOrder defines the ordering of TrustcenterEntity.
type TrustcenterEntityOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *TrustcenterEntityOrderField `json:"field"`
}

// DefaultTrustcenterEntityOrder is the default ordering of TrustcenterEntity.
var DefaultTrustcenterEntityOrder = &TrustcenterEntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrustcenterEntityOrderField{
		Value: func(_m *TrustcenterEntity) (ent.Value, error) {
			return _m.ID, nil
		},
		column: trustcenterentity.FieldID,
		toTerm: trustcenterentity.ByID,
		toCursor: func(_m *TrustcenterEntity) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts TrustcenterEntity into TrustcenterEntityEdge.
func (_m *TrustcenterEntity) ToEdge(order *TrustcenterEntityOrder) *TrustcenterEntityEdge {
	if order == nil {
		order = DefaultTrustcenterEntityOrder
	}
	return &TrustcenterEntityEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order []*UserOrder) UserPaginateOption {
	return func(pager *userPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   []*UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(_m *User) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (_m *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// UserOrderFieldFirstName orders User by first_name.
	UserOrderFieldFirstName = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.FirstName, nil
		},
		column: user.FieldFirstName,
		toTerm: user.ByFirstName,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.FirstName,
			}
		},
	}
	// UserOrderFieldLastName orders User by last_name.
	UserOrderFieldLastName = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.LastName, nil
		},
		column: user.FieldLastName,
		toTerm: user.ByLastName,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.LastName,
			}
		},
	}
	// UserOrderFieldDisplayName orders User by display_name.
	UserOrderFieldDisplayName = &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.DisplayName, nil
		},
		column: user.FieldDisplayName,
		toTerm: user.ByDisplayName,
		toCursor: func(_m *User) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.DisplayName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "created_at"
	case UserOrderFieldUpdatedAt.column:
		str = "updated_at"
	case UserOrderFieldFirstName.column:
		str = "first_name"
	case UserOrderFieldLastName.column:
		str = "last_name"
	case UserOrderFieldDisplayName.column:
		str = "display_name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserOrderFieldCreatedAt
	case "updated_at":
		*f = *UserOrderFieldUpdatedAt
	case "first_name":
		*f = *UserOrderFieldFirstName
	case "last_name":
		*f = *UserOrderFieldLastName
	case "display_name":
		*f = *UserOrderFieldDisplayName
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(_m *User) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (_m *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserSettingEdge is the edge representation of UserSetting.
type UserSettingEdge struct {
	Node   *UserSetting `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserSettingConnection is the connection containing edges to UserSetting.
type UserSettingConnection struct {
	Edges      []*UserSettingEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserSettingConnection) build(nodes []*UserSetting, pager *usersettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *UserSetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingPaginateOption enables pagination customization.
type UserSettingPaginateOption func(*usersettingPager) error

// WithUserSettingOrder configures pagination ordering.
func WithUserSettingOrder(order []*UserSettingOrder) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithUserSettingFilter configures pagination filter.
func WithUserSettingFilter(filter func(*UserSettingQuery) (*UserSettingQuery, error)) UserSettingPaginateOption {
	return func(pager *usersettingPager) error {
		if filter == nil {
			return errors.New("UserSettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettingPager struct {
	reverse bool
	order   []*UserSettingOrder
	filter  func(*UserSettingQuery) (*UserSettingQuery, error)
}

func newUserSettingPager(opts []UserSettingPaginateOption, reverse bool) (*usersettingPager, error) {
	pager := &usersettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *usersettingPager) applyFilter(query *UserSettingQuery) (*UserSettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettingPager) toCursor(_m *UserSetting) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *usersettingPager) applyCursors(query *UserSettingQuery, after, before *Cursor) (*UserSettingQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultUserSettingOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *usersettingPager) applyOrder(query *UserSettingQuery) *UserSettingQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultUserSettingOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultUserSettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *usersettingPager) orderExpr(query *UserSettingQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultUserSettingOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSetting.
func (_m *UserSettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingPaginateOption,
) (*UserSettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserSettingConnection{Edges: []*UserSettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSettingOrderFieldCreatedAt orders UserSetting by created_at.
	UserSettingOrderFieldCreatedAt = &UserSettingOrderField{
		Value: func(_m *UserSetting) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: usersetting.FieldCreatedAt,
		toTerm: usersetting.ByCreatedAt,
		toCursor: func(_m *UserSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// UserSettingOrderFieldUpdatedAt orders UserSetting by updated_at.
	UserSettingOrderFieldUpdatedAt = &UserSettingOrderField{
		Value: func(_m *UserSetting) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: usersetting.FieldUpdatedAt,
		toTerm: usersetting.ByUpdatedAt,
		toCursor: func(_m *UserSetting) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSettingOrderField) String() string {
	var str string
	switch f.column {
	case UserSettingOrderFieldCreatedAt.column:
		str = "created_at"
	case UserSettingOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSettingOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserSettingOrderFieldCreatedAt
	case "updated_at":
		*f = *UserSettingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSettingOrderField", str)
	}
	return nil
}

// UserSettingOrderField defines the ordering field of UserSetting.
type UserSettingOrderField struct {
	// Value extracts the ordering value from the given UserSetting.
	Value    func(*UserSetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersetting.OrderOption
	toCursor func(*UserSetting) Cursor
}

// UserSettingOrder defines the ordering of UserSetting.
type UserSettingOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserSettingOrderField `json:"field"`
}

// DefaultUserSettingOrder is the default ordering of UserSetting.
var DefaultUserSettingOrder = &UserSettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingOrderField{
		Value: func(_m *UserSetting) (ent.Value, error) {
			return _m.ID, nil
		},
		column: usersetting.FieldID,
		toTerm: usersetting.ByID,
		toCursor: func(_m *UserSetting) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts UserSetting into UserSettingEdge.
func (_m *UserSetting) ToEdge(order *UserSettingOrder) *UserSettingEdge {
	if order == nil {
		order = DefaultUserSettingOrder
	}
	return &UserSettingEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// VulnerabilityEdge is the edge representation of Vulnerability.
type VulnerabilityEdge struct {
	Node   *Vulnerability `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// VulnerabilityConnection is the connection containing edges to Vulnerability.
type VulnerabilityConnection struct {
	Edges      []*VulnerabilityEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *VulnerabilityConnection) build(nodes []*Vulnerability, pager *vulnerabilityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Vulnerability
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vulnerability {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vulnerability {
			return nodes[i]
		}
	}
	c.Edges = make([]*VulnerabilityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VulnerabilityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VulnerabilityPaginateOption enables pagination customization.
type VulnerabilityPaginateOption func(*vulnerabilityPager) error

// WithVulnerabilityOrder configures pagination ordering.
func WithVulnerabilityOrder(order []*VulnerabilityOrder) VulnerabilityPaginateOption {
	return func(pager *vulnerabilityPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithVulnerabilityFilter configures pagination filter.
func WithVulnerabilityFilter(filter func(*VulnerabilityQuery) (*VulnerabilityQuery, error)) VulnerabilityPaginateOption {
	return func(pager *vulnerabilityPager) error {
		if filter == nil {
			return errors.New("VulnerabilityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityPager struct {
	reverse bool
	order   []*VulnerabilityOrder
	filter  func(*VulnerabilityQuery) (*VulnerabilityQuery, error)
}

func newVulnerabilityPager(opts []VulnerabilityPaginateOption, reverse bool) (*vulnerabilityPager, error) {
	pager := &vulnerabilityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *vulnerabilityPager) applyFilter(query *VulnerabilityQuery) (*VulnerabilityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityPager) toCursor(_m *Vulnerability) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *vulnerabilityPager) applyCursors(query *VulnerabilityQuery, after, before *Cursor) (*VulnerabilityQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultVulnerabilityOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *vulnerabilityPager) applyOrder(query *VulnerabilityQuery) *VulnerabilityQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultVulnerabilityOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultVulnerabilityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *vulnerabilityPager) orderExpr(query *VulnerabilityQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultVulnerabilityOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Vulnerability.
func (_m *VulnerabilityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityPaginateOption,
) (*VulnerabilityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &VulnerabilityConnection{Edges: []*VulnerabilityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VulnerabilityOrderFieldCreatedAt orders Vulnerability by created_at.
	VulnerabilityOrderFieldCreatedAt = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: vulnerability.FieldCreatedAt,
		toTerm: vulnerability.ByCreatedAt,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// VulnerabilityOrderFieldUpdatedAt orders Vulnerability by updated_at.
	VulnerabilityOrderFieldUpdatedAt = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: vulnerability.FieldUpdatedAt,
		toTerm: vulnerability.ByUpdatedAt,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
	// VulnerabilityOrderFieldExternalOwnerID orders Vulnerability by external_owner_id.
	VulnerabilityOrderFieldExternalOwnerID = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.ExternalOwnerID, nil
		},
		column: vulnerability.FieldExternalOwnerID,
		toTerm: vulnerability.ByExternalOwnerID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalOwnerID,
			}
		},
	}
	// VulnerabilityOrderFieldExternalID orders Vulnerability by external_id.
	VulnerabilityOrderFieldExternalID = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.ExternalID, nil
		},
		column: vulnerability.FieldExternalID,
		toTerm: vulnerability.ByExternalID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.ExternalID,
			}
		},
	}
	// VulnerabilityOrderFieldCveID orders Vulnerability by cve_id.
	VulnerabilityOrderFieldCveID = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.CveID, nil
		},
		column: vulnerability.FieldCveID,
		toTerm: vulnerability.ByCveID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CveID,
			}
		},
	}
	// VulnerabilityOrderFieldCategory orders Vulnerability by category.
	VulnerabilityOrderFieldCategory = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.Category, nil
		},
		column: vulnerability.FieldCategory,
		toTerm: vulnerability.ByCategory,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Category,
			}
		},
	}
	// VulnerabilityOrderFieldSeverity orders Vulnerability by severity.
	VulnerabilityOrderFieldSeverity = &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.Severity, nil
		},
		column: vulnerability.FieldSeverity,
		toTerm: vulnerability.BySeverity,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.Severity,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VulnerabilityOrderField) String() string {
	var str string
	switch f.column {
	case VulnerabilityOrderFieldCreatedAt.column:
		str = "created_at"
	case VulnerabilityOrderFieldUpdatedAt.column:
		str = "updated_at"
	case VulnerabilityOrderFieldExternalOwnerID.column:
		str = "external_owner_id"
	case VulnerabilityOrderFieldExternalID.column:
		str = "external_id"
	case VulnerabilityOrderFieldCveID.column:
		str = "cve_id"
	case VulnerabilityOrderFieldCategory.column:
		str = "category"
	case VulnerabilityOrderFieldSeverity.column:
		str = "severity"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VulnerabilityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VulnerabilityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VulnerabilityOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *VulnerabilityOrderFieldCreatedAt
	case "updated_at":
		*f = *VulnerabilityOrderFieldUpdatedAt
	case "external_owner_id":
		*f = *VulnerabilityOrderFieldExternalOwnerID
	case "external_id":
		*f = *VulnerabilityOrderFieldExternalID
	case "cve_id":
		*f = *VulnerabilityOrderFieldCveID
	case "category":
		*f = *VulnerabilityOrderFieldCategory
	case "severity":
		*f = *VulnerabilityOrderFieldSeverity
	default:
		return fmt.Errorf("%s is not a valid VulnerabilityOrderField", str)
	}
	return nil
}

// VulnerabilityOrderField defines the ordering field of Vulnerability.
type VulnerabilityOrderField struct {
	// Value extracts the ordering value from the given Vulnerability.
	Value    func(*Vulnerability) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) vulnerability.OrderOption
	toCursor func(*Vulnerability) Cursor
}

// VulnerabilityOrder defines the ordering of Vulnerability.
type VulnerabilityOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *VulnerabilityOrderField `json:"field"`
}

// DefaultVulnerabilityOrder is the default ordering of Vulnerability.
var DefaultVulnerabilityOrder = &VulnerabilityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &VulnerabilityOrderField{
		Value: func(_m *Vulnerability) (ent.Value, error) {
			return _m.ID, nil
		},
		column: vulnerability.FieldID,
		toTerm: vulnerability.ByID,
		toCursor: func(_m *Vulnerability) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Vulnerability into VulnerabilityEdge.
func (_m *Vulnerability) ToEdge(order *VulnerabilityOrder) *VulnerabilityEdge {
	if order == nil {
		order = DefaultVulnerabilityOrder
	}
	return &VulnerabilityEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WebauthnEdge is the edge representation of Webauthn.
type WebauthnEdge struct {
	Node   *Webauthn `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// WebauthnConnection is the connection containing edges to Webauthn.
type WebauthnConnection struct {
	Edges      []*WebauthnEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *WebauthnConnection) build(nodes []*Webauthn, pager *webauthnPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *Webauthn
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Webauthn {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Webauthn {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebauthnEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebauthnEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebauthnPaginateOption enables pagination customization.
type WebauthnPaginateOption func(*webauthnPager) error

// WithWebauthnOrder configures pagination ordering.
func WithWebauthnOrder(order *WebauthnOrder) WebauthnPaginateOption {
	if order == nil {
		order = DefaultWebauthnOrder
	}
	o := *order
	return func(pager *webauthnPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebauthnOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebauthnFilter configures pagination filter.
func WithWebauthnFilter(filter func(*WebauthnQuery) (*WebauthnQuery, error)) WebauthnPaginateOption {
	return func(pager *webauthnPager) error {
		if filter == nil {
			return errors.New("WebauthnQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type webauthnPager struct {
	reverse bool
	order   *WebauthnOrder
	filter  func(*WebauthnQuery) (*WebauthnQuery, error)
}

func newWebauthnPager(opts []WebauthnPaginateOption, reverse bool) (*webauthnPager, error) {
	pager := &webauthnPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebauthnOrder
	}
	return pager, nil
}

func (p *webauthnPager) applyFilter(query *WebauthnQuery) (*WebauthnQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *webauthnPager) toCursor(_m *Webauthn) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *webauthnPager) applyCursors(query *WebauthnQuery, after, before *Cursor) (*WebauthnQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWebauthnOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *webauthnPager) applyOrder(query *WebauthnQuery) *WebauthnQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWebauthnOrder.Field {
		query = query.Order(DefaultWebauthnOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *webauthnPager) orderExpr(query *WebauthnQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebauthnOrder.Field {
			b.Comma().Ident(DefaultWebauthnOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Webauthn.
func (_m *WebauthnQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebauthnPaginateOption,
) (*WebauthnConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebauthnPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WebauthnConnection{Edges: []*WebauthnEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebauthnOrderFieldCreatedAt orders Webauthn by created_at.
	WebauthnOrderFieldCreatedAt = &WebauthnOrderField{
		Value: func(_m *Webauthn) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: webauthn.FieldCreatedAt,
		toTerm: webauthn.ByCreatedAt,
		toCursor: func(_m *Webauthn) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WebauthnOrderFieldUpdatedAt orders Webauthn by updated_at.
	WebauthnOrderFieldUpdatedAt = &WebauthnOrderField{
		Value: func(_m *Webauthn) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: webauthn.FieldUpdatedAt,
		toTerm: webauthn.ByUpdatedAt,
		toCursor: func(_m *Webauthn) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebauthnOrderField) String() string {
	var str string
	switch f.column {
	case WebauthnOrderFieldCreatedAt.column:
		str = "created_at"
	case WebauthnOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebauthnOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebauthnOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebauthnOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WebauthnOrderFieldCreatedAt
	case "updated_at":
		*f = *WebauthnOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WebauthnOrderField", str)
	}
	return nil
}

// WebauthnOrderField defines the ordering field of Webauthn.
type WebauthnOrderField struct {
	// Value extracts the ordering value from the given Webauthn.
	Value    func(*Webauthn) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) webauthn.OrderOption
	toCursor func(*Webauthn) Cursor
}

// WebauthnOrder defines the ordering of Webauthn.
type WebauthnOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *WebauthnOrderField `json:"field"`
}

// DefaultWebauthnOrder is the default ordering of Webauthn.
var DefaultWebauthnOrder = &WebauthnOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WebauthnOrderField{
		Value: func(_m *Webauthn) (ent.Value, error) {
			return _m.ID, nil
		},
		column: webauthn.FieldID,
		toTerm: webauthn.ByID,
		toCursor: func(_m *Webauthn) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts Webauthn into WebauthnEdge.
func (_m *Webauthn) ToEdge(order *WebauthnOrder) *WebauthnEdge {
	if order == nil {
		order = DefaultWebauthnOrder
	}
	return &WebauthnEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentEdge is the edge representation of WorkflowAssignment.
type WorkflowAssignmentEdge struct {
	Node   *WorkflowAssignment `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// WorkflowAssignmentConnection is the connection containing edges to WorkflowAssignment.
type WorkflowAssignmentConnection struct {
	Edges      []*WorkflowAssignmentEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *WorkflowAssignmentConnection) build(nodes []*WorkflowAssignment, pager *workflowassignmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignment {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentPaginateOption enables pagination customization.
type WorkflowAssignmentPaginateOption func(*workflowassignmentPager) error

// WithWorkflowAssignmentOrder configures pagination ordering.
func WithWorkflowAssignmentOrder(order []*WorkflowAssignmentOrder) WorkflowAssignmentPaginateOption {
	return func(pager *workflowassignmentPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowAssignmentFilter configures pagination filter.
func WithWorkflowAssignmentFilter(filter func(*WorkflowAssignmentQuery) (*WorkflowAssignmentQuery, error)) WorkflowAssignmentPaginateOption {
	return func(pager *workflowassignmentPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmentPager struct {
	reverse bool
	order   []*WorkflowAssignmentOrder
	filter  func(*WorkflowAssignmentQuery) (*WorkflowAssignmentQuery, error)
}

func newWorkflowAssignmentPager(opts []WorkflowAssignmentPaginateOption, reverse bool) (*workflowassignmentPager, error) {
	pager := &workflowassignmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowassignmentPager) applyFilter(query *WorkflowAssignmentQuery) (*WorkflowAssignmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmentPager) toCursor(_m *WorkflowAssignment) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowassignmentPager) applyCursors(query *WorkflowAssignmentQuery, after, before *Cursor) (*WorkflowAssignmentQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowAssignmentOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowassignmentPager) applyOrder(query *WorkflowAssignmentQuery) *WorkflowAssignmentQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowAssignmentOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowAssignmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowassignmentPager) orderExpr(query *WorkflowAssignmentQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowAssignmentOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignment.
func (_m *WorkflowAssignmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentPaginateOption,
) (*WorkflowAssignmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentConnection{Edges: []*WorkflowAssignmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentOrderFieldCreatedAt orders WorkflowAssignment by created_at.
	WorkflowAssignmentOrderFieldCreatedAt = &WorkflowAssignmentOrderField{
		Value: func(_m *WorkflowAssignment) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignment.FieldCreatedAt,
		toTerm: workflowassignment.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentOrderFieldUpdatedAt orders WorkflowAssignment by updated_at.
	WorkflowAssignmentOrderFieldUpdatedAt = &WorkflowAssignmentOrderField{
		Value: func(_m *WorkflowAssignment) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignment.FieldUpdatedAt,
		toTerm: workflowassignment.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignment) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowAssignmentOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentOrderField", str)
	}
	return nil
}

// WorkflowAssignmentOrderField defines the ordering field of WorkflowAssignment.
type WorkflowAssignmentOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignment.
	Value    func(*WorkflowAssignment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignment.OrderOption
	toCursor func(*WorkflowAssignment) Cursor
}

// WorkflowAssignmentOrder defines the ordering of WorkflowAssignment.
type WorkflowAssignmentOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *WorkflowAssignmentOrderField `json:"field"`
}

// DefaultWorkflowAssignmentOrder is the default ordering of WorkflowAssignment.
var DefaultWorkflowAssignmentOrder = &WorkflowAssignmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentOrderField{
		Value: func(_m *WorkflowAssignment) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignment.FieldID,
		toTerm: workflowassignment.ByID,
		toCursor: func(_m *WorkflowAssignment) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignment into WorkflowAssignmentEdge.
func (_m *WorkflowAssignment) ToEdge(order *WorkflowAssignmentOrder) *WorkflowAssignmentEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentOrder
	}
	return &WorkflowAssignmentEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowAssignmentTargetEdge is the edge representation of WorkflowAssignmentTarget.
type WorkflowAssignmentTargetEdge struct {
	Node   *WorkflowAssignmentTarget `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// WorkflowAssignmentTargetConnection is the connection containing edges to WorkflowAssignmentTarget.
type WorkflowAssignmentTargetConnection struct {
	Edges      []*WorkflowAssignmentTargetEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *WorkflowAssignmentTargetConnection) build(nodes []*WorkflowAssignmentTarget, pager *workflowassignmenttargetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowAssignmentTarget
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowAssignmentTarget {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowAssignmentTarget {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowAssignmentTargetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowAssignmentTargetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowAssignmentTargetPaginateOption enables pagination customization.
type WorkflowAssignmentTargetPaginateOption func(*workflowassignmenttargetPager) error

// WithWorkflowAssignmentTargetOrder configures pagination ordering.
func WithWorkflowAssignmentTargetOrder(order []*WorkflowAssignmentTargetOrder) WorkflowAssignmentTargetPaginateOption {
	return func(pager *workflowassignmenttargetPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowAssignmentTargetFilter configures pagination filter.
func WithWorkflowAssignmentTargetFilter(filter func(*WorkflowAssignmentTargetQuery) (*WorkflowAssignmentTargetQuery, error)) WorkflowAssignmentTargetPaginateOption {
	return func(pager *workflowassignmenttargetPager) error {
		if filter == nil {
			return errors.New("WorkflowAssignmentTargetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowassignmenttargetPager struct {
	reverse bool
	order   []*WorkflowAssignmentTargetOrder
	filter  func(*WorkflowAssignmentTargetQuery) (*WorkflowAssignmentTargetQuery, error)
}

func newWorkflowAssignmentTargetPager(opts []WorkflowAssignmentTargetPaginateOption, reverse bool) (*workflowassignmenttargetPager, error) {
	pager := &workflowassignmenttargetPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowassignmenttargetPager) applyFilter(query *WorkflowAssignmentTargetQuery) (*WorkflowAssignmentTargetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowassignmenttargetPager) toCursor(_m *WorkflowAssignmentTarget) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowassignmenttargetPager) applyCursors(query *WorkflowAssignmentTargetQuery, after, before *Cursor) (*WorkflowAssignmentTargetQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowAssignmentTargetOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowassignmenttargetPager) applyOrder(query *WorkflowAssignmentTargetQuery) *WorkflowAssignmentTargetQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowAssignmentTargetOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowAssignmentTargetOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowassignmenttargetPager) orderExpr(query *WorkflowAssignmentTargetQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowAssignmentTargetOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowAssignmentTarget.
func (_m *WorkflowAssignmentTargetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowAssignmentTargetPaginateOption,
) (*WorkflowAssignmentTargetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowAssignmentTargetPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowAssignmentTargetConnection{Edges: []*WorkflowAssignmentTargetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowAssignmentTargetOrderFieldCreatedAt orders WorkflowAssignmentTarget by created_at.
	WorkflowAssignmentTargetOrderFieldCreatedAt = &WorkflowAssignmentTargetOrderField{
		Value: func(_m *WorkflowAssignmentTarget) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowassignmenttarget.FieldCreatedAt,
		toTerm: workflowassignmenttarget.ByCreatedAt,
		toCursor: func(_m *WorkflowAssignmentTarget) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowAssignmentTargetOrderFieldUpdatedAt orders WorkflowAssignmentTarget by updated_at.
	WorkflowAssignmentTargetOrderFieldUpdatedAt = &WorkflowAssignmentTargetOrderField{
		Value: func(_m *WorkflowAssignmentTarget) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowassignmenttarget.FieldUpdatedAt,
		toTerm: workflowassignmenttarget.ByUpdatedAt,
		toCursor: func(_m *WorkflowAssignmentTarget) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowAssignmentTargetOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowAssignmentTargetOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowAssignmentTargetOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowAssignmentTargetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowAssignmentTargetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowAssignmentTargetOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowAssignmentTargetOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowAssignmentTargetOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowAssignmentTargetOrderField", str)
	}
	return nil
}

// WorkflowAssignmentTargetOrderField defines the ordering field of WorkflowAssignmentTarget.
type WorkflowAssignmentTargetOrderField struct {
	// Value extracts the ordering value from the given WorkflowAssignmentTarget.
	Value    func(*WorkflowAssignmentTarget) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowassignmenttarget.OrderOption
	toCursor func(*WorkflowAssignmentTarget) Cursor
}

// WorkflowAssignmentTargetOrder defines the ordering of WorkflowAssignmentTarget.
type WorkflowAssignmentTargetOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *WorkflowAssignmentTargetOrderField `json:"field"`
}

// DefaultWorkflowAssignmentTargetOrder is the default ordering of WorkflowAssignmentTarget.
var DefaultWorkflowAssignmentTargetOrder = &WorkflowAssignmentTargetOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowAssignmentTargetOrderField{
		Value: func(_m *WorkflowAssignmentTarget) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowassignmenttarget.FieldID,
		toTerm: workflowassignmenttarget.ByID,
		toCursor: func(_m *WorkflowAssignmentTarget) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowAssignmentTarget into WorkflowAssignmentTargetEdge.
func (_m *WorkflowAssignmentTarget) ToEdge(order *WorkflowAssignmentTargetOrder) *WorkflowAssignmentTargetEdge {
	if order == nil {
		order = DefaultWorkflowAssignmentTargetOrder
	}
	return &WorkflowAssignmentTargetEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowDefinitionEdge is the edge representation of WorkflowDefinition.
type WorkflowDefinitionEdge struct {
	Node   *WorkflowDefinition `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// WorkflowDefinitionConnection is the connection containing edges to WorkflowDefinition.
type WorkflowDefinitionConnection struct {
	Edges      []*WorkflowDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *WorkflowDefinitionConnection) build(nodes []*WorkflowDefinition, pager *workflowdefinitionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowDefinition {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowDefinitionPaginateOption enables pagination customization.
type WorkflowDefinitionPaginateOption func(*workflowdefinitionPager) error

// WithWorkflowDefinitionOrder configures pagination ordering.
func WithWorkflowDefinitionOrder(order []*WorkflowDefinitionOrder) WorkflowDefinitionPaginateOption {
	return func(pager *workflowdefinitionPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowDefinitionFilter configures pagination filter.
func WithWorkflowDefinitionFilter(filter func(*WorkflowDefinitionQuery) (*WorkflowDefinitionQuery, error)) WorkflowDefinitionPaginateOption {
	return func(pager *workflowdefinitionPager) error {
		if filter == nil {
			return errors.New("WorkflowDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowdefinitionPager struct {
	reverse bool
	order   []*WorkflowDefinitionOrder
	filter  func(*WorkflowDefinitionQuery) (*WorkflowDefinitionQuery, error)
}

func newWorkflowDefinitionPager(opts []WorkflowDefinitionPaginateOption, reverse bool) (*workflowdefinitionPager, error) {
	pager := &workflowdefinitionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowdefinitionPager) applyFilter(query *WorkflowDefinitionQuery) (*WorkflowDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowdefinitionPager) toCursor(_m *WorkflowDefinition) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowdefinitionPager) applyCursors(query *WorkflowDefinitionQuery, after, before *Cursor) (*WorkflowDefinitionQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowDefinitionOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowdefinitionPager) applyOrder(query *WorkflowDefinitionQuery) *WorkflowDefinitionQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowDefinitionOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowDefinitionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowdefinitionPager) orderExpr(query *WorkflowDefinitionQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowDefinitionOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowDefinition.
func (_m *WorkflowDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowDefinitionPaginateOption,
) (*WorkflowDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowDefinitionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowDefinitionConnection{Edges: []*WorkflowDefinitionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowDefinitionOrderFieldCreatedAt orders WorkflowDefinition by created_at.
	WorkflowDefinitionOrderFieldCreatedAt = &WorkflowDefinitionOrderField{
		Value: func(_m *WorkflowDefinition) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowdefinition.FieldCreatedAt,
		toTerm: workflowdefinition.ByCreatedAt,
		toCursor: func(_m *WorkflowDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowDefinitionOrderFieldUpdatedAt orders WorkflowDefinition by updated_at.
	WorkflowDefinitionOrderFieldUpdatedAt = &WorkflowDefinitionOrderField{
		Value: func(_m *WorkflowDefinition) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowdefinition.FieldUpdatedAt,
		toTerm: workflowdefinition.ByUpdatedAt,
		toCursor: func(_m *WorkflowDefinition) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowDefinitionOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowDefinitionOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowDefinitionOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowDefinitionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowDefinitionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowDefinitionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowDefinitionOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowDefinitionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowDefinitionOrderField", str)
	}
	return nil
}

// WorkflowDefinitionOrderField defines the ordering field of WorkflowDefinition.
type WorkflowDefinitionOrderField struct {
	// Value extracts the ordering value from the given WorkflowDefinition.
	Value    func(*WorkflowDefinition) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowdefinition.OrderOption
	toCursor func(*WorkflowDefinition) Cursor
}

// WorkflowDefinitionOrder defines the ordering of WorkflowDefinition.
type WorkflowDefinitionOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *WorkflowDefinitionOrderField `json:"field"`
}

// DefaultWorkflowDefinitionOrder is the default ordering of WorkflowDefinition.
var DefaultWorkflowDefinitionOrder = &WorkflowDefinitionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowDefinitionOrderField{
		Value: func(_m *WorkflowDefinition) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowdefinition.FieldID,
		toTerm: workflowdefinition.ByID,
		toCursor: func(_m *WorkflowDefinition) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowDefinition into WorkflowDefinitionEdge.
func (_m *WorkflowDefinition) ToEdge(order *WorkflowDefinitionOrder) *WorkflowDefinitionEdge {
	if order == nil {
		order = DefaultWorkflowDefinitionOrder
	}
	return &WorkflowDefinitionEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowEventEdge is the edge representation of WorkflowEvent.
type WorkflowEventEdge struct {
	Node   *WorkflowEvent `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// WorkflowEventConnection is the connection containing edges to WorkflowEvent.
type WorkflowEventConnection struct {
	Edges      []*WorkflowEventEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *WorkflowEventConnection) build(nodes []*WorkflowEvent, pager *workfloweventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowEvent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowEvent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowEvent {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowEventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowEventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowEventPaginateOption enables pagination customization.
type WorkflowEventPaginateOption func(*workfloweventPager) error

// WithWorkflowEventOrder configures pagination ordering.
func WithWorkflowEventOrder(order []*WorkflowEventOrder) WorkflowEventPaginateOption {
	return func(pager *workfloweventPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowEventFilter configures pagination filter.
func WithWorkflowEventFilter(filter func(*WorkflowEventQuery) (*WorkflowEventQuery, error)) WorkflowEventPaginateOption {
	return func(pager *workfloweventPager) error {
		if filter == nil {
			return errors.New("WorkflowEventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workfloweventPager struct {
	reverse bool
	order   []*WorkflowEventOrder
	filter  func(*WorkflowEventQuery) (*WorkflowEventQuery, error)
}

func newWorkflowEventPager(opts []WorkflowEventPaginateOption, reverse bool) (*workfloweventPager, error) {
	pager := &workfloweventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workfloweventPager) applyFilter(query *WorkflowEventQuery) (*WorkflowEventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workfloweventPager) toCursor(_m *WorkflowEvent) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workfloweventPager) applyCursors(query *WorkflowEventQuery, after, before *Cursor) (*WorkflowEventQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowEventOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workfloweventPager) applyOrder(query *WorkflowEventQuery) *WorkflowEventQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowEventOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workfloweventPager) orderExpr(query *WorkflowEventQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowEventOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowEvent.
func (_m *WorkflowEventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowEventPaginateOption,
) (*WorkflowEventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowEventConnection{Edges: []*WorkflowEventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowEventOrderFieldCreatedAt orders WorkflowEvent by created_at.
	WorkflowEventOrderFieldCreatedAt = &WorkflowEventOrderField{
		Value: func(_m *WorkflowEvent) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowevent.FieldCreatedAt,
		toTerm: workflowevent.ByCreatedAt,
		toCursor: func(_m *WorkflowEvent) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowEventOrderFieldUpdatedAt orders WorkflowEvent by updated_at.
	WorkflowEventOrderFieldUpdatedAt = &WorkflowEventOrderField{
		Value: func(_m *WorkflowEvent) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowevent.FieldUpdatedAt,
		toTerm: workflowevent.ByUpdatedAt,
		toCursor: func(_m *WorkflowEvent) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowEventOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowEventOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowEventOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowEventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowEventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowEventOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowEventOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowEventOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowEventOrderField", str)
	}
	return nil
}

// WorkflowEventOrderField defines the ordering field of WorkflowEvent.
type WorkflowEventOrderField struct {
	// Value extracts the ordering value from the given WorkflowEvent.
	Value    func(*WorkflowEvent) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowevent.OrderOption
	toCursor func(*WorkflowEvent) Cursor
}

// WorkflowEventOrder defines the ordering of WorkflowEvent.
type WorkflowEventOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *WorkflowEventOrderField `json:"field"`
}

// DefaultWorkflowEventOrder is the default ordering of WorkflowEvent.
var DefaultWorkflowEventOrder = &WorkflowEventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowEventOrderField{
		Value: func(_m *WorkflowEvent) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowevent.FieldID,
		toTerm: workflowevent.ByID,
		toCursor: func(_m *WorkflowEvent) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowEvent into WorkflowEventEdge.
func (_m *WorkflowEvent) ToEdge(order *WorkflowEventOrder) *WorkflowEventEdge {
	if order == nil {
		order = DefaultWorkflowEventOrder
	}
	return &WorkflowEventEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowInstanceEdge is the edge representation of WorkflowInstance.
type WorkflowInstanceEdge struct {
	Node   *WorkflowInstance `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// WorkflowInstanceConnection is the connection containing edges to WorkflowInstance.
type WorkflowInstanceConnection struct {
	Edges      []*WorkflowInstanceEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *WorkflowInstanceConnection) build(nodes []*WorkflowInstance, pager *workflowinstancePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowInstance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowInstance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowInstance {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowInstanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowInstanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowInstancePaginateOption enables pagination customization.
type WorkflowInstancePaginateOption func(*workflowinstancePager) error

// WithWorkflowInstanceOrder configures pagination ordering.
func WithWorkflowInstanceOrder(order []*WorkflowInstanceOrder) WorkflowInstancePaginateOption {
	return func(pager *workflowinstancePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowInstanceFilter configures pagination filter.
func WithWorkflowInstanceFilter(filter func(*WorkflowInstanceQuery) (*WorkflowInstanceQuery, error)) WorkflowInstancePaginateOption {
	return func(pager *workflowinstancePager) error {
		if filter == nil {
			return errors.New("WorkflowInstanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowinstancePager struct {
	reverse bool
	order   []*WorkflowInstanceOrder
	filter  func(*WorkflowInstanceQuery) (*WorkflowInstanceQuery, error)
}

func newWorkflowInstancePager(opts []WorkflowInstancePaginateOption, reverse bool) (*workflowinstancePager, error) {
	pager := &workflowinstancePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowinstancePager) applyFilter(query *WorkflowInstanceQuery) (*WorkflowInstanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowinstancePager) toCursor(_m *WorkflowInstance) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowinstancePager) applyCursors(query *WorkflowInstanceQuery, after, before *Cursor) (*WorkflowInstanceQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowInstanceOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowinstancePager) applyOrder(query *WorkflowInstanceQuery) *WorkflowInstanceQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowInstanceOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowInstanceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowinstancePager) orderExpr(query *WorkflowInstanceQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowInstanceOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowInstance.
func (_m *WorkflowInstanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowInstancePaginateOption,
) (*WorkflowInstanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowInstancePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowInstanceConnection{Edges: []*WorkflowInstanceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowInstanceOrderFieldCreatedAt orders WorkflowInstance by created_at.
	WorkflowInstanceOrderFieldCreatedAt = &WorkflowInstanceOrderField{
		Value: func(_m *WorkflowInstance) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowinstance.FieldCreatedAt,
		toTerm: workflowinstance.ByCreatedAt,
		toCursor: func(_m *WorkflowInstance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowInstanceOrderFieldUpdatedAt orders WorkflowInstance by updated_at.
	WorkflowInstanceOrderFieldUpdatedAt = &WorkflowInstanceOrderField{
		Value: func(_m *WorkflowInstance) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowinstance.FieldUpdatedAt,
		toTerm: workflowinstance.ByUpdatedAt,
		toCursor: func(_m *WorkflowInstance) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowInstanceOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowInstanceOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowInstanceOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowInstanceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowInstanceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowInstanceOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowInstanceOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowInstanceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowInstanceOrderField", str)
	}
	return nil
}

// WorkflowInstanceOrderField defines the ordering field of WorkflowInstance.
type WorkflowInstanceOrderField struct {
	// Value extracts the ordering value from the given WorkflowInstance.
	Value    func(*WorkflowInstance) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowinstance.OrderOption
	toCursor func(*WorkflowInstance) Cursor
}

// WorkflowInstanceOrder defines the ordering of WorkflowInstance.
type WorkflowInstanceOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *WorkflowInstanceOrderField `json:"field"`
}

// DefaultWorkflowInstanceOrder is the default ordering of WorkflowInstance.
var DefaultWorkflowInstanceOrder = &WorkflowInstanceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowInstanceOrderField{
		Value: func(_m *WorkflowInstance) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowinstance.FieldID,
		toTerm: workflowinstance.ByID,
		toCursor: func(_m *WorkflowInstance) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowInstance into WorkflowInstanceEdge.
func (_m *WorkflowInstance) ToEdge(order *WorkflowInstanceOrder) *WorkflowInstanceEdge {
	if order == nil {
		order = DefaultWorkflowInstanceOrder
	}
	return &WorkflowInstanceEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// WorkflowObjectRefEdge is the edge representation of WorkflowObjectRef.
type WorkflowObjectRefEdge struct {
	Node   *WorkflowObjectRef `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// WorkflowObjectRefConnection is the connection containing edges to WorkflowObjectRef.
type WorkflowObjectRefConnection struct {
	Edges      []*WorkflowObjectRefEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *WorkflowObjectRefConnection) build(nodes []*WorkflowObjectRef, pager *workflowobjectrefPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && len(nodes) >= *first+1 {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:*first]
	} else if last != nil && len(nodes) >= *last+1 {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:*last]
	}
	var nodeAt func(int) *WorkflowObjectRef
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkflowObjectRef {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkflowObjectRef {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkflowObjectRefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkflowObjectRefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkflowObjectRefPaginateOption enables pagination customization.
type WorkflowObjectRefPaginateOption func(*workflowobjectrefPager) error

// WithWorkflowObjectRefOrder configures pagination ordering.
func WithWorkflowObjectRefOrder(order []*WorkflowObjectRefOrder) WorkflowObjectRefPaginateOption {
	return func(pager *workflowobjectrefPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithWorkflowObjectRefFilter configures pagination filter.
func WithWorkflowObjectRefFilter(filter func(*WorkflowObjectRefQuery) (*WorkflowObjectRefQuery, error)) WorkflowObjectRefPaginateOption {
	return func(pager *workflowobjectrefPager) error {
		if filter == nil {
			return errors.New("WorkflowObjectRefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowobjectrefPager struct {
	reverse bool
	order   []*WorkflowObjectRefOrder
	filter  func(*WorkflowObjectRefQuery) (*WorkflowObjectRefQuery, error)
}

func newWorkflowObjectRefPager(opts []WorkflowObjectRefPaginateOption, reverse bool) (*workflowobjectrefPager, error) {
	pager := &workflowobjectrefPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *workflowobjectrefPager) applyFilter(query *WorkflowObjectRefQuery) (*WorkflowObjectRefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowobjectrefPager) toCursor(_m *WorkflowObjectRef) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(_m).Value)
	}
	return Cursor{ID: _m.ID, Value: cs_}
}

func (p *workflowobjectrefPager) applyCursors(query *WorkflowObjectRefQuery, after, before *Cursor) (*WorkflowObjectRefQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultWorkflowObjectRefOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for i, predicate := range predicates {
		query = query.Where(func(s *sql.Selector) {
			predicate(s)
			s.Or().Where(sql.IsNull(fields[i]))
		})
	}
	return query, nil
}

func (p *workflowobjectrefPager) applyOrder(query *WorkflowObjectRefQuery) *WorkflowObjectRefQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultWorkflowObjectRefOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultWorkflowObjectRefOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *workflowobjectrefPager) orderExpr(query *WorkflowObjectRefQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultWorkflowObjectRefOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkflowObjectRef.
func (_m *WorkflowObjectRefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowObjectRefPaginateOption,
) (*WorkflowObjectRefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowObjectRefPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &WorkflowObjectRefConnection{Edges: []*WorkflowObjectRefEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.CountIDs(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WorkflowObjectRefOrderFieldCreatedAt orders WorkflowObjectRef by created_at.
	WorkflowObjectRefOrderFieldCreatedAt = &WorkflowObjectRefOrderField{
		Value: func(_m *WorkflowObjectRef) (ent.Value, error) {
			return _m.CreatedAt, nil
		},
		column: workflowobjectref.FieldCreatedAt,
		toTerm: workflowobjectref.ByCreatedAt,
		toCursor: func(_m *WorkflowObjectRef) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.CreatedAt,
			}
		},
	}
	// WorkflowObjectRefOrderFieldUpdatedAt orders WorkflowObjectRef by updated_at.
	WorkflowObjectRefOrderFieldUpdatedAt = &WorkflowObjectRefOrderField{
		Value: func(_m *WorkflowObjectRef) (ent.Value, error) {
			return _m.UpdatedAt, nil
		},
		column: workflowobjectref.FieldUpdatedAt,
		toTerm: workflowobjectref.ByUpdatedAt,
		toCursor: func(_m *WorkflowObjectRef) Cursor {
			return Cursor{
				ID:    _m.ID,
				Value: _m.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkflowObjectRefOrderField) String() string {
	var str string
	switch f.column {
	case WorkflowObjectRefOrderFieldCreatedAt.column:
		str = "created_at"
	case WorkflowObjectRefOrderFieldUpdatedAt.column:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkflowObjectRefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkflowObjectRefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkflowObjectRefOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *WorkflowObjectRefOrderFieldCreatedAt
	case "updated_at":
		*f = *WorkflowObjectRefOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid WorkflowObjectRefOrderField", str)
	}
	return nil
}

// WorkflowObjectRefOrderField defines the ordering field of WorkflowObjectRef.
type WorkflowObjectRefOrderField struct {
	// Value extracts the ordering value from the given WorkflowObjectRef.
	Value    func(*WorkflowObjectRef) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workflowobjectref.OrderOption
	toCursor func(*WorkflowObjectRef) Cursor
}

// WorkflowObjectRefOrder defines the ordering of WorkflowObjectRef.
type WorkflowObjectRefOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *WorkflowObjectRefOrderField `json:"field"`
}

// DefaultWorkflowObjectRefOrder is the default ordering of WorkflowObjectRef.
var DefaultWorkflowObjectRefOrder = &WorkflowObjectRefOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkflowObjectRefOrderField{
		Value: func(_m *WorkflowObjectRef) (ent.Value, error) {
			return _m.ID, nil
		},
		column: workflowobjectref.FieldID,
		toTerm: workflowobjectref.ByID,
		toCursor: func(_m *WorkflowObjectRef) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts WorkflowObjectRef into WorkflowObjectRefEdge.
func (_m *WorkflowObjectRef) ToEdge(order *WorkflowObjectRefOrder) *WorkflowObjectRefEdge {
	if order == nil {
		order = DefaultWorkflowObjectRefOrder
	}
	return &WorkflowObjectRefEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
