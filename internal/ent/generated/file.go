// Code generated by ent, DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/core/internal/ent/generated/file"
)

// File is the model entity for the File schema.
type File struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedBy holds the value of the "updated_by" field.
	UpdatedBy string `json:"updated_by,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt time.Time `json:"deleted_at,omitempty"`
	// DeletedBy holds the value of the "deleted_by" field.
	DeletedBy string `json:"deleted_by,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned bool `json:"system_owned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internal_notes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"system_internal_id,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"provided_file_name,omitempty"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"provided_file_extension,omitempty"`
	// the computed size of the file in the original http request
	ProvidedFileSize int64 `json:"provided_file_size,omitempty"`
	// PersistedFileSize holds the value of the "persisted_file_size" field.
	PersistedFileSize int64 `json:"persisted_file_size,omitempty"`
	// the mime type detected by the system
	DetectedMimeType string `json:"detected_mime_type,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash string `json:"md5_hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detected_content_type,omitempty"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey string `json:"store_key,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType string `json:"category_type,omitempty"`
	// the full URI of the file
	URI string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme string `json:"storage_scheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume string `json:"storage_volume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath string `json:"storage_path,omitempty"`
	// the contents of the file
	FileContents []byte `json:"file_contents,omitempty"`
	// additional metadata about the file
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// the region the file is stored in, if applicable
	StorageRegion string `json:"storage_region,omitempty"`
	// the storage provider the file is stored in, if applicable
	StorageProvider string `json:"storage_provider,omitempty"`
	// LastAccessedAt holds the value of the "last_accessed_at" field.
	LastAccessedAt *time.Time `json:"last_accessed_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the FileQuery when eager-loading is set.
	Edges               FileEdges `json:"edges"`
	export_files        *string
	finding_files       *string
	integration_files   *string
	note_files          *string
	remediation_files   *string
	review_files        *string
	vulnerability_files *string
	selectValues        sql.SelectValues

	// PresignedURL is the presigned URL for the file when using s3 storage
	PresignedURL string `json:"presignedURL,omitempty"`
	// Base64 is the base64 representation of the file when using database storage
	Base64 string `json:"base64,omitempty"`
}

// FileEdges holds the relations/edges for other nodes in the graph.
type FileEdges struct {
	// Organization holds the value of the organization edge.
	Organization []*Organization `json:"organization,omitempty"`
	// Groups holds the value of the groups edge.
	Groups []*Group `json:"groups,omitempty"`
	// Contact holds the value of the contact edge.
	Contact []*Contact `json:"contact,omitempty"`
	// Entity holds the value of the entity edge.
	Entity []*Entity `json:"entity,omitempty"`
	// OrganizationSetting holds the value of the organization_setting edge.
	OrganizationSetting []*OrganizationSetting `json:"organization_setting,omitempty"`
	// Template holds the value of the template edge.
	Template []*Template `json:"template,omitempty"`
	// Document holds the value of the document edge.
	Document []*DocumentData `json:"document,omitempty"`
	// Program holds the value of the program edge.
	Program []*Program `json:"program,omitempty"`
	// Evidence holds the value of the evidence edge.
	Evidence []*Evidence `json:"evidence,omitempty"`
	// Events holds the value of the events edge.
	Events []*Event `json:"events,omitempty"`
	// TrustCenterSetting holds the value of the trust_center_setting edge.
	TrustCenterSetting []*TrustCenterSetting `json:"trust_center_setting,omitempty"`
	// Integrations holds the value of the integrations edge.
	Integrations []*Integration `json:"integrations,omitempty"`
	// Secrets holds the value of the secrets edge.
	Secrets []*Hush `json:"secrets,omitempty"`
	// TrustcenterEntities holds the value of the trustcenter_entities edge.
	TrustcenterEntities []*TrustcenterEntity `json:"trustcenter_entities,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [14]bool
	// totalCount holds the count of the edges above.
	totalCount [14]map[string]int

	namedOrganization        map[string][]*Organization
	namedGroups              map[string][]*Group
	namedContact             map[string][]*Contact
	namedEntity              map[string][]*Entity
	namedOrganizationSetting map[string][]*OrganizationSetting
	namedTemplate            map[string][]*Template
	namedDocument            map[string][]*DocumentData
	namedProgram             map[string][]*Program
	namedEvidence            map[string][]*Evidence
	namedEvents              map[string][]*Event
	namedTrustCenterSetting  map[string][]*TrustCenterSetting
	namedIntegrations        map[string][]*Integration
	namedSecrets             map[string][]*Hush
	namedTrustcenterEntities map[string][]*TrustcenterEntity
}

// OrganizationOrErr returns the Organization value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) OrganizationOrErr() ([]*Organization, error) {
	if e.loadedTypes[0] {
		return e.Organization, nil
	}
	return nil, &NotLoadedError{edge: "organization"}
}

// GroupsOrErr returns the Groups value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) GroupsOrErr() ([]*Group, error) {
	if e.loadedTypes[1] {
		return e.Groups, nil
	}
	return nil, &NotLoadedError{edge: "groups"}
}

// ContactOrErr returns the Contact value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) ContactOrErr() ([]*Contact, error) {
	if e.loadedTypes[2] {
		return e.Contact, nil
	}
	return nil, &NotLoadedError{edge: "contact"}
}

// EntityOrErr returns the Entity value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) EntityOrErr() ([]*Entity, error) {
	if e.loadedTypes[3] {
		return e.Entity, nil
	}
	return nil, &NotLoadedError{edge: "entity"}
}

// OrganizationSettingOrErr returns the OrganizationSetting value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) OrganizationSettingOrErr() ([]*OrganizationSetting, error) {
	if e.loadedTypes[4] {
		return e.OrganizationSetting, nil
	}
	return nil, &NotLoadedError{edge: "organization_setting"}
}

// TemplateOrErr returns the Template value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) TemplateOrErr() ([]*Template, error) {
	if e.loadedTypes[5] {
		return e.Template, nil
	}
	return nil, &NotLoadedError{edge: "template"}
}

// DocumentOrErr returns the Document value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) DocumentOrErr() ([]*DocumentData, error) {
	if e.loadedTypes[6] {
		return e.Document, nil
	}
	return nil, &NotLoadedError{edge: "document"}
}

// ProgramOrErr returns the Program value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) ProgramOrErr() ([]*Program, error) {
	if e.loadedTypes[7] {
		return e.Program, nil
	}
	return nil, &NotLoadedError{edge: "program"}
}

// EvidenceOrErr returns the Evidence value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) EvidenceOrErr() ([]*Evidence, error) {
	if e.loadedTypes[8] {
		return e.Evidence, nil
	}
	return nil, &NotLoadedError{edge: "evidence"}
}

// EventsOrErr returns the Events value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) EventsOrErr() ([]*Event, error) {
	if e.loadedTypes[9] {
		return e.Events, nil
	}
	return nil, &NotLoadedError{edge: "events"}
}

// TrustCenterSettingOrErr returns the TrustCenterSetting value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) TrustCenterSettingOrErr() ([]*TrustCenterSetting, error) {
	if e.loadedTypes[10] {
		return e.TrustCenterSetting, nil
	}
	return nil, &NotLoadedError{edge: "trust_center_setting"}
}

// IntegrationsOrErr returns the Integrations value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) IntegrationsOrErr() ([]*Integration, error) {
	if e.loadedTypes[11] {
		return e.Integrations, nil
	}
	return nil, &NotLoadedError{edge: "integrations"}
}

// SecretsOrErr returns the Secrets value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) SecretsOrErr() ([]*Hush, error) {
	if e.loadedTypes[12] {
		return e.Secrets, nil
	}
	return nil, &NotLoadedError{edge: "secrets"}
}

// TrustcenterEntitiesOrErr returns the TrustcenterEntities value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) TrustcenterEntitiesOrErr() ([]*TrustcenterEntity, error) {
	if e.loadedTypes[13] {
		return e.TrustcenterEntities, nil
	}
	return nil, &NotLoadedError{edge: "trustcenter_entities"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*File) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case file.FieldTags, file.FieldFileContents, file.FieldMetadata:
			values[i] = new([]byte)
		case file.FieldSystemOwned:
			values[i] = new(sql.NullBool)
		case file.FieldProvidedFileSize, file.FieldPersistedFileSize:
			values[i] = new(sql.NullInt64)
		case file.FieldID, file.FieldCreatedBy, file.FieldUpdatedBy, file.FieldDeletedBy, file.FieldInternalNotes, file.FieldSystemInternalID, file.FieldProvidedFileName, file.FieldProvidedFileExtension, file.FieldDetectedMimeType, file.FieldMd5Hash, file.FieldDetectedContentType, file.FieldStoreKey, file.FieldCategoryType, file.FieldURI, file.FieldStorageScheme, file.FieldStorageVolume, file.FieldStoragePath, file.FieldStorageRegion, file.FieldStorageProvider:
			values[i] = new(sql.NullString)
		case file.FieldCreatedAt, file.FieldUpdatedAt, file.FieldDeletedAt, file.FieldLastAccessedAt:
			values[i] = new(sql.NullTime)
		case file.ForeignKeys[0]: // export_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[1]: // finding_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[2]: // integration_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[3]: // note_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[4]: // remediation_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[5]: // review_files
			values[i] = new(sql.NullString)
		case file.ForeignKeys[6]: // vulnerability_files
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the File fields.
func (_m *File) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case file.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case file.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case file.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case file.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				_m.CreatedBy = value.String
			}
		case file.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				_m.UpdatedBy = value.String
			}
		case file.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = value.Time
			}
		case file.FieldDeletedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[i])
			} else if value.Valid {
				_m.DeletedBy = value.String
			}
		case file.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case file.FieldSystemOwned:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field system_owned", values[i])
			} else if value.Valid {
				_m.SystemOwned = value.Bool
			}
		case file.FieldInternalNotes:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field internal_notes", values[i])
			} else if value.Valid {
				_m.InternalNotes = new(string)
				*_m.InternalNotes = value.String
			}
		case file.FieldSystemInternalID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field system_internal_id", values[i])
			} else if value.Valid {
				_m.SystemInternalID = new(string)
				*_m.SystemInternalID = value.String
			}
		case file.FieldProvidedFileName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field provided_file_name", values[i])
			} else if value.Valid {
				_m.ProvidedFileName = value.String
			}
		case file.FieldProvidedFileExtension:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field provided_file_extension", values[i])
			} else if value.Valid {
				_m.ProvidedFileExtension = value.String
			}
		case file.FieldProvidedFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field provided_file_size", values[i])
			} else if value.Valid {
				_m.ProvidedFileSize = value.Int64
			}
		case file.FieldPersistedFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field persisted_file_size", values[i])
			} else if value.Valid {
				_m.PersistedFileSize = value.Int64
			}
		case file.FieldDetectedMimeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field detected_mime_type", values[i])
			} else if value.Valid {
				_m.DetectedMimeType = value.String
			}
		case file.FieldMd5Hash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field md5_hash", values[i])
			} else if value.Valid {
				_m.Md5Hash = value.String
			}
		case file.FieldDetectedContentType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field detected_content_type", values[i])
			} else if value.Valid {
				_m.DetectedContentType = value.String
			}
		case file.FieldStoreKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field store_key", values[i])
			} else if value.Valid {
				_m.StoreKey = value.String
			}
		case file.FieldCategoryType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field category_type", values[i])
			} else if value.Valid {
				_m.CategoryType = value.String
			}
		case file.FieldURI:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field uri", values[i])
			} else if value.Valid {
				_m.URI = value.String
			}
		case file.FieldStorageScheme:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_scheme", values[i])
			} else if value.Valid {
				_m.StorageScheme = value.String
			}
		case file.FieldStorageVolume:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_volume", values[i])
			} else if value.Valid {
				_m.StorageVolume = value.String
			}
		case file.FieldStoragePath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_path", values[i])
			} else if value.Valid {
				_m.StoragePath = value.String
			}
		case file.FieldFileContents:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field file_contents", values[i])
			} else if value != nil {
				_m.FileContents = *value
			}
		case file.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		case file.FieldStorageRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_region", values[i])
			} else if value.Valid {
				_m.StorageRegion = value.String
			}
		case file.FieldStorageProvider:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_provider", values[i])
			} else if value.Valid {
				_m.StorageProvider = value.String
			}
		case file.FieldLastAccessedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_accessed_at", values[i])
			} else if value.Valid {
				_m.LastAccessedAt = new(time.Time)
				*_m.LastAccessedAt = value.Time
			}
		case file.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field export_files", values[i])
			} else if value.Valid {
				_m.export_files = new(string)
				*_m.export_files = value.String
			}
		case file.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field finding_files", values[i])
			} else if value.Valid {
				_m.finding_files = new(string)
				*_m.finding_files = value.String
			}
		case file.ForeignKeys[2]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field integration_files", values[i])
			} else if value.Valid {
				_m.integration_files = new(string)
				*_m.integration_files = value.String
			}
		case file.ForeignKeys[3]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field note_files", values[i])
			} else if value.Valid {
				_m.note_files = new(string)
				*_m.note_files = value.String
			}
		case file.ForeignKeys[4]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remediation_files", values[i])
			} else if value.Valid {
				_m.remediation_files = new(string)
				*_m.remediation_files = value.String
			}
		case file.ForeignKeys[5]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field review_files", values[i])
			} else if value.Valid {
				_m.review_files = new(string)
				*_m.review_files = value.String
			}
		case file.ForeignKeys[6]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field vulnerability_files", values[i])
			} else if value.Valid {
				_m.vulnerability_files = new(string)
				*_m.vulnerability_files = value.String
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the File.
// This includes values selected through modifiers, order, etc.
func (_m *File) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryOrganization queries the "organization" edge of the File entity.
func (_m *File) QueryOrganization() *OrganizationQuery {
	return NewFileClient(_m.config).QueryOrganization(_m)
}

// QueryGroups queries the "groups" edge of the File entity.
func (_m *File) QueryGroups() *GroupQuery {
	return NewFileClient(_m.config).QueryGroups(_m)
}

// QueryContact queries the "contact" edge of the File entity.
func (_m *File) QueryContact() *ContactQuery {
	return NewFileClient(_m.config).QueryContact(_m)
}

// QueryEntity queries the "entity" edge of the File entity.
func (_m *File) QueryEntity() *EntityQuery {
	return NewFileClient(_m.config).QueryEntity(_m)
}

// QueryOrganizationSetting queries the "organization_setting" edge of the File entity.
func (_m *File) QueryOrganizationSetting() *OrganizationSettingQuery {
	return NewFileClient(_m.config).QueryOrganizationSetting(_m)
}

// QueryTemplate queries the "template" edge of the File entity.
func (_m *File) QueryTemplate() *TemplateQuery {
	return NewFileClient(_m.config).QueryTemplate(_m)
}

// QueryDocument queries the "document" edge of the File entity.
func (_m *File) QueryDocument() *DocumentDataQuery {
	return NewFileClient(_m.config).QueryDocument(_m)
}

// QueryProgram queries the "program" edge of the File entity.
func (_m *File) QueryProgram() *ProgramQuery {
	return NewFileClient(_m.config).QueryProgram(_m)
}

// QueryEvidence queries the "evidence" edge of the File entity.
func (_m *File) QueryEvidence() *EvidenceQuery {
	return NewFileClient(_m.config).QueryEvidence(_m)
}

// QueryEvents queries the "events" edge of the File entity.
func (_m *File) QueryEvents() *EventQuery {
	return NewFileClient(_m.config).QueryEvents(_m)
}

// QueryTrustCenterSetting queries the "trust_center_setting" edge of the File entity.
func (_m *File) QueryTrustCenterSetting() *TrustCenterSettingQuery {
	return NewFileClient(_m.config).QueryTrustCenterSetting(_m)
}

// QueryIntegrations queries the "integrations" edge of the File entity.
func (_m *File) QueryIntegrations() *IntegrationQuery {
	return NewFileClient(_m.config).QueryIntegrations(_m)
}

// QuerySecrets queries the "secrets" edge of the File entity.
func (_m *File) QuerySecrets() *HushQuery {
	return NewFileClient(_m.config).QuerySecrets(_m)
}

// QueryTrustcenterEntities queries the "trustcenter_entities" edge of the File entity.
func (_m *File) QueryTrustcenterEntities() *TrustcenterEntityQuery {
	return NewFileClient(_m.config).QueryTrustcenterEntities(_m)
}

// Update returns a builder for updating this File.
// Note that you need to call File.Unwrap() before calling this method if this File
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *File) Update() *FileUpdateOne {
	return NewFileClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the File entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *File) Unwrap() *File {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("generated: File is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *File) String() string {
	var builder strings.Builder
	builder.WriteString("File(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(_m.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(_m.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(_m.DeletedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_by=")
	builder.WriteString(_m.DeletedBy)
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", _m.Tags))
	builder.WriteString(", ")
	builder.WriteString("system_owned=")
	builder.WriteString(fmt.Sprintf("%v", _m.SystemOwned))
	builder.WriteString(", ")
	if v := _m.InternalNotes; v != nil {
		builder.WriteString("internal_notes=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.SystemInternalID; v != nil {
		builder.WriteString("system_internal_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("provided_file_name=")
	builder.WriteString(_m.ProvidedFileName)
	builder.WriteString(", ")
	builder.WriteString("provided_file_extension=")
	builder.WriteString(_m.ProvidedFileExtension)
	builder.WriteString(", ")
	builder.WriteString("provided_file_size=")
	builder.WriteString(fmt.Sprintf("%v", _m.ProvidedFileSize))
	builder.WriteString(", ")
	builder.WriteString("persisted_file_size=")
	builder.WriteString(fmt.Sprintf("%v", _m.PersistedFileSize))
	builder.WriteString(", ")
	builder.WriteString("detected_mime_type=")
	builder.WriteString(_m.DetectedMimeType)
	builder.WriteString(", ")
	builder.WriteString("md5_hash=")
	builder.WriteString(_m.Md5Hash)
	builder.WriteString(", ")
	builder.WriteString("detected_content_type=")
	builder.WriteString(_m.DetectedContentType)
	builder.WriteString(", ")
	builder.WriteString("store_key=")
	builder.WriteString(_m.StoreKey)
	builder.WriteString(", ")
	builder.WriteString("category_type=")
	builder.WriteString(_m.CategoryType)
	builder.WriteString(", ")
	builder.WriteString("uri=")
	builder.WriteString(_m.URI)
	builder.WriteString(", ")
	builder.WriteString("storage_scheme=")
	builder.WriteString(_m.StorageScheme)
	builder.WriteString(", ")
	builder.WriteString("storage_volume=")
	builder.WriteString(_m.StorageVolume)
	builder.WriteString(", ")
	builder.WriteString("storage_path=")
	builder.WriteString(_m.StoragePath)
	builder.WriteString(", ")
	builder.WriteString("file_contents=")
	builder.WriteString(fmt.Sprintf("%v", _m.FileContents))
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", _m.Metadata))
	builder.WriteString(", ")
	builder.WriteString("storage_region=")
	builder.WriteString(_m.StorageRegion)
	builder.WriteString(", ")
	builder.WriteString("storage_provider=")
	builder.WriteString(_m.StorageProvider)
	builder.WriteString(", ")
	if v := _m.LastAccessedAt; v != nil {
		builder.WriteString("last_accessed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// NamedOrganization returns the Organization named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedOrganization(name string) ([]*Organization, error) {
	if _m.Edges.namedOrganization == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedOrganization[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedOrganization(name string, edges ...*Organization) {
	if _m.Edges.namedOrganization == nil {
		_m.Edges.namedOrganization = make(map[string][]*Organization)
	}
	if len(edges) == 0 {
		_m.Edges.namedOrganization[name] = []*Organization{}
	} else {
		_m.Edges.namedOrganization[name] = append(_m.Edges.namedOrganization[name], edges...)
	}
}

// NamedGroups returns the Groups named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedGroups(name string) ([]*Group, error) {
	if _m.Edges.namedGroups == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedGroups[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedGroups(name string, edges ...*Group) {
	if _m.Edges.namedGroups == nil {
		_m.Edges.namedGroups = make(map[string][]*Group)
	}
	if len(edges) == 0 {
		_m.Edges.namedGroups[name] = []*Group{}
	} else {
		_m.Edges.namedGroups[name] = append(_m.Edges.namedGroups[name], edges...)
	}
}

// NamedContact returns the Contact named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedContact(name string) ([]*Contact, error) {
	if _m.Edges.namedContact == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedContact[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedContact(name string, edges ...*Contact) {
	if _m.Edges.namedContact == nil {
		_m.Edges.namedContact = make(map[string][]*Contact)
	}
	if len(edges) == 0 {
		_m.Edges.namedContact[name] = []*Contact{}
	} else {
		_m.Edges.namedContact[name] = append(_m.Edges.namedContact[name], edges...)
	}
}

// NamedEntity returns the Entity named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedEntity(name string) ([]*Entity, error) {
	if _m.Edges.namedEntity == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedEntity[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedEntity(name string, edges ...*Entity) {
	if _m.Edges.namedEntity == nil {
		_m.Edges.namedEntity = make(map[string][]*Entity)
	}
	if len(edges) == 0 {
		_m.Edges.namedEntity[name] = []*Entity{}
	} else {
		_m.Edges.namedEntity[name] = append(_m.Edges.namedEntity[name], edges...)
	}
}

// NamedOrganizationSetting returns the OrganizationSetting named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedOrganizationSetting(name string) ([]*OrganizationSetting, error) {
	if _m.Edges.namedOrganizationSetting == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedOrganizationSetting[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedOrganizationSetting(name string, edges ...*OrganizationSetting) {
	if _m.Edges.namedOrganizationSetting == nil {
		_m.Edges.namedOrganizationSetting = make(map[string][]*OrganizationSetting)
	}
	if len(edges) == 0 {
		_m.Edges.namedOrganizationSetting[name] = []*OrganizationSetting{}
	} else {
		_m.Edges.namedOrganizationSetting[name] = append(_m.Edges.namedOrganizationSetting[name], edges...)
	}
}

// NamedTemplate returns the Template named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedTemplate(name string) ([]*Template, error) {
	if _m.Edges.namedTemplate == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedTemplate[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedTemplate(name string, edges ...*Template) {
	if _m.Edges.namedTemplate == nil {
		_m.Edges.namedTemplate = make(map[string][]*Template)
	}
	if len(edges) == 0 {
		_m.Edges.namedTemplate[name] = []*Template{}
	} else {
		_m.Edges.namedTemplate[name] = append(_m.Edges.namedTemplate[name], edges...)
	}
}

// NamedDocument returns the Document named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedDocument(name string) ([]*DocumentData, error) {
	if _m.Edges.namedDocument == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedDocument[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedDocument(name string, edges ...*DocumentData) {
	if _m.Edges.namedDocument == nil {
		_m.Edges.namedDocument = make(map[string][]*DocumentData)
	}
	if len(edges) == 0 {
		_m.Edges.namedDocument[name] = []*DocumentData{}
	} else {
		_m.Edges.namedDocument[name] = append(_m.Edges.namedDocument[name], edges...)
	}
}

// NamedProgram returns the Program named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedProgram(name string) ([]*Program, error) {
	if _m.Edges.namedProgram == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedProgram[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedProgram(name string, edges ...*Program) {
	if _m.Edges.namedProgram == nil {
		_m.Edges.namedProgram = make(map[string][]*Program)
	}
	if len(edges) == 0 {
		_m.Edges.namedProgram[name] = []*Program{}
	} else {
		_m.Edges.namedProgram[name] = append(_m.Edges.namedProgram[name], edges...)
	}
}

// NamedEvidence returns the Evidence named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedEvidence(name string) ([]*Evidence, error) {
	if _m.Edges.namedEvidence == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedEvidence[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedEvidence(name string, edges ...*Evidence) {
	if _m.Edges.namedEvidence == nil {
		_m.Edges.namedEvidence = make(map[string][]*Evidence)
	}
	if len(edges) == 0 {
		_m.Edges.namedEvidence[name] = []*Evidence{}
	} else {
		_m.Edges.namedEvidence[name] = append(_m.Edges.namedEvidence[name], edges...)
	}
}

// NamedEvents returns the Events named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedEvents(name string) ([]*Event, error) {
	if _m.Edges.namedEvents == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedEvents[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedEvents(name string, edges ...*Event) {
	if _m.Edges.namedEvents == nil {
		_m.Edges.namedEvents = make(map[string][]*Event)
	}
	if len(edges) == 0 {
		_m.Edges.namedEvents[name] = []*Event{}
	} else {
		_m.Edges.namedEvents[name] = append(_m.Edges.namedEvents[name], edges...)
	}
}

// NamedTrustCenterSetting returns the TrustCenterSetting named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedTrustCenterSetting(name string) ([]*TrustCenterSetting, error) {
	if _m.Edges.namedTrustCenterSetting == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedTrustCenterSetting[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedTrustCenterSetting(name string, edges ...*TrustCenterSetting) {
	if _m.Edges.namedTrustCenterSetting == nil {
		_m.Edges.namedTrustCenterSetting = make(map[string][]*TrustCenterSetting)
	}
	if len(edges) == 0 {
		_m.Edges.namedTrustCenterSetting[name] = []*TrustCenterSetting{}
	} else {
		_m.Edges.namedTrustCenterSetting[name] = append(_m.Edges.namedTrustCenterSetting[name], edges...)
	}
}

// NamedIntegrations returns the Integrations named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedIntegrations(name string) ([]*Integration, error) {
	if _m.Edges.namedIntegrations == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedIntegrations[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedIntegrations(name string, edges ...*Integration) {
	if _m.Edges.namedIntegrations == nil {
		_m.Edges.namedIntegrations = make(map[string][]*Integration)
	}
	if len(edges) == 0 {
		_m.Edges.namedIntegrations[name] = []*Integration{}
	} else {
		_m.Edges.namedIntegrations[name] = append(_m.Edges.namedIntegrations[name], edges...)
	}
}

// NamedSecrets returns the Secrets named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedSecrets(name string) ([]*Hush, error) {
	if _m.Edges.namedSecrets == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedSecrets[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedSecrets(name string, edges ...*Hush) {
	if _m.Edges.namedSecrets == nil {
		_m.Edges.namedSecrets = make(map[string][]*Hush)
	}
	if len(edges) == 0 {
		_m.Edges.namedSecrets[name] = []*Hush{}
	} else {
		_m.Edges.namedSecrets[name] = append(_m.Edges.namedSecrets[name], edges...)
	}
}

// NamedTrustcenterEntities returns the TrustcenterEntities named value or an error if the edge was not
// loaded in eager-loading with this name.
func (_m *File) NamedTrustcenterEntities(name string) ([]*TrustcenterEntity, error) {
	if _m.Edges.namedTrustcenterEntities == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := _m.Edges.namedTrustcenterEntities[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (_m *File) appendNamedTrustcenterEntities(name string, edges ...*TrustcenterEntity) {
	if _m.Edges.namedTrustcenterEntities == nil {
		_m.Edges.namedTrustcenterEntities = make(map[string][]*TrustcenterEntity)
	}
	if len(edges) == 0 {
		_m.Edges.namedTrustcenterEntities[name] = []*TrustcenterEntity{}
	} else {
		_m.Edges.namedTrustcenterEntities[name] = append(_m.Edges.namedTrustcenterEntities[name], edges...)
	}
}

// Files is a parsable slice of File.
type Files []*File
