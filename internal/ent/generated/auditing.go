// Code generated by entx.history, DO NOT EDIT.
// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strings"
	"time"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/rs/zerolog/log"
	"github.com/theopenlane/entx/history"

	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/assethistory"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/jobtemplatehistory"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/scanhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliancehistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdochistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfighistory"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
)

type Change struct {
	FieldName string
	Old       any
	New       any
}

// MarshalGQL implement the Marshaler interface for gqlgen
func (c Change) MarshalGQL(w io.Writer) {
	marshalGQLJSON(w, c)
}

// UnmarshalGQL implement the Unmarshaler interface for gqlgen
func (c *Change) UnmarshalGQL(v interface{}) error {
	return unmarshalGQLJSON(v, c)
}

// MarshalGQL implement the Marshaler interface for gqlgen
func (c AuditLogOrderField) MarshalGQL(w io.Writer) {
	marshalGQLJSON(w, c)
}

// UnmarshalGQL implement the Unmarshaler interface for gqlgen
func (c *AuditLogOrderField) UnmarshalGQL(v interface{}) error {
	return unmarshalGQLJSON(v, c)
}

// marshalGQLJSON marshals the given type into JSON and writes it to the given writer
func marshalGQLJSON[T any](w io.Writer, a T) {
	byteData, err := json.Marshal(a)
	if err != nil {
		log.Fatal().Err(err).Msg("error marshalling json object")
	}

	_, err = w.Write(byteData)
	if err != nil {
		log.Fatal().Err(err).Msg("error writing json object")
	}
}

// unmarshalGQLJSON unmarshals a JSON object into the given type
func unmarshalGQLJSON[T any](v any, a T) error {
	byteData, err := json.Marshal(v)
	if err != nil {
		return err
	}

	err = json.Unmarshal(byteData, &a)
	if err != nil {
		return err
	}

	return nil
}

func NewChange(fieldName string, old, new any) Change {
	return Change{
		FieldName: fieldName,
		Old:       old,
		New:       new,
	}
}

type HistoryDiff[T any] struct {
	Old     *T
	New     *T
	Changes []Change
}

// AuditLog is the representation of an audit log entry.
type AuditLog struct {
	// Table is the name of the table that this audit log entry is for.
	Table string `json:"table"`
	// Ref is the reference ID of the object that this audit log entry is for.
	RefID string `json:"id"`
	// HistoryTime is the time when the history entry was created.
	HistoryTime time.Time `json:"time"`
	// Operation is the type of operation that was performed on the object.
	Operation history.OpType `json:"operation"`
	// Changes is a JSON-encoded string containing the changes made to the object.
	Changes []Change `json:"changes"`
	// UpdatedBy is the user who performed the operation.
	UpdatedBy string `json:"updatedBy"`
}

var auditlogImplementors = []string{"AuditLog", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*AuditLog) IsNode() {}

// AuditLogEdge is the edge representation of AuditLog.
type AuditLogEdge struct {
	Node   *AuditLog `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuditLogConnection is the connection containing edges to AuditLog.
type AuditLogConnection struct {
	Edges      []*AuditLogEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// AuditLogWhereInput is the input type for filtering AuditLog entries
// Table is always required for now due to pagination on a single table
// TODO: (sfunk) use joins to allow for pagination across multiple tables
type AuditLogWhereInput struct {
	RefID     *string         `json:"refID,omitempty"`
	UpdatedBy *string         `json:"updatedBy,omitempty"`
	Operation *history.OpType `json:"operation,omitempty"`
	Table     string          `json:"table"`
	Before    *time.Time      `json:"before,omitempty"`
	After     *time.Time      `json:"after,omitempty"`
}

// AuditLogOrderField defines the ordering field of AuditLog.
type AuditLogOrderField struct {
	// Value extracts the ordering value from the given AuditLog.
	Value    func(*AuditLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) OrderOption
	toCursor func(*AuditLog) Cursor
}

// OrderOption defines the ordering options for the AuditLog queries.
type OrderOption func(*sql.Selector)

// AuditLogOrder defines the ordering of AuditLog.
type AuditLogOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuditLogOrderField `json:"field"`
}

// ByHistoryTime orders the results by the history_time field.
func ByHistoryTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(AuditLogFieldHistoryTime, opts...).ToFunc()
}

const (
	AuditLogFieldHistoryTime = "history_time"
)

var (
	// AuditLogOrderFieldCreatedAt orders AuditLog by history_time.
	AuditLogOrderFieldHistoryTime = &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.HistoryTime, nil
		},
		column: AuditLogFieldHistoryTime,
		toTerm: ByHistoryTime,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{
				ID:    al.RefID,
				Value: al.HistoryTime,
			}
		},
	}
)

var (
	ErrMismatchedRef    = errors.New("cannot take diff of histories with different Refs")
	ErrIdenticalHistory = errors.New("cannot take diff of identical history")
)

func (_m *ActionPlanHistory) changes(new *ActionPlanHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(actionplanhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(actionplanhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(actionplanhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(actionplanhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(actionplanhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(actionplanhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Revision, new.Revision) {
		changes = append(changes, NewChange(actionplanhistory.FieldRevision, _m.Revision, new.Revision))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(actionplanhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(actionplanhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.ActionPlanType, new.ActionPlanType) {
		changes = append(changes, NewChange(actionplanhistory.FieldActionPlanType, _m.ActionPlanType, new.ActionPlanType))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(actionplanhistory.FieldDetails, _m.Details, new.Details))
	}
	if !reflect.DeepEqual(_m.ApprovalRequired, new.ApprovalRequired) {
		changes = append(changes, NewChange(actionplanhistory.FieldApprovalRequired, _m.ApprovalRequired, new.ApprovalRequired))
	}
	if !reflect.DeepEqual(_m.ReviewDue, new.ReviewDue) {
		changes = append(changes, NewChange(actionplanhistory.FieldReviewDue, _m.ReviewDue, new.ReviewDue))
	}
	if !reflect.DeepEqual(_m.ReviewFrequency, new.ReviewFrequency) {
		changes = append(changes, NewChange(actionplanhistory.FieldReviewFrequency, _m.ReviewFrequency, new.ReviewFrequency))
	}
	if !reflect.DeepEqual(_m.ApproverID, new.ApproverID) {
		changes = append(changes, NewChange(actionplanhistory.FieldApproverID, _m.ApproverID, new.ApproverID))
	}
	if !reflect.DeepEqual(_m.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(actionplanhistory.FieldDelegateID, _m.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(_m.Summary, new.Summary) {
		changes = append(changes, NewChange(actionplanhistory.FieldSummary, _m.Summary, new.Summary))
	}
	if !reflect.DeepEqual(_m.TagSuggestions, new.TagSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldTagSuggestions, _m.TagSuggestions, new.TagSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedTagSuggestions, new.DismissedTagSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldDismissedTagSuggestions, _m.DismissedTagSuggestions, new.DismissedTagSuggestions))
	}
	if !reflect.DeepEqual(_m.ControlSuggestions, new.ControlSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldControlSuggestions, _m.ControlSuggestions, new.ControlSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedControlSuggestions, new.DismissedControlSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldDismissedControlSuggestions, _m.DismissedControlSuggestions, new.DismissedControlSuggestions))
	}
	if !reflect.DeepEqual(_m.ImprovementSuggestions, new.ImprovementSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldImprovementSuggestions, _m.ImprovementSuggestions, new.ImprovementSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldDismissedImprovementSuggestions, _m.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(actionplanhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(actionplanhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(actionplanhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(actionplanhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.DueDate, new.DueDate) {
		changes = append(changes, NewChange(actionplanhistory.FieldDueDate, _m.DueDate, new.DueDate))
	}
	if !reflect.DeepEqual(_m.Priority, new.Priority) {
		changes = append(changes, NewChange(actionplanhistory.FieldPriority, _m.Priority, new.Priority))
	}
	if !reflect.DeepEqual(_m.Source, new.Source) {
		changes = append(changes, NewChange(actionplanhistory.FieldSource, _m.Source, new.Source))
	}
	return changes
}

func (_m *ActionPlanHistory) Diff(history *ActionPlanHistory) (*HistoryDiff[ActionPlanHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ActionPlanHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ActionPlanHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *AssetHistory) changes(new *AssetHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(assethistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(assethistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(assethistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(assethistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(assethistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(assethistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(assethistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(assethistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(assethistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(assethistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.AssetType, new.AssetType) {
		changes = append(changes, NewChange(assethistory.FieldAssetType, _m.AssetType, new.AssetType))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(assethistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(assethistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Identifier, new.Identifier) {
		changes = append(changes, NewChange(assethistory.FieldIdentifier, _m.Identifier, new.Identifier))
	}
	if !reflect.DeepEqual(_m.Website, new.Website) {
		changes = append(changes, NewChange(assethistory.FieldWebsite, _m.Website, new.Website))
	}
	if !reflect.DeepEqual(_m.Cpe, new.Cpe) {
		changes = append(changes, NewChange(assethistory.FieldCpe, _m.Cpe, new.Cpe))
	}
	if !reflect.DeepEqual(_m.Categories, new.Categories) {
		changes = append(changes, NewChange(assethistory.FieldCategories, _m.Categories, new.Categories))
	}
	return changes
}

func (_m *AssetHistory) Diff(history *AssetHistory) (*HistoryDiff[AssetHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[AssetHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[AssetHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ContactHistory) changes(new *ContactHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(contacthistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(contacthistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(contacthistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(contacthistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(contacthistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(contacthistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(contacthistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.FullName, new.FullName) {
		changes = append(changes, NewChange(contacthistory.FieldFullName, _m.FullName, new.FullName))
	}
	if !reflect.DeepEqual(_m.Title, new.Title) {
		changes = append(changes, NewChange(contacthistory.FieldTitle, _m.Title, new.Title))
	}
	if !reflect.DeepEqual(_m.Company, new.Company) {
		changes = append(changes, NewChange(contacthistory.FieldCompany, _m.Company, new.Company))
	}
	if !reflect.DeepEqual(_m.Email, new.Email) {
		changes = append(changes, NewChange(contacthistory.FieldEmail, _m.Email, new.Email))
	}
	if !reflect.DeepEqual(_m.PhoneNumber, new.PhoneNumber) {
		changes = append(changes, NewChange(contacthistory.FieldPhoneNumber, _m.PhoneNumber, new.PhoneNumber))
	}
	if !reflect.DeepEqual(_m.Address, new.Address) {
		changes = append(changes, NewChange(contacthistory.FieldAddress, _m.Address, new.Address))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(contacthistory.FieldStatus, _m.Status, new.Status))
	}
	return changes
}

func (_m *ContactHistory) Diff(history *ContactHistory) (*HistoryDiff[ContactHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ContactHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ContactHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ControlHistory) changes(new *ControlHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(controlhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(controlhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(controlhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.ReferenceID, new.ReferenceID) {
		changes = append(changes, NewChange(controlhistory.FieldReferenceID, _m.ReferenceID, new.ReferenceID))
	}
	if !reflect.DeepEqual(_m.AuditorReferenceID, new.AuditorReferenceID) {
		changes = append(changes, NewChange(controlhistory.FieldAuditorReferenceID, _m.AuditorReferenceID, new.AuditorReferenceID))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(controlhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.Source, new.Source) {
		changes = append(changes, NewChange(controlhistory.FieldSource, _m.Source, new.Source))
	}
	if !reflect.DeepEqual(_m.ReferenceFramework, new.ReferenceFramework) {
		changes = append(changes, NewChange(controlhistory.FieldReferenceFramework, _m.ReferenceFramework, new.ReferenceFramework))
	}
	if !reflect.DeepEqual(_m.ControlType, new.ControlType) {
		changes = append(changes, NewChange(controlhistory.FieldControlType, _m.ControlType, new.ControlType))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(controlhistory.FieldCategory, _m.Category, new.Category))
	}
	if !reflect.DeepEqual(_m.CategoryID, new.CategoryID) {
		changes = append(changes, NewChange(controlhistory.FieldCategoryID, _m.CategoryID, new.CategoryID))
	}
	if !reflect.DeepEqual(_m.Subcategory, new.Subcategory) {
		changes = append(changes, NewChange(controlhistory.FieldSubcategory, _m.Subcategory, new.Subcategory))
	}
	if !reflect.DeepEqual(_m.MappedCategories, new.MappedCategories) {
		changes = append(changes, NewChange(controlhistory.FieldMappedCategories, _m.MappedCategories, new.MappedCategories))
	}
	if !reflect.DeepEqual(_m.AssessmentObjectives, new.AssessmentObjectives) {
		changes = append(changes, NewChange(controlhistory.FieldAssessmentObjectives, _m.AssessmentObjectives, new.AssessmentObjectives))
	}
	if !reflect.DeepEqual(_m.AssessmentMethods, new.AssessmentMethods) {
		changes = append(changes, NewChange(controlhistory.FieldAssessmentMethods, _m.AssessmentMethods, new.AssessmentMethods))
	}
	if !reflect.DeepEqual(_m.ControlQuestions, new.ControlQuestions) {
		changes = append(changes, NewChange(controlhistory.FieldControlQuestions, _m.ControlQuestions, new.ControlQuestions))
	}
	if !reflect.DeepEqual(_m.ImplementationGuidance, new.ImplementationGuidance) {
		changes = append(changes, NewChange(controlhistory.FieldImplementationGuidance, _m.ImplementationGuidance, new.ImplementationGuidance))
	}
	if !reflect.DeepEqual(_m.ExampleEvidence, new.ExampleEvidence) {
		changes = append(changes, NewChange(controlhistory.FieldExampleEvidence, _m.ExampleEvidence, new.ExampleEvidence))
	}
	if !reflect.DeepEqual(_m.References, new.References) {
		changes = append(changes, NewChange(controlhistory.FieldReferences, _m.References, new.References))
	}
	if !reflect.DeepEqual(_m.ControlOwnerID, new.ControlOwnerID) {
		changes = append(changes, NewChange(controlhistory.FieldControlOwnerID, _m.ControlOwnerID, new.ControlOwnerID))
	}
	if !reflect.DeepEqual(_m.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(controlhistory.FieldDelegateID, _m.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(controlhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(controlhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(controlhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.RefCode, new.RefCode) {
		changes = append(changes, NewChange(controlhistory.FieldRefCode, _m.RefCode, new.RefCode))
	}
	if !reflect.DeepEqual(_m.StandardID, new.StandardID) {
		changes = append(changes, NewChange(controlhistory.FieldStandardID, _m.StandardID, new.StandardID))
	}
	return changes
}

func (_m *ControlHistory) Diff(history *ControlHistory) (*HistoryDiff[ControlHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ControlHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ControlImplementationHistory) changes(new *ControlImplementationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.ImplementationDate, new.ImplementationDate) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldImplementationDate, _m.ImplementationDate, new.ImplementationDate))
	}
	if !reflect.DeepEqual(_m.Verified, new.Verified) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldVerified, _m.Verified, new.Verified))
	}
	if !reflect.DeepEqual(_m.VerificationDate, new.VerificationDate) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldVerificationDate, _m.VerificationDate, new.VerificationDate))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldDetails, _m.Details, new.Details))
	}
	return changes
}

func (_m *ControlImplementationHistory) Diff(history *ControlImplementationHistory) (*HistoryDiff[ControlImplementationHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ControlImplementationHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlImplementationHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ControlObjectiveHistory) changes(new *ControlObjectiveHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Revision, new.Revision) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldRevision, _m.Revision, new.Revision))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.DesiredOutcome, new.DesiredOutcome) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDesiredOutcome, _m.DesiredOutcome, new.DesiredOutcome))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.Source, new.Source) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldSource, _m.Source, new.Source))
	}
	if !reflect.DeepEqual(_m.ControlObjectiveType, new.ControlObjectiveType) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldControlObjectiveType, _m.ControlObjectiveType, new.ControlObjectiveType))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldCategory, _m.Category, new.Category))
	}
	if !reflect.DeepEqual(_m.Subcategory, new.Subcategory) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldSubcategory, _m.Subcategory, new.Subcategory))
	}
	return changes
}

func (_m *ControlObjectiveHistory) Diff(history *ControlObjectiveHistory) (*HistoryDiff[ControlObjectiveHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ControlObjectiveHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlObjectiveHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *CustomDomainHistory) changes(new *CustomDomainHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(customdomainhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(customdomainhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(customdomainhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(customdomainhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(customdomainhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(customdomainhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(customdomainhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(customdomainhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(customdomainhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(customdomainhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.CnameRecord, new.CnameRecord) {
		changes = append(changes, NewChange(customdomainhistory.FieldCnameRecord, _m.CnameRecord, new.CnameRecord))
	}
	if !reflect.DeepEqual(_m.MappableDomainID, new.MappableDomainID) {
		changes = append(changes, NewChange(customdomainhistory.FieldMappableDomainID, _m.MappableDomainID, new.MappableDomainID))
	}
	if !reflect.DeepEqual(_m.DNSVerificationID, new.DNSVerificationID) {
		changes = append(changes, NewChange(customdomainhistory.FieldDNSVerificationID, _m.DNSVerificationID, new.DNSVerificationID))
	}
	return changes
}

func (_m *CustomDomainHistory) Diff(history *CustomDomainHistory) (*HistoryDiff[CustomDomainHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[CustomDomainHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[CustomDomainHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *DNSVerificationHistory) changes(new *DNSVerificationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.CloudflareHostnameID, new.CloudflareHostnameID) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldCloudflareHostnameID, _m.CloudflareHostnameID, new.CloudflareHostnameID))
	}
	if !reflect.DeepEqual(_m.DNSTxtRecord, new.DNSTxtRecord) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSTxtRecord, _m.DNSTxtRecord, new.DNSTxtRecord))
	}
	if !reflect.DeepEqual(_m.DNSTxtValue, new.DNSTxtValue) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSTxtValue, _m.DNSTxtValue, new.DNSTxtValue))
	}
	if !reflect.DeepEqual(_m.DNSVerificationStatus, new.DNSVerificationStatus) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSVerificationStatus, _m.DNSVerificationStatus, new.DNSVerificationStatus))
	}
	if !reflect.DeepEqual(_m.DNSVerificationStatusReason, new.DNSVerificationStatusReason) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSVerificationStatusReason, _m.DNSVerificationStatusReason, new.DNSVerificationStatusReason))
	}
	if !reflect.DeepEqual(_m.AcmeChallengePath, new.AcmeChallengePath) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldAcmeChallengePath, _m.AcmeChallengePath, new.AcmeChallengePath))
	}
	if !reflect.DeepEqual(_m.ExpectedAcmeChallengeValue, new.ExpectedAcmeChallengeValue) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldExpectedAcmeChallengeValue, _m.ExpectedAcmeChallengeValue, new.ExpectedAcmeChallengeValue))
	}
	if !reflect.DeepEqual(_m.AcmeChallengeStatus, new.AcmeChallengeStatus) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldAcmeChallengeStatus, _m.AcmeChallengeStatus, new.AcmeChallengeStatus))
	}
	if !reflect.DeepEqual(_m.AcmeChallengeStatusReason, new.AcmeChallengeStatusReason) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldAcmeChallengeStatusReason, _m.AcmeChallengeStatusReason, new.AcmeChallengeStatusReason))
	}
	return changes
}

func (_m *DNSVerificationHistory) Diff(history *DNSVerificationHistory) (*HistoryDiff[DNSVerificationHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[DNSVerificationHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[DNSVerificationHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *DocumentDataHistory) changes(new *DocumentDataHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(documentdatahistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(documentdatahistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(documentdatahistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(documentdatahistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(documentdatahistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(documentdatahistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(documentdatahistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.TemplateID, new.TemplateID) {
		changes = append(changes, NewChange(documentdatahistory.FieldTemplateID, _m.TemplateID, new.TemplateID))
	}
	if !reflect.DeepEqual(_m.Data, new.Data) {
		changes = append(changes, NewChange(documentdatahistory.FieldData, _m.Data, new.Data))
	}
	return changes
}

func (_m *DocumentDataHistory) Diff(history *DocumentDataHistory) (*HistoryDiff[DocumentDataHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[DocumentDataHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[DocumentDataHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *EntityHistory) changes(new *EntityHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(entityhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(entityhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(entityhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(entityhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(entityhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(entityhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(entityhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(entityhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(entityhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(entityhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(entityhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(entityhistory.FieldDisplayName, _m.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(entityhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Domains, new.Domains) {
		changes = append(changes, NewChange(entityhistory.FieldDomains, _m.Domains, new.Domains))
	}
	if !reflect.DeepEqual(_m.EntityTypeID, new.EntityTypeID) {
		changes = append(changes, NewChange(entityhistory.FieldEntityTypeID, _m.EntityTypeID, new.EntityTypeID))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(entityhistory.FieldStatus, _m.Status, new.Status))
	}
	return changes
}

func (_m *EntityHistory) Diff(history *EntityHistory) (*HistoryDiff[EntityHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[EntityHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EntityHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *EntityTypeHistory) changes(new *EntityTypeHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(entitytypehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(entitytypehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(entitytypehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(entitytypehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(entitytypehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(entitytypehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(entitytypehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(entitytypehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(entitytypehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(entitytypehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(entitytypehistory.FieldName, _m.Name, new.Name))
	}
	return changes
}

func (_m *EntityTypeHistory) Diff(history *EntityTypeHistory) (*HistoryDiff[EntityTypeHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[EntityTypeHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EntityTypeHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *EvidenceHistory) changes(new *EvidenceHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(evidencehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(evidencehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(evidencehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(evidencehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(evidencehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(evidencehistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(evidencehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(evidencehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(evidencehistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(evidencehistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.CollectionProcedure, new.CollectionProcedure) {
		changes = append(changes, NewChange(evidencehistory.FieldCollectionProcedure, _m.CollectionProcedure, new.CollectionProcedure))
	}
	if !reflect.DeepEqual(_m.CreationDate, new.CreationDate) {
		changes = append(changes, NewChange(evidencehistory.FieldCreationDate, _m.CreationDate, new.CreationDate))
	}
	if !reflect.DeepEqual(_m.RenewalDate, new.RenewalDate) {
		changes = append(changes, NewChange(evidencehistory.FieldRenewalDate, _m.RenewalDate, new.RenewalDate))
	}
	if !reflect.DeepEqual(_m.Source, new.Source) {
		changes = append(changes, NewChange(evidencehistory.FieldSource, _m.Source, new.Source))
	}
	if !reflect.DeepEqual(_m.IsAutomated, new.IsAutomated) {
		changes = append(changes, NewChange(evidencehistory.FieldIsAutomated, _m.IsAutomated, new.IsAutomated))
	}
	if !reflect.DeepEqual(_m.URL, new.URL) {
		changes = append(changes, NewChange(evidencehistory.FieldURL, _m.URL, new.URL))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(evidencehistory.FieldStatus, _m.Status, new.Status))
	}
	return changes
}

func (_m *EvidenceHistory) Diff(history *EvidenceHistory) (*HistoryDiff[EvidenceHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[EvidenceHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EvidenceHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *FileHistory) changes(new *FileHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(filehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(filehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(filehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(filehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(filehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(filehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(filehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(filehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(filehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.ProvidedFileName, new.ProvidedFileName) {
		changes = append(changes, NewChange(filehistory.FieldProvidedFileName, _m.ProvidedFileName, new.ProvidedFileName))
	}
	if !reflect.DeepEqual(_m.ProvidedFileExtension, new.ProvidedFileExtension) {
		changes = append(changes, NewChange(filehistory.FieldProvidedFileExtension, _m.ProvidedFileExtension, new.ProvidedFileExtension))
	}
	if !reflect.DeepEqual(_m.ProvidedFileSize, new.ProvidedFileSize) {
		changes = append(changes, NewChange(filehistory.FieldProvidedFileSize, _m.ProvidedFileSize, new.ProvidedFileSize))
	}
	if !reflect.DeepEqual(_m.PersistedFileSize, new.PersistedFileSize) {
		changes = append(changes, NewChange(filehistory.FieldPersistedFileSize, _m.PersistedFileSize, new.PersistedFileSize))
	}
	if !reflect.DeepEqual(_m.DetectedMimeType, new.DetectedMimeType) {
		changes = append(changes, NewChange(filehistory.FieldDetectedMimeType, _m.DetectedMimeType, new.DetectedMimeType))
	}
	if !reflect.DeepEqual(_m.Md5Hash, new.Md5Hash) {
		changes = append(changes, NewChange(filehistory.FieldMd5Hash, _m.Md5Hash, new.Md5Hash))
	}
	if !reflect.DeepEqual(_m.DetectedContentType, new.DetectedContentType) {
		changes = append(changes, NewChange(filehistory.FieldDetectedContentType, _m.DetectedContentType, new.DetectedContentType))
	}
	if !reflect.DeepEqual(_m.StoreKey, new.StoreKey) {
		changes = append(changes, NewChange(filehistory.FieldStoreKey, _m.StoreKey, new.StoreKey))
	}
	if !reflect.DeepEqual(_m.CategoryType, new.CategoryType) {
		changes = append(changes, NewChange(filehistory.FieldCategoryType, _m.CategoryType, new.CategoryType))
	}
	if !reflect.DeepEqual(_m.URI, new.URI) {
		changes = append(changes, NewChange(filehistory.FieldURI, _m.URI, new.URI))
	}
	if !reflect.DeepEqual(_m.StorageScheme, new.StorageScheme) {
		changes = append(changes, NewChange(filehistory.FieldStorageScheme, _m.StorageScheme, new.StorageScheme))
	}
	if !reflect.DeepEqual(_m.StorageVolume, new.StorageVolume) {
		changes = append(changes, NewChange(filehistory.FieldStorageVolume, _m.StorageVolume, new.StorageVolume))
	}
	if !reflect.DeepEqual(_m.StoragePath, new.StoragePath) {
		changes = append(changes, NewChange(filehistory.FieldStoragePath, _m.StoragePath, new.StoragePath))
	}
	if !reflect.DeepEqual(_m.FileContents, new.FileContents) {
		changes = append(changes, NewChange(filehistory.FieldFileContents, _m.FileContents, new.FileContents))
	}
	if !reflect.DeepEqual(_m.Metadata, new.Metadata) {
		changes = append(changes, NewChange(filehistory.FieldMetadata, _m.Metadata, new.Metadata))
	}
	if !reflect.DeepEqual(_m.StorageRegion, new.StorageRegion) {
		changes = append(changes, NewChange(filehistory.FieldStorageRegion, _m.StorageRegion, new.StorageRegion))
	}
	if !reflect.DeepEqual(_m.StorageProvider, new.StorageProvider) {
		changes = append(changes, NewChange(filehistory.FieldStorageProvider, _m.StorageProvider, new.StorageProvider))
	}
	if !reflect.DeepEqual(_m.LastAccessedAt, new.LastAccessedAt) {
		changes = append(changes, NewChange(filehistory.FieldLastAccessedAt, _m.LastAccessedAt, new.LastAccessedAt))
	}
	return changes
}

func (_m *FileHistory) Diff(history *FileHistory) (*HistoryDiff[FileHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[FileHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[FileHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *GroupHistory) changes(new *GroupHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(grouphistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(grouphistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(grouphistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(grouphistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(grouphistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(grouphistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(grouphistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(grouphistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(grouphistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(grouphistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.IsManaged, new.IsManaged) {
		changes = append(changes, NewChange(grouphistory.FieldIsManaged, _m.IsManaged, new.IsManaged))
	}
	if !reflect.DeepEqual(_m.GravatarLogoURL, new.GravatarLogoURL) {
		changes = append(changes, NewChange(grouphistory.FieldGravatarLogoURL, _m.GravatarLogoURL, new.GravatarLogoURL))
	}
	if !reflect.DeepEqual(_m.LogoURL, new.LogoURL) {
		changes = append(changes, NewChange(grouphistory.FieldLogoURL, _m.LogoURL, new.LogoURL))
	}
	if !reflect.DeepEqual(_m.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(grouphistory.FieldDisplayName, _m.DisplayName, new.DisplayName))
	}
	return changes
}

func (_m *GroupHistory) Diff(history *GroupHistory) (*HistoryDiff[GroupHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[GroupHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *GroupMembershipHistory) changes(new *GroupMembershipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.Role, new.Role) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldRole, _m.Role, new.Role))
	}
	if !reflect.DeepEqual(_m.GroupID, new.GroupID) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldGroupID, _m.GroupID, new.GroupID))
	}
	if !reflect.DeepEqual(_m.UserID, new.UserID) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldUserID, _m.UserID, new.UserID))
	}
	return changes
}

func (_m *GroupMembershipHistory) Diff(history *GroupMembershipHistory) (*HistoryDiff[GroupMembershipHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[GroupMembershipHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupMembershipHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *GroupSettingHistory) changes(new *GroupSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Visibility, new.Visibility) {
		changes = append(changes, NewChange(groupsettinghistory.FieldVisibility, _m.Visibility, new.Visibility))
	}
	if !reflect.DeepEqual(_m.JoinPolicy, new.JoinPolicy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldJoinPolicy, _m.JoinPolicy, new.JoinPolicy))
	}
	if !reflect.DeepEqual(_m.SyncToSlack, new.SyncToSlack) {
		changes = append(changes, NewChange(groupsettinghistory.FieldSyncToSlack, _m.SyncToSlack, new.SyncToSlack))
	}
	if !reflect.DeepEqual(_m.SyncToGithub, new.SyncToGithub) {
		changes = append(changes, NewChange(groupsettinghistory.FieldSyncToGithub, _m.SyncToGithub, new.SyncToGithub))
	}
	if !reflect.DeepEqual(_m.GroupID, new.GroupID) {
		changes = append(changes, NewChange(groupsettinghistory.FieldGroupID, _m.GroupID, new.GroupID))
	}
	return changes
}

func (_m *GroupSettingHistory) Diff(history *GroupSettingHistory) (*HistoryDiff[GroupSettingHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[GroupSettingHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupSettingHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *HushHistory) changes(new *HushHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(hushhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(hushhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(hushhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(hushhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(hushhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(hushhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(hushhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(hushhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(hushhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(hushhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(hushhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Kind, new.Kind) {
		changes = append(changes, NewChange(hushhistory.FieldKind, _m.Kind, new.Kind))
	}
	if !reflect.DeepEqual(_m.SecretName, new.SecretName) {
		changes = append(changes, NewChange(hushhistory.FieldSecretName, _m.SecretName, new.SecretName))
	}
	if !reflect.DeepEqual(_m.SecretValue, new.SecretValue) {
		changes = append(changes, NewChange(hushhistory.FieldSecretValue, _m.SecretValue, new.SecretValue))
	}
	if !reflect.DeepEqual(_m.CredentialSet, new.CredentialSet) {
		changes = append(changes, NewChange(hushhistory.FieldCredentialSet, _m.CredentialSet, new.CredentialSet))
	}
	if !reflect.DeepEqual(_m.Metadata, new.Metadata) {
		changes = append(changes, NewChange(hushhistory.FieldMetadata, _m.Metadata, new.Metadata))
	}
	if !reflect.DeepEqual(_m.LastUsedAt, new.LastUsedAt) {
		changes = append(changes, NewChange(hushhistory.FieldLastUsedAt, _m.LastUsedAt, new.LastUsedAt))
	}
	if !reflect.DeepEqual(_m.ExpiresAt, new.ExpiresAt) {
		changes = append(changes, NewChange(hushhistory.FieldExpiresAt, _m.ExpiresAt, new.ExpiresAt))
	}
	return changes
}

func (_m *HushHistory) Diff(history *HushHistory) (*HistoryDiff[HushHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[HushHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[HushHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *IntegrationHistory) changes(new *IntegrationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(integrationhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(integrationhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(integrationhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(integrationhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(integrationhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(integrationhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(integrationhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(integrationhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(integrationhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Kind, new.Kind) {
		changes = append(changes, NewChange(integrationhistory.FieldKind, _m.Kind, new.Kind))
	}
	if !reflect.DeepEqual(_m.IntegrationType, new.IntegrationType) {
		changes = append(changes, NewChange(integrationhistory.FieldIntegrationType, _m.IntegrationType, new.IntegrationType))
	}
	if !reflect.DeepEqual(_m.Metadata, new.Metadata) {
		changes = append(changes, NewChange(integrationhistory.FieldMetadata, _m.Metadata, new.Metadata))
	}
	return changes
}

func (_m *IntegrationHistory) Diff(history *IntegrationHistory) (*HistoryDiff[IntegrationHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[IntegrationHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[IntegrationHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *InternalPolicyHistory) changes(new *InternalPolicyHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Revision, new.Revision) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldRevision, _m.Revision, new.Revision))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.PolicyType, new.PolicyType) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldPolicyType, _m.PolicyType, new.PolicyType))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDetails, _m.Details, new.Details))
	}
	if !reflect.DeepEqual(_m.ApprovalRequired, new.ApprovalRequired) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldApprovalRequired, _m.ApprovalRequired, new.ApprovalRequired))
	}
	if !reflect.DeepEqual(_m.ReviewDue, new.ReviewDue) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldReviewDue, _m.ReviewDue, new.ReviewDue))
	}
	if !reflect.DeepEqual(_m.ReviewFrequency, new.ReviewFrequency) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldReviewFrequency, _m.ReviewFrequency, new.ReviewFrequency))
	}
	if !reflect.DeepEqual(_m.ApproverID, new.ApproverID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldApproverID, _m.ApproverID, new.ApproverID))
	}
	if !reflect.DeepEqual(_m.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDelegateID, _m.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(_m.Summary, new.Summary) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldSummary, _m.Summary, new.Summary))
	}
	if !reflect.DeepEqual(_m.TagSuggestions, new.TagSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldTagSuggestions, _m.TagSuggestions, new.TagSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedTagSuggestions, new.DismissedTagSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDismissedTagSuggestions, _m.DismissedTagSuggestions, new.DismissedTagSuggestions))
	}
	if !reflect.DeepEqual(_m.ControlSuggestions, new.ControlSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldControlSuggestions, _m.ControlSuggestions, new.ControlSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedControlSuggestions, new.DismissedControlSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDismissedControlSuggestions, _m.DismissedControlSuggestions, new.DismissedControlSuggestions))
	}
	if !reflect.DeepEqual(_m.ImprovementSuggestions, new.ImprovementSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldImprovementSuggestions, _m.ImprovementSuggestions, new.ImprovementSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDismissedImprovementSuggestions, _m.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions))
	}
	if !reflect.DeepEqual(_m.FileID, new.FileID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldFileID, _m.FileID, new.FileID))
	}
	if !reflect.DeepEqual(_m.URL, new.URL) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldURL, _m.URL, new.URL))
	}
	return changes
}

func (_m *InternalPolicyHistory) Diff(history *InternalPolicyHistory) (*HistoryDiff[InternalPolicyHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[InternalPolicyHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[InternalPolicyHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *JobTemplateHistory) changes(new *JobTemplateHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Title, new.Title) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldTitle, _m.Title, new.Title))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Platform, new.Platform) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldPlatform, _m.Platform, new.Platform))
	}
	if !reflect.DeepEqual(_m.WindmillPath, new.WindmillPath) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldWindmillPath, _m.WindmillPath, new.WindmillPath))
	}
	if !reflect.DeepEqual(_m.DownloadURL, new.DownloadURL) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldDownloadURL, _m.DownloadURL, new.DownloadURL))
	}
	if !reflect.DeepEqual(_m.Configuration, new.Configuration) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldConfiguration, _m.Configuration, new.Configuration))
	}
	if !reflect.DeepEqual(_m.Cron, new.Cron) {
		changes = append(changes, NewChange(jobtemplatehistory.FieldCron, _m.Cron, new.Cron))
	}
	return changes
}

func (_m *JobTemplateHistory) Diff(history *JobTemplateHistory) (*HistoryDiff[JobTemplateHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[JobTemplateHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[JobTemplateHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *MappableDomainHistory) changes(new *MappableDomainHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.ZoneID, new.ZoneID) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldZoneID, _m.ZoneID, new.ZoneID))
	}
	return changes
}

func (_m *MappableDomainHistory) Diff(history *MappableDomainHistory) (*HistoryDiff[MappableDomainHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[MappableDomainHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[MappableDomainHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *MappedControlHistory) changes(new *MappedControlHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.MappingType, new.MappingType) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldMappingType, _m.MappingType, new.MappingType))
	}
	if !reflect.DeepEqual(_m.Relation, new.Relation) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldRelation, _m.Relation, new.Relation))
	}
	if !reflect.DeepEqual(_m.Confidence, new.Confidence) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldConfidence, _m.Confidence, new.Confidence))
	}
	if !reflect.DeepEqual(_m.Source, new.Source) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldSource, _m.Source, new.Source))
	}
	return changes
}

func (_m *MappedControlHistory) Diff(history *MappedControlHistory) (*HistoryDiff[MappedControlHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[MappedControlHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[MappedControlHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *NarrativeHistory) changes(new *NarrativeHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(narrativehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(narrativehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(narrativehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(narrativehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(narrativehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(narrativehistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(narrativehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(narrativehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(narrativehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(narrativehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(narrativehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(narrativehistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(narrativehistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(narrativehistory.FieldDetails, _m.Details, new.Details))
	}
	return changes
}

func (_m *NarrativeHistory) Diff(history *NarrativeHistory) (*HistoryDiff[NarrativeHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[NarrativeHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[NarrativeHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *NoteHistory) changes(new *NoteHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(notehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(notehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(notehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(notehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(notehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(notehistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(notehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Text, new.Text) {
		changes = append(changes, NewChange(notehistory.FieldText, _m.Text, new.Text))
	}
	return changes
}

func (_m *NoteHistory) Diff(history *NoteHistory) (*HistoryDiff[NoteHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[NoteHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[NoteHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *OrgMembershipHistory) changes(new *OrgMembershipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.Role, new.Role) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldRole, _m.Role, new.Role))
	}
	if !reflect.DeepEqual(_m.OrganizationID, new.OrganizationID) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldOrganizationID, _m.OrganizationID, new.OrganizationID))
	}
	if !reflect.DeepEqual(_m.UserID, new.UserID) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldUserID, _m.UserID, new.UserID))
	}
	return changes
}

func (_m *OrgMembershipHistory) Diff(history *OrgMembershipHistory) (*HistoryDiff[OrgMembershipHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[OrgMembershipHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrgMembershipHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *OrgSubscriptionHistory) changes(new *OrgSubscriptionHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.StripeSubscriptionID, new.StripeSubscriptionID) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldStripeSubscriptionID, _m.StripeSubscriptionID, new.StripeSubscriptionID))
	}
	if !reflect.DeepEqual(_m.ProductPrice, new.ProductPrice) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldProductPrice, _m.ProductPrice, new.ProductPrice))
	}
	if !reflect.DeepEqual(_m.StripeSubscriptionStatus, new.StripeSubscriptionStatus) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldStripeSubscriptionStatus, _m.StripeSubscriptionStatus, new.StripeSubscriptionStatus))
	}
	if !reflect.DeepEqual(_m.Active, new.Active) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldActive, _m.Active, new.Active))
	}
	if !reflect.DeepEqual(_m.ExpiresAt, new.ExpiresAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldExpiresAt, _m.ExpiresAt, new.ExpiresAt))
	}
	if !reflect.DeepEqual(_m.TrialExpiresAt, new.TrialExpiresAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldTrialExpiresAt, _m.TrialExpiresAt, new.TrialExpiresAt))
	}
	if !reflect.DeepEqual(_m.DaysUntilDue, new.DaysUntilDue) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldDaysUntilDue, _m.DaysUntilDue, new.DaysUntilDue))
	}
	if !reflect.DeepEqual(_m.Features, new.Features) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldFeatures, _m.Features, new.Features))
	}
	if !reflect.DeepEqual(_m.FeatureLookupKeys, new.FeatureLookupKeys) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldFeatureLookupKeys, _m.FeatureLookupKeys, new.FeatureLookupKeys))
	}
	return changes
}

func (_m *OrgSubscriptionHistory) Diff(history *OrgSubscriptionHistory) (*HistoryDiff[OrgSubscriptionHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[OrgSubscriptionHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrgSubscriptionHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *OrganizationHistory) changes(new *OrganizationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(organizationhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(organizationhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(organizationhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(organizationhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(organizationhistory.FieldDisplayName, _m.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(organizationhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.ParentOrganizationID, new.ParentOrganizationID) {
		changes = append(changes, NewChange(organizationhistory.FieldParentOrganizationID, _m.ParentOrganizationID, new.ParentOrganizationID))
	}
	if !reflect.DeepEqual(_m.PersonalOrg, new.PersonalOrg) {
		changes = append(changes, NewChange(organizationhistory.FieldPersonalOrg, _m.PersonalOrg, new.PersonalOrg))
	}
	if !reflect.DeepEqual(_m.AvatarRemoteURL, new.AvatarRemoteURL) {
		changes = append(changes, NewChange(organizationhistory.FieldAvatarRemoteURL, _m.AvatarRemoteURL, new.AvatarRemoteURL))
	}
	if !reflect.DeepEqual(_m.AvatarLocalFileID, new.AvatarLocalFileID) {
		changes = append(changes, NewChange(organizationhistory.FieldAvatarLocalFileID, _m.AvatarLocalFileID, new.AvatarLocalFileID))
	}
	if !reflect.DeepEqual(_m.AvatarUpdatedAt, new.AvatarUpdatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldAvatarUpdatedAt, _m.AvatarUpdatedAt, new.AvatarUpdatedAt))
	}
	if !reflect.DeepEqual(_m.DedicatedDb, new.DedicatedDb) {
		changes = append(changes, NewChange(organizationhistory.FieldDedicatedDb, _m.DedicatedDb, new.DedicatedDb))
	}
	if !reflect.DeepEqual(_m.StripeCustomerID, new.StripeCustomerID) {
		changes = append(changes, NewChange(organizationhistory.FieldStripeCustomerID, _m.StripeCustomerID, new.StripeCustomerID))
	}
	return changes
}

func (_m *OrganizationHistory) Diff(history *OrganizationHistory) (*HistoryDiff[OrganizationHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[OrganizationHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrganizationHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *OrganizationSettingHistory) changes(new *OrganizationSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Domains, new.Domains) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDomains, _m.Domains, new.Domains))
	}
	if !reflect.DeepEqual(_m.BillingContact, new.BillingContact) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingContact, _m.BillingContact, new.BillingContact))
	}
	if !reflect.DeepEqual(_m.BillingEmail, new.BillingEmail) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingEmail, _m.BillingEmail, new.BillingEmail))
	}
	if !reflect.DeepEqual(_m.BillingPhone, new.BillingPhone) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingPhone, _m.BillingPhone, new.BillingPhone))
	}
	if !reflect.DeepEqual(_m.BillingAddress, new.BillingAddress) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingAddress, _m.BillingAddress, new.BillingAddress))
	}
	if !reflect.DeepEqual(_m.TaxIdentifier, new.TaxIdentifier) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldTaxIdentifier, _m.TaxIdentifier, new.TaxIdentifier))
	}
	if !reflect.DeepEqual(_m.GeoLocation, new.GeoLocation) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldGeoLocation, _m.GeoLocation, new.GeoLocation))
	}
	if !reflect.DeepEqual(_m.OrganizationID, new.OrganizationID) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldOrganizationID, _m.OrganizationID, new.OrganizationID))
	}
	if !reflect.DeepEqual(_m.BillingNotificationsEnabled, new.BillingNotificationsEnabled) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingNotificationsEnabled, _m.BillingNotificationsEnabled, new.BillingNotificationsEnabled))
	}
	if !reflect.DeepEqual(_m.AllowedEmailDomains, new.AllowedEmailDomains) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldAllowedEmailDomains, _m.AllowedEmailDomains, new.AllowedEmailDomains))
	}
	if !reflect.DeepEqual(_m.AllowMatchingDomainsAutojoin, new.AllowMatchingDomainsAutojoin) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldAllowMatchingDomainsAutojoin, _m.AllowMatchingDomainsAutojoin, new.AllowMatchingDomainsAutojoin))
	}
	if !reflect.DeepEqual(_m.IdentityProvider, new.IdentityProvider) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProvider, _m.IdentityProvider, new.IdentityProvider))
	}
	if !reflect.DeepEqual(_m.IdentityProviderClientID, new.IdentityProviderClientID) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderClientID, _m.IdentityProviderClientID, new.IdentityProviderClientID))
	}
	if !reflect.DeepEqual(_m.IdentityProviderClientSecret, new.IdentityProviderClientSecret) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderClientSecret, _m.IdentityProviderClientSecret, new.IdentityProviderClientSecret))
	}
	if !reflect.DeepEqual(_m.IdentityProviderMetadataEndpoint, new.IdentityProviderMetadataEndpoint) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderMetadataEndpoint, _m.IdentityProviderMetadataEndpoint, new.IdentityProviderMetadataEndpoint))
	}
	if !reflect.DeepEqual(_m.IdentityProviderAuthTested, new.IdentityProviderAuthTested) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderAuthTested, _m.IdentityProviderAuthTested, new.IdentityProviderAuthTested))
	}
	if !reflect.DeepEqual(_m.IdentityProviderEntityID, new.IdentityProviderEntityID) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderEntityID, _m.IdentityProviderEntityID, new.IdentityProviderEntityID))
	}
	if !reflect.DeepEqual(_m.OidcDiscoveryEndpoint, new.OidcDiscoveryEndpoint) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldOidcDiscoveryEndpoint, _m.OidcDiscoveryEndpoint, new.OidcDiscoveryEndpoint))
	}
	if !reflect.DeepEqual(_m.SamlSigninURL, new.SamlSigninURL) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldSamlSigninURL, _m.SamlSigninURL, new.SamlSigninURL))
	}
	if !reflect.DeepEqual(_m.SamlIssuer, new.SamlIssuer) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldSamlIssuer, _m.SamlIssuer, new.SamlIssuer))
	}
	if !reflect.DeepEqual(_m.SamlCert, new.SamlCert) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldSamlCert, _m.SamlCert, new.SamlCert))
	}
	if !reflect.DeepEqual(_m.IdentityProviderLoginEnforced, new.IdentityProviderLoginEnforced) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderLoginEnforced, _m.IdentityProviderLoginEnforced, new.IdentityProviderLoginEnforced))
	}
	if !reflect.DeepEqual(_m.MultifactorAuthEnforced, new.MultifactorAuthEnforced) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldMultifactorAuthEnforced, _m.MultifactorAuthEnforced, new.MultifactorAuthEnforced))
	}
	if !reflect.DeepEqual(_m.ComplianceWebhookToken, new.ComplianceWebhookToken) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldComplianceWebhookToken, _m.ComplianceWebhookToken, new.ComplianceWebhookToken))
	}
	if !reflect.DeepEqual(_m.PaymentMethodAdded, new.PaymentMethodAdded) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldPaymentMethodAdded, _m.PaymentMethodAdded, new.PaymentMethodAdded))
	}
	return changes
}

func (_m *OrganizationSettingHistory) Diff(history *OrganizationSettingHistory) (*HistoryDiff[OrganizationSettingHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[OrganizationSettingHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrganizationSettingHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ProcedureHistory) changes(new *ProcedureHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(procedurehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(procedurehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(procedurehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(procedurehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(procedurehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(procedurehistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(procedurehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Revision, new.Revision) {
		changes = append(changes, NewChange(procedurehistory.FieldRevision, _m.Revision, new.Revision))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(procedurehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(procedurehistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(procedurehistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.ProcedureType, new.ProcedureType) {
		changes = append(changes, NewChange(procedurehistory.FieldProcedureType, _m.ProcedureType, new.ProcedureType))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(procedurehistory.FieldDetails, _m.Details, new.Details))
	}
	if !reflect.DeepEqual(_m.ApprovalRequired, new.ApprovalRequired) {
		changes = append(changes, NewChange(procedurehistory.FieldApprovalRequired, _m.ApprovalRequired, new.ApprovalRequired))
	}
	if !reflect.DeepEqual(_m.ReviewDue, new.ReviewDue) {
		changes = append(changes, NewChange(procedurehistory.FieldReviewDue, _m.ReviewDue, new.ReviewDue))
	}
	if !reflect.DeepEqual(_m.ReviewFrequency, new.ReviewFrequency) {
		changes = append(changes, NewChange(procedurehistory.FieldReviewFrequency, _m.ReviewFrequency, new.ReviewFrequency))
	}
	if !reflect.DeepEqual(_m.ApproverID, new.ApproverID) {
		changes = append(changes, NewChange(procedurehistory.FieldApproverID, _m.ApproverID, new.ApproverID))
	}
	if !reflect.DeepEqual(_m.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(procedurehistory.FieldDelegateID, _m.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(_m.Summary, new.Summary) {
		changes = append(changes, NewChange(procedurehistory.FieldSummary, _m.Summary, new.Summary))
	}
	if !reflect.DeepEqual(_m.TagSuggestions, new.TagSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldTagSuggestions, _m.TagSuggestions, new.TagSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedTagSuggestions, new.DismissedTagSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldDismissedTagSuggestions, _m.DismissedTagSuggestions, new.DismissedTagSuggestions))
	}
	if !reflect.DeepEqual(_m.ControlSuggestions, new.ControlSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldControlSuggestions, _m.ControlSuggestions, new.ControlSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedControlSuggestions, new.DismissedControlSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldDismissedControlSuggestions, _m.DismissedControlSuggestions, new.DismissedControlSuggestions))
	}
	if !reflect.DeepEqual(_m.ImprovementSuggestions, new.ImprovementSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldImprovementSuggestions, _m.ImprovementSuggestions, new.ImprovementSuggestions))
	}
	if !reflect.DeepEqual(_m.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldDismissedImprovementSuggestions, _m.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(procedurehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(procedurehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(procedurehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.FileID, new.FileID) {
		changes = append(changes, NewChange(procedurehistory.FieldFileID, _m.FileID, new.FileID))
	}
	if !reflect.DeepEqual(_m.URL, new.URL) {
		changes = append(changes, NewChange(procedurehistory.FieldURL, _m.URL, new.URL))
	}
	return changes
}

func (_m *ProcedureHistory) Diff(history *ProcedureHistory) (*HistoryDiff[ProcedureHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ProcedureHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ProcedureHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ProgramHistory) changes(new *ProgramHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(programhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(programhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(programhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(programhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(programhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(programhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(programhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(programhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(programhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(programhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(programhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.ProgramType, new.ProgramType) {
		changes = append(changes, NewChange(programhistory.FieldProgramType, _m.ProgramType, new.ProgramType))
	}
	if !reflect.DeepEqual(_m.FrameworkName, new.FrameworkName) {
		changes = append(changes, NewChange(programhistory.FieldFrameworkName, _m.FrameworkName, new.FrameworkName))
	}
	if !reflect.DeepEqual(_m.StartDate, new.StartDate) {
		changes = append(changes, NewChange(programhistory.FieldStartDate, _m.StartDate, new.StartDate))
	}
	if !reflect.DeepEqual(_m.EndDate, new.EndDate) {
		changes = append(changes, NewChange(programhistory.FieldEndDate, _m.EndDate, new.EndDate))
	}
	if !reflect.DeepEqual(_m.AuditorReady, new.AuditorReady) {
		changes = append(changes, NewChange(programhistory.FieldAuditorReady, _m.AuditorReady, new.AuditorReady))
	}
	if !reflect.DeepEqual(_m.AuditorWriteComments, new.AuditorWriteComments) {
		changes = append(changes, NewChange(programhistory.FieldAuditorWriteComments, _m.AuditorWriteComments, new.AuditorWriteComments))
	}
	if !reflect.DeepEqual(_m.AuditorReadComments, new.AuditorReadComments) {
		changes = append(changes, NewChange(programhistory.FieldAuditorReadComments, _m.AuditorReadComments, new.AuditorReadComments))
	}
	if !reflect.DeepEqual(_m.AuditFirm, new.AuditFirm) {
		changes = append(changes, NewChange(programhistory.FieldAuditFirm, _m.AuditFirm, new.AuditFirm))
	}
	if !reflect.DeepEqual(_m.Auditor, new.Auditor) {
		changes = append(changes, NewChange(programhistory.FieldAuditor, _m.Auditor, new.Auditor))
	}
	if !reflect.DeepEqual(_m.AuditorEmail, new.AuditorEmail) {
		changes = append(changes, NewChange(programhistory.FieldAuditorEmail, _m.AuditorEmail, new.AuditorEmail))
	}
	return changes
}

func (_m *ProgramHistory) Diff(history *ProgramHistory) (*HistoryDiff[ProgramHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ProgramHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ProgramHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ProgramMembershipHistory) changes(new *ProgramMembershipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(programmembershiphistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(programmembershiphistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(programmembershiphistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.Role, new.Role) {
		changes = append(changes, NewChange(programmembershiphistory.FieldRole, _m.Role, new.Role))
	}
	if !reflect.DeepEqual(_m.ProgramID, new.ProgramID) {
		changes = append(changes, NewChange(programmembershiphistory.FieldProgramID, _m.ProgramID, new.ProgramID))
	}
	if !reflect.DeepEqual(_m.UserID, new.UserID) {
		changes = append(changes, NewChange(programmembershiphistory.FieldUserID, _m.UserID, new.UserID))
	}
	return changes
}

func (_m *ProgramMembershipHistory) Diff(history *ProgramMembershipHistory) (*HistoryDiff[ProgramMembershipHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ProgramMembershipHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ProgramMembershipHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *RiskHistory) changes(new *RiskHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(riskhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(riskhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(riskhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(riskhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(riskhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(riskhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(riskhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(riskhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(riskhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(riskhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.RiskType, new.RiskType) {
		changes = append(changes, NewChange(riskhistory.FieldRiskType, _m.RiskType, new.RiskType))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(riskhistory.FieldCategory, _m.Category, new.Category))
	}
	if !reflect.DeepEqual(_m.Impact, new.Impact) {
		changes = append(changes, NewChange(riskhistory.FieldImpact, _m.Impact, new.Impact))
	}
	if !reflect.DeepEqual(_m.Likelihood, new.Likelihood) {
		changes = append(changes, NewChange(riskhistory.FieldLikelihood, _m.Likelihood, new.Likelihood))
	}
	if !reflect.DeepEqual(_m.Score, new.Score) {
		changes = append(changes, NewChange(riskhistory.FieldScore, _m.Score, new.Score))
	}
	if !reflect.DeepEqual(_m.Mitigation, new.Mitigation) {
		changes = append(changes, NewChange(riskhistory.FieldMitigation, _m.Mitigation, new.Mitigation))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(riskhistory.FieldDetails, _m.Details, new.Details))
	}
	if !reflect.DeepEqual(_m.BusinessCosts, new.BusinessCosts) {
		changes = append(changes, NewChange(riskhistory.FieldBusinessCosts, _m.BusinessCosts, new.BusinessCosts))
	}
	if !reflect.DeepEqual(_m.StakeholderID, new.StakeholderID) {
		changes = append(changes, NewChange(riskhistory.FieldStakeholderID, _m.StakeholderID, new.StakeholderID))
	}
	if !reflect.DeepEqual(_m.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(riskhistory.FieldDelegateID, _m.DelegateID, new.DelegateID))
	}
	return changes
}

func (_m *RiskHistory) Diff(history *RiskHistory) (*HistoryDiff[RiskHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[RiskHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[RiskHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ScanHistory) changes(new *ScanHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(scanhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(scanhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(scanhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(scanhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(scanhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(scanhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(scanhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Target, new.Target) {
		changes = append(changes, NewChange(scanhistory.FieldTarget, _m.Target, new.Target))
	}
	if !reflect.DeepEqual(_m.ScanType, new.ScanType) {
		changes = append(changes, NewChange(scanhistory.FieldScanType, _m.ScanType, new.ScanType))
	}
	if !reflect.DeepEqual(_m.Metadata, new.Metadata) {
		changes = append(changes, NewChange(scanhistory.FieldMetadata, _m.Metadata, new.Metadata))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(scanhistory.FieldStatus, _m.Status, new.Status))
	}
	return changes
}

func (_m *ScanHistory) Diff(history *ScanHistory) (*HistoryDiff[ScanHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ScanHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ScanHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *ScheduledJobHistory) changes(new *ScheduledJobHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.JobID, new.JobID) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldJobID, _m.JobID, new.JobID))
	}
	if !reflect.DeepEqual(_m.Active, new.Active) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldActive, _m.Active, new.Active))
	}
	if !reflect.DeepEqual(_m.Configuration, new.Configuration) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldConfiguration, _m.Configuration, new.Configuration))
	}
	if !reflect.DeepEqual(_m.Cron, new.Cron) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCron, _m.Cron, new.Cron))
	}
	if !reflect.DeepEqual(_m.JobRunnerID, new.JobRunnerID) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldJobRunnerID, _m.JobRunnerID, new.JobRunnerID))
	}
	return changes
}

func (_m *ScheduledJobHistory) Diff(history *ScheduledJobHistory) (*HistoryDiff[ScheduledJobHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[ScheduledJobHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ScheduledJobHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *StandardHistory) changes(new *StandardHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(standardhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(standardhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(standardhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(standardhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(standardhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(standardhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Revision, new.Revision) {
		changes = append(changes, NewChange(standardhistory.FieldRevision, _m.Revision, new.Revision))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(standardhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(standardhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(standardhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(standardhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(standardhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.ShortName, new.ShortName) {
		changes = append(changes, NewChange(standardhistory.FieldShortName, _m.ShortName, new.ShortName))
	}
	if !reflect.DeepEqual(_m.Framework, new.Framework) {
		changes = append(changes, NewChange(standardhistory.FieldFramework, _m.Framework, new.Framework))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(standardhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.GoverningBodyLogoURL, new.GoverningBodyLogoURL) {
		changes = append(changes, NewChange(standardhistory.FieldGoverningBodyLogoURL, _m.GoverningBodyLogoURL, new.GoverningBodyLogoURL))
	}
	if !reflect.DeepEqual(_m.GoverningBody, new.GoverningBody) {
		changes = append(changes, NewChange(standardhistory.FieldGoverningBody, _m.GoverningBody, new.GoverningBody))
	}
	if !reflect.DeepEqual(_m.Domains, new.Domains) {
		changes = append(changes, NewChange(standardhistory.FieldDomains, _m.Domains, new.Domains))
	}
	if !reflect.DeepEqual(_m.Link, new.Link) {
		changes = append(changes, NewChange(standardhistory.FieldLink, _m.Link, new.Link))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(standardhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.IsPublic, new.IsPublic) {
		changes = append(changes, NewChange(standardhistory.FieldIsPublic, _m.IsPublic, new.IsPublic))
	}
	if !reflect.DeepEqual(_m.FreeToUse, new.FreeToUse) {
		changes = append(changes, NewChange(standardhistory.FieldFreeToUse, _m.FreeToUse, new.FreeToUse))
	}
	if !reflect.DeepEqual(_m.StandardType, new.StandardType) {
		changes = append(changes, NewChange(standardhistory.FieldStandardType, _m.StandardType, new.StandardType))
	}
	if !reflect.DeepEqual(_m.Version, new.Version) {
		changes = append(changes, NewChange(standardhistory.FieldVersion, _m.Version, new.Version))
	}
	return changes
}

func (_m *StandardHistory) Diff(history *StandardHistory) (*HistoryDiff[StandardHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[StandardHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[StandardHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *SubcontrolHistory) changes(new *SubcontrolHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(subcontrolhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(subcontrolhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.ReferenceID, new.ReferenceID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldReferenceID, _m.ReferenceID, new.ReferenceID))
	}
	if !reflect.DeepEqual(_m.AuditorReferenceID, new.AuditorReferenceID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldAuditorReferenceID, _m.AuditorReferenceID, new.AuditorReferenceID))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(subcontrolhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.Source, new.Source) {
		changes = append(changes, NewChange(subcontrolhistory.FieldSource, _m.Source, new.Source))
	}
	if !reflect.DeepEqual(_m.ReferenceFramework, new.ReferenceFramework) {
		changes = append(changes, NewChange(subcontrolhistory.FieldReferenceFramework, _m.ReferenceFramework, new.ReferenceFramework))
	}
	if !reflect.DeepEqual(_m.ControlType, new.ControlType) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlType, _m.ControlType, new.ControlType))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCategory, _m.Category, new.Category))
	}
	if !reflect.DeepEqual(_m.CategoryID, new.CategoryID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCategoryID, _m.CategoryID, new.CategoryID))
	}
	if !reflect.DeepEqual(_m.Subcategory, new.Subcategory) {
		changes = append(changes, NewChange(subcontrolhistory.FieldSubcategory, _m.Subcategory, new.Subcategory))
	}
	if !reflect.DeepEqual(_m.MappedCategories, new.MappedCategories) {
		changes = append(changes, NewChange(subcontrolhistory.FieldMappedCategories, _m.MappedCategories, new.MappedCategories))
	}
	if !reflect.DeepEqual(_m.AssessmentObjectives, new.AssessmentObjectives) {
		changes = append(changes, NewChange(subcontrolhistory.FieldAssessmentObjectives, _m.AssessmentObjectives, new.AssessmentObjectives))
	}
	if !reflect.DeepEqual(_m.AssessmentMethods, new.AssessmentMethods) {
		changes = append(changes, NewChange(subcontrolhistory.FieldAssessmentMethods, _m.AssessmentMethods, new.AssessmentMethods))
	}
	if !reflect.DeepEqual(_m.ControlQuestions, new.ControlQuestions) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlQuestions, _m.ControlQuestions, new.ControlQuestions))
	}
	if !reflect.DeepEqual(_m.ImplementationGuidance, new.ImplementationGuidance) {
		changes = append(changes, NewChange(subcontrolhistory.FieldImplementationGuidance, _m.ImplementationGuidance, new.ImplementationGuidance))
	}
	if !reflect.DeepEqual(_m.ExampleEvidence, new.ExampleEvidence) {
		changes = append(changes, NewChange(subcontrolhistory.FieldExampleEvidence, _m.ExampleEvidence, new.ExampleEvidence))
	}
	if !reflect.DeepEqual(_m.References, new.References) {
		changes = append(changes, NewChange(subcontrolhistory.FieldReferences, _m.References, new.References))
	}
	if !reflect.DeepEqual(_m.ControlOwnerID, new.ControlOwnerID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlOwnerID, _m.ControlOwnerID, new.ControlOwnerID))
	}
	if !reflect.DeepEqual(_m.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDelegateID, _m.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(subcontrolhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(subcontrolhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.RefCode, new.RefCode) {
		changes = append(changes, NewChange(subcontrolhistory.FieldRefCode, _m.RefCode, new.RefCode))
	}
	if !reflect.DeepEqual(_m.ControlID, new.ControlID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlID, _m.ControlID, new.ControlID))
	}
	return changes
}

func (_m *SubcontrolHistory) Diff(history *SubcontrolHistory) (*HistoryDiff[SubcontrolHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[SubcontrolHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[SubcontrolHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *SubprocessorHistory) changes(new *SubprocessorHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(subprocessorhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(subprocessorhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(subprocessorhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(subprocessorhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(subprocessorhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(subprocessorhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(subprocessorhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(subprocessorhistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(subprocessorhistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(subprocessorhistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(subprocessorhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(subprocessorhistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.LogoRemoteURL, new.LogoRemoteURL) {
		changes = append(changes, NewChange(subprocessorhistory.FieldLogoRemoteURL, _m.LogoRemoteURL, new.LogoRemoteURL))
	}
	if !reflect.DeepEqual(_m.LogoLocalFileID, new.LogoLocalFileID) {
		changes = append(changes, NewChange(subprocessorhistory.FieldLogoLocalFileID, _m.LogoLocalFileID, new.LogoLocalFileID))
	}
	return changes
}

func (_m *SubprocessorHistory) Diff(history *SubprocessorHistory) (*HistoryDiff[SubprocessorHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[SubprocessorHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[SubprocessorHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TaskHistory) changes(new *TaskHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(taskhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(taskhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(taskhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(taskhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(taskhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(taskhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(taskhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(taskhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Title, new.Title) {
		changes = append(changes, NewChange(taskhistory.FieldTitle, _m.Title, new.Title))
	}
	if !reflect.DeepEqual(_m.Details, new.Details) {
		changes = append(changes, NewChange(taskhistory.FieldDetails, _m.Details, new.Details))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(taskhistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(taskhistory.FieldCategory, _m.Category, new.Category))
	}
	if !reflect.DeepEqual(_m.Due, new.Due) {
		changes = append(changes, NewChange(taskhistory.FieldDue, _m.Due, new.Due))
	}
	if !reflect.DeepEqual(_m.Completed, new.Completed) {
		changes = append(changes, NewChange(taskhistory.FieldCompleted, _m.Completed, new.Completed))
	}
	if !reflect.DeepEqual(_m.AssigneeID, new.AssigneeID) {
		changes = append(changes, NewChange(taskhistory.FieldAssigneeID, _m.AssigneeID, new.AssigneeID))
	}
	if !reflect.DeepEqual(_m.AssignerID, new.AssignerID) {
		changes = append(changes, NewChange(taskhistory.FieldAssignerID, _m.AssignerID, new.AssignerID))
	}
	return changes
}

func (_m *TaskHistory) Diff(history *TaskHistory) (*HistoryDiff[TaskHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TaskHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TaskHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TemplateHistory) changes(new *TemplateHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(templatehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(templatehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(templatehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(templatehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(templatehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(templatehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(templatehistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(templatehistory.FieldSystemOwned, _m.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(_m.InternalNotes, new.InternalNotes) {
		changes = append(changes, NewChange(templatehistory.FieldInternalNotes, _m.InternalNotes, new.InternalNotes))
	}
	if !reflect.DeepEqual(_m.SystemInternalID, new.SystemInternalID) {
		changes = append(changes, NewChange(templatehistory.FieldSystemInternalID, _m.SystemInternalID, new.SystemInternalID))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(templatehistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.TemplateType, new.TemplateType) {
		changes = append(changes, NewChange(templatehistory.FieldTemplateType, _m.TemplateType, new.TemplateType))
	}
	if !reflect.DeepEqual(_m.Description, new.Description) {
		changes = append(changes, NewChange(templatehistory.FieldDescription, _m.Description, new.Description))
	}
	if !reflect.DeepEqual(_m.Kind, new.Kind) {
		changes = append(changes, NewChange(templatehistory.FieldKind, _m.Kind, new.Kind))
	}
	if !reflect.DeepEqual(_m.Jsonconfig, new.Jsonconfig) {
		changes = append(changes, NewChange(templatehistory.FieldJsonconfig, _m.Jsonconfig, new.Jsonconfig))
	}
	if !reflect.DeepEqual(_m.Uischema, new.Uischema) {
		changes = append(changes, NewChange(templatehistory.FieldUischema, _m.Uischema, new.Uischema))
	}
	if !reflect.DeepEqual(_m.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(templatehistory.FieldTrustCenterID, _m.TrustCenterID, new.TrustCenterID))
	}
	return changes
}

func (_m *TemplateHistory) Diff(history *TemplateHistory) (*HistoryDiff[TemplateHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TemplateHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TemplateHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TrustCenterHistory) changes(new *TrustCenterHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcenterhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcenterhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcenterhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcenterhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcenterhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(trustcenterhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(trustcenterhistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.Slug, new.Slug) {
		changes = append(changes, NewChange(trustcenterhistory.FieldSlug, _m.Slug, new.Slug))
	}
	if !reflect.DeepEqual(_m.CustomDomainID, new.CustomDomainID) {
		changes = append(changes, NewChange(trustcenterhistory.FieldCustomDomainID, _m.CustomDomainID, new.CustomDomainID))
	}
	return changes
}

func (_m *TrustCenterHistory) Diff(history *TrustCenterHistory) (*HistoryDiff[TrustCenterHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TrustCenterHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TrustCenterComplianceHistory) changes(new *TrustCenterComplianceHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.StandardID, new.StandardID) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldStandardID, _m.StandardID, new.StandardID))
	}
	if !reflect.DeepEqual(_m.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldTrustCenterID, _m.TrustCenterID, new.TrustCenterID))
	}
	return changes
}

func (_m *TrustCenterComplianceHistory) Diff(history *TrustCenterComplianceHistory) (*HistoryDiff[TrustCenterComplianceHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TrustCenterComplianceHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterComplianceHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TrustCenterDocHistory) changes(new *TrustCenterDocHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldTrustCenterID, _m.TrustCenterID, new.TrustCenterID))
	}
	if !reflect.DeepEqual(_m.Title, new.Title) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldTitle, _m.Title, new.Title))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldCategory, _m.Category, new.Category))
	}
	if !reflect.DeepEqual(_m.FileID, new.FileID) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldFileID, _m.FileID, new.FileID))
	}
	if !reflect.DeepEqual(_m.Visibility, new.Visibility) {
		changes = append(changes, NewChange(trustcenterdochistory.FieldVisibility, _m.Visibility, new.Visibility))
	}
	return changes
}

func (_m *TrustCenterDocHistory) Diff(history *TrustCenterDocHistory) (*HistoryDiff[TrustCenterDocHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TrustCenterDocHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterDocHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TrustCenterSettingHistory) changes(new *TrustCenterSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldTrustCenterID, _m.TrustCenterID, new.TrustCenterID))
	}
	if !reflect.DeepEqual(_m.Title, new.Title) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldTitle, _m.Title, new.Title))
	}
	if !reflect.DeepEqual(_m.Overview, new.Overview) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldOverview, _m.Overview, new.Overview))
	}
	if !reflect.DeepEqual(_m.LogoRemoteURL, new.LogoRemoteURL) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldLogoRemoteURL, _m.LogoRemoteURL, new.LogoRemoteURL))
	}
	if !reflect.DeepEqual(_m.LogoLocalFileID, new.LogoLocalFileID) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldLogoLocalFileID, _m.LogoLocalFileID, new.LogoLocalFileID))
	}
	if !reflect.DeepEqual(_m.FaviconRemoteURL, new.FaviconRemoteURL) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldFaviconRemoteURL, _m.FaviconRemoteURL, new.FaviconRemoteURL))
	}
	if !reflect.DeepEqual(_m.FaviconLocalFileID, new.FaviconLocalFileID) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldFaviconLocalFileID, _m.FaviconLocalFileID, new.FaviconLocalFileID))
	}
	if !reflect.DeepEqual(_m.ThemeMode, new.ThemeMode) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldThemeMode, _m.ThemeMode, new.ThemeMode))
	}
	if !reflect.DeepEqual(_m.PrimaryColor, new.PrimaryColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldPrimaryColor, _m.PrimaryColor, new.PrimaryColor))
	}
	if !reflect.DeepEqual(_m.Font, new.Font) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldFont, _m.Font, new.Font))
	}
	if !reflect.DeepEqual(_m.ForegroundColor, new.ForegroundColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldForegroundColor, _m.ForegroundColor, new.ForegroundColor))
	}
	if !reflect.DeepEqual(_m.BackgroundColor, new.BackgroundColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldBackgroundColor, _m.BackgroundColor, new.BackgroundColor))
	}
	if !reflect.DeepEqual(_m.AccentColor, new.AccentColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldAccentColor, _m.AccentColor, new.AccentColor))
	}
	return changes
}

func (_m *TrustCenterSettingHistory) Diff(history *TrustCenterSettingHistory) (*HistoryDiff[TrustCenterSettingHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TrustCenterSettingHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterSettingHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TrustCenterSubprocessorHistory) changes(new *TrustCenterSubprocessorHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.SubprocessorID, new.SubprocessorID) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldSubprocessorID, _m.SubprocessorID, new.SubprocessorID))
	}
	if !reflect.DeepEqual(_m.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldTrustCenterID, _m.TrustCenterID, new.TrustCenterID))
	}
	if !reflect.DeepEqual(_m.Countries, new.Countries) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCountries, _m.Countries, new.Countries))
	}
	if !reflect.DeepEqual(_m.Category, new.Category) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCategory, _m.Category, new.Category))
	}
	return changes
}

func (_m *TrustCenterSubprocessorHistory) Diff(history *TrustCenterSubprocessorHistory) (*HistoryDiff[TrustCenterSubprocessorHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TrustCenterSubprocessorHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterSubprocessorHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *TrustCenterWatermarkConfigHistory) changes(new *TrustCenterWatermarkConfigHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldOwnerID, _m.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(_m.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldTrustCenterID, _m.TrustCenterID, new.TrustCenterID))
	}
	if !reflect.DeepEqual(_m.LogoID, new.LogoID) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldLogoID, _m.LogoID, new.LogoID))
	}
	if !reflect.DeepEqual(_m.Text, new.Text) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldText, _m.Text, new.Text))
	}
	if !reflect.DeepEqual(_m.FontSize, new.FontSize) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldFontSize, _m.FontSize, new.FontSize))
	}
	if !reflect.DeepEqual(_m.Opacity, new.Opacity) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldOpacity, _m.Opacity, new.Opacity))
	}
	if !reflect.DeepEqual(_m.Rotation, new.Rotation) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldRotation, _m.Rotation, new.Rotation))
	}
	if !reflect.DeepEqual(_m.Color, new.Color) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldColor, _m.Color, new.Color))
	}
	if !reflect.DeepEqual(_m.Font, new.Font) {
		changes = append(changes, NewChange(trustcenterwatermarkconfighistory.FieldFont, _m.Font, new.Font))
	}
	return changes
}

func (_m *TrustCenterWatermarkConfigHistory) Diff(history *TrustCenterWatermarkConfigHistory) (*HistoryDiff[TrustCenterWatermarkConfigHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[TrustCenterWatermarkConfigHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterWatermarkConfigHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *UserHistory) changes(new *UserHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(userhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(userhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(userhistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(userhistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(userhistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(userhistory.FieldDisplayID, _m.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(userhistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.Email, new.Email) {
		changes = append(changes, NewChange(userhistory.FieldEmail, _m.Email, new.Email))
	}
	if !reflect.DeepEqual(_m.FirstName, new.FirstName) {
		changes = append(changes, NewChange(userhistory.FieldFirstName, _m.FirstName, new.FirstName))
	}
	if !reflect.DeepEqual(_m.LastName, new.LastName) {
		changes = append(changes, NewChange(userhistory.FieldLastName, _m.LastName, new.LastName))
	}
	if !reflect.DeepEqual(_m.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(userhistory.FieldDisplayName, _m.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(_m.AvatarRemoteURL, new.AvatarRemoteURL) {
		changes = append(changes, NewChange(userhistory.FieldAvatarRemoteURL, _m.AvatarRemoteURL, new.AvatarRemoteURL))
	}
	if !reflect.DeepEqual(_m.AvatarLocalFileID, new.AvatarLocalFileID) {
		changes = append(changes, NewChange(userhistory.FieldAvatarLocalFileID, _m.AvatarLocalFileID, new.AvatarLocalFileID))
	}
	if !reflect.DeepEqual(_m.AvatarUpdatedAt, new.AvatarUpdatedAt) {
		changes = append(changes, NewChange(userhistory.FieldAvatarUpdatedAt, _m.AvatarUpdatedAt, new.AvatarUpdatedAt))
	}
	if !reflect.DeepEqual(_m.LastSeen, new.LastSeen) {
		changes = append(changes, NewChange(userhistory.FieldLastSeen, _m.LastSeen, new.LastSeen))
	}
	if !reflect.DeepEqual(_m.LastLoginProvider, new.LastLoginProvider) {
		changes = append(changes, NewChange(userhistory.FieldLastLoginProvider, _m.LastLoginProvider, new.LastLoginProvider))
	}
	if !reflect.DeepEqual(_m.Password, new.Password) {
		changes = append(changes, NewChange(userhistory.FieldPassword, _m.Password, new.Password))
	}
	if !reflect.DeepEqual(_m.Sub, new.Sub) {
		changes = append(changes, NewChange(userhistory.FieldSub, _m.Sub, new.Sub))
	}
	if !reflect.DeepEqual(_m.AuthProvider, new.AuthProvider) {
		changes = append(changes, NewChange(userhistory.FieldAuthProvider, _m.AuthProvider, new.AuthProvider))
	}
	if !reflect.DeepEqual(_m.Role, new.Role) {
		changes = append(changes, NewChange(userhistory.FieldRole, _m.Role, new.Role))
	}
	return changes
}

func (_m *UserHistory) Diff(history *UserHistory) (*HistoryDiff[UserHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[UserHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[UserHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (_m *UserSettingHistory) changes(new *UserSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(usersettinghistory.FieldCreatedBy, _m.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(_m.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldDeletedAt, _m.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(_m.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(usersettinghistory.FieldDeletedBy, _m.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(_m.Tags, new.Tags) {
		changes = append(changes, NewChange(usersettinghistory.FieldTags, _m.Tags, new.Tags))
	}
	if !reflect.DeepEqual(_m.UserID, new.UserID) {
		changes = append(changes, NewChange(usersettinghistory.FieldUserID, _m.UserID, new.UserID))
	}
	if !reflect.DeepEqual(_m.Locked, new.Locked) {
		changes = append(changes, NewChange(usersettinghistory.FieldLocked, _m.Locked, new.Locked))
	}
	if !reflect.DeepEqual(_m.SilencedAt, new.SilencedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldSilencedAt, _m.SilencedAt, new.SilencedAt))
	}
	if !reflect.DeepEqual(_m.SuspendedAt, new.SuspendedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldSuspendedAt, _m.SuspendedAt, new.SuspendedAt))
	}
	if !reflect.DeepEqual(_m.Status, new.Status) {
		changes = append(changes, NewChange(usersettinghistory.FieldStatus, _m.Status, new.Status))
	}
	if !reflect.DeepEqual(_m.EmailConfirmed, new.EmailConfirmed) {
		changes = append(changes, NewChange(usersettinghistory.FieldEmailConfirmed, _m.EmailConfirmed, new.EmailConfirmed))
	}
	if !reflect.DeepEqual(_m.IsWebauthnAllowed, new.IsWebauthnAllowed) {
		changes = append(changes, NewChange(usersettinghistory.FieldIsWebauthnAllowed, _m.IsWebauthnAllowed, new.IsWebauthnAllowed))
	}
	if !reflect.DeepEqual(_m.IsTfaEnabled, new.IsTfaEnabled) {
		changes = append(changes, NewChange(usersettinghistory.FieldIsTfaEnabled, _m.IsTfaEnabled, new.IsTfaEnabled))
	}
	if !reflect.DeepEqual(_m.PhoneNumber, new.PhoneNumber) {
		changes = append(changes, NewChange(usersettinghistory.FieldPhoneNumber, _m.PhoneNumber, new.PhoneNumber))
	}
	return changes
}

func (_m *UserSettingHistory) Diff(history *UserSettingHistory) (*HistoryDiff[UserSettingHistory], error) {
	if _m.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	_mUnix, historyUnix := _m.HistoryTime.Unix(), history.HistoryTime.Unix()
	_mOlder := _mUnix < historyUnix || (_mUnix == historyUnix && _m.ID < history.ID)
	historyOlder := _mUnix > historyUnix || (_mUnix == historyUnix && _m.ID > history.ID)

	if _mOlder {
		return &HistoryDiff[UserSettingHistory]{
			Old:     _m,
			New:     history,
			Changes: _m.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[UserSettingHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (c Change) String(op history.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case history.OpTypeInsert:
		return fmt.Sprintf("%s: %s", c.FieldName, newstr)
	case history.OpTypeDelete:
		return fmt.Sprintf("%s: %s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %s -> %s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context, after *Cursor, first *int, before *Cursor, last *int) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{}

	var record *AuditLogConnection
	record, err = auditActionPlanHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditAssetHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditContactHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlImplementationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlObjectiveHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditCustomDomainHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditDNSVerificationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditDocumentDataHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditEntityHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditEntityTypeHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditEvidenceHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditFileHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditGroupHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditGroupMembershipHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditGroupSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditHushHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditIntegrationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditInternalPolicyHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditJobTemplateHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditMappableDomainHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditMappedControlHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditNarrativeHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditNoteHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrgMembershipHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrgSubscriptionHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrganizationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrganizationSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditProcedureHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditProgramHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditProgramMembershipHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditRiskHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditScanHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditScheduledJobHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditStandardHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditSubcontrolHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditSubprocessorHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTaskHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTemplateHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterComplianceHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterDocHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterSubprocessorHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterWatermarkConfigHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditUserHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditUserSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	return result, nil
}

func (c *Client) AuditWithFilter(ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, where *AuditLogWhereInput, orderBy *AuditLogOrder) (result *AuditLogConnection, err error) {
	if where.Table == strings.TrimSuffix("ActionPlanHistory", "History") {
		// map AuditLogWhereInput to ActionPlanHistoryWhereInput
		whereInput := &ActionPlanHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ActionPlanHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ActionPlanHistoryOrder{
			Field:     ActionPlanHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditActionPlanHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("AssetHistory", "History") {
		// map AuditLogWhereInput to AssetHistoryWhereInput
		whereInput := &AssetHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to AssetHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &AssetHistoryOrder{
			Field:     AssetHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditAssetHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ContactHistory", "History") {
		// map AuditLogWhereInput to ContactHistoryWhereInput
		whereInput := &ContactHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ContactHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ContactHistoryOrder{
			Field:     ContactHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditContactHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlHistory", "History") {
		// map AuditLogWhereInput to ControlHistoryWhereInput
		whereInput := &ControlHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlHistoryOrder{
			Field:     ControlHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlImplementationHistory", "History") {
		// map AuditLogWhereInput to ControlImplementationHistoryWhereInput
		whereInput := &ControlImplementationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlImplementationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlImplementationHistoryOrder{
			Field:     ControlImplementationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlImplementationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlObjectiveHistory", "History") {
		// map AuditLogWhereInput to ControlObjectiveHistoryWhereInput
		whereInput := &ControlObjectiveHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlObjectiveHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlObjectiveHistoryOrder{
			Field:     ControlObjectiveHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlObjectiveHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("CustomDomainHistory", "History") {
		// map AuditLogWhereInput to CustomDomainHistoryWhereInput
		whereInput := &CustomDomainHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to CustomDomainHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &CustomDomainHistoryOrder{
			Field:     CustomDomainHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditCustomDomainHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("DNSVerificationHistory", "History") {
		// map AuditLogWhereInput to DNSVerificationHistoryWhereInput
		whereInput := &DNSVerificationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to DNSVerificationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &DNSVerificationHistoryOrder{
			Field:     DNSVerificationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditDNSVerificationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("DocumentDataHistory", "History") {
		// map AuditLogWhereInput to DocumentDataHistoryWhereInput
		whereInput := &DocumentDataHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to DocumentDataHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &DocumentDataHistoryOrder{
			Field:     DocumentDataHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditDocumentDataHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("EntityHistory", "History") {
		// map AuditLogWhereInput to EntityHistoryWhereInput
		whereInput := &EntityHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to EntityHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &EntityHistoryOrder{
			Field:     EntityHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditEntityHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("EntityTypeHistory", "History") {
		// map AuditLogWhereInput to EntityTypeHistoryWhereInput
		whereInput := &EntityTypeHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to EntityTypeHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &EntityTypeHistoryOrder{
			Field:     EntityTypeHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditEntityTypeHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("EvidenceHistory", "History") {
		// map AuditLogWhereInput to EvidenceHistoryWhereInput
		whereInput := &EvidenceHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to EvidenceHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &EvidenceHistoryOrder{
			Field:     EvidenceHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditEvidenceHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("FileHistory", "History") {
		// map AuditLogWhereInput to FileHistoryWhereInput
		whereInput := &FileHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to FileHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &FileHistoryOrder{
			Field:     FileHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditFileHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("GroupHistory", "History") {
		// map AuditLogWhereInput to GroupHistoryWhereInput
		whereInput := &GroupHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to GroupHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &GroupHistoryOrder{
			Field:     GroupHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditGroupHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("GroupMembershipHistory", "History") {
		// map AuditLogWhereInput to GroupMembershipHistoryWhereInput
		whereInput := &GroupMembershipHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to GroupMembershipHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &GroupMembershipHistoryOrder{
			Field:     GroupMembershipHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditGroupMembershipHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("GroupSettingHistory", "History") {
		// map AuditLogWhereInput to GroupSettingHistoryWhereInput
		whereInput := &GroupSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to GroupSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &GroupSettingHistoryOrder{
			Field:     GroupSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditGroupSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("HushHistory", "History") {
		// map AuditLogWhereInput to HushHistoryWhereInput
		whereInput := &HushHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to HushHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &HushHistoryOrder{
			Field:     HushHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditHushHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("IntegrationHistory", "History") {
		// map AuditLogWhereInput to IntegrationHistoryWhereInput
		whereInput := &IntegrationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to IntegrationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &IntegrationHistoryOrder{
			Field:     IntegrationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditIntegrationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("InternalPolicyHistory", "History") {
		// map AuditLogWhereInput to InternalPolicyHistoryWhereInput
		whereInput := &InternalPolicyHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to InternalPolicyHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &InternalPolicyHistoryOrder{
			Field:     InternalPolicyHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditInternalPolicyHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("JobTemplateHistory", "History") {
		// map AuditLogWhereInput to JobTemplateHistoryWhereInput
		whereInput := &JobTemplateHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to JobTemplateHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &JobTemplateHistoryOrder{
			Field:     JobTemplateHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditJobTemplateHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("MappableDomainHistory", "History") {
		// map AuditLogWhereInput to MappableDomainHistoryWhereInput
		whereInput := &MappableDomainHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to MappableDomainHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &MappableDomainHistoryOrder{
			Field:     MappableDomainHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditMappableDomainHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("MappedControlHistory", "History") {
		// map AuditLogWhereInput to MappedControlHistoryWhereInput
		whereInput := &MappedControlHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to MappedControlHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &MappedControlHistoryOrder{
			Field:     MappedControlHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditMappedControlHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("NarrativeHistory", "History") {
		// map AuditLogWhereInput to NarrativeHistoryWhereInput
		whereInput := &NarrativeHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to NarrativeHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &NarrativeHistoryOrder{
			Field:     NarrativeHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditNarrativeHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("NoteHistory", "History") {
		// map AuditLogWhereInput to NoteHistoryWhereInput
		whereInput := &NoteHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to NoteHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &NoteHistoryOrder{
			Field:     NoteHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditNoteHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrgMembershipHistory", "History") {
		// map AuditLogWhereInput to OrgMembershipHistoryWhereInput
		whereInput := &OrgMembershipHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrgMembershipHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrgMembershipHistoryOrder{
			Field:     OrgMembershipHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrgMembershipHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrgSubscriptionHistory", "History") {
		// map AuditLogWhereInput to OrgSubscriptionHistoryWhereInput
		whereInput := &OrgSubscriptionHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrgSubscriptionHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrgSubscriptionHistoryOrder{
			Field:     OrgSubscriptionHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrgSubscriptionHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrganizationHistory", "History") {
		// map AuditLogWhereInput to OrganizationHistoryWhereInput
		whereInput := &OrganizationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrganizationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrganizationHistoryOrder{
			Field:     OrganizationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrganizationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrganizationSettingHistory", "History") {
		// map AuditLogWhereInput to OrganizationSettingHistoryWhereInput
		whereInput := &OrganizationSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrganizationSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrganizationSettingHistoryOrder{
			Field:     OrganizationSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrganizationSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ProcedureHistory", "History") {
		// map AuditLogWhereInput to ProcedureHistoryWhereInput
		whereInput := &ProcedureHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ProcedureHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ProcedureHistoryOrder{
			Field:     ProcedureHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditProcedureHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ProgramHistory", "History") {
		// map AuditLogWhereInput to ProgramHistoryWhereInput
		whereInput := &ProgramHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ProgramHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ProgramHistoryOrder{
			Field:     ProgramHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditProgramHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ProgramMembershipHistory", "History") {
		// map AuditLogWhereInput to ProgramMembershipHistoryWhereInput
		whereInput := &ProgramMembershipHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ProgramMembershipHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ProgramMembershipHistoryOrder{
			Field:     ProgramMembershipHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditProgramMembershipHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("RiskHistory", "History") {
		// map AuditLogWhereInput to RiskHistoryWhereInput
		whereInput := &RiskHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to RiskHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &RiskHistoryOrder{
			Field:     RiskHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditRiskHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ScanHistory", "History") {
		// map AuditLogWhereInput to ScanHistoryWhereInput
		whereInput := &ScanHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ScanHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ScanHistoryOrder{
			Field:     ScanHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditScanHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ScheduledJobHistory", "History") {
		// map AuditLogWhereInput to ScheduledJobHistoryWhereInput
		whereInput := &ScheduledJobHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ScheduledJobHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ScheduledJobHistoryOrder{
			Field:     ScheduledJobHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditScheduledJobHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("StandardHistory", "History") {
		// map AuditLogWhereInput to StandardHistoryWhereInput
		whereInput := &StandardHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to StandardHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &StandardHistoryOrder{
			Field:     StandardHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditStandardHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("SubcontrolHistory", "History") {
		// map AuditLogWhereInput to SubcontrolHistoryWhereInput
		whereInput := &SubcontrolHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to SubcontrolHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &SubcontrolHistoryOrder{
			Field:     SubcontrolHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditSubcontrolHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("SubprocessorHistory", "History") {
		// map AuditLogWhereInput to SubprocessorHistoryWhereInput
		whereInput := &SubprocessorHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to SubprocessorHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &SubprocessorHistoryOrder{
			Field:     SubprocessorHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditSubprocessorHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TaskHistory", "History") {
		// map AuditLogWhereInput to TaskHistoryWhereInput
		whereInput := &TaskHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TaskHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TaskHistoryOrder{
			Field:     TaskHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTaskHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TemplateHistory", "History") {
		// map AuditLogWhereInput to TemplateHistoryWhereInput
		whereInput := &TemplateHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TemplateHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TemplateHistoryOrder{
			Field:     TemplateHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTemplateHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterComplianceHistory", "History") {
		// map AuditLogWhereInput to TrustCenterComplianceHistoryWhereInput
		whereInput := &TrustCenterComplianceHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterComplianceHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterComplianceHistoryOrder{
			Field:     TrustCenterComplianceHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterComplianceHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterDocHistory", "History") {
		// map AuditLogWhereInput to TrustCenterDocHistoryWhereInput
		whereInput := &TrustCenterDocHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterDocHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterDocHistoryOrder{
			Field:     TrustCenterDocHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterDocHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterHistory", "History") {
		// map AuditLogWhereInput to TrustCenterHistoryWhereInput
		whereInput := &TrustCenterHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterHistoryOrder{
			Field:     TrustCenterHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterSettingHistory", "History") {
		// map AuditLogWhereInput to TrustCenterSettingHistoryWhereInput
		whereInput := &TrustCenterSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterSettingHistoryOrder{
			Field:     TrustCenterSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterSubprocessorHistory", "History") {
		// map AuditLogWhereInput to TrustCenterSubprocessorHistoryWhereInput
		whereInput := &TrustCenterSubprocessorHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterSubprocessorHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterSubprocessorHistoryOrder{
			Field:     TrustCenterSubprocessorHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterSubprocessorHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterWatermarkConfigHistory", "History") {
		// map AuditLogWhereInput to TrustCenterWatermarkConfigHistoryWhereInput
		whereInput := &TrustCenterWatermarkConfigHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterWatermarkConfigHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterWatermarkConfigHistoryOrder{
			Field:     TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterWatermarkConfigHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("UserHistory", "History") {
		// map AuditLogWhereInput to UserHistoryWhereInput
		whereInput := &UserHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to UserHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &UserHistoryOrder{
			Field:     UserHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditUserHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("UserSettingHistory", "History") {
		// map AuditLogWhereInput to UserSettingHistoryWhereInput
		whereInput := &UserSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to UserSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &UserSettingHistoryOrder{
			Field:     UserSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditUserSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}

	return
}

func (r *AuditLog) toRow() []string {
	row := make([]string, 6)

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefID)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	if r.UpdatedBy != "" {
		row[5] = fmt.Sprintf("%v", r.UpdatedBy)
	}
	return row
}

type actionplanhistoryref struct {
	Ref string
}

func auditActionPlanHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ActionPlanHistoryOrder, where *ActionPlanHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ActionPlanHistoryPaginateOption{
		WithActionPlanHistoryOrder(orderBy),
		WithActionPlanHistoryFilter(where.Filter),
	}

	client := NewActionPlanHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ActionPlanHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ActionPlanHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ActionPlanHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					actionplanhistory.Ref(curr.Node.Ref),
					actionplanhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(actionplanhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ActionPlanHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type assethistoryref struct {
	Ref string
}

func auditAssetHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *AssetHistoryOrder, where *AssetHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []AssetHistoryPaginateOption{
		WithAssetHistoryOrder(orderBy),
		WithAssetHistoryFilter(where.Filter),
	}

	client := NewAssetHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "AssetHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&AssetHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&AssetHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					assethistory.Ref(curr.Node.Ref),
					assethistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(assethistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &AssetHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type contacthistoryref struct {
	Ref string
}

func auditContactHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ContactHistoryOrder, where *ContactHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ContactHistoryPaginateOption{
		WithContactHistoryOrder(orderBy),
		WithContactHistoryFilter(where.Filter),
	}

	client := NewContactHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ContactHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ContactHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ContactHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					contacthistory.Ref(curr.Node.Ref),
					contacthistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(contacthistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ContactHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlhistoryref struct {
	Ref string
}

func auditControlHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlHistoryOrder, where *ControlHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlHistoryPaginateOption{
		WithControlHistoryOrder(orderBy),
		WithControlHistoryFilter(where.Filter),
	}

	client := NewControlHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlhistory.Ref(curr.Node.Ref),
					controlhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlimplementationhistoryref struct {
	Ref string
}

func auditControlImplementationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlImplementationHistoryOrder, where *ControlImplementationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlImplementationHistoryPaginateOption{
		WithControlImplementationHistoryOrder(orderBy),
		WithControlImplementationHistoryFilter(where.Filter),
	}

	client := NewControlImplementationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlImplementationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlImplementationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlImplementationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlimplementationhistory.Ref(curr.Node.Ref),
					controlimplementationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlimplementationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlImplementationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlobjectivehistoryref struct {
	Ref string
}

func auditControlObjectiveHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlObjectiveHistoryOrder, where *ControlObjectiveHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlObjectiveHistoryPaginateOption{
		WithControlObjectiveHistoryOrder(orderBy),
		WithControlObjectiveHistoryFilter(where.Filter),
	}

	client := NewControlObjectiveHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlObjectiveHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlObjectiveHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlObjectiveHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlobjectivehistory.Ref(curr.Node.Ref),
					controlobjectivehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlobjectivehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlObjectiveHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type customdomainhistoryref struct {
	Ref string
}

func auditCustomDomainHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *CustomDomainHistoryOrder, where *CustomDomainHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []CustomDomainHistoryPaginateOption{
		WithCustomDomainHistoryOrder(orderBy),
		WithCustomDomainHistoryFilter(where.Filter),
	}

	client := NewCustomDomainHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "CustomDomainHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&CustomDomainHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&CustomDomainHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					customdomainhistory.Ref(curr.Node.Ref),
					customdomainhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(customdomainhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &CustomDomainHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type dnsverificationhistoryref struct {
	Ref string
}

func auditDNSVerificationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *DNSVerificationHistoryOrder, where *DNSVerificationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []DNSVerificationHistoryPaginateOption{
		WithDNSVerificationHistoryOrder(orderBy),
		WithDNSVerificationHistoryFilter(where.Filter),
	}

	client := NewDNSVerificationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "DNSVerificationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&DNSVerificationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&DNSVerificationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					dnsverificationhistory.Ref(curr.Node.Ref),
					dnsverificationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(dnsverificationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &DNSVerificationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type documentdatahistoryref struct {
	Ref string
}

func auditDocumentDataHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *DocumentDataHistoryOrder, where *DocumentDataHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []DocumentDataHistoryPaginateOption{
		WithDocumentDataHistoryOrder(orderBy),
		WithDocumentDataHistoryFilter(where.Filter),
	}

	client := NewDocumentDataHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "DocumentDataHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&DocumentDataHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&DocumentDataHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					documentdatahistory.Ref(curr.Node.Ref),
					documentdatahistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(documentdatahistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &DocumentDataHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type entityhistoryref struct {
	Ref string
}

func auditEntityHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *EntityHistoryOrder, where *EntityHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []EntityHistoryPaginateOption{
		WithEntityHistoryOrder(orderBy),
		WithEntityHistoryFilter(where.Filter),
	}

	client := NewEntityHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "EntityHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&EntityHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&EntityHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					entityhistory.Ref(curr.Node.Ref),
					entityhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(entityhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &EntityHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type entitytypehistoryref struct {
	Ref string
}

func auditEntityTypeHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *EntityTypeHistoryOrder, where *EntityTypeHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []EntityTypeHistoryPaginateOption{
		WithEntityTypeHistoryOrder(orderBy),
		WithEntityTypeHistoryFilter(where.Filter),
	}

	client := NewEntityTypeHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "EntityTypeHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&EntityTypeHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&EntityTypeHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					entitytypehistory.Ref(curr.Node.Ref),
					entitytypehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(entitytypehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &EntityTypeHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type evidencehistoryref struct {
	Ref string
}

func auditEvidenceHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *EvidenceHistoryOrder, where *EvidenceHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []EvidenceHistoryPaginateOption{
		WithEvidenceHistoryOrder(orderBy),
		WithEvidenceHistoryFilter(where.Filter),
	}

	client := NewEvidenceHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "EvidenceHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&EvidenceHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&EvidenceHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					evidencehistory.Ref(curr.Node.Ref),
					evidencehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(evidencehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &EvidenceHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type filehistoryref struct {
	Ref string
}

func auditFileHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *FileHistoryOrder, where *FileHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []FileHistoryPaginateOption{
		WithFileHistoryOrder(orderBy),
		WithFileHistoryFilter(where.Filter),
	}

	client := NewFileHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "FileHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&FileHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&FileHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					filehistory.Ref(curr.Node.Ref),
					filehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(filehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &FileHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type grouphistoryref struct {
	Ref string
}

func auditGroupHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *GroupHistoryOrder, where *GroupHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []GroupHistoryPaginateOption{
		WithGroupHistoryOrder(orderBy),
		WithGroupHistoryFilter(where.Filter),
	}

	client := NewGroupHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "GroupHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&GroupHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&GroupHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					grouphistory.Ref(curr.Node.Ref),
					grouphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(grouphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &GroupHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type groupmembershiphistoryref struct {
	Ref string
}

func auditGroupMembershipHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *GroupMembershipHistoryOrder, where *GroupMembershipHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []GroupMembershipHistoryPaginateOption{
		WithGroupMembershipHistoryOrder(orderBy),
		WithGroupMembershipHistoryFilter(where.Filter),
	}

	client := NewGroupMembershipHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "GroupMembershipHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&GroupMembershipHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&GroupMembershipHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					groupmembershiphistory.Ref(curr.Node.Ref),
					groupmembershiphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(groupmembershiphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &GroupMembershipHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type groupsettinghistoryref struct {
	Ref string
}

func auditGroupSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *GroupSettingHistoryOrder, where *GroupSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []GroupSettingHistoryPaginateOption{
		WithGroupSettingHistoryOrder(orderBy),
		WithGroupSettingHistoryFilter(where.Filter),
	}

	client := NewGroupSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "GroupSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&GroupSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&GroupSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					groupsettinghistory.Ref(curr.Node.Ref),
					groupsettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(groupsettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &GroupSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type hushhistoryref struct {
	Ref string
}

func auditHushHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *HushHistoryOrder, where *HushHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []HushHistoryPaginateOption{
		WithHushHistoryOrder(orderBy),
		WithHushHistoryFilter(where.Filter),
	}

	client := NewHushHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "HushHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&HushHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&HushHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					hushhistory.Ref(curr.Node.Ref),
					hushhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(hushhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &HushHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type integrationhistoryref struct {
	Ref string
}

func auditIntegrationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *IntegrationHistoryOrder, where *IntegrationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []IntegrationHistoryPaginateOption{
		WithIntegrationHistoryOrder(orderBy),
		WithIntegrationHistoryFilter(where.Filter),
	}

	client := NewIntegrationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "IntegrationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&IntegrationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&IntegrationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					integrationhistory.Ref(curr.Node.Ref),
					integrationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(integrationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &IntegrationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type internalpolicyhistoryref struct {
	Ref string
}

func auditInternalPolicyHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *InternalPolicyHistoryOrder, where *InternalPolicyHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []InternalPolicyHistoryPaginateOption{
		WithInternalPolicyHistoryOrder(orderBy),
		WithInternalPolicyHistoryFilter(where.Filter),
	}

	client := NewInternalPolicyHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "InternalPolicyHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&InternalPolicyHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&InternalPolicyHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					internalpolicyhistory.Ref(curr.Node.Ref),
					internalpolicyhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(internalpolicyhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &InternalPolicyHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type jobtemplatehistoryref struct {
	Ref string
}

func auditJobTemplateHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *JobTemplateHistoryOrder, where *JobTemplateHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []JobTemplateHistoryPaginateOption{
		WithJobTemplateHistoryOrder(orderBy),
		WithJobTemplateHistoryFilter(where.Filter),
	}

	client := NewJobTemplateHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "JobTemplateHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&JobTemplateHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&JobTemplateHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					jobtemplatehistory.Ref(curr.Node.Ref),
					jobtemplatehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(jobtemplatehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &JobTemplateHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type mappabledomainhistoryref struct {
	Ref string
}

func auditMappableDomainHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *MappableDomainHistoryOrder, where *MappableDomainHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []MappableDomainHistoryPaginateOption{
		WithMappableDomainHistoryOrder(orderBy),
		WithMappableDomainHistoryFilter(where.Filter),
	}

	client := NewMappableDomainHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "MappableDomainHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&MappableDomainHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&MappableDomainHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					mappabledomainhistory.Ref(curr.Node.Ref),
					mappabledomainhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(mappabledomainhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &MappableDomainHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type mappedcontrolhistoryref struct {
	Ref string
}

func auditMappedControlHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *MappedControlHistoryOrder, where *MappedControlHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []MappedControlHistoryPaginateOption{
		WithMappedControlHistoryOrder(orderBy),
		WithMappedControlHistoryFilter(where.Filter),
	}

	client := NewMappedControlHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "MappedControlHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&MappedControlHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&MappedControlHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					mappedcontrolhistory.Ref(curr.Node.Ref),
					mappedcontrolhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(mappedcontrolhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &MappedControlHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type narrativehistoryref struct {
	Ref string
}

func auditNarrativeHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *NarrativeHistoryOrder, where *NarrativeHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []NarrativeHistoryPaginateOption{
		WithNarrativeHistoryOrder(orderBy),
		WithNarrativeHistoryFilter(where.Filter),
	}

	client := NewNarrativeHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "NarrativeHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&NarrativeHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&NarrativeHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					narrativehistory.Ref(curr.Node.Ref),
					narrativehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(narrativehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &NarrativeHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type notehistoryref struct {
	Ref string
}

func auditNoteHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *NoteHistoryOrder, where *NoteHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []NoteHistoryPaginateOption{
		WithNoteHistoryOrder(orderBy),
		WithNoteHistoryFilter(where.Filter),
	}

	client := NewNoteHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "NoteHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&NoteHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&NoteHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					notehistory.Ref(curr.Node.Ref),
					notehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(notehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &NoteHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type orgmembershiphistoryref struct {
	Ref string
}

func auditOrgMembershipHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrgMembershipHistoryOrder, where *OrgMembershipHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrgMembershipHistoryPaginateOption{
		WithOrgMembershipHistoryOrder(orderBy),
		WithOrgMembershipHistoryFilter(where.Filter),
	}

	client := NewOrgMembershipHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrgMembershipHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrgMembershipHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrgMembershipHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					orgmembershiphistory.Ref(curr.Node.Ref),
					orgmembershiphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(orgmembershiphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrgMembershipHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type orgsubscriptionhistoryref struct {
	Ref string
}

func auditOrgSubscriptionHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrgSubscriptionHistoryOrder, where *OrgSubscriptionHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrgSubscriptionHistoryPaginateOption{
		WithOrgSubscriptionHistoryOrder(orderBy),
		WithOrgSubscriptionHistoryFilter(where.Filter),
	}

	client := NewOrgSubscriptionHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrgSubscriptionHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrgSubscriptionHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrgSubscriptionHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					orgsubscriptionhistory.Ref(curr.Node.Ref),
					orgsubscriptionhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(orgsubscriptionhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrgSubscriptionHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type organizationhistoryref struct {
	Ref string
}

func auditOrganizationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrganizationHistoryOrder, where *OrganizationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrganizationHistoryPaginateOption{
		WithOrganizationHistoryOrder(orderBy),
		WithOrganizationHistoryFilter(where.Filter),
	}

	client := NewOrganizationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrganizationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrganizationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrganizationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					organizationhistory.Ref(curr.Node.Ref),
					organizationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(organizationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrganizationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type organizationsettinghistoryref struct {
	Ref string
}

func auditOrganizationSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrganizationSettingHistoryOrder, where *OrganizationSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrganizationSettingHistoryPaginateOption{
		WithOrganizationSettingHistoryOrder(orderBy),
		WithOrganizationSettingHistoryFilter(where.Filter),
	}

	client := NewOrganizationSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrganizationSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrganizationSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrganizationSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					organizationsettinghistory.Ref(curr.Node.Ref),
					organizationsettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(organizationsettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrganizationSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type procedurehistoryref struct {
	Ref string
}

func auditProcedureHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ProcedureHistoryOrder, where *ProcedureHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ProcedureHistoryPaginateOption{
		WithProcedureHistoryOrder(orderBy),
		WithProcedureHistoryFilter(where.Filter),
	}

	client := NewProcedureHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ProcedureHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ProcedureHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ProcedureHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					procedurehistory.Ref(curr.Node.Ref),
					procedurehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(procedurehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ProcedureHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type programhistoryref struct {
	Ref string
}

func auditProgramHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ProgramHistoryOrder, where *ProgramHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ProgramHistoryPaginateOption{
		WithProgramHistoryOrder(orderBy),
		WithProgramHistoryFilter(where.Filter),
	}

	client := NewProgramHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ProgramHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ProgramHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ProgramHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					programhistory.Ref(curr.Node.Ref),
					programhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(programhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ProgramHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type programmembershiphistoryref struct {
	Ref string
}

func auditProgramMembershipHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ProgramMembershipHistoryOrder, where *ProgramMembershipHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ProgramMembershipHistoryPaginateOption{
		WithProgramMembershipHistoryOrder(orderBy),
		WithProgramMembershipHistoryFilter(where.Filter),
	}

	client := NewProgramMembershipHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ProgramMembershipHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ProgramMembershipHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ProgramMembershipHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					programmembershiphistory.Ref(curr.Node.Ref),
					programmembershiphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(programmembershiphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ProgramMembershipHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type riskhistoryref struct {
	Ref string
}

func auditRiskHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *RiskHistoryOrder, where *RiskHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []RiskHistoryPaginateOption{
		WithRiskHistoryOrder(orderBy),
		WithRiskHistoryFilter(where.Filter),
	}

	client := NewRiskHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "RiskHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&RiskHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&RiskHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					riskhistory.Ref(curr.Node.Ref),
					riskhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(riskhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &RiskHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type scanhistoryref struct {
	Ref string
}

func auditScanHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ScanHistoryOrder, where *ScanHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ScanHistoryPaginateOption{
		WithScanHistoryOrder(orderBy),
		WithScanHistoryFilter(where.Filter),
	}

	client := NewScanHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ScanHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ScanHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ScanHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					scanhistory.Ref(curr.Node.Ref),
					scanhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(scanhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ScanHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type scheduledjobhistoryref struct {
	Ref string
}

func auditScheduledJobHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ScheduledJobHistoryOrder, where *ScheduledJobHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ScheduledJobHistoryPaginateOption{
		WithScheduledJobHistoryOrder(orderBy),
		WithScheduledJobHistoryFilter(where.Filter),
	}

	client := NewScheduledJobHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ScheduledJobHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ScheduledJobHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ScheduledJobHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					scheduledjobhistory.Ref(curr.Node.Ref),
					scheduledjobhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(scheduledjobhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ScheduledJobHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type standardhistoryref struct {
	Ref string
}

func auditStandardHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *StandardHistoryOrder, where *StandardHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []StandardHistoryPaginateOption{
		WithStandardHistoryOrder(orderBy),
		WithStandardHistoryFilter(where.Filter),
	}

	client := NewStandardHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "StandardHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&StandardHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&StandardHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					standardhistory.Ref(curr.Node.Ref),
					standardhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(standardhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &StandardHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type subcontrolhistoryref struct {
	Ref string
}

func auditSubcontrolHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *SubcontrolHistoryOrder, where *SubcontrolHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []SubcontrolHistoryPaginateOption{
		WithSubcontrolHistoryOrder(orderBy),
		WithSubcontrolHistoryFilter(where.Filter),
	}

	client := NewSubcontrolHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "SubcontrolHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&SubcontrolHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&SubcontrolHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					subcontrolhistory.Ref(curr.Node.Ref),
					subcontrolhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(subcontrolhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &SubcontrolHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type subprocessorhistoryref struct {
	Ref string
}

func auditSubprocessorHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *SubprocessorHistoryOrder, where *SubprocessorHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []SubprocessorHistoryPaginateOption{
		WithSubprocessorHistoryOrder(orderBy),
		WithSubprocessorHistoryFilter(where.Filter),
	}

	client := NewSubprocessorHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "SubprocessorHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&SubprocessorHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&SubprocessorHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					subprocessorhistory.Ref(curr.Node.Ref),
					subprocessorhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(subprocessorhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &SubprocessorHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type taskhistoryref struct {
	Ref string
}

func auditTaskHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TaskHistoryOrder, where *TaskHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TaskHistoryPaginateOption{
		WithTaskHistoryOrder(orderBy),
		WithTaskHistoryFilter(where.Filter),
	}

	client := NewTaskHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TaskHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TaskHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TaskHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					taskhistory.Ref(curr.Node.Ref),
					taskhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(taskhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TaskHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type templatehistoryref struct {
	Ref string
}

func auditTemplateHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TemplateHistoryOrder, where *TemplateHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TemplateHistoryPaginateOption{
		WithTemplateHistoryOrder(orderBy),
		WithTemplateHistoryFilter(where.Filter),
	}

	client := NewTemplateHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TemplateHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TemplateHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TemplateHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					templatehistory.Ref(curr.Node.Ref),
					templatehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(templatehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TemplateHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcentercompliancehistoryref struct {
	Ref string
}

func auditTrustCenterComplianceHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterComplianceHistoryOrder, where *TrustCenterComplianceHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterComplianceHistoryPaginateOption{
		WithTrustCenterComplianceHistoryOrder(orderBy),
		WithTrustCenterComplianceHistoryFilter(where.Filter),
	}

	client := NewTrustCenterComplianceHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterComplianceHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterComplianceHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterComplianceHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcentercompliancehistory.Ref(curr.Node.Ref),
					trustcentercompliancehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcentercompliancehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterComplianceHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcenterdochistoryref struct {
	Ref string
}

func auditTrustCenterDocHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterDocHistoryOrder, where *TrustCenterDocHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterDocHistoryPaginateOption{
		WithTrustCenterDocHistoryOrder(orderBy),
		WithTrustCenterDocHistoryFilter(where.Filter),
	}

	client := NewTrustCenterDocHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterDocHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterDocHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterDocHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcenterdochistory.Ref(curr.Node.Ref),
					trustcenterdochistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcenterdochistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterDocHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcenterhistoryref struct {
	Ref string
}

func auditTrustCenterHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterHistoryOrder, where *TrustCenterHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterHistoryPaginateOption{
		WithTrustCenterHistoryOrder(orderBy),
		WithTrustCenterHistoryFilter(where.Filter),
	}

	client := NewTrustCenterHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcenterhistory.Ref(curr.Node.Ref),
					trustcenterhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcenterhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcentersettinghistoryref struct {
	Ref string
}

func auditTrustCenterSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterSettingHistoryOrder, where *TrustCenterSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterSettingHistoryPaginateOption{
		WithTrustCenterSettingHistoryOrder(orderBy),
		WithTrustCenterSettingHistoryFilter(where.Filter),
	}

	client := NewTrustCenterSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcentersettinghistory.Ref(curr.Node.Ref),
					trustcentersettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcentersettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcentersubprocessorhistoryref struct {
	Ref string
}

func auditTrustCenterSubprocessorHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterSubprocessorHistoryOrder, where *TrustCenterSubprocessorHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterSubprocessorHistoryPaginateOption{
		WithTrustCenterSubprocessorHistoryOrder(orderBy),
		WithTrustCenterSubprocessorHistoryFilter(where.Filter),
	}

	client := NewTrustCenterSubprocessorHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterSubprocessorHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterSubprocessorHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterSubprocessorHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcentersubprocessorhistory.Ref(curr.Node.Ref),
					trustcentersubprocessorhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcentersubprocessorhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterSubprocessorHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcenterwatermarkconfighistoryref struct {
	Ref string
}

func auditTrustCenterWatermarkConfigHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterWatermarkConfigHistoryOrder, where *TrustCenterWatermarkConfigHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterWatermarkConfigHistoryPaginateOption{
		WithTrustCenterWatermarkConfigHistoryOrder(orderBy),
		WithTrustCenterWatermarkConfigHistoryFilter(where.Filter),
	}

	client := NewTrustCenterWatermarkConfigHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterWatermarkConfigHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterWatermarkConfigHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterWatermarkConfigHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcenterwatermarkconfighistory.Ref(curr.Node.Ref),
					trustcenterwatermarkconfighistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcenterwatermarkconfighistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterWatermarkConfigHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type userhistoryref struct {
	Ref string
}

func auditUserHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *UserHistoryOrder, where *UserHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []UserHistoryPaginateOption{
		WithUserHistoryOrder(orderBy),
		WithUserHistoryFilter(where.Filter),
	}

	client := NewUserHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "UserHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&UserHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&UserHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					userhistory.Ref(curr.Node.Ref),
					userhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(userhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &UserHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type usersettinghistoryref struct {
	Ref string
}

func auditUserSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *UserSettingHistoryOrder, where *UserSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []UserSettingHistoryPaginateOption{
		WithUserSettingHistoryOrder(orderBy),
		WithUserSettingHistoryFilter(where.Filter),
	}

	client := NewUserSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "UserSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&UserSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&UserSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					usersettinghistory.Ref(curr.Node.Ref),
					usersettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(usersettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &UserSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}
