// Code generated by entx.history, DO NOT EDIT.
// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strings"
	"time"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/rs/zerolog/log"
	"github.com/theopenlane/entx/history"

	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/assethistory"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/controlscheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/scanhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliancehistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
)

type Change struct {
	FieldName string
	Old       any
	New       any
}

// MarshalGQL implement the Marshaler interface for gqlgen
func (c Change) MarshalGQL(w io.Writer) {
	marshalGQLJSON(w, c)
}

// UnmarshalGQL implement the Unmarshaler interface for gqlgen
func (c *Change) UnmarshalGQL(v interface{}) error {
	return unmarshalGQLJSON(v, c)
}

// MarshalGQL implement the Marshaler interface for gqlgen
func (c AuditLogOrderField) MarshalGQL(w io.Writer) {
	marshalGQLJSON(w, c)
}

// UnmarshalGQL implement the Unmarshaler interface for gqlgen
func (c *AuditLogOrderField) UnmarshalGQL(v interface{}) error {
	return unmarshalGQLJSON(v, c)
}

// marshalGQLJSON marshals the given type into JSON and writes it to the given writer
func marshalGQLJSON[T any](w io.Writer, a T) {
	byteData, err := json.Marshal(a)
	if err != nil {
		log.Fatal().Err(err).Msg("error marshalling json object")
	}

	_, err = w.Write(byteData)
	if err != nil {
		log.Fatal().Err(err).Msg("error writing json object")
	}
}

// unmarshalGQLJSON unmarshals a JSON object into the given type
func unmarshalGQLJSON[T any](v any, a T) error {
	byteData, err := json.Marshal(v)
	if err != nil {
		return err
	}

	err = json.Unmarshal(byteData, &a)
	if err != nil {
		return err
	}

	return nil
}

func NewChange(fieldName string, old, new any) Change {
	return Change{
		FieldName: fieldName,
		Old:       old,
		New:       new,
	}
}

type HistoryDiff[T any] struct {
	Old     *T
	New     *T
	Changes []Change
}

// AuditLog is the representation of an audit log entry.
type AuditLog struct {
	// Table is the name of the table that this audit log entry is for.
	Table string `json:"table"`
	// Ref is the reference ID of the object that this audit log entry is for.
	RefID string `json:"id"`
	// HistoryTime is the time when the history entry was created.
	HistoryTime time.Time `json:"time"`
	// Operation is the type of operation that was performed on the object.
	Operation history.OpType `json:"operation"`
	// Changes is a JSON-encoded string containing the changes made to the object.
	Changes []Change `json:"changes"`
	// UpdatedBy is the user who performed the operation.
	UpdatedBy string `json:"updatedBy"`
}

var auditlogImplementors = []string{"AuditLog", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*AuditLog) IsNode() {}

// AuditLogEdge is the edge representation of AuditLog.
type AuditLogEdge struct {
	Node   *AuditLog `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuditLogConnection is the connection containing edges to AuditLog.
type AuditLogConnection struct {
	Edges      []*AuditLogEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// AuditLogWhereInput is the input type for filtering AuditLog entries
// Table is always required for now due to pagination on a single table
// TODO: (sfunk) use joins to allow for pagination across multiple tables
type AuditLogWhereInput struct {
	RefID     *string         `json:"refID,omitempty"`
	UpdatedBy *string         `json:"updatedBy,omitempty"`
	Operation *history.OpType `json:"operation,omitempty"`
	Table     string          `json:"table"`
	Before    *time.Time      `json:"before,omitempty"`
	After     *time.Time      `json:"after,omitempty"`
}

// AuditLogOrderField defines the ordering field of AuditLog.
type AuditLogOrderField struct {
	// Value extracts the ordering value from the given AuditLog.
	Value    func(*AuditLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) OrderOption
	toCursor func(*AuditLog) Cursor
}

// OrderOption defines the ordering options for the AuditLog queries.
type OrderOption func(*sql.Selector)

// AuditLogOrder defines the ordering of AuditLog.
type AuditLogOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuditLogOrderField `json:"field"`
}

// ByHistoryTime orders the results by the history_time field.
func ByHistoryTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(AuditLogFieldHistoryTime, opts...).ToFunc()
}

const (
	AuditLogFieldHistoryTime = "history_time"
)

var (
	// AuditLogOrderFieldCreatedAt orders AuditLog by history_time.
	AuditLogOrderFieldHistoryTime = &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.HistoryTime, nil
		},
		column: AuditLogFieldHistoryTime,
		toTerm: ByHistoryTime,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{
				ID:    al.RefID,
				Value: al.HistoryTime,
			}
		},
	}
)

var (
	ErrMismatchedRef    = errors.New("cannot take diff of histories with different Refs")
	ErrIdenticalHistory = errors.New("cannot take diff of identical history")
)

func (aph *ActionPlanHistory) changes(new *ActionPlanHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(aph.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(actionplanhistory.FieldCreatedAt, aph.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(aph.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(actionplanhistory.FieldUpdatedAt, aph.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(aph.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(actionplanhistory.FieldCreatedBy, aph.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(aph.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(actionplanhistory.FieldDeletedAt, aph.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(aph.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(actionplanhistory.FieldDeletedBy, aph.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(aph.Tags, new.Tags) {
		changes = append(changes, NewChange(actionplanhistory.FieldTags, aph.Tags, new.Tags))
	}
	if !reflect.DeepEqual(aph.Revision, new.Revision) {
		changes = append(changes, NewChange(actionplanhistory.FieldRevision, aph.Revision, new.Revision))
	}
	if !reflect.DeepEqual(aph.Name, new.Name) {
		changes = append(changes, NewChange(actionplanhistory.FieldName, aph.Name, new.Name))
	}
	if !reflect.DeepEqual(aph.Status, new.Status) {
		changes = append(changes, NewChange(actionplanhistory.FieldStatus, aph.Status, new.Status))
	}
	if !reflect.DeepEqual(aph.ActionPlanType, new.ActionPlanType) {
		changes = append(changes, NewChange(actionplanhistory.FieldActionPlanType, aph.ActionPlanType, new.ActionPlanType))
	}
	if !reflect.DeepEqual(aph.Details, new.Details) {
		changes = append(changes, NewChange(actionplanhistory.FieldDetails, aph.Details, new.Details))
	}
	if !reflect.DeepEqual(aph.ApprovalRequired, new.ApprovalRequired) {
		changes = append(changes, NewChange(actionplanhistory.FieldApprovalRequired, aph.ApprovalRequired, new.ApprovalRequired))
	}
	if !reflect.DeepEqual(aph.ReviewDue, new.ReviewDue) {
		changes = append(changes, NewChange(actionplanhistory.FieldReviewDue, aph.ReviewDue, new.ReviewDue))
	}
	if !reflect.DeepEqual(aph.ReviewFrequency, new.ReviewFrequency) {
		changes = append(changes, NewChange(actionplanhistory.FieldReviewFrequency, aph.ReviewFrequency, new.ReviewFrequency))
	}
	if !reflect.DeepEqual(aph.ApproverID, new.ApproverID) {
		changes = append(changes, NewChange(actionplanhistory.FieldApproverID, aph.ApproverID, new.ApproverID))
	}
	if !reflect.DeepEqual(aph.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(actionplanhistory.FieldDelegateID, aph.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(aph.Summary, new.Summary) {
		changes = append(changes, NewChange(actionplanhistory.FieldSummary, aph.Summary, new.Summary))
	}
	if !reflect.DeepEqual(aph.TagSuggestions, new.TagSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldTagSuggestions, aph.TagSuggestions, new.TagSuggestions))
	}
	if !reflect.DeepEqual(aph.DismissedTagSuggestions, new.DismissedTagSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldDismissedTagSuggestions, aph.DismissedTagSuggestions, new.DismissedTagSuggestions))
	}
	if !reflect.DeepEqual(aph.ControlSuggestions, new.ControlSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldControlSuggestions, aph.ControlSuggestions, new.ControlSuggestions))
	}
	if !reflect.DeepEqual(aph.DismissedControlSuggestions, new.DismissedControlSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldDismissedControlSuggestions, aph.DismissedControlSuggestions, new.DismissedControlSuggestions))
	}
	if !reflect.DeepEqual(aph.ImprovementSuggestions, new.ImprovementSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldImprovementSuggestions, aph.ImprovementSuggestions, new.ImprovementSuggestions))
	}
	if !reflect.DeepEqual(aph.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions) {
		changes = append(changes, NewChange(actionplanhistory.FieldDismissedImprovementSuggestions, aph.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions))
	}
	if !reflect.DeepEqual(aph.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(actionplanhistory.FieldOwnerID, aph.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(aph.DueDate, new.DueDate) {
		changes = append(changes, NewChange(actionplanhistory.FieldDueDate, aph.DueDate, new.DueDate))
	}
	if !reflect.DeepEqual(aph.Priority, new.Priority) {
		changes = append(changes, NewChange(actionplanhistory.FieldPriority, aph.Priority, new.Priority))
	}
	if !reflect.DeepEqual(aph.Source, new.Source) {
		changes = append(changes, NewChange(actionplanhistory.FieldSource, aph.Source, new.Source))
	}
	return changes
}

func (aph *ActionPlanHistory) Diff(history *ActionPlanHistory) (*HistoryDiff[ActionPlanHistory], error) {
	if aph.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	aphUnix, historyUnix := aph.HistoryTime.Unix(), history.HistoryTime.Unix()
	aphOlder := aphUnix < historyUnix || (aphUnix == historyUnix && aph.ID < history.ID)
	historyOlder := aphUnix > historyUnix || (aphUnix == historyUnix && aph.ID > history.ID)

	if aphOlder {
		return &HistoryDiff[ActionPlanHistory]{
			Old:     aph,
			New:     history,
			Changes: aph.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ActionPlanHistory]{
			Old:     history,
			New:     aph,
			Changes: history.changes(aph),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ah *AssetHistory) changes(new *AssetHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ah.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(assethistory.FieldCreatedAt, ah.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ah.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(assethistory.FieldUpdatedAt, ah.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ah.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(assethistory.FieldCreatedBy, ah.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ah.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(assethistory.FieldDeletedAt, ah.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ah.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(assethistory.FieldDeletedBy, ah.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ah.Tags, new.Tags) {
		changes = append(changes, NewChange(assethistory.FieldTags, ah.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ah.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(assethistory.FieldOwnerID, ah.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ah.AssetType, new.AssetType) {
		changes = append(changes, NewChange(assethistory.FieldAssetType, ah.AssetType, new.AssetType))
	}
	if !reflect.DeepEqual(ah.Name, new.Name) {
		changes = append(changes, NewChange(assethistory.FieldName, ah.Name, new.Name))
	}
	if !reflect.DeepEqual(ah.Description, new.Description) {
		changes = append(changes, NewChange(assethistory.FieldDescription, ah.Description, new.Description))
	}
	if !reflect.DeepEqual(ah.Identifier, new.Identifier) {
		changes = append(changes, NewChange(assethistory.FieldIdentifier, ah.Identifier, new.Identifier))
	}
	if !reflect.DeepEqual(ah.Website, new.Website) {
		changes = append(changes, NewChange(assethistory.FieldWebsite, ah.Website, new.Website))
	}
	if !reflect.DeepEqual(ah.Cpe, new.Cpe) {
		changes = append(changes, NewChange(assethistory.FieldCpe, ah.Cpe, new.Cpe))
	}
	if !reflect.DeepEqual(ah.Categories, new.Categories) {
		changes = append(changes, NewChange(assethistory.FieldCategories, ah.Categories, new.Categories))
	}
	return changes
}

func (ah *AssetHistory) Diff(history *AssetHistory) (*HistoryDiff[AssetHistory], error) {
	if ah.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ahUnix, historyUnix := ah.HistoryTime.Unix(), history.HistoryTime.Unix()
	ahOlder := ahUnix < historyUnix || (ahUnix == historyUnix && ah.ID < history.ID)
	historyOlder := ahUnix > historyUnix || (ahUnix == historyUnix && ah.ID > history.ID)

	if ahOlder {
		return &HistoryDiff[AssetHistory]{
			Old:     ah,
			New:     history,
			Changes: ah.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[AssetHistory]{
			Old:     history,
			New:     ah,
			Changes: history.changes(ah),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ch *ContactHistory) changes(new *ContactHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ch.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(contacthistory.FieldCreatedAt, ch.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ch.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(contacthistory.FieldUpdatedAt, ch.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ch.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(contacthistory.FieldCreatedBy, ch.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ch.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(contacthistory.FieldDeletedAt, ch.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ch.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(contacthistory.FieldDeletedBy, ch.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ch.Tags, new.Tags) {
		changes = append(changes, NewChange(contacthistory.FieldTags, ch.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ch.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(contacthistory.FieldOwnerID, ch.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ch.FullName, new.FullName) {
		changes = append(changes, NewChange(contacthistory.FieldFullName, ch.FullName, new.FullName))
	}
	if !reflect.DeepEqual(ch.Title, new.Title) {
		changes = append(changes, NewChange(contacthistory.FieldTitle, ch.Title, new.Title))
	}
	if !reflect.DeepEqual(ch.Company, new.Company) {
		changes = append(changes, NewChange(contacthistory.FieldCompany, ch.Company, new.Company))
	}
	if !reflect.DeepEqual(ch.Email, new.Email) {
		changes = append(changes, NewChange(contacthistory.FieldEmail, ch.Email, new.Email))
	}
	if !reflect.DeepEqual(ch.PhoneNumber, new.PhoneNumber) {
		changes = append(changes, NewChange(contacthistory.FieldPhoneNumber, ch.PhoneNumber, new.PhoneNumber))
	}
	if !reflect.DeepEqual(ch.Address, new.Address) {
		changes = append(changes, NewChange(contacthistory.FieldAddress, ch.Address, new.Address))
	}
	if !reflect.DeepEqual(ch.Status, new.Status) {
		changes = append(changes, NewChange(contacthistory.FieldStatus, ch.Status, new.Status))
	}
	return changes
}

func (ch *ContactHistory) Diff(history *ContactHistory) (*HistoryDiff[ContactHistory], error) {
	if ch.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	chUnix, historyUnix := ch.HistoryTime.Unix(), history.HistoryTime.Unix()
	chOlder := chUnix < historyUnix || (chUnix == historyUnix && ch.ID < history.ID)
	historyOlder := chUnix > historyUnix || (chUnix == historyUnix && ch.ID > history.ID)

	if chOlder {
		return &HistoryDiff[ContactHistory]{
			Old:     ch,
			New:     history,
			Changes: ch.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ContactHistory]{
			Old:     history,
			New:     ch,
			Changes: history.changes(ch),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ch *ControlHistory) changes(new *ControlHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ch.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlhistory.FieldCreatedAt, ch.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ch.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlhistory.FieldUpdatedAt, ch.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ch.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlhistory.FieldCreatedBy, ch.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ch.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlhistory.FieldDeletedAt, ch.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ch.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlhistory.FieldDeletedBy, ch.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ch.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(controlhistory.FieldDisplayID, ch.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(ch.Tags, new.Tags) {
		changes = append(changes, NewChange(controlhistory.FieldTags, ch.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ch.Description, new.Description) {
		changes = append(changes, NewChange(controlhistory.FieldDescription, ch.Description, new.Description))
	}
	if !reflect.DeepEqual(ch.ReferenceID, new.ReferenceID) {
		changes = append(changes, NewChange(controlhistory.FieldReferenceID, ch.ReferenceID, new.ReferenceID))
	}
	if !reflect.DeepEqual(ch.AuditorReferenceID, new.AuditorReferenceID) {
		changes = append(changes, NewChange(controlhistory.FieldAuditorReferenceID, ch.AuditorReferenceID, new.AuditorReferenceID))
	}
	if !reflect.DeepEqual(ch.Status, new.Status) {
		changes = append(changes, NewChange(controlhistory.FieldStatus, ch.Status, new.Status))
	}
	if !reflect.DeepEqual(ch.Source, new.Source) {
		changes = append(changes, NewChange(controlhistory.FieldSource, ch.Source, new.Source))
	}
	if !reflect.DeepEqual(ch.ReferenceFramework, new.ReferenceFramework) {
		changes = append(changes, NewChange(controlhistory.FieldReferenceFramework, ch.ReferenceFramework, new.ReferenceFramework))
	}
	if !reflect.DeepEqual(ch.ControlType, new.ControlType) {
		changes = append(changes, NewChange(controlhistory.FieldControlType, ch.ControlType, new.ControlType))
	}
	if !reflect.DeepEqual(ch.Category, new.Category) {
		changes = append(changes, NewChange(controlhistory.FieldCategory, ch.Category, new.Category))
	}
	if !reflect.DeepEqual(ch.CategoryID, new.CategoryID) {
		changes = append(changes, NewChange(controlhistory.FieldCategoryID, ch.CategoryID, new.CategoryID))
	}
	if !reflect.DeepEqual(ch.Subcategory, new.Subcategory) {
		changes = append(changes, NewChange(controlhistory.FieldSubcategory, ch.Subcategory, new.Subcategory))
	}
	if !reflect.DeepEqual(ch.MappedCategories, new.MappedCategories) {
		changes = append(changes, NewChange(controlhistory.FieldMappedCategories, ch.MappedCategories, new.MappedCategories))
	}
	if !reflect.DeepEqual(ch.AssessmentObjectives, new.AssessmentObjectives) {
		changes = append(changes, NewChange(controlhistory.FieldAssessmentObjectives, ch.AssessmentObjectives, new.AssessmentObjectives))
	}
	if !reflect.DeepEqual(ch.AssessmentMethods, new.AssessmentMethods) {
		changes = append(changes, NewChange(controlhistory.FieldAssessmentMethods, ch.AssessmentMethods, new.AssessmentMethods))
	}
	if !reflect.DeepEqual(ch.ControlQuestions, new.ControlQuestions) {
		changes = append(changes, NewChange(controlhistory.FieldControlQuestions, ch.ControlQuestions, new.ControlQuestions))
	}
	if !reflect.DeepEqual(ch.ImplementationGuidance, new.ImplementationGuidance) {
		changes = append(changes, NewChange(controlhistory.FieldImplementationGuidance, ch.ImplementationGuidance, new.ImplementationGuidance))
	}
	if !reflect.DeepEqual(ch.ExampleEvidence, new.ExampleEvidence) {
		changes = append(changes, NewChange(controlhistory.FieldExampleEvidence, ch.ExampleEvidence, new.ExampleEvidence))
	}
	if !reflect.DeepEqual(ch.References, new.References) {
		changes = append(changes, NewChange(controlhistory.FieldReferences, ch.References, new.References))
	}
	if !reflect.DeepEqual(ch.ControlOwnerID, new.ControlOwnerID) {
		changes = append(changes, NewChange(controlhistory.FieldControlOwnerID, ch.ControlOwnerID, new.ControlOwnerID))
	}
	if !reflect.DeepEqual(ch.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(controlhistory.FieldDelegateID, ch.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(ch.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlhistory.FieldOwnerID, ch.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ch.RefCode, new.RefCode) {
		changes = append(changes, NewChange(controlhistory.FieldRefCode, ch.RefCode, new.RefCode))
	}
	if !reflect.DeepEqual(ch.StandardID, new.StandardID) {
		changes = append(changes, NewChange(controlhistory.FieldStandardID, ch.StandardID, new.StandardID))
	}
	return changes
}

func (ch *ControlHistory) Diff(history *ControlHistory) (*HistoryDiff[ControlHistory], error) {
	if ch.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	chUnix, historyUnix := ch.HistoryTime.Unix(), history.HistoryTime.Unix()
	chOlder := chUnix < historyUnix || (chUnix == historyUnix && ch.ID < history.ID)
	historyOlder := chUnix > historyUnix || (chUnix == historyUnix && ch.ID > history.ID)

	if chOlder {
		return &HistoryDiff[ControlHistory]{
			Old:     ch,
			New:     history,
			Changes: ch.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlHistory]{
			Old:     history,
			New:     ch,
			Changes: history.changes(ch),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (cih *ControlImplementationHistory) changes(new *ControlImplementationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(cih.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldCreatedAt, cih.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(cih.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldUpdatedAt, cih.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(cih.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldCreatedBy, cih.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(cih.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldDeletedAt, cih.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(cih.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldDeletedBy, cih.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(cih.Tags, new.Tags) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldTags, cih.Tags, new.Tags))
	}
	if !reflect.DeepEqual(cih.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldOwnerID, cih.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(cih.Status, new.Status) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldStatus, cih.Status, new.Status))
	}
	if !reflect.DeepEqual(cih.ImplementationDate, new.ImplementationDate) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldImplementationDate, cih.ImplementationDate, new.ImplementationDate))
	}
	if !reflect.DeepEqual(cih.Verified, new.Verified) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldVerified, cih.Verified, new.Verified))
	}
	if !reflect.DeepEqual(cih.VerificationDate, new.VerificationDate) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldVerificationDate, cih.VerificationDate, new.VerificationDate))
	}
	if !reflect.DeepEqual(cih.Details, new.Details) {
		changes = append(changes, NewChange(controlimplementationhistory.FieldDetails, cih.Details, new.Details))
	}
	return changes
}

func (cih *ControlImplementationHistory) Diff(history *ControlImplementationHistory) (*HistoryDiff[ControlImplementationHistory], error) {
	if cih.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	cihUnix, historyUnix := cih.HistoryTime.Unix(), history.HistoryTime.Unix()
	cihOlder := cihUnix < historyUnix || (cihUnix == historyUnix && cih.ID < history.ID)
	historyOlder := cihUnix > historyUnix || (cihUnix == historyUnix && cih.ID > history.ID)

	if cihOlder {
		return &HistoryDiff[ControlImplementationHistory]{
			Old:     cih,
			New:     history,
			Changes: cih.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlImplementationHistory]{
			Old:     history,
			New:     cih,
			Changes: history.changes(cih),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (coh *ControlObjectiveHistory) changes(new *ControlObjectiveHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(coh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldCreatedAt, coh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(coh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldUpdatedAt, coh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(coh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldCreatedBy, coh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(coh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDeletedAt, coh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(coh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDeletedBy, coh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(coh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDisplayID, coh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(coh.Tags, new.Tags) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldTags, coh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(coh.Revision, new.Revision) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldRevision, coh.Revision, new.Revision))
	}
	if !reflect.DeepEqual(coh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldOwnerID, coh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(coh.Name, new.Name) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldName, coh.Name, new.Name))
	}
	if !reflect.DeepEqual(coh.DesiredOutcome, new.DesiredOutcome) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldDesiredOutcome, coh.DesiredOutcome, new.DesiredOutcome))
	}
	if !reflect.DeepEqual(coh.Status, new.Status) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldStatus, coh.Status, new.Status))
	}
	if !reflect.DeepEqual(coh.Source, new.Source) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldSource, coh.Source, new.Source))
	}
	if !reflect.DeepEqual(coh.ControlObjectiveType, new.ControlObjectiveType) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldControlObjectiveType, coh.ControlObjectiveType, new.ControlObjectiveType))
	}
	if !reflect.DeepEqual(coh.Category, new.Category) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldCategory, coh.Category, new.Category))
	}
	if !reflect.DeepEqual(coh.Subcategory, new.Subcategory) {
		changes = append(changes, NewChange(controlobjectivehistory.FieldSubcategory, coh.Subcategory, new.Subcategory))
	}
	return changes
}

func (coh *ControlObjectiveHistory) Diff(history *ControlObjectiveHistory) (*HistoryDiff[ControlObjectiveHistory], error) {
	if coh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	cohUnix, historyUnix := coh.HistoryTime.Unix(), history.HistoryTime.Unix()
	cohOlder := cohUnix < historyUnix || (cohUnix == historyUnix && coh.ID < history.ID)
	historyOlder := cohUnix > historyUnix || (cohUnix == historyUnix && coh.ID > history.ID)

	if cohOlder {
		return &HistoryDiff[ControlObjectiveHistory]{
			Old:     coh,
			New:     history,
			Changes: coh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlObjectiveHistory]{
			Old:     history,
			New:     coh,
			Changes: history.changes(coh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (csjh *ControlScheduledJobHistory) changes(new *ControlScheduledJobHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(csjh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldCreatedAt, csjh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(csjh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldUpdatedAt, csjh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(csjh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldCreatedBy, csjh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(csjh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldDeletedAt, csjh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(csjh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldDeletedBy, csjh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(csjh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldOwnerID, csjh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(csjh.JobID, new.JobID) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldJobID, csjh.JobID, new.JobID))
	}
	if !reflect.DeepEqual(csjh.Configuration, new.Configuration) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldConfiguration, csjh.Configuration, new.Configuration))
	}
	if !reflect.DeepEqual(csjh.Cron, new.Cron) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldCron, csjh.Cron, new.Cron))
	}
	if !reflect.DeepEqual(csjh.JobRunnerID, new.JobRunnerID) {
		changes = append(changes, NewChange(controlscheduledjobhistory.FieldJobRunnerID, csjh.JobRunnerID, new.JobRunnerID))
	}
	return changes
}

func (csjh *ControlScheduledJobHistory) Diff(history *ControlScheduledJobHistory) (*HistoryDiff[ControlScheduledJobHistory], error) {
	if csjh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	csjhUnix, historyUnix := csjh.HistoryTime.Unix(), history.HistoryTime.Unix()
	csjhOlder := csjhUnix < historyUnix || (csjhUnix == historyUnix && csjh.ID < history.ID)
	historyOlder := csjhUnix > historyUnix || (csjhUnix == historyUnix && csjh.ID > history.ID)

	if csjhOlder {
		return &HistoryDiff[ControlScheduledJobHistory]{
			Old:     csjh,
			New:     history,
			Changes: csjh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ControlScheduledJobHistory]{
			Old:     history,
			New:     csjh,
			Changes: history.changes(csjh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (cdh *CustomDomainHistory) changes(new *CustomDomainHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(cdh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(customdomainhistory.FieldCreatedAt, cdh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(cdh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(customdomainhistory.FieldUpdatedAt, cdh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(cdh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(customdomainhistory.FieldCreatedBy, cdh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(cdh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(customdomainhistory.FieldDeletedAt, cdh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(cdh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(customdomainhistory.FieldDeletedBy, cdh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(cdh.Tags, new.Tags) {
		changes = append(changes, NewChange(customdomainhistory.FieldTags, cdh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(cdh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(customdomainhistory.FieldOwnerID, cdh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(cdh.CnameRecord, new.CnameRecord) {
		changes = append(changes, NewChange(customdomainhistory.FieldCnameRecord, cdh.CnameRecord, new.CnameRecord))
	}
	if !reflect.DeepEqual(cdh.MappableDomainID, new.MappableDomainID) {
		changes = append(changes, NewChange(customdomainhistory.FieldMappableDomainID, cdh.MappableDomainID, new.MappableDomainID))
	}
	if !reflect.DeepEqual(cdh.DNSVerificationID, new.DNSVerificationID) {
		changes = append(changes, NewChange(customdomainhistory.FieldDNSVerificationID, cdh.DNSVerificationID, new.DNSVerificationID))
	}
	return changes
}

func (cdh *CustomDomainHistory) Diff(history *CustomDomainHistory) (*HistoryDiff[CustomDomainHistory], error) {
	if cdh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	cdhUnix, historyUnix := cdh.HistoryTime.Unix(), history.HistoryTime.Unix()
	cdhOlder := cdhUnix < historyUnix || (cdhUnix == historyUnix && cdh.ID < history.ID)
	historyOlder := cdhUnix > historyUnix || (cdhUnix == historyUnix && cdh.ID > history.ID)

	if cdhOlder {
		return &HistoryDiff[CustomDomainHistory]{
			Old:     cdh,
			New:     history,
			Changes: cdh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[CustomDomainHistory]{
			Old:     history,
			New:     cdh,
			Changes: history.changes(cdh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (dvh *DNSVerificationHistory) changes(new *DNSVerificationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(dvh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldCreatedAt, dvh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(dvh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldUpdatedAt, dvh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(dvh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldCreatedBy, dvh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(dvh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDeletedAt, dvh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(dvh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDeletedBy, dvh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(dvh.Tags, new.Tags) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldTags, dvh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(dvh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldOwnerID, dvh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(dvh.CloudflareHostnameID, new.CloudflareHostnameID) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldCloudflareHostnameID, dvh.CloudflareHostnameID, new.CloudflareHostnameID))
	}
	if !reflect.DeepEqual(dvh.DNSTxtRecord, new.DNSTxtRecord) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSTxtRecord, dvh.DNSTxtRecord, new.DNSTxtRecord))
	}
	if !reflect.DeepEqual(dvh.DNSTxtValue, new.DNSTxtValue) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSTxtValue, dvh.DNSTxtValue, new.DNSTxtValue))
	}
	if !reflect.DeepEqual(dvh.DNSVerificationStatus, new.DNSVerificationStatus) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSVerificationStatus, dvh.DNSVerificationStatus, new.DNSVerificationStatus))
	}
	if !reflect.DeepEqual(dvh.DNSVerificationStatusReason, new.DNSVerificationStatusReason) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldDNSVerificationStatusReason, dvh.DNSVerificationStatusReason, new.DNSVerificationStatusReason))
	}
	if !reflect.DeepEqual(dvh.AcmeChallengePath, new.AcmeChallengePath) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldAcmeChallengePath, dvh.AcmeChallengePath, new.AcmeChallengePath))
	}
	if !reflect.DeepEqual(dvh.ExpectedAcmeChallengeValue, new.ExpectedAcmeChallengeValue) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldExpectedAcmeChallengeValue, dvh.ExpectedAcmeChallengeValue, new.ExpectedAcmeChallengeValue))
	}
	if !reflect.DeepEqual(dvh.AcmeChallengeStatus, new.AcmeChallengeStatus) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldAcmeChallengeStatus, dvh.AcmeChallengeStatus, new.AcmeChallengeStatus))
	}
	if !reflect.DeepEqual(dvh.AcmeChallengeStatusReason, new.AcmeChallengeStatusReason) {
		changes = append(changes, NewChange(dnsverificationhistory.FieldAcmeChallengeStatusReason, dvh.AcmeChallengeStatusReason, new.AcmeChallengeStatusReason))
	}
	return changes
}

func (dvh *DNSVerificationHistory) Diff(history *DNSVerificationHistory) (*HistoryDiff[DNSVerificationHistory], error) {
	if dvh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	dvhUnix, historyUnix := dvh.HistoryTime.Unix(), history.HistoryTime.Unix()
	dvhOlder := dvhUnix < historyUnix || (dvhUnix == historyUnix && dvh.ID < history.ID)
	historyOlder := dvhUnix > historyUnix || (dvhUnix == historyUnix && dvh.ID > history.ID)

	if dvhOlder {
		return &HistoryDiff[DNSVerificationHistory]{
			Old:     dvh,
			New:     history,
			Changes: dvh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[DNSVerificationHistory]{
			Old:     history,
			New:     dvh,
			Changes: history.changes(dvh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ddh *DocumentDataHistory) changes(new *DocumentDataHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ddh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(documentdatahistory.FieldCreatedAt, ddh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ddh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(documentdatahistory.FieldUpdatedAt, ddh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ddh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(documentdatahistory.FieldCreatedBy, ddh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ddh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(documentdatahistory.FieldDeletedAt, ddh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ddh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(documentdatahistory.FieldDeletedBy, ddh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ddh.Tags, new.Tags) {
		changes = append(changes, NewChange(documentdatahistory.FieldTags, ddh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ddh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(documentdatahistory.FieldOwnerID, ddh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ddh.TemplateID, new.TemplateID) {
		changes = append(changes, NewChange(documentdatahistory.FieldTemplateID, ddh.TemplateID, new.TemplateID))
	}
	if !reflect.DeepEqual(ddh.Data, new.Data) {
		changes = append(changes, NewChange(documentdatahistory.FieldData, ddh.Data, new.Data))
	}
	return changes
}

func (ddh *DocumentDataHistory) Diff(history *DocumentDataHistory) (*HistoryDiff[DocumentDataHistory], error) {
	if ddh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ddhUnix, historyUnix := ddh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ddhOlder := ddhUnix < historyUnix || (ddhUnix == historyUnix && ddh.ID < history.ID)
	historyOlder := ddhUnix > historyUnix || (ddhUnix == historyUnix && ddh.ID > history.ID)

	if ddhOlder {
		return &HistoryDiff[DocumentDataHistory]{
			Old:     ddh,
			New:     history,
			Changes: ddh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[DocumentDataHistory]{
			Old:     history,
			New:     ddh,
			Changes: history.changes(ddh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (eh *EntityHistory) changes(new *EntityHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(eh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(entityhistory.FieldCreatedAt, eh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(eh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(entityhistory.FieldUpdatedAt, eh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(eh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(entityhistory.FieldCreatedBy, eh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(eh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(entityhistory.FieldDeletedAt, eh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(eh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(entityhistory.FieldDeletedBy, eh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(eh.Tags, new.Tags) {
		changes = append(changes, NewChange(entityhistory.FieldTags, eh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(eh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(entityhistory.FieldOwnerID, eh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(eh.Name, new.Name) {
		changes = append(changes, NewChange(entityhistory.FieldName, eh.Name, new.Name))
	}
	if !reflect.DeepEqual(eh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(entityhistory.FieldDisplayName, eh.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(eh.Description, new.Description) {
		changes = append(changes, NewChange(entityhistory.FieldDescription, eh.Description, new.Description))
	}
	if !reflect.DeepEqual(eh.Domains, new.Domains) {
		changes = append(changes, NewChange(entityhistory.FieldDomains, eh.Domains, new.Domains))
	}
	if !reflect.DeepEqual(eh.EntityTypeID, new.EntityTypeID) {
		changes = append(changes, NewChange(entityhistory.FieldEntityTypeID, eh.EntityTypeID, new.EntityTypeID))
	}
	if !reflect.DeepEqual(eh.Status, new.Status) {
		changes = append(changes, NewChange(entityhistory.FieldStatus, eh.Status, new.Status))
	}
	return changes
}

func (eh *EntityHistory) Diff(history *EntityHistory) (*HistoryDiff[EntityHistory], error) {
	if eh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ehUnix, historyUnix := eh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ehOlder := ehUnix < historyUnix || (ehUnix == historyUnix && eh.ID < history.ID)
	historyOlder := ehUnix > historyUnix || (ehUnix == historyUnix && eh.ID > history.ID)

	if ehOlder {
		return &HistoryDiff[EntityHistory]{
			Old:     eh,
			New:     history,
			Changes: eh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EntityHistory]{
			Old:     history,
			New:     eh,
			Changes: history.changes(eh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (eth *EntityTypeHistory) changes(new *EntityTypeHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(eth.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(entitytypehistory.FieldCreatedAt, eth.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(eth.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(entitytypehistory.FieldUpdatedAt, eth.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(eth.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(entitytypehistory.FieldCreatedBy, eth.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(eth.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(entitytypehistory.FieldDeletedAt, eth.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(eth.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(entitytypehistory.FieldDeletedBy, eth.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(eth.Tags, new.Tags) {
		changes = append(changes, NewChange(entitytypehistory.FieldTags, eth.Tags, new.Tags))
	}
	if !reflect.DeepEqual(eth.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(entitytypehistory.FieldOwnerID, eth.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(eth.Name, new.Name) {
		changes = append(changes, NewChange(entitytypehistory.FieldName, eth.Name, new.Name))
	}
	return changes
}

func (eth *EntityTypeHistory) Diff(history *EntityTypeHistory) (*HistoryDiff[EntityTypeHistory], error) {
	if eth.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ethUnix, historyUnix := eth.HistoryTime.Unix(), history.HistoryTime.Unix()
	ethOlder := ethUnix < historyUnix || (ethUnix == historyUnix && eth.ID < history.ID)
	historyOlder := ethUnix > historyUnix || (ethUnix == historyUnix && eth.ID > history.ID)

	if ethOlder {
		return &HistoryDiff[EntityTypeHistory]{
			Old:     eth,
			New:     history,
			Changes: eth.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EntityTypeHistory]{
			Old:     history,
			New:     eth,
			Changes: history.changes(eth),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (eh *EvidenceHistory) changes(new *EvidenceHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(eh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(evidencehistory.FieldCreatedAt, eh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(eh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(evidencehistory.FieldUpdatedAt, eh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(eh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(evidencehistory.FieldCreatedBy, eh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(eh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(evidencehistory.FieldDeletedAt, eh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(eh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(evidencehistory.FieldDeletedBy, eh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(eh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(evidencehistory.FieldDisplayID, eh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(eh.Tags, new.Tags) {
		changes = append(changes, NewChange(evidencehistory.FieldTags, eh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(eh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(evidencehistory.FieldOwnerID, eh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(eh.Name, new.Name) {
		changes = append(changes, NewChange(evidencehistory.FieldName, eh.Name, new.Name))
	}
	if !reflect.DeepEqual(eh.Description, new.Description) {
		changes = append(changes, NewChange(evidencehistory.FieldDescription, eh.Description, new.Description))
	}
	if !reflect.DeepEqual(eh.CollectionProcedure, new.CollectionProcedure) {
		changes = append(changes, NewChange(evidencehistory.FieldCollectionProcedure, eh.CollectionProcedure, new.CollectionProcedure))
	}
	if !reflect.DeepEqual(eh.CreationDate, new.CreationDate) {
		changes = append(changes, NewChange(evidencehistory.FieldCreationDate, eh.CreationDate, new.CreationDate))
	}
	if !reflect.DeepEqual(eh.RenewalDate, new.RenewalDate) {
		changes = append(changes, NewChange(evidencehistory.FieldRenewalDate, eh.RenewalDate, new.RenewalDate))
	}
	if !reflect.DeepEqual(eh.Source, new.Source) {
		changes = append(changes, NewChange(evidencehistory.FieldSource, eh.Source, new.Source))
	}
	if !reflect.DeepEqual(eh.IsAutomated, new.IsAutomated) {
		changes = append(changes, NewChange(evidencehistory.FieldIsAutomated, eh.IsAutomated, new.IsAutomated))
	}
	if !reflect.DeepEqual(eh.URL, new.URL) {
		changes = append(changes, NewChange(evidencehistory.FieldURL, eh.URL, new.URL))
	}
	if !reflect.DeepEqual(eh.Status, new.Status) {
		changes = append(changes, NewChange(evidencehistory.FieldStatus, eh.Status, new.Status))
	}
	return changes
}

func (eh *EvidenceHistory) Diff(history *EvidenceHistory) (*HistoryDiff[EvidenceHistory], error) {
	if eh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ehUnix, historyUnix := eh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ehOlder := ehUnix < historyUnix || (ehUnix == historyUnix && eh.ID < history.ID)
	historyOlder := ehUnix > historyUnix || (ehUnix == historyUnix && eh.ID > history.ID)

	if ehOlder {
		return &HistoryDiff[EvidenceHistory]{
			Old:     eh,
			New:     history,
			Changes: eh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[EvidenceHistory]{
			Old:     history,
			New:     eh,
			Changes: history.changes(eh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (fh *FileHistory) changes(new *FileHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(fh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(filehistory.FieldCreatedAt, fh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(fh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(filehistory.FieldUpdatedAt, fh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(fh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(filehistory.FieldCreatedBy, fh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(fh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(filehistory.FieldDeletedAt, fh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(fh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(filehistory.FieldDeletedBy, fh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(fh.Tags, new.Tags) {
		changes = append(changes, NewChange(filehistory.FieldTags, fh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(fh.ProvidedFileName, new.ProvidedFileName) {
		changes = append(changes, NewChange(filehistory.FieldProvidedFileName, fh.ProvidedFileName, new.ProvidedFileName))
	}
	if !reflect.DeepEqual(fh.ProvidedFileExtension, new.ProvidedFileExtension) {
		changes = append(changes, NewChange(filehistory.FieldProvidedFileExtension, fh.ProvidedFileExtension, new.ProvidedFileExtension))
	}
	if !reflect.DeepEqual(fh.ProvidedFileSize, new.ProvidedFileSize) {
		changes = append(changes, NewChange(filehistory.FieldProvidedFileSize, fh.ProvidedFileSize, new.ProvidedFileSize))
	}
	if !reflect.DeepEqual(fh.PersistedFileSize, new.PersistedFileSize) {
		changes = append(changes, NewChange(filehistory.FieldPersistedFileSize, fh.PersistedFileSize, new.PersistedFileSize))
	}
	if !reflect.DeepEqual(fh.DetectedMimeType, new.DetectedMimeType) {
		changes = append(changes, NewChange(filehistory.FieldDetectedMimeType, fh.DetectedMimeType, new.DetectedMimeType))
	}
	if !reflect.DeepEqual(fh.Md5Hash, new.Md5Hash) {
		changes = append(changes, NewChange(filehistory.FieldMd5Hash, fh.Md5Hash, new.Md5Hash))
	}
	if !reflect.DeepEqual(fh.DetectedContentType, new.DetectedContentType) {
		changes = append(changes, NewChange(filehistory.FieldDetectedContentType, fh.DetectedContentType, new.DetectedContentType))
	}
	if !reflect.DeepEqual(fh.StoreKey, new.StoreKey) {
		changes = append(changes, NewChange(filehistory.FieldStoreKey, fh.StoreKey, new.StoreKey))
	}
	if !reflect.DeepEqual(fh.CategoryType, new.CategoryType) {
		changes = append(changes, NewChange(filehistory.FieldCategoryType, fh.CategoryType, new.CategoryType))
	}
	if !reflect.DeepEqual(fh.URI, new.URI) {
		changes = append(changes, NewChange(filehistory.FieldURI, fh.URI, new.URI))
	}
	if !reflect.DeepEqual(fh.StorageScheme, new.StorageScheme) {
		changes = append(changes, NewChange(filehistory.FieldStorageScheme, fh.StorageScheme, new.StorageScheme))
	}
	if !reflect.DeepEqual(fh.StorageVolume, new.StorageVolume) {
		changes = append(changes, NewChange(filehistory.FieldStorageVolume, fh.StorageVolume, new.StorageVolume))
	}
	if !reflect.DeepEqual(fh.StoragePath, new.StoragePath) {
		changes = append(changes, NewChange(filehistory.FieldStoragePath, fh.StoragePath, new.StoragePath))
	}
	if !reflect.DeepEqual(fh.FileContents, new.FileContents) {
		changes = append(changes, NewChange(filehistory.FieldFileContents, fh.FileContents, new.FileContents))
	}
	return changes
}

func (fh *FileHistory) Diff(history *FileHistory) (*HistoryDiff[FileHistory], error) {
	if fh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	fhUnix, historyUnix := fh.HistoryTime.Unix(), history.HistoryTime.Unix()
	fhOlder := fhUnix < historyUnix || (fhUnix == historyUnix && fh.ID < history.ID)
	historyOlder := fhUnix > historyUnix || (fhUnix == historyUnix && fh.ID > history.ID)

	if fhOlder {
		return &HistoryDiff[FileHistory]{
			Old:     fh,
			New:     history,
			Changes: fh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[FileHistory]{
			Old:     history,
			New:     fh,
			Changes: history.changes(fh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (gh *GroupHistory) changes(new *GroupHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(gh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(grouphistory.FieldCreatedAt, gh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(gh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(grouphistory.FieldUpdatedAt, gh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(gh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(grouphistory.FieldCreatedBy, gh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(gh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(grouphistory.FieldDeletedAt, gh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(gh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(grouphistory.FieldDeletedBy, gh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(gh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(grouphistory.FieldDisplayID, gh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(gh.Tags, new.Tags) {
		changes = append(changes, NewChange(grouphistory.FieldTags, gh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(gh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(grouphistory.FieldOwnerID, gh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(gh.Name, new.Name) {
		changes = append(changes, NewChange(grouphistory.FieldName, gh.Name, new.Name))
	}
	if !reflect.DeepEqual(gh.Description, new.Description) {
		changes = append(changes, NewChange(grouphistory.FieldDescription, gh.Description, new.Description))
	}
	if !reflect.DeepEqual(gh.IsManaged, new.IsManaged) {
		changes = append(changes, NewChange(grouphistory.FieldIsManaged, gh.IsManaged, new.IsManaged))
	}
	if !reflect.DeepEqual(gh.GravatarLogoURL, new.GravatarLogoURL) {
		changes = append(changes, NewChange(grouphistory.FieldGravatarLogoURL, gh.GravatarLogoURL, new.GravatarLogoURL))
	}
	if !reflect.DeepEqual(gh.LogoURL, new.LogoURL) {
		changes = append(changes, NewChange(grouphistory.FieldLogoURL, gh.LogoURL, new.LogoURL))
	}
	if !reflect.DeepEqual(gh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(grouphistory.FieldDisplayName, gh.DisplayName, new.DisplayName))
	}
	return changes
}

func (gh *GroupHistory) Diff(history *GroupHistory) (*HistoryDiff[GroupHistory], error) {
	if gh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ghUnix, historyUnix := gh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ghOlder := ghUnix < historyUnix || (ghUnix == historyUnix && gh.ID < history.ID)
	historyOlder := ghUnix > historyUnix || (ghUnix == historyUnix && gh.ID > history.ID)

	if ghOlder {
		return &HistoryDiff[GroupHistory]{
			Old:     gh,
			New:     history,
			Changes: gh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupHistory]{
			Old:     history,
			New:     gh,
			Changes: history.changes(gh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (gmh *GroupMembershipHistory) changes(new *GroupMembershipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(gmh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldCreatedAt, gmh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(gmh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldUpdatedAt, gmh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(gmh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldCreatedBy, gmh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(gmh.Role, new.Role) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldRole, gmh.Role, new.Role))
	}
	if !reflect.DeepEqual(gmh.GroupID, new.GroupID) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldGroupID, gmh.GroupID, new.GroupID))
	}
	if !reflect.DeepEqual(gmh.UserID, new.UserID) {
		changes = append(changes, NewChange(groupmembershiphistory.FieldUserID, gmh.UserID, new.UserID))
	}
	return changes
}

func (gmh *GroupMembershipHistory) Diff(history *GroupMembershipHistory) (*HistoryDiff[GroupMembershipHistory], error) {
	if gmh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	gmhUnix, historyUnix := gmh.HistoryTime.Unix(), history.HistoryTime.Unix()
	gmhOlder := gmhUnix < historyUnix || (gmhUnix == historyUnix && gmh.ID < history.ID)
	historyOlder := gmhUnix > historyUnix || (gmhUnix == historyUnix && gmh.ID > history.ID)

	if gmhOlder {
		return &HistoryDiff[GroupMembershipHistory]{
			Old:     gmh,
			New:     history,
			Changes: gmh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupMembershipHistory]{
			Old:     history,
			New:     gmh,
			Changes: history.changes(gmh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (gsh *GroupSettingHistory) changes(new *GroupSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(gsh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldCreatedAt, gsh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(gsh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldUpdatedAt, gsh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(gsh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldCreatedBy, gsh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(gsh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(groupsettinghistory.FieldDeletedAt, gsh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(gsh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldDeletedBy, gsh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(gsh.Visibility, new.Visibility) {
		changes = append(changes, NewChange(groupsettinghistory.FieldVisibility, gsh.Visibility, new.Visibility))
	}
	if !reflect.DeepEqual(gsh.JoinPolicy, new.JoinPolicy) {
		changes = append(changes, NewChange(groupsettinghistory.FieldJoinPolicy, gsh.JoinPolicy, new.JoinPolicy))
	}
	if !reflect.DeepEqual(gsh.SyncToSlack, new.SyncToSlack) {
		changes = append(changes, NewChange(groupsettinghistory.FieldSyncToSlack, gsh.SyncToSlack, new.SyncToSlack))
	}
	if !reflect.DeepEqual(gsh.SyncToGithub, new.SyncToGithub) {
		changes = append(changes, NewChange(groupsettinghistory.FieldSyncToGithub, gsh.SyncToGithub, new.SyncToGithub))
	}
	if !reflect.DeepEqual(gsh.GroupID, new.GroupID) {
		changes = append(changes, NewChange(groupsettinghistory.FieldGroupID, gsh.GroupID, new.GroupID))
	}
	return changes
}

func (gsh *GroupSettingHistory) Diff(history *GroupSettingHistory) (*HistoryDiff[GroupSettingHistory], error) {
	if gsh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	gshUnix, historyUnix := gsh.HistoryTime.Unix(), history.HistoryTime.Unix()
	gshOlder := gshUnix < historyUnix || (gshUnix == historyUnix && gsh.ID < history.ID)
	historyOlder := gshUnix > historyUnix || (gshUnix == historyUnix && gsh.ID > history.ID)

	if gshOlder {
		return &HistoryDiff[GroupSettingHistory]{
			Old:     gsh,
			New:     history,
			Changes: gsh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[GroupSettingHistory]{
			Old:     history,
			New:     gsh,
			Changes: history.changes(gsh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (hh *HushHistory) changes(new *HushHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(hh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(hushhistory.FieldCreatedAt, hh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(hh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(hushhistory.FieldUpdatedAt, hh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(hh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(hushhistory.FieldCreatedBy, hh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(hh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(hushhistory.FieldDeletedAt, hh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(hh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(hushhistory.FieldDeletedBy, hh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(hh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(hushhistory.FieldOwnerID, hh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(hh.Name, new.Name) {
		changes = append(changes, NewChange(hushhistory.FieldName, hh.Name, new.Name))
	}
	if !reflect.DeepEqual(hh.Description, new.Description) {
		changes = append(changes, NewChange(hushhistory.FieldDescription, hh.Description, new.Description))
	}
	if !reflect.DeepEqual(hh.Kind, new.Kind) {
		changes = append(changes, NewChange(hushhistory.FieldKind, hh.Kind, new.Kind))
	}
	if !reflect.DeepEqual(hh.SecretName, new.SecretName) {
		changes = append(changes, NewChange(hushhistory.FieldSecretName, hh.SecretName, new.SecretName))
	}
	if !reflect.DeepEqual(hh.SecretValue, new.SecretValue) {
		changes = append(changes, NewChange(hushhistory.FieldSecretValue, hh.SecretValue, new.SecretValue))
	}
	return changes
}

func (hh *HushHistory) Diff(history *HushHistory) (*HistoryDiff[HushHistory], error) {
	if hh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	hhUnix, historyUnix := hh.HistoryTime.Unix(), history.HistoryTime.Unix()
	hhOlder := hhUnix < historyUnix || (hhUnix == historyUnix && hh.ID < history.ID)
	historyOlder := hhUnix > historyUnix || (hhUnix == historyUnix && hh.ID > history.ID)

	if hhOlder {
		return &HistoryDiff[HushHistory]{
			Old:     hh,
			New:     history,
			Changes: hh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[HushHistory]{
			Old:     history,
			New:     hh,
			Changes: history.changes(hh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ih *IntegrationHistory) changes(new *IntegrationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ih.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldCreatedAt, ih.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ih.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldUpdatedAt, ih.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ih.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(integrationhistory.FieldCreatedBy, ih.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ih.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(integrationhistory.FieldDeletedAt, ih.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ih.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(integrationhistory.FieldDeletedBy, ih.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ih.Tags, new.Tags) {
		changes = append(changes, NewChange(integrationhistory.FieldTags, ih.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ih.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(integrationhistory.FieldOwnerID, ih.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ih.Name, new.Name) {
		changes = append(changes, NewChange(integrationhistory.FieldName, ih.Name, new.Name))
	}
	if !reflect.DeepEqual(ih.Description, new.Description) {
		changes = append(changes, NewChange(integrationhistory.FieldDescription, ih.Description, new.Description))
	}
	if !reflect.DeepEqual(ih.Kind, new.Kind) {
		changes = append(changes, NewChange(integrationhistory.FieldKind, ih.Kind, new.Kind))
	}
	return changes
}

func (ih *IntegrationHistory) Diff(history *IntegrationHistory) (*HistoryDiff[IntegrationHistory], error) {
	if ih.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ihUnix, historyUnix := ih.HistoryTime.Unix(), history.HistoryTime.Unix()
	ihOlder := ihUnix < historyUnix || (ihUnix == historyUnix && ih.ID < history.ID)
	historyOlder := ihUnix > historyUnix || (ihUnix == historyUnix && ih.ID > history.ID)

	if ihOlder {
		return &HistoryDiff[IntegrationHistory]{
			Old:     ih,
			New:     history,
			Changes: ih.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[IntegrationHistory]{
			Old:     history,
			New:     ih,
			Changes: history.changes(ih),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (iph *InternalPolicyHistory) changes(new *InternalPolicyHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(iph.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldCreatedAt, iph.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(iph.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldUpdatedAt, iph.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(iph.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldCreatedBy, iph.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(iph.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDeletedAt, iph.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(iph.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDeletedBy, iph.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(iph.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDisplayID, iph.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(iph.Tags, new.Tags) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldTags, iph.Tags, new.Tags))
	}
	if !reflect.DeepEqual(iph.Revision, new.Revision) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldRevision, iph.Revision, new.Revision))
	}
	if !reflect.DeepEqual(iph.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldOwnerID, iph.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(iph.Name, new.Name) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldName, iph.Name, new.Name))
	}
	if !reflect.DeepEqual(iph.Status, new.Status) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldStatus, iph.Status, new.Status))
	}
	if !reflect.DeepEqual(iph.PolicyType, new.PolicyType) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldPolicyType, iph.PolicyType, new.PolicyType))
	}
	if !reflect.DeepEqual(iph.Details, new.Details) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDetails, iph.Details, new.Details))
	}
	if !reflect.DeepEqual(iph.ApprovalRequired, new.ApprovalRequired) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldApprovalRequired, iph.ApprovalRequired, new.ApprovalRequired))
	}
	if !reflect.DeepEqual(iph.ReviewDue, new.ReviewDue) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldReviewDue, iph.ReviewDue, new.ReviewDue))
	}
	if !reflect.DeepEqual(iph.ReviewFrequency, new.ReviewFrequency) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldReviewFrequency, iph.ReviewFrequency, new.ReviewFrequency))
	}
	if !reflect.DeepEqual(iph.ApproverID, new.ApproverID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldApproverID, iph.ApproverID, new.ApproverID))
	}
	if !reflect.DeepEqual(iph.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDelegateID, iph.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(iph.Summary, new.Summary) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldSummary, iph.Summary, new.Summary))
	}
	if !reflect.DeepEqual(iph.TagSuggestions, new.TagSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldTagSuggestions, iph.TagSuggestions, new.TagSuggestions))
	}
	if !reflect.DeepEqual(iph.DismissedTagSuggestions, new.DismissedTagSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDismissedTagSuggestions, iph.DismissedTagSuggestions, new.DismissedTagSuggestions))
	}
	if !reflect.DeepEqual(iph.ControlSuggestions, new.ControlSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldControlSuggestions, iph.ControlSuggestions, new.ControlSuggestions))
	}
	if !reflect.DeepEqual(iph.DismissedControlSuggestions, new.DismissedControlSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDismissedControlSuggestions, iph.DismissedControlSuggestions, new.DismissedControlSuggestions))
	}
	if !reflect.DeepEqual(iph.ImprovementSuggestions, new.ImprovementSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldImprovementSuggestions, iph.ImprovementSuggestions, new.ImprovementSuggestions))
	}
	if !reflect.DeepEqual(iph.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions) {
		changes = append(changes, NewChange(internalpolicyhistory.FieldDismissedImprovementSuggestions, iph.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions))
	}
	return changes
}

func (iph *InternalPolicyHistory) Diff(history *InternalPolicyHistory) (*HistoryDiff[InternalPolicyHistory], error) {
	if iph.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	iphUnix, historyUnix := iph.HistoryTime.Unix(), history.HistoryTime.Unix()
	iphOlder := iphUnix < historyUnix || (iphUnix == historyUnix && iph.ID < history.ID)
	historyOlder := iphUnix > historyUnix || (iphUnix == historyUnix && iph.ID > history.ID)

	if iphOlder {
		return &HistoryDiff[InternalPolicyHistory]{
			Old:     iph,
			New:     history,
			Changes: iph.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[InternalPolicyHistory]{
			Old:     history,
			New:     iph,
			Changes: history.changes(iph),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (mdh *MappableDomainHistory) changes(new *MappableDomainHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(mdh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldCreatedAt, mdh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(mdh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldUpdatedAt, mdh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(mdh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldCreatedBy, mdh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(mdh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldDeletedAt, mdh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(mdh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldDeletedBy, mdh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(mdh.Tags, new.Tags) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldTags, mdh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(mdh.Name, new.Name) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldName, mdh.Name, new.Name))
	}
	if !reflect.DeepEqual(mdh.ZoneID, new.ZoneID) {
		changes = append(changes, NewChange(mappabledomainhistory.FieldZoneID, mdh.ZoneID, new.ZoneID))
	}
	return changes
}

func (mdh *MappableDomainHistory) Diff(history *MappableDomainHistory) (*HistoryDiff[MappableDomainHistory], error) {
	if mdh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	mdhUnix, historyUnix := mdh.HistoryTime.Unix(), history.HistoryTime.Unix()
	mdhOlder := mdhUnix < historyUnix || (mdhUnix == historyUnix && mdh.ID < history.ID)
	historyOlder := mdhUnix > historyUnix || (mdhUnix == historyUnix && mdh.ID > history.ID)

	if mdhOlder {
		return &HistoryDiff[MappableDomainHistory]{
			Old:     mdh,
			New:     history,
			Changes: mdh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[MappableDomainHistory]{
			Old:     history,
			New:     mdh,
			Changes: history.changes(mdh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (mch *MappedControlHistory) changes(new *MappedControlHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(mch.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldCreatedAt, mch.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(mch.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldUpdatedAt, mch.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(mch.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldCreatedBy, mch.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(mch.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldDeletedAt, mch.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(mch.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldDeletedBy, mch.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(mch.Tags, new.Tags) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldTags, mch.Tags, new.Tags))
	}
	if !reflect.DeepEqual(mch.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldOwnerID, mch.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(mch.MappingType, new.MappingType) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldMappingType, mch.MappingType, new.MappingType))
	}
	if !reflect.DeepEqual(mch.Relation, new.Relation) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldRelation, mch.Relation, new.Relation))
	}
	if !reflect.DeepEqual(mch.Confidence, new.Confidence) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldConfidence, mch.Confidence, new.Confidence))
	}
	if !reflect.DeepEqual(mch.Source, new.Source) {
		changes = append(changes, NewChange(mappedcontrolhistory.FieldSource, mch.Source, new.Source))
	}
	return changes
}

func (mch *MappedControlHistory) Diff(history *MappedControlHistory) (*HistoryDiff[MappedControlHistory], error) {
	if mch.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	mchUnix, historyUnix := mch.HistoryTime.Unix(), history.HistoryTime.Unix()
	mchOlder := mchUnix < historyUnix || (mchUnix == historyUnix && mch.ID < history.ID)
	historyOlder := mchUnix > historyUnix || (mchUnix == historyUnix && mch.ID > history.ID)

	if mchOlder {
		return &HistoryDiff[MappedControlHistory]{
			Old:     mch,
			New:     history,
			Changes: mch.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[MappedControlHistory]{
			Old:     history,
			New:     mch,
			Changes: history.changes(mch),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (nh *NarrativeHistory) changes(new *NarrativeHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(nh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(narrativehistory.FieldCreatedAt, nh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(nh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(narrativehistory.FieldUpdatedAt, nh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(nh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(narrativehistory.FieldCreatedBy, nh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(nh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(narrativehistory.FieldDeletedAt, nh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(nh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(narrativehistory.FieldDeletedBy, nh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(nh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(narrativehistory.FieldDisplayID, nh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(nh.Tags, new.Tags) {
		changes = append(changes, NewChange(narrativehistory.FieldTags, nh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(nh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(narrativehistory.FieldOwnerID, nh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(nh.Name, new.Name) {
		changes = append(changes, NewChange(narrativehistory.FieldName, nh.Name, new.Name))
	}
	if !reflect.DeepEqual(nh.Description, new.Description) {
		changes = append(changes, NewChange(narrativehistory.FieldDescription, nh.Description, new.Description))
	}
	if !reflect.DeepEqual(nh.Details, new.Details) {
		changes = append(changes, NewChange(narrativehistory.FieldDetails, nh.Details, new.Details))
	}
	return changes
}

func (nh *NarrativeHistory) Diff(history *NarrativeHistory) (*HistoryDiff[NarrativeHistory], error) {
	if nh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	nhUnix, historyUnix := nh.HistoryTime.Unix(), history.HistoryTime.Unix()
	nhOlder := nhUnix < historyUnix || (nhUnix == historyUnix && nh.ID < history.ID)
	historyOlder := nhUnix > historyUnix || (nhUnix == historyUnix && nh.ID > history.ID)

	if nhOlder {
		return &HistoryDiff[NarrativeHistory]{
			Old:     nh,
			New:     history,
			Changes: nh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[NarrativeHistory]{
			Old:     history,
			New:     nh,
			Changes: history.changes(nh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (nh *NoteHistory) changes(new *NoteHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(nh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(notehistory.FieldCreatedAt, nh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(nh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(notehistory.FieldUpdatedAt, nh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(nh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(notehistory.FieldCreatedBy, nh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(nh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(notehistory.FieldDeletedAt, nh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(nh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(notehistory.FieldDeletedBy, nh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(nh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(notehistory.FieldDisplayID, nh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(nh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(notehistory.FieldOwnerID, nh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(nh.Text, new.Text) {
		changes = append(changes, NewChange(notehistory.FieldText, nh.Text, new.Text))
	}
	return changes
}

func (nh *NoteHistory) Diff(history *NoteHistory) (*HistoryDiff[NoteHistory], error) {
	if nh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	nhUnix, historyUnix := nh.HistoryTime.Unix(), history.HistoryTime.Unix()
	nhOlder := nhUnix < historyUnix || (nhUnix == historyUnix && nh.ID < history.ID)
	historyOlder := nhUnix > historyUnix || (nhUnix == historyUnix && nh.ID > history.ID)

	if nhOlder {
		return &HistoryDiff[NoteHistory]{
			Old:     nh,
			New:     history,
			Changes: nh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[NoteHistory]{
			Old:     history,
			New:     nh,
			Changes: history.changes(nh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (omh *OrgMembershipHistory) changes(new *OrgMembershipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(omh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldCreatedAt, omh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(omh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldUpdatedAt, omh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(omh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldCreatedBy, omh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(omh.Role, new.Role) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldRole, omh.Role, new.Role))
	}
	if !reflect.DeepEqual(omh.OrganizationID, new.OrganizationID) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldOrganizationID, omh.OrganizationID, new.OrganizationID))
	}
	if !reflect.DeepEqual(omh.UserID, new.UserID) {
		changes = append(changes, NewChange(orgmembershiphistory.FieldUserID, omh.UserID, new.UserID))
	}
	return changes
}

func (omh *OrgMembershipHistory) Diff(history *OrgMembershipHistory) (*HistoryDiff[OrgMembershipHistory], error) {
	if omh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	omhUnix, historyUnix := omh.HistoryTime.Unix(), history.HistoryTime.Unix()
	omhOlder := omhUnix < historyUnix || (omhUnix == historyUnix && omh.ID < history.ID)
	historyOlder := omhUnix > historyUnix || (omhUnix == historyUnix && omh.ID > history.ID)

	if omhOlder {
		return &HistoryDiff[OrgMembershipHistory]{
			Old:     omh,
			New:     history,
			Changes: omh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrgMembershipHistory]{
			Old:     history,
			New:     omh,
			Changes: history.changes(omh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (osh *OrgSubscriptionHistory) changes(new *OrgSubscriptionHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(osh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldCreatedAt, osh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(osh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldUpdatedAt, osh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(osh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldCreatedBy, osh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(osh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldDeletedAt, osh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(osh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldDeletedBy, osh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(osh.Tags, new.Tags) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldTags, osh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(osh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldOwnerID, osh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(osh.StripeSubscriptionID, new.StripeSubscriptionID) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldStripeSubscriptionID, osh.StripeSubscriptionID, new.StripeSubscriptionID))
	}
	if !reflect.DeepEqual(osh.ProductTier, new.ProductTier) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldProductTier, osh.ProductTier, new.ProductTier))
	}
	if !reflect.DeepEqual(osh.ProductPrice, new.ProductPrice) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldProductPrice, osh.ProductPrice, new.ProductPrice))
	}
	if !reflect.DeepEqual(osh.StripeProductTierID, new.StripeProductTierID) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldStripeProductTierID, osh.StripeProductTierID, new.StripeProductTierID))
	}
	if !reflect.DeepEqual(osh.StripeSubscriptionStatus, new.StripeSubscriptionStatus) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldStripeSubscriptionStatus, osh.StripeSubscriptionStatus, new.StripeSubscriptionStatus))
	}
	if !reflect.DeepEqual(osh.Active, new.Active) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldActive, osh.Active, new.Active))
	}
	if !reflect.DeepEqual(osh.StripeCustomerID, new.StripeCustomerID) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldStripeCustomerID, osh.StripeCustomerID, new.StripeCustomerID))
	}
	if !reflect.DeepEqual(osh.ExpiresAt, new.ExpiresAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldExpiresAt, osh.ExpiresAt, new.ExpiresAt))
	}
	if !reflect.DeepEqual(osh.TrialExpiresAt, new.TrialExpiresAt) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldTrialExpiresAt, osh.TrialExpiresAt, new.TrialExpiresAt))
	}
	if !reflect.DeepEqual(osh.DaysUntilDue, new.DaysUntilDue) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldDaysUntilDue, osh.DaysUntilDue, new.DaysUntilDue))
	}
	if !reflect.DeepEqual(osh.PaymentMethodAdded, new.PaymentMethodAdded) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldPaymentMethodAdded, osh.PaymentMethodAdded, new.PaymentMethodAdded))
	}
	if !reflect.DeepEqual(osh.Features, new.Features) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldFeatures, osh.Features, new.Features))
	}
	if !reflect.DeepEqual(osh.FeatureLookupKeys, new.FeatureLookupKeys) {
		changes = append(changes, NewChange(orgsubscriptionhistory.FieldFeatureLookupKeys, osh.FeatureLookupKeys, new.FeatureLookupKeys))
	}
	return changes
}

func (osh *OrgSubscriptionHistory) Diff(history *OrgSubscriptionHistory) (*HistoryDiff[OrgSubscriptionHistory], error) {
	if osh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	oshUnix, historyUnix := osh.HistoryTime.Unix(), history.HistoryTime.Unix()
	oshOlder := oshUnix < historyUnix || (oshUnix == historyUnix && osh.ID < history.ID)
	historyOlder := oshUnix > historyUnix || (oshUnix == historyUnix && osh.ID > history.ID)

	if oshOlder {
		return &HistoryDiff[OrgSubscriptionHistory]{
			Old:     osh,
			New:     history,
			Changes: osh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrgSubscriptionHistory]{
			Old:     history,
			New:     osh,
			Changes: history.changes(osh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (oh *OrganizationHistory) changes(new *OrganizationHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(oh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldCreatedAt, oh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(oh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldUpdatedAt, oh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(oh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(organizationhistory.FieldCreatedBy, oh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(oh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldDeletedAt, oh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(oh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(organizationhistory.FieldDeletedBy, oh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(oh.Tags, new.Tags) {
		changes = append(changes, NewChange(organizationhistory.FieldTags, oh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(oh.Name, new.Name) {
		changes = append(changes, NewChange(organizationhistory.FieldName, oh.Name, new.Name))
	}
	if !reflect.DeepEqual(oh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(organizationhistory.FieldDisplayName, oh.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(oh.Description, new.Description) {
		changes = append(changes, NewChange(organizationhistory.FieldDescription, oh.Description, new.Description))
	}
	if !reflect.DeepEqual(oh.ParentOrganizationID, new.ParentOrganizationID) {
		changes = append(changes, NewChange(organizationhistory.FieldParentOrganizationID, oh.ParentOrganizationID, new.ParentOrganizationID))
	}
	if !reflect.DeepEqual(oh.PersonalOrg, new.PersonalOrg) {
		changes = append(changes, NewChange(organizationhistory.FieldPersonalOrg, oh.PersonalOrg, new.PersonalOrg))
	}
	if !reflect.DeepEqual(oh.AvatarRemoteURL, new.AvatarRemoteURL) {
		changes = append(changes, NewChange(organizationhistory.FieldAvatarRemoteURL, oh.AvatarRemoteURL, new.AvatarRemoteURL))
	}
	if !reflect.DeepEqual(oh.AvatarLocalFileID, new.AvatarLocalFileID) {
		changes = append(changes, NewChange(organizationhistory.FieldAvatarLocalFileID, oh.AvatarLocalFileID, new.AvatarLocalFileID))
	}
	if !reflect.DeepEqual(oh.AvatarUpdatedAt, new.AvatarUpdatedAt) {
		changes = append(changes, NewChange(organizationhistory.FieldAvatarUpdatedAt, oh.AvatarUpdatedAt, new.AvatarUpdatedAt))
	}
	if !reflect.DeepEqual(oh.DedicatedDb, new.DedicatedDb) {
		changes = append(changes, NewChange(organizationhistory.FieldDedicatedDb, oh.DedicatedDb, new.DedicatedDb))
	}
	return changes
}

func (oh *OrganizationHistory) Diff(history *OrganizationHistory) (*HistoryDiff[OrganizationHistory], error) {
	if oh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ohUnix, historyUnix := oh.HistoryTime.Unix(), history.HistoryTime.Unix()
	ohOlder := ohUnix < historyUnix || (ohUnix == historyUnix && oh.ID < history.ID)
	historyOlder := ohUnix > historyUnix || (ohUnix == historyUnix && oh.ID > history.ID)

	if ohOlder {
		return &HistoryDiff[OrganizationHistory]{
			Old:     oh,
			New:     history,
			Changes: oh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrganizationHistory]{
			Old:     history,
			New:     oh,
			Changes: history.changes(oh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (osh *OrganizationSettingHistory) changes(new *OrganizationSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(osh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldCreatedAt, osh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(osh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldUpdatedAt, osh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(osh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldCreatedBy, osh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(osh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDeletedAt, osh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(osh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDeletedBy, osh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(osh.Tags, new.Tags) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldTags, osh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(osh.Domains, new.Domains) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldDomains, osh.Domains, new.Domains))
	}
	if !reflect.DeepEqual(osh.BillingContact, new.BillingContact) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingContact, osh.BillingContact, new.BillingContact))
	}
	if !reflect.DeepEqual(osh.BillingEmail, new.BillingEmail) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingEmail, osh.BillingEmail, new.BillingEmail))
	}
	if !reflect.DeepEqual(osh.BillingPhone, new.BillingPhone) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingPhone, osh.BillingPhone, new.BillingPhone))
	}
	if !reflect.DeepEqual(osh.BillingAddress, new.BillingAddress) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingAddress, osh.BillingAddress, new.BillingAddress))
	}
	if !reflect.DeepEqual(osh.TaxIdentifier, new.TaxIdentifier) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldTaxIdentifier, osh.TaxIdentifier, new.TaxIdentifier))
	}
	if !reflect.DeepEqual(osh.GeoLocation, new.GeoLocation) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldGeoLocation, osh.GeoLocation, new.GeoLocation))
	}
	if !reflect.DeepEqual(osh.OrganizationID, new.OrganizationID) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldOrganizationID, osh.OrganizationID, new.OrganizationID))
	}
	if !reflect.DeepEqual(osh.BillingNotificationsEnabled, new.BillingNotificationsEnabled) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldBillingNotificationsEnabled, osh.BillingNotificationsEnabled, new.BillingNotificationsEnabled))
	}
	if !reflect.DeepEqual(osh.AllowedEmailDomains, new.AllowedEmailDomains) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldAllowedEmailDomains, osh.AllowedEmailDomains, new.AllowedEmailDomains))
	}
	if !reflect.DeepEqual(osh.IdentityProvider, new.IdentityProvider) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProvider, osh.IdentityProvider, new.IdentityProvider))
	}
	if !reflect.DeepEqual(osh.IdentityProviderClientID, new.IdentityProviderClientID) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderClientID, osh.IdentityProviderClientID, new.IdentityProviderClientID))
	}
	if !reflect.DeepEqual(osh.IdentityProviderClientSecret, new.IdentityProviderClientSecret) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderClientSecret, osh.IdentityProviderClientSecret, new.IdentityProviderClientSecret))
	}
	if !reflect.DeepEqual(osh.IdentityProviderMetadataEndpoint, new.IdentityProviderMetadataEndpoint) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderMetadataEndpoint, osh.IdentityProviderMetadataEndpoint, new.IdentityProviderMetadataEndpoint))
	}
	if !reflect.DeepEqual(osh.IdentityProviderEntityID, new.IdentityProviderEntityID) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderEntityID, osh.IdentityProviderEntityID, new.IdentityProviderEntityID))
	}
	if !reflect.DeepEqual(osh.OidcDiscoveryEndpoint, new.OidcDiscoveryEndpoint) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldOidcDiscoveryEndpoint, osh.OidcDiscoveryEndpoint, new.OidcDiscoveryEndpoint))
	}
	if !reflect.DeepEqual(osh.IdentityProviderLoginEnforced, new.IdentityProviderLoginEnforced) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldIdentityProviderLoginEnforced, osh.IdentityProviderLoginEnforced, new.IdentityProviderLoginEnforced))
	}
	if !reflect.DeepEqual(osh.ComplianceWebhookToken, new.ComplianceWebhookToken) {
		changes = append(changes, NewChange(organizationsettinghistory.FieldComplianceWebhookToken, osh.ComplianceWebhookToken, new.ComplianceWebhookToken))
	}
	return changes
}

func (osh *OrganizationSettingHistory) Diff(history *OrganizationSettingHistory) (*HistoryDiff[OrganizationSettingHistory], error) {
	if osh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	oshUnix, historyUnix := osh.HistoryTime.Unix(), history.HistoryTime.Unix()
	oshOlder := oshUnix < historyUnix || (oshUnix == historyUnix && osh.ID < history.ID)
	historyOlder := oshUnix > historyUnix || (oshUnix == historyUnix && osh.ID > history.ID)

	if oshOlder {
		return &HistoryDiff[OrganizationSettingHistory]{
			Old:     osh,
			New:     history,
			Changes: osh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[OrganizationSettingHistory]{
			Old:     history,
			New:     osh,
			Changes: history.changes(osh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ph *ProcedureHistory) changes(new *ProcedureHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ph.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(procedurehistory.FieldCreatedAt, ph.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ph.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(procedurehistory.FieldUpdatedAt, ph.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ph.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(procedurehistory.FieldCreatedBy, ph.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ph.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(procedurehistory.FieldDeletedAt, ph.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ph.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(procedurehistory.FieldDeletedBy, ph.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ph.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(procedurehistory.FieldDisplayID, ph.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(ph.Tags, new.Tags) {
		changes = append(changes, NewChange(procedurehistory.FieldTags, ph.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ph.Revision, new.Revision) {
		changes = append(changes, NewChange(procedurehistory.FieldRevision, ph.Revision, new.Revision))
	}
	if !reflect.DeepEqual(ph.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(procedurehistory.FieldOwnerID, ph.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ph.Name, new.Name) {
		changes = append(changes, NewChange(procedurehistory.FieldName, ph.Name, new.Name))
	}
	if !reflect.DeepEqual(ph.Status, new.Status) {
		changes = append(changes, NewChange(procedurehistory.FieldStatus, ph.Status, new.Status))
	}
	if !reflect.DeepEqual(ph.ProcedureType, new.ProcedureType) {
		changes = append(changes, NewChange(procedurehistory.FieldProcedureType, ph.ProcedureType, new.ProcedureType))
	}
	if !reflect.DeepEqual(ph.Details, new.Details) {
		changes = append(changes, NewChange(procedurehistory.FieldDetails, ph.Details, new.Details))
	}
	if !reflect.DeepEqual(ph.ApprovalRequired, new.ApprovalRequired) {
		changes = append(changes, NewChange(procedurehistory.FieldApprovalRequired, ph.ApprovalRequired, new.ApprovalRequired))
	}
	if !reflect.DeepEqual(ph.ReviewDue, new.ReviewDue) {
		changes = append(changes, NewChange(procedurehistory.FieldReviewDue, ph.ReviewDue, new.ReviewDue))
	}
	if !reflect.DeepEqual(ph.ReviewFrequency, new.ReviewFrequency) {
		changes = append(changes, NewChange(procedurehistory.FieldReviewFrequency, ph.ReviewFrequency, new.ReviewFrequency))
	}
	if !reflect.DeepEqual(ph.ApproverID, new.ApproverID) {
		changes = append(changes, NewChange(procedurehistory.FieldApproverID, ph.ApproverID, new.ApproverID))
	}
	if !reflect.DeepEqual(ph.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(procedurehistory.FieldDelegateID, ph.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(ph.Summary, new.Summary) {
		changes = append(changes, NewChange(procedurehistory.FieldSummary, ph.Summary, new.Summary))
	}
	if !reflect.DeepEqual(ph.TagSuggestions, new.TagSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldTagSuggestions, ph.TagSuggestions, new.TagSuggestions))
	}
	if !reflect.DeepEqual(ph.DismissedTagSuggestions, new.DismissedTagSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldDismissedTagSuggestions, ph.DismissedTagSuggestions, new.DismissedTagSuggestions))
	}
	if !reflect.DeepEqual(ph.ControlSuggestions, new.ControlSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldControlSuggestions, ph.ControlSuggestions, new.ControlSuggestions))
	}
	if !reflect.DeepEqual(ph.DismissedControlSuggestions, new.DismissedControlSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldDismissedControlSuggestions, ph.DismissedControlSuggestions, new.DismissedControlSuggestions))
	}
	if !reflect.DeepEqual(ph.ImprovementSuggestions, new.ImprovementSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldImprovementSuggestions, ph.ImprovementSuggestions, new.ImprovementSuggestions))
	}
	if !reflect.DeepEqual(ph.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions) {
		changes = append(changes, NewChange(procedurehistory.FieldDismissedImprovementSuggestions, ph.DismissedImprovementSuggestions, new.DismissedImprovementSuggestions))
	}
	return changes
}

func (ph *ProcedureHistory) Diff(history *ProcedureHistory) (*HistoryDiff[ProcedureHistory], error) {
	if ph.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	phUnix, historyUnix := ph.HistoryTime.Unix(), history.HistoryTime.Unix()
	phOlder := phUnix < historyUnix || (phUnix == historyUnix && ph.ID < history.ID)
	historyOlder := phUnix > historyUnix || (phUnix == historyUnix && ph.ID > history.ID)

	if phOlder {
		return &HistoryDiff[ProcedureHistory]{
			Old:     ph,
			New:     history,
			Changes: ph.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ProcedureHistory]{
			Old:     history,
			New:     ph,
			Changes: history.changes(ph),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ph *ProgramHistory) changes(new *ProgramHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ph.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(programhistory.FieldCreatedAt, ph.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ph.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(programhistory.FieldUpdatedAt, ph.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ph.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(programhistory.FieldCreatedBy, ph.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ph.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(programhistory.FieldDeletedAt, ph.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ph.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(programhistory.FieldDeletedBy, ph.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ph.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(programhistory.FieldDisplayID, ph.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(ph.Tags, new.Tags) {
		changes = append(changes, NewChange(programhistory.FieldTags, ph.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ph.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(programhistory.FieldOwnerID, ph.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(ph.Name, new.Name) {
		changes = append(changes, NewChange(programhistory.FieldName, ph.Name, new.Name))
	}
	if !reflect.DeepEqual(ph.Description, new.Description) {
		changes = append(changes, NewChange(programhistory.FieldDescription, ph.Description, new.Description))
	}
	if !reflect.DeepEqual(ph.Status, new.Status) {
		changes = append(changes, NewChange(programhistory.FieldStatus, ph.Status, new.Status))
	}
	if !reflect.DeepEqual(ph.ProgramType, new.ProgramType) {
		changes = append(changes, NewChange(programhistory.FieldProgramType, ph.ProgramType, new.ProgramType))
	}
	if !reflect.DeepEqual(ph.FrameworkName, new.FrameworkName) {
		changes = append(changes, NewChange(programhistory.FieldFrameworkName, ph.FrameworkName, new.FrameworkName))
	}
	if !reflect.DeepEqual(ph.StartDate, new.StartDate) {
		changes = append(changes, NewChange(programhistory.FieldStartDate, ph.StartDate, new.StartDate))
	}
	if !reflect.DeepEqual(ph.EndDate, new.EndDate) {
		changes = append(changes, NewChange(programhistory.FieldEndDate, ph.EndDate, new.EndDate))
	}
	if !reflect.DeepEqual(ph.AuditorReady, new.AuditorReady) {
		changes = append(changes, NewChange(programhistory.FieldAuditorReady, ph.AuditorReady, new.AuditorReady))
	}
	if !reflect.DeepEqual(ph.AuditorWriteComments, new.AuditorWriteComments) {
		changes = append(changes, NewChange(programhistory.FieldAuditorWriteComments, ph.AuditorWriteComments, new.AuditorWriteComments))
	}
	if !reflect.DeepEqual(ph.AuditorReadComments, new.AuditorReadComments) {
		changes = append(changes, NewChange(programhistory.FieldAuditorReadComments, ph.AuditorReadComments, new.AuditorReadComments))
	}
	if !reflect.DeepEqual(ph.AuditFirm, new.AuditFirm) {
		changes = append(changes, NewChange(programhistory.FieldAuditFirm, ph.AuditFirm, new.AuditFirm))
	}
	if !reflect.DeepEqual(ph.Auditor, new.Auditor) {
		changes = append(changes, NewChange(programhistory.FieldAuditor, ph.Auditor, new.Auditor))
	}
	if !reflect.DeepEqual(ph.AuditorEmail, new.AuditorEmail) {
		changes = append(changes, NewChange(programhistory.FieldAuditorEmail, ph.AuditorEmail, new.AuditorEmail))
	}
	return changes
}

func (ph *ProgramHistory) Diff(history *ProgramHistory) (*HistoryDiff[ProgramHistory], error) {
	if ph.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	phUnix, historyUnix := ph.HistoryTime.Unix(), history.HistoryTime.Unix()
	phOlder := phUnix < historyUnix || (phUnix == historyUnix && ph.ID < history.ID)
	historyOlder := phUnix > historyUnix || (phUnix == historyUnix && ph.ID > history.ID)

	if phOlder {
		return &HistoryDiff[ProgramHistory]{
			Old:     ph,
			New:     history,
			Changes: ph.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ProgramHistory]{
			Old:     history,
			New:     ph,
			Changes: history.changes(ph),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (pmh *ProgramMembershipHistory) changes(new *ProgramMembershipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(pmh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(programmembershiphistory.FieldCreatedAt, pmh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(pmh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(programmembershiphistory.FieldUpdatedAt, pmh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(pmh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(programmembershiphistory.FieldCreatedBy, pmh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(pmh.Role, new.Role) {
		changes = append(changes, NewChange(programmembershiphistory.FieldRole, pmh.Role, new.Role))
	}
	if !reflect.DeepEqual(pmh.ProgramID, new.ProgramID) {
		changes = append(changes, NewChange(programmembershiphistory.FieldProgramID, pmh.ProgramID, new.ProgramID))
	}
	if !reflect.DeepEqual(pmh.UserID, new.UserID) {
		changes = append(changes, NewChange(programmembershiphistory.FieldUserID, pmh.UserID, new.UserID))
	}
	return changes
}

func (pmh *ProgramMembershipHistory) Diff(history *ProgramMembershipHistory) (*HistoryDiff[ProgramMembershipHistory], error) {
	if pmh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	pmhUnix, historyUnix := pmh.HistoryTime.Unix(), history.HistoryTime.Unix()
	pmhOlder := pmhUnix < historyUnix || (pmhUnix == historyUnix && pmh.ID < history.ID)
	historyOlder := pmhUnix > historyUnix || (pmhUnix == historyUnix && pmh.ID > history.ID)

	if pmhOlder {
		return &HistoryDiff[ProgramMembershipHistory]{
			Old:     pmh,
			New:     history,
			Changes: pmh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ProgramMembershipHistory]{
			Old:     history,
			New:     pmh,
			Changes: history.changes(pmh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (rh *RiskHistory) changes(new *RiskHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(rh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(riskhistory.FieldCreatedAt, rh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(rh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(riskhistory.FieldUpdatedAt, rh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(rh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(riskhistory.FieldCreatedBy, rh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(rh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(riskhistory.FieldDeletedAt, rh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(rh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(riskhistory.FieldDeletedBy, rh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(rh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(riskhistory.FieldDisplayID, rh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(rh.Tags, new.Tags) {
		changes = append(changes, NewChange(riskhistory.FieldTags, rh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(rh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(riskhistory.FieldOwnerID, rh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(rh.Name, new.Name) {
		changes = append(changes, NewChange(riskhistory.FieldName, rh.Name, new.Name))
	}
	if !reflect.DeepEqual(rh.Status, new.Status) {
		changes = append(changes, NewChange(riskhistory.FieldStatus, rh.Status, new.Status))
	}
	if !reflect.DeepEqual(rh.RiskType, new.RiskType) {
		changes = append(changes, NewChange(riskhistory.FieldRiskType, rh.RiskType, new.RiskType))
	}
	if !reflect.DeepEqual(rh.Category, new.Category) {
		changes = append(changes, NewChange(riskhistory.FieldCategory, rh.Category, new.Category))
	}
	if !reflect.DeepEqual(rh.Impact, new.Impact) {
		changes = append(changes, NewChange(riskhistory.FieldImpact, rh.Impact, new.Impact))
	}
	if !reflect.DeepEqual(rh.Likelihood, new.Likelihood) {
		changes = append(changes, NewChange(riskhistory.FieldLikelihood, rh.Likelihood, new.Likelihood))
	}
	if !reflect.DeepEqual(rh.Score, new.Score) {
		changes = append(changes, NewChange(riskhistory.FieldScore, rh.Score, new.Score))
	}
	if !reflect.DeepEqual(rh.Mitigation, new.Mitigation) {
		changes = append(changes, NewChange(riskhistory.FieldMitigation, rh.Mitigation, new.Mitigation))
	}
	if !reflect.DeepEqual(rh.Details, new.Details) {
		changes = append(changes, NewChange(riskhistory.FieldDetails, rh.Details, new.Details))
	}
	if !reflect.DeepEqual(rh.BusinessCosts, new.BusinessCosts) {
		changes = append(changes, NewChange(riskhistory.FieldBusinessCosts, rh.BusinessCosts, new.BusinessCosts))
	}
	if !reflect.DeepEqual(rh.StakeholderID, new.StakeholderID) {
		changes = append(changes, NewChange(riskhistory.FieldStakeholderID, rh.StakeholderID, new.StakeholderID))
	}
	if !reflect.DeepEqual(rh.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(riskhistory.FieldDelegateID, rh.DelegateID, new.DelegateID))
	}
	return changes
}

func (rh *RiskHistory) Diff(history *RiskHistory) (*HistoryDiff[RiskHistory], error) {
	if rh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	rhUnix, historyUnix := rh.HistoryTime.Unix(), history.HistoryTime.Unix()
	rhOlder := rhUnix < historyUnix || (rhUnix == historyUnix && rh.ID < history.ID)
	historyOlder := rhUnix > historyUnix || (rhUnix == historyUnix && rh.ID > history.ID)

	if rhOlder {
		return &HistoryDiff[RiskHistory]{
			Old:     rh,
			New:     history,
			Changes: rh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[RiskHistory]{
			Old:     history,
			New:     rh,
			Changes: history.changes(rh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (sh *ScanHistory) changes(new *ScanHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(sh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(scanhistory.FieldCreatedAt, sh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(sh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(scanhistory.FieldUpdatedAt, sh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(sh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(scanhistory.FieldCreatedBy, sh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(sh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(scanhistory.FieldDeletedAt, sh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(sh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(scanhistory.FieldDeletedBy, sh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(sh.Tags, new.Tags) {
		changes = append(changes, NewChange(scanhistory.FieldTags, sh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(sh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(scanhistory.FieldOwnerID, sh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(sh.Target, new.Target) {
		changes = append(changes, NewChange(scanhistory.FieldTarget, sh.Target, new.Target))
	}
	if !reflect.DeepEqual(sh.ScanType, new.ScanType) {
		changes = append(changes, NewChange(scanhistory.FieldScanType, sh.ScanType, new.ScanType))
	}
	if !reflect.DeepEqual(sh.Metadata, new.Metadata) {
		changes = append(changes, NewChange(scanhistory.FieldMetadata, sh.Metadata, new.Metadata))
	}
	if !reflect.DeepEqual(sh.Status, new.Status) {
		changes = append(changes, NewChange(scanhistory.FieldStatus, sh.Status, new.Status))
	}
	return changes
}

func (sh *ScanHistory) Diff(history *ScanHistory) (*HistoryDiff[ScanHistory], error) {
	if sh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	shUnix, historyUnix := sh.HistoryTime.Unix(), history.HistoryTime.Unix()
	shOlder := shUnix < historyUnix || (shUnix == historyUnix && sh.ID < history.ID)
	historyOlder := shUnix > historyUnix || (shUnix == historyUnix && sh.ID > history.ID)

	if shOlder {
		return &HistoryDiff[ScanHistory]{
			Old:     sh,
			New:     history,
			Changes: sh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ScanHistory]{
			Old:     history,
			New:     sh,
			Changes: history.changes(sh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (sjh *ScheduledJobHistory) changes(new *ScheduledJobHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(sjh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCreatedAt, sjh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(sjh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldUpdatedAt, sjh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(sjh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCreatedBy, sjh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(sjh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDeletedAt, sjh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(sjh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDeletedBy, sjh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(sjh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDisplayID, sjh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(sjh.Tags, new.Tags) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldTags, sjh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(sjh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldOwnerID, sjh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(sjh.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldSystemOwned, sjh.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(sjh.Title, new.Title) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldTitle, sjh.Title, new.Title))
	}
	if !reflect.DeepEqual(sjh.Description, new.Description) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDescription, sjh.Description, new.Description))
	}
	if !reflect.DeepEqual(sjh.JobType, new.JobType) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldJobType, sjh.JobType, new.JobType))
	}
	if !reflect.DeepEqual(sjh.Platform, new.Platform) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldPlatform, sjh.Platform, new.Platform))
	}
	if !reflect.DeepEqual(sjh.Script, new.Script) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldScript, sjh.Script, new.Script))
	}
	if !reflect.DeepEqual(sjh.WindmillPath, new.WindmillPath) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldWindmillPath, sjh.WindmillPath, new.WindmillPath))
	}
	if !reflect.DeepEqual(sjh.DownloadURL, new.DownloadURL) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldDownloadURL, sjh.DownloadURL, new.DownloadURL))
	}
	if !reflect.DeepEqual(sjh.Configuration, new.Configuration) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldConfiguration, sjh.Configuration, new.Configuration))
	}
	if !reflect.DeepEqual(sjh.Cadence, new.Cadence) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCadence, sjh.Cadence, new.Cadence))
	}
	if !reflect.DeepEqual(sjh.Cron, new.Cron) {
		changes = append(changes, NewChange(scheduledjobhistory.FieldCron, sjh.Cron, new.Cron))
	}
	return changes
}

func (sjh *ScheduledJobHistory) Diff(history *ScheduledJobHistory) (*HistoryDiff[ScheduledJobHistory], error) {
	if sjh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	sjhUnix, historyUnix := sjh.HistoryTime.Unix(), history.HistoryTime.Unix()
	sjhOlder := sjhUnix < historyUnix || (sjhUnix == historyUnix && sjh.ID < history.ID)
	historyOlder := sjhUnix > historyUnix || (sjhUnix == historyUnix && sjh.ID > history.ID)

	if sjhOlder {
		return &HistoryDiff[ScheduledJobHistory]{
			Old:     sjh,
			New:     history,
			Changes: sjh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[ScheduledJobHistory]{
			Old:     history,
			New:     sjh,
			Changes: history.changes(sjh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (sh *StandardHistory) changes(new *StandardHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(sh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(standardhistory.FieldCreatedAt, sh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(sh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(standardhistory.FieldUpdatedAt, sh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(sh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(standardhistory.FieldCreatedBy, sh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(sh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(standardhistory.FieldDeletedAt, sh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(sh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(standardhistory.FieldDeletedBy, sh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(sh.Tags, new.Tags) {
		changes = append(changes, NewChange(standardhistory.FieldTags, sh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(sh.Revision, new.Revision) {
		changes = append(changes, NewChange(standardhistory.FieldRevision, sh.Revision, new.Revision))
	}
	if !reflect.DeepEqual(sh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(standardhistory.FieldOwnerID, sh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(sh.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(standardhistory.FieldSystemOwned, sh.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(sh.Name, new.Name) {
		changes = append(changes, NewChange(standardhistory.FieldName, sh.Name, new.Name))
	}
	if !reflect.DeepEqual(sh.ShortName, new.ShortName) {
		changes = append(changes, NewChange(standardhistory.FieldShortName, sh.ShortName, new.ShortName))
	}
	if !reflect.DeepEqual(sh.Framework, new.Framework) {
		changes = append(changes, NewChange(standardhistory.FieldFramework, sh.Framework, new.Framework))
	}
	if !reflect.DeepEqual(sh.Description, new.Description) {
		changes = append(changes, NewChange(standardhistory.FieldDescription, sh.Description, new.Description))
	}
	if !reflect.DeepEqual(sh.GoverningBodyLogoURL, new.GoverningBodyLogoURL) {
		changes = append(changes, NewChange(standardhistory.FieldGoverningBodyLogoURL, sh.GoverningBodyLogoURL, new.GoverningBodyLogoURL))
	}
	if !reflect.DeepEqual(sh.GoverningBody, new.GoverningBody) {
		changes = append(changes, NewChange(standardhistory.FieldGoverningBody, sh.GoverningBody, new.GoverningBody))
	}
	if !reflect.DeepEqual(sh.Domains, new.Domains) {
		changes = append(changes, NewChange(standardhistory.FieldDomains, sh.Domains, new.Domains))
	}
	if !reflect.DeepEqual(sh.Link, new.Link) {
		changes = append(changes, NewChange(standardhistory.FieldLink, sh.Link, new.Link))
	}
	if !reflect.DeepEqual(sh.Status, new.Status) {
		changes = append(changes, NewChange(standardhistory.FieldStatus, sh.Status, new.Status))
	}
	if !reflect.DeepEqual(sh.IsPublic, new.IsPublic) {
		changes = append(changes, NewChange(standardhistory.FieldIsPublic, sh.IsPublic, new.IsPublic))
	}
	if !reflect.DeepEqual(sh.FreeToUse, new.FreeToUse) {
		changes = append(changes, NewChange(standardhistory.FieldFreeToUse, sh.FreeToUse, new.FreeToUse))
	}
	if !reflect.DeepEqual(sh.StandardType, new.StandardType) {
		changes = append(changes, NewChange(standardhistory.FieldStandardType, sh.StandardType, new.StandardType))
	}
	if !reflect.DeepEqual(sh.Version, new.Version) {
		changes = append(changes, NewChange(standardhistory.FieldVersion, sh.Version, new.Version))
	}
	return changes
}

func (sh *StandardHistory) Diff(history *StandardHistory) (*HistoryDiff[StandardHistory], error) {
	if sh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	shUnix, historyUnix := sh.HistoryTime.Unix(), history.HistoryTime.Unix()
	shOlder := shUnix < historyUnix || (shUnix == historyUnix && sh.ID < history.ID)
	historyOlder := shUnix > historyUnix || (shUnix == historyUnix && sh.ID > history.ID)

	if shOlder {
		return &HistoryDiff[StandardHistory]{
			Old:     sh,
			New:     history,
			Changes: sh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[StandardHistory]{
			Old:     history,
			New:     sh,
			Changes: history.changes(sh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (sh *SubcontrolHistory) changes(new *SubcontrolHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(sh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCreatedAt, sh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(sh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(subcontrolhistory.FieldUpdatedAt, sh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(sh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCreatedBy, sh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(sh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDeletedAt, sh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(sh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDeletedBy, sh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(sh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDisplayID, sh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(sh.Tags, new.Tags) {
		changes = append(changes, NewChange(subcontrolhistory.FieldTags, sh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(sh.Description, new.Description) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDescription, sh.Description, new.Description))
	}
	if !reflect.DeepEqual(sh.ReferenceID, new.ReferenceID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldReferenceID, sh.ReferenceID, new.ReferenceID))
	}
	if !reflect.DeepEqual(sh.AuditorReferenceID, new.AuditorReferenceID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldAuditorReferenceID, sh.AuditorReferenceID, new.AuditorReferenceID))
	}
	if !reflect.DeepEqual(sh.Status, new.Status) {
		changes = append(changes, NewChange(subcontrolhistory.FieldStatus, sh.Status, new.Status))
	}
	if !reflect.DeepEqual(sh.Source, new.Source) {
		changes = append(changes, NewChange(subcontrolhistory.FieldSource, sh.Source, new.Source))
	}
	if !reflect.DeepEqual(sh.ReferenceFramework, new.ReferenceFramework) {
		changes = append(changes, NewChange(subcontrolhistory.FieldReferenceFramework, sh.ReferenceFramework, new.ReferenceFramework))
	}
	if !reflect.DeepEqual(sh.ControlType, new.ControlType) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlType, sh.ControlType, new.ControlType))
	}
	if !reflect.DeepEqual(sh.Category, new.Category) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCategory, sh.Category, new.Category))
	}
	if !reflect.DeepEqual(sh.CategoryID, new.CategoryID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldCategoryID, sh.CategoryID, new.CategoryID))
	}
	if !reflect.DeepEqual(sh.Subcategory, new.Subcategory) {
		changes = append(changes, NewChange(subcontrolhistory.FieldSubcategory, sh.Subcategory, new.Subcategory))
	}
	if !reflect.DeepEqual(sh.MappedCategories, new.MappedCategories) {
		changes = append(changes, NewChange(subcontrolhistory.FieldMappedCategories, sh.MappedCategories, new.MappedCategories))
	}
	if !reflect.DeepEqual(sh.AssessmentObjectives, new.AssessmentObjectives) {
		changes = append(changes, NewChange(subcontrolhistory.FieldAssessmentObjectives, sh.AssessmentObjectives, new.AssessmentObjectives))
	}
	if !reflect.DeepEqual(sh.AssessmentMethods, new.AssessmentMethods) {
		changes = append(changes, NewChange(subcontrolhistory.FieldAssessmentMethods, sh.AssessmentMethods, new.AssessmentMethods))
	}
	if !reflect.DeepEqual(sh.ControlQuestions, new.ControlQuestions) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlQuestions, sh.ControlQuestions, new.ControlQuestions))
	}
	if !reflect.DeepEqual(sh.ImplementationGuidance, new.ImplementationGuidance) {
		changes = append(changes, NewChange(subcontrolhistory.FieldImplementationGuidance, sh.ImplementationGuidance, new.ImplementationGuidance))
	}
	if !reflect.DeepEqual(sh.ExampleEvidence, new.ExampleEvidence) {
		changes = append(changes, NewChange(subcontrolhistory.FieldExampleEvidence, sh.ExampleEvidence, new.ExampleEvidence))
	}
	if !reflect.DeepEqual(sh.References, new.References) {
		changes = append(changes, NewChange(subcontrolhistory.FieldReferences, sh.References, new.References))
	}
	if !reflect.DeepEqual(sh.ControlOwnerID, new.ControlOwnerID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlOwnerID, sh.ControlOwnerID, new.ControlOwnerID))
	}
	if !reflect.DeepEqual(sh.DelegateID, new.DelegateID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldDelegateID, sh.DelegateID, new.DelegateID))
	}
	if !reflect.DeepEqual(sh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldOwnerID, sh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(sh.RefCode, new.RefCode) {
		changes = append(changes, NewChange(subcontrolhistory.FieldRefCode, sh.RefCode, new.RefCode))
	}
	if !reflect.DeepEqual(sh.ControlID, new.ControlID) {
		changes = append(changes, NewChange(subcontrolhistory.FieldControlID, sh.ControlID, new.ControlID))
	}
	return changes
}

func (sh *SubcontrolHistory) Diff(history *SubcontrolHistory) (*HistoryDiff[SubcontrolHistory], error) {
	if sh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	shUnix, historyUnix := sh.HistoryTime.Unix(), history.HistoryTime.Unix()
	shOlder := shUnix < historyUnix || (shUnix == historyUnix && sh.ID < history.ID)
	historyOlder := shUnix > historyUnix || (shUnix == historyUnix && sh.ID > history.ID)

	if shOlder {
		return &HistoryDiff[SubcontrolHistory]{
			Old:     sh,
			New:     history,
			Changes: sh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[SubcontrolHistory]{
			Old:     history,
			New:     sh,
			Changes: history.changes(sh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (sh *SubprocessorHistory) changes(new *SubprocessorHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(sh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(subprocessorhistory.FieldCreatedAt, sh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(sh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(subprocessorhistory.FieldUpdatedAt, sh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(sh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(subprocessorhistory.FieldCreatedBy, sh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(sh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(subprocessorhistory.FieldDeletedAt, sh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(sh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(subprocessorhistory.FieldDeletedBy, sh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(sh.Tags, new.Tags) {
		changes = append(changes, NewChange(subprocessorhistory.FieldTags, sh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(sh.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(subprocessorhistory.FieldOwnerID, sh.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(sh.SystemOwned, new.SystemOwned) {
		changes = append(changes, NewChange(subprocessorhistory.FieldSystemOwned, sh.SystemOwned, new.SystemOwned))
	}
	if !reflect.DeepEqual(sh.Name, new.Name) {
		changes = append(changes, NewChange(subprocessorhistory.FieldName, sh.Name, new.Name))
	}
	if !reflect.DeepEqual(sh.Description, new.Description) {
		changes = append(changes, NewChange(subprocessorhistory.FieldDescription, sh.Description, new.Description))
	}
	if !reflect.DeepEqual(sh.LogoRemoteURL, new.LogoRemoteURL) {
		changes = append(changes, NewChange(subprocessorhistory.FieldLogoRemoteURL, sh.LogoRemoteURL, new.LogoRemoteURL))
	}
	if !reflect.DeepEqual(sh.LogoLocalFileID, new.LogoLocalFileID) {
		changes = append(changes, NewChange(subprocessorhistory.FieldLogoLocalFileID, sh.LogoLocalFileID, new.LogoLocalFileID))
	}
	return changes
}

func (sh *SubprocessorHistory) Diff(history *SubprocessorHistory) (*HistoryDiff[SubprocessorHistory], error) {
	if sh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	shUnix, historyUnix := sh.HistoryTime.Unix(), history.HistoryTime.Unix()
	shOlder := shUnix < historyUnix || (shUnix == historyUnix && sh.ID < history.ID)
	historyOlder := shUnix > historyUnix || (shUnix == historyUnix && sh.ID > history.ID)

	if shOlder {
		return &HistoryDiff[SubprocessorHistory]{
			Old:     sh,
			New:     history,
			Changes: sh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[SubprocessorHistory]{
			Old:     history,
			New:     sh,
			Changes: history.changes(sh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (th *TaskHistory) changes(new *TaskHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(th.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(taskhistory.FieldCreatedAt, th.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(th.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(taskhistory.FieldUpdatedAt, th.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(th.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(taskhistory.FieldCreatedBy, th.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(th.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(taskhistory.FieldDeletedAt, th.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(th.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(taskhistory.FieldDeletedBy, th.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(th.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(taskhistory.FieldDisplayID, th.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(th.Tags, new.Tags) {
		changes = append(changes, NewChange(taskhistory.FieldTags, th.Tags, new.Tags))
	}
	if !reflect.DeepEqual(th.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(taskhistory.FieldOwnerID, th.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(th.Title, new.Title) {
		changes = append(changes, NewChange(taskhistory.FieldTitle, th.Title, new.Title))
	}
	if !reflect.DeepEqual(th.Details, new.Details) {
		changes = append(changes, NewChange(taskhistory.FieldDetails, th.Details, new.Details))
	}
	if !reflect.DeepEqual(th.Status, new.Status) {
		changes = append(changes, NewChange(taskhistory.FieldStatus, th.Status, new.Status))
	}
	if !reflect.DeepEqual(th.Category, new.Category) {
		changes = append(changes, NewChange(taskhistory.FieldCategory, th.Category, new.Category))
	}
	if !reflect.DeepEqual(th.Due, new.Due) {
		changes = append(changes, NewChange(taskhistory.FieldDue, th.Due, new.Due))
	}
	if !reflect.DeepEqual(th.Completed, new.Completed) {
		changes = append(changes, NewChange(taskhistory.FieldCompleted, th.Completed, new.Completed))
	}
	if !reflect.DeepEqual(th.AssigneeID, new.AssigneeID) {
		changes = append(changes, NewChange(taskhistory.FieldAssigneeID, th.AssigneeID, new.AssigneeID))
	}
	if !reflect.DeepEqual(th.AssignerID, new.AssignerID) {
		changes = append(changes, NewChange(taskhistory.FieldAssignerID, th.AssignerID, new.AssignerID))
	}
	return changes
}

func (th *TaskHistory) Diff(history *TaskHistory) (*HistoryDiff[TaskHistory], error) {
	if th.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	thUnix, historyUnix := th.HistoryTime.Unix(), history.HistoryTime.Unix()
	thOlder := thUnix < historyUnix || (thUnix == historyUnix && th.ID < history.ID)
	historyOlder := thUnix > historyUnix || (thUnix == historyUnix && th.ID > history.ID)

	if thOlder {
		return &HistoryDiff[TaskHistory]{
			Old:     th,
			New:     history,
			Changes: th.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TaskHistory]{
			Old:     history,
			New:     th,
			Changes: history.changes(th),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (th *TemplateHistory) changes(new *TemplateHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(th.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(templatehistory.FieldCreatedAt, th.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(th.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(templatehistory.FieldUpdatedAt, th.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(th.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(templatehistory.FieldCreatedBy, th.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(th.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(templatehistory.FieldDeletedAt, th.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(th.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(templatehistory.FieldDeletedBy, th.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(th.Tags, new.Tags) {
		changes = append(changes, NewChange(templatehistory.FieldTags, th.Tags, new.Tags))
	}
	if !reflect.DeepEqual(th.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(templatehistory.FieldOwnerID, th.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(th.Name, new.Name) {
		changes = append(changes, NewChange(templatehistory.FieldName, th.Name, new.Name))
	}
	if !reflect.DeepEqual(th.TemplateType, new.TemplateType) {
		changes = append(changes, NewChange(templatehistory.FieldTemplateType, th.TemplateType, new.TemplateType))
	}
	if !reflect.DeepEqual(th.Description, new.Description) {
		changes = append(changes, NewChange(templatehistory.FieldDescription, th.Description, new.Description))
	}
	if !reflect.DeepEqual(th.Jsonconfig, new.Jsonconfig) {
		changes = append(changes, NewChange(templatehistory.FieldJsonconfig, th.Jsonconfig, new.Jsonconfig))
	}
	if !reflect.DeepEqual(th.Uischema, new.Uischema) {
		changes = append(changes, NewChange(templatehistory.FieldUischema, th.Uischema, new.Uischema))
	}
	return changes
}

func (th *TemplateHistory) Diff(history *TemplateHistory) (*HistoryDiff[TemplateHistory], error) {
	if th.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	thUnix, historyUnix := th.HistoryTime.Unix(), history.HistoryTime.Unix()
	thOlder := thUnix < historyUnix || (thUnix == historyUnix && th.ID < history.ID)
	historyOlder := thUnix > historyUnix || (thUnix == historyUnix && th.ID > history.ID)

	if thOlder {
		return &HistoryDiff[TemplateHistory]{
			Old:     th,
			New:     history,
			Changes: th.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TemplateHistory]{
			Old:     history,
			New:     th,
			Changes: history.changes(th),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (tch *TrustCenterHistory) changes(new *TrustCenterHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(tch.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcenterhistory.FieldCreatedAt, tch.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(tch.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcenterhistory.FieldUpdatedAt, tch.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(tch.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcenterhistory.FieldCreatedBy, tch.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(tch.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcenterhistory.FieldDeletedAt, tch.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(tch.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcenterhistory.FieldDeletedBy, tch.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(tch.Tags, new.Tags) {
		changes = append(changes, NewChange(trustcenterhistory.FieldTags, tch.Tags, new.Tags))
	}
	if !reflect.DeepEqual(tch.OwnerID, new.OwnerID) {
		changes = append(changes, NewChange(trustcenterhistory.FieldOwnerID, tch.OwnerID, new.OwnerID))
	}
	if !reflect.DeepEqual(tch.Slug, new.Slug) {
		changes = append(changes, NewChange(trustcenterhistory.FieldSlug, tch.Slug, new.Slug))
	}
	if !reflect.DeepEqual(tch.CustomDomainID, new.CustomDomainID) {
		changes = append(changes, NewChange(trustcenterhistory.FieldCustomDomainID, tch.CustomDomainID, new.CustomDomainID))
	}
	return changes
}

func (tch *TrustCenterHistory) Diff(history *TrustCenterHistory) (*HistoryDiff[TrustCenterHistory], error) {
	if tch.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	tchUnix, historyUnix := tch.HistoryTime.Unix(), history.HistoryTime.Unix()
	tchOlder := tchUnix < historyUnix || (tchUnix == historyUnix && tch.ID < history.ID)
	historyOlder := tchUnix > historyUnix || (tchUnix == historyUnix && tch.ID > history.ID)

	if tchOlder {
		return &HistoryDiff[TrustCenterHistory]{
			Old:     tch,
			New:     history,
			Changes: tch.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterHistory]{
			Old:     history,
			New:     tch,
			Changes: history.changes(tch),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (tcch *TrustCenterComplianceHistory) changes(new *TrustCenterComplianceHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(tcch.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldCreatedAt, tcch.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(tcch.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldUpdatedAt, tcch.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(tcch.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldCreatedBy, tcch.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(tcch.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldDeletedAt, tcch.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(tcch.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldDeletedBy, tcch.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(tcch.Tags, new.Tags) {
		changes = append(changes, NewChange(trustcentercompliancehistory.FieldTags, tcch.Tags, new.Tags))
	}
	return changes
}

func (tcch *TrustCenterComplianceHistory) Diff(history *TrustCenterComplianceHistory) (*HistoryDiff[TrustCenterComplianceHistory], error) {
	if tcch.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	tcchUnix, historyUnix := tcch.HistoryTime.Unix(), history.HistoryTime.Unix()
	tcchOlder := tcchUnix < historyUnix || (tcchUnix == historyUnix && tcch.ID < history.ID)
	historyOlder := tcchUnix > historyUnix || (tcchUnix == historyUnix && tcch.ID > history.ID)

	if tcchOlder {
		return &HistoryDiff[TrustCenterComplianceHistory]{
			Old:     tcch,
			New:     history,
			Changes: tcch.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterComplianceHistory]{
			Old:     history,
			New:     tcch,
			Changes: history.changes(tcch),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (tcsh *TrustCenterSettingHistory) changes(new *TrustCenterSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(tcsh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldCreatedAt, tcsh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(tcsh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldUpdatedAt, tcsh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(tcsh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldCreatedBy, tcsh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(tcsh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldDeletedAt, tcsh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(tcsh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldDeletedBy, tcsh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(tcsh.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldTrustCenterID, tcsh.TrustCenterID, new.TrustCenterID))
	}
	if !reflect.DeepEqual(tcsh.Title, new.Title) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldTitle, tcsh.Title, new.Title))
	}
	if !reflect.DeepEqual(tcsh.Overview, new.Overview) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldOverview, tcsh.Overview, new.Overview))
	}
	if !reflect.DeepEqual(tcsh.LogoRemoteURL, new.LogoRemoteURL) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldLogoRemoteURL, tcsh.LogoRemoteURL, new.LogoRemoteURL))
	}
	if !reflect.DeepEqual(tcsh.LogoLocalFileID, new.LogoLocalFileID) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldLogoLocalFileID, tcsh.LogoLocalFileID, new.LogoLocalFileID))
	}
	if !reflect.DeepEqual(tcsh.FaviconRemoteURL, new.FaviconRemoteURL) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldFaviconRemoteURL, tcsh.FaviconRemoteURL, new.FaviconRemoteURL))
	}
	if !reflect.DeepEqual(tcsh.FaviconLocalFileID, new.FaviconLocalFileID) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldFaviconLocalFileID, tcsh.FaviconLocalFileID, new.FaviconLocalFileID))
	}
	if !reflect.DeepEqual(tcsh.ThemeMode, new.ThemeMode) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldThemeMode, tcsh.ThemeMode, new.ThemeMode))
	}
	if !reflect.DeepEqual(tcsh.PrimaryColor, new.PrimaryColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldPrimaryColor, tcsh.PrimaryColor, new.PrimaryColor))
	}
	if !reflect.DeepEqual(tcsh.Font, new.Font) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldFont, tcsh.Font, new.Font))
	}
	if !reflect.DeepEqual(tcsh.ForegroundColor, new.ForegroundColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldForegroundColor, tcsh.ForegroundColor, new.ForegroundColor))
	}
	if !reflect.DeepEqual(tcsh.BackgroundColor, new.BackgroundColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldBackgroundColor, tcsh.BackgroundColor, new.BackgroundColor))
	}
	if !reflect.DeepEqual(tcsh.AccentColor, new.AccentColor) {
		changes = append(changes, NewChange(trustcentersettinghistory.FieldAccentColor, tcsh.AccentColor, new.AccentColor))
	}
	return changes
}

func (tcsh *TrustCenterSettingHistory) Diff(history *TrustCenterSettingHistory) (*HistoryDiff[TrustCenterSettingHistory], error) {
	if tcsh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	tcshUnix, historyUnix := tcsh.HistoryTime.Unix(), history.HistoryTime.Unix()
	tcshOlder := tcshUnix < historyUnix || (tcshUnix == historyUnix && tcsh.ID < history.ID)
	historyOlder := tcshUnix > historyUnix || (tcshUnix == historyUnix && tcsh.ID > history.ID)

	if tcshOlder {
		return &HistoryDiff[TrustCenterSettingHistory]{
			Old:     tcsh,
			New:     history,
			Changes: tcsh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterSettingHistory]{
			Old:     history,
			New:     tcsh,
			Changes: history.changes(tcsh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (tcsh *TrustCenterSubprocessorHistory) changes(new *TrustCenterSubprocessorHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(tcsh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCreatedAt, tcsh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(tcsh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldUpdatedAt, tcsh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(tcsh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCreatedBy, tcsh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(tcsh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldDeletedAt, tcsh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(tcsh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldDeletedBy, tcsh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(tcsh.SubprocessorID, new.SubprocessorID) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldSubprocessorID, tcsh.SubprocessorID, new.SubprocessorID))
	}
	if !reflect.DeepEqual(tcsh.TrustCenterID, new.TrustCenterID) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldTrustCenterID, tcsh.TrustCenterID, new.TrustCenterID))
	}
	if !reflect.DeepEqual(tcsh.Countries, new.Countries) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCountries, tcsh.Countries, new.Countries))
	}
	if !reflect.DeepEqual(tcsh.Category, new.Category) {
		changes = append(changes, NewChange(trustcentersubprocessorhistory.FieldCategory, tcsh.Category, new.Category))
	}
	return changes
}

func (tcsh *TrustCenterSubprocessorHistory) Diff(history *TrustCenterSubprocessorHistory) (*HistoryDiff[TrustCenterSubprocessorHistory], error) {
	if tcsh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	tcshUnix, historyUnix := tcsh.HistoryTime.Unix(), history.HistoryTime.Unix()
	tcshOlder := tcshUnix < historyUnix || (tcshUnix == historyUnix && tcsh.ID < history.ID)
	historyOlder := tcshUnix > historyUnix || (tcshUnix == historyUnix && tcsh.ID > history.ID)

	if tcshOlder {
		return &HistoryDiff[TrustCenterSubprocessorHistory]{
			Old:     tcsh,
			New:     history,
			Changes: tcsh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[TrustCenterSubprocessorHistory]{
			Old:     history,
			New:     tcsh,
			Changes: history.changes(tcsh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (uh *UserHistory) changes(new *UserHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(uh.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(userhistory.FieldCreatedAt, uh.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(uh.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(userhistory.FieldUpdatedAt, uh.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(uh.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(userhistory.FieldCreatedBy, uh.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(uh.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(userhistory.FieldDeletedAt, uh.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(uh.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(userhistory.FieldDeletedBy, uh.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(uh.DisplayID, new.DisplayID) {
		changes = append(changes, NewChange(userhistory.FieldDisplayID, uh.DisplayID, new.DisplayID))
	}
	if !reflect.DeepEqual(uh.Tags, new.Tags) {
		changes = append(changes, NewChange(userhistory.FieldTags, uh.Tags, new.Tags))
	}
	if !reflect.DeepEqual(uh.Email, new.Email) {
		changes = append(changes, NewChange(userhistory.FieldEmail, uh.Email, new.Email))
	}
	if !reflect.DeepEqual(uh.FirstName, new.FirstName) {
		changes = append(changes, NewChange(userhistory.FieldFirstName, uh.FirstName, new.FirstName))
	}
	if !reflect.DeepEqual(uh.LastName, new.LastName) {
		changes = append(changes, NewChange(userhistory.FieldLastName, uh.LastName, new.LastName))
	}
	if !reflect.DeepEqual(uh.DisplayName, new.DisplayName) {
		changes = append(changes, NewChange(userhistory.FieldDisplayName, uh.DisplayName, new.DisplayName))
	}
	if !reflect.DeepEqual(uh.AvatarRemoteURL, new.AvatarRemoteURL) {
		changes = append(changes, NewChange(userhistory.FieldAvatarRemoteURL, uh.AvatarRemoteURL, new.AvatarRemoteURL))
	}
	if !reflect.DeepEqual(uh.AvatarLocalFileID, new.AvatarLocalFileID) {
		changes = append(changes, NewChange(userhistory.FieldAvatarLocalFileID, uh.AvatarLocalFileID, new.AvatarLocalFileID))
	}
	if !reflect.DeepEqual(uh.AvatarUpdatedAt, new.AvatarUpdatedAt) {
		changes = append(changes, NewChange(userhistory.FieldAvatarUpdatedAt, uh.AvatarUpdatedAt, new.AvatarUpdatedAt))
	}
	if !reflect.DeepEqual(uh.LastSeen, new.LastSeen) {
		changes = append(changes, NewChange(userhistory.FieldLastSeen, uh.LastSeen, new.LastSeen))
	}
	if !reflect.DeepEqual(uh.LastLoginProvider, new.LastLoginProvider) {
		changes = append(changes, NewChange(userhistory.FieldLastLoginProvider, uh.LastLoginProvider, new.LastLoginProvider))
	}
	if !reflect.DeepEqual(uh.Password, new.Password) {
		changes = append(changes, NewChange(userhistory.FieldPassword, uh.Password, new.Password))
	}
	if !reflect.DeepEqual(uh.Sub, new.Sub) {
		changes = append(changes, NewChange(userhistory.FieldSub, uh.Sub, new.Sub))
	}
	if !reflect.DeepEqual(uh.AuthProvider, new.AuthProvider) {
		changes = append(changes, NewChange(userhistory.FieldAuthProvider, uh.AuthProvider, new.AuthProvider))
	}
	if !reflect.DeepEqual(uh.Role, new.Role) {
		changes = append(changes, NewChange(userhistory.FieldRole, uh.Role, new.Role))
	}
	return changes
}

func (uh *UserHistory) Diff(history *UserHistory) (*HistoryDiff[UserHistory], error) {
	if uh.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	uhUnix, historyUnix := uh.HistoryTime.Unix(), history.HistoryTime.Unix()
	uhOlder := uhUnix < historyUnix || (uhUnix == historyUnix && uh.ID < history.ID)
	historyOlder := uhUnix > historyUnix || (uhUnix == historyUnix && uh.ID > history.ID)

	if uhOlder {
		return &HistoryDiff[UserHistory]{
			Old:     uh,
			New:     history,
			Changes: uh.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[UserHistory]{
			Old:     history,
			New:     uh,
			Changes: history.changes(uh),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (ush *UserSettingHistory) changes(new *UserSettingHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(ush.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldCreatedAt, ush.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(ush.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldUpdatedAt, ush.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(ush.CreatedBy, new.CreatedBy) {
		changes = append(changes, NewChange(usersettinghistory.FieldCreatedBy, ush.CreatedBy, new.CreatedBy))
	}
	if !reflect.DeepEqual(ush.DeletedAt, new.DeletedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldDeletedAt, ush.DeletedAt, new.DeletedAt))
	}
	if !reflect.DeepEqual(ush.DeletedBy, new.DeletedBy) {
		changes = append(changes, NewChange(usersettinghistory.FieldDeletedBy, ush.DeletedBy, new.DeletedBy))
	}
	if !reflect.DeepEqual(ush.Tags, new.Tags) {
		changes = append(changes, NewChange(usersettinghistory.FieldTags, ush.Tags, new.Tags))
	}
	if !reflect.DeepEqual(ush.UserID, new.UserID) {
		changes = append(changes, NewChange(usersettinghistory.FieldUserID, ush.UserID, new.UserID))
	}
	if !reflect.DeepEqual(ush.Locked, new.Locked) {
		changes = append(changes, NewChange(usersettinghistory.FieldLocked, ush.Locked, new.Locked))
	}
	if !reflect.DeepEqual(ush.SilencedAt, new.SilencedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldSilencedAt, ush.SilencedAt, new.SilencedAt))
	}
	if !reflect.DeepEqual(ush.SuspendedAt, new.SuspendedAt) {
		changes = append(changes, NewChange(usersettinghistory.FieldSuspendedAt, ush.SuspendedAt, new.SuspendedAt))
	}
	if !reflect.DeepEqual(ush.Status, new.Status) {
		changes = append(changes, NewChange(usersettinghistory.FieldStatus, ush.Status, new.Status))
	}
	if !reflect.DeepEqual(ush.EmailConfirmed, new.EmailConfirmed) {
		changes = append(changes, NewChange(usersettinghistory.FieldEmailConfirmed, ush.EmailConfirmed, new.EmailConfirmed))
	}
	if !reflect.DeepEqual(ush.IsWebauthnAllowed, new.IsWebauthnAllowed) {
		changes = append(changes, NewChange(usersettinghistory.FieldIsWebauthnAllowed, ush.IsWebauthnAllowed, new.IsWebauthnAllowed))
	}
	if !reflect.DeepEqual(ush.IsTfaEnabled, new.IsTfaEnabled) {
		changes = append(changes, NewChange(usersettinghistory.FieldIsTfaEnabled, ush.IsTfaEnabled, new.IsTfaEnabled))
	}
	if !reflect.DeepEqual(ush.PhoneNumber, new.PhoneNumber) {
		changes = append(changes, NewChange(usersettinghistory.FieldPhoneNumber, ush.PhoneNumber, new.PhoneNumber))
	}
	return changes
}

func (ush *UserSettingHistory) Diff(history *UserSettingHistory) (*HistoryDiff[UserSettingHistory], error) {
	if ush.Ref != history.Ref {
		return nil, ErrMismatchedRef
	}

	ushUnix, historyUnix := ush.HistoryTime.Unix(), history.HistoryTime.Unix()
	ushOlder := ushUnix < historyUnix || (ushUnix == historyUnix && ush.ID < history.ID)
	historyOlder := ushUnix > historyUnix || (ushUnix == historyUnix && ush.ID > history.ID)

	if ushOlder {
		return &HistoryDiff[UserSettingHistory]{
			Old:     ush,
			New:     history,
			Changes: ush.changes(history),
		}, nil
	} else if historyOlder {
		return &HistoryDiff[UserSettingHistory]{
			Old:     history,
			New:     ush,
			Changes: history.changes(ush),
		}, nil
	}
	return nil, ErrIdenticalHistory
}

func (c Change) String(op history.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case history.OpTypeInsert:
		return fmt.Sprintf("%s: %s", c.FieldName, newstr)
	case history.OpTypeDelete:
		return fmt.Sprintf("%s: %s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %s -> %s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context, after *Cursor, first *int, before *Cursor, last *int) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{}

	var record *AuditLogConnection
	record, err = auditActionPlanHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditAssetHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditContactHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlImplementationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlObjectiveHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditControlScheduledJobHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditCustomDomainHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditDNSVerificationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditDocumentDataHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditEntityHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditEntityTypeHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditEvidenceHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditFileHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditGroupHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditGroupMembershipHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditGroupSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditHushHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditIntegrationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditInternalPolicyHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditMappableDomainHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditMappedControlHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditNarrativeHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditNoteHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrgMembershipHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrgSubscriptionHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrganizationHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditOrganizationSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditProcedureHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditProgramHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditProgramMembershipHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditRiskHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditScanHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditScheduledJobHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditStandardHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditSubcontrolHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditSubprocessorHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTaskHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTemplateHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterComplianceHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditTrustCenterSubprocessorHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditUserHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	record, err = auditUserSettingHistory(ctx, c.config, after, first, before, last, nil, nil)
	if err != nil {
		return nil, err
	}
	result.Edges = append(result.Edges, record.Edges...)

	return result, nil
}

func (c *Client) AuditWithFilter(ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, where *AuditLogWhereInput, orderBy *AuditLogOrder) (result *AuditLogConnection, err error) {
	if where.Table == strings.TrimSuffix("ActionPlanHistory", "History") {
		// map AuditLogWhereInput to ActionPlanHistoryWhereInput
		whereInput := &ActionPlanHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ActionPlanHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ActionPlanHistoryOrder{
			Field:     ActionPlanHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditActionPlanHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("AssetHistory", "History") {
		// map AuditLogWhereInput to AssetHistoryWhereInput
		whereInput := &AssetHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to AssetHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &AssetHistoryOrder{
			Field:     AssetHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditAssetHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ContactHistory", "History") {
		// map AuditLogWhereInput to ContactHistoryWhereInput
		whereInput := &ContactHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ContactHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ContactHistoryOrder{
			Field:     ContactHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditContactHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlHistory", "History") {
		// map AuditLogWhereInput to ControlHistoryWhereInput
		whereInput := &ControlHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlHistoryOrder{
			Field:     ControlHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlImplementationHistory", "History") {
		// map AuditLogWhereInput to ControlImplementationHistoryWhereInput
		whereInput := &ControlImplementationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlImplementationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlImplementationHistoryOrder{
			Field:     ControlImplementationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlImplementationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlObjectiveHistory", "History") {
		// map AuditLogWhereInput to ControlObjectiveHistoryWhereInput
		whereInput := &ControlObjectiveHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlObjectiveHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlObjectiveHistoryOrder{
			Field:     ControlObjectiveHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlObjectiveHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ControlScheduledJobHistory", "History") {
		// map AuditLogWhereInput to ControlScheduledJobHistoryWhereInput
		whereInput := &ControlScheduledJobHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ControlScheduledJobHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ControlScheduledJobHistoryOrder{
			Field:     ControlScheduledJobHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditControlScheduledJobHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("CustomDomainHistory", "History") {
		// map AuditLogWhereInput to CustomDomainHistoryWhereInput
		whereInput := &CustomDomainHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to CustomDomainHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &CustomDomainHistoryOrder{
			Field:     CustomDomainHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditCustomDomainHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("DNSVerificationHistory", "History") {
		// map AuditLogWhereInput to DNSVerificationHistoryWhereInput
		whereInput := &DNSVerificationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to DNSVerificationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &DNSVerificationHistoryOrder{
			Field:     DNSVerificationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditDNSVerificationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("DocumentDataHistory", "History") {
		// map AuditLogWhereInput to DocumentDataHistoryWhereInput
		whereInput := &DocumentDataHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to DocumentDataHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &DocumentDataHistoryOrder{
			Field:     DocumentDataHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditDocumentDataHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("EntityHistory", "History") {
		// map AuditLogWhereInput to EntityHistoryWhereInput
		whereInput := &EntityHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to EntityHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &EntityHistoryOrder{
			Field:     EntityHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditEntityHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("EntityTypeHistory", "History") {
		// map AuditLogWhereInput to EntityTypeHistoryWhereInput
		whereInput := &EntityTypeHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to EntityTypeHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &EntityTypeHistoryOrder{
			Field:     EntityTypeHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditEntityTypeHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("EvidenceHistory", "History") {
		// map AuditLogWhereInput to EvidenceHistoryWhereInput
		whereInput := &EvidenceHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to EvidenceHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &EvidenceHistoryOrder{
			Field:     EvidenceHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditEvidenceHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("FileHistory", "History") {
		// map AuditLogWhereInput to FileHistoryWhereInput
		whereInput := &FileHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to FileHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &FileHistoryOrder{
			Field:     FileHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditFileHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("GroupHistory", "History") {
		// map AuditLogWhereInput to GroupHistoryWhereInput
		whereInput := &GroupHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to GroupHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &GroupHistoryOrder{
			Field:     GroupHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditGroupHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("GroupMembershipHistory", "History") {
		// map AuditLogWhereInput to GroupMembershipHistoryWhereInput
		whereInput := &GroupMembershipHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to GroupMembershipHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &GroupMembershipHistoryOrder{
			Field:     GroupMembershipHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditGroupMembershipHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("GroupSettingHistory", "History") {
		// map AuditLogWhereInput to GroupSettingHistoryWhereInput
		whereInput := &GroupSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to GroupSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &GroupSettingHistoryOrder{
			Field:     GroupSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditGroupSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("HushHistory", "History") {
		// map AuditLogWhereInput to HushHistoryWhereInput
		whereInput := &HushHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to HushHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &HushHistoryOrder{
			Field:     HushHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditHushHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("IntegrationHistory", "History") {
		// map AuditLogWhereInput to IntegrationHistoryWhereInput
		whereInput := &IntegrationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to IntegrationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &IntegrationHistoryOrder{
			Field:     IntegrationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditIntegrationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("InternalPolicyHistory", "History") {
		// map AuditLogWhereInput to InternalPolicyHistoryWhereInput
		whereInput := &InternalPolicyHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to InternalPolicyHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &InternalPolicyHistoryOrder{
			Field:     InternalPolicyHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditInternalPolicyHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("MappableDomainHistory", "History") {
		// map AuditLogWhereInput to MappableDomainHistoryWhereInput
		whereInput := &MappableDomainHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to MappableDomainHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &MappableDomainHistoryOrder{
			Field:     MappableDomainHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditMappableDomainHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("MappedControlHistory", "History") {
		// map AuditLogWhereInput to MappedControlHistoryWhereInput
		whereInput := &MappedControlHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to MappedControlHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &MappedControlHistoryOrder{
			Field:     MappedControlHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditMappedControlHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("NarrativeHistory", "History") {
		// map AuditLogWhereInput to NarrativeHistoryWhereInput
		whereInput := &NarrativeHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to NarrativeHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &NarrativeHistoryOrder{
			Field:     NarrativeHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditNarrativeHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("NoteHistory", "History") {
		// map AuditLogWhereInput to NoteHistoryWhereInput
		whereInput := &NoteHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to NoteHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &NoteHistoryOrder{
			Field:     NoteHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditNoteHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrgMembershipHistory", "History") {
		// map AuditLogWhereInput to OrgMembershipHistoryWhereInput
		whereInput := &OrgMembershipHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrgMembershipHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrgMembershipHistoryOrder{
			Field:     OrgMembershipHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrgMembershipHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrgSubscriptionHistory", "History") {
		// map AuditLogWhereInput to OrgSubscriptionHistoryWhereInput
		whereInput := &OrgSubscriptionHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrgSubscriptionHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrgSubscriptionHistoryOrder{
			Field:     OrgSubscriptionHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrgSubscriptionHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrganizationHistory", "History") {
		// map AuditLogWhereInput to OrganizationHistoryWhereInput
		whereInput := &OrganizationHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrganizationHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrganizationHistoryOrder{
			Field:     OrganizationHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrganizationHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("OrganizationSettingHistory", "History") {
		// map AuditLogWhereInput to OrganizationSettingHistoryWhereInput
		whereInput := &OrganizationSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to OrganizationSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &OrganizationSettingHistoryOrder{
			Field:     OrganizationSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditOrganizationSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ProcedureHistory", "History") {
		// map AuditLogWhereInput to ProcedureHistoryWhereInput
		whereInput := &ProcedureHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ProcedureHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ProcedureHistoryOrder{
			Field:     ProcedureHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditProcedureHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ProgramHistory", "History") {
		// map AuditLogWhereInput to ProgramHistoryWhereInput
		whereInput := &ProgramHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ProgramHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ProgramHistoryOrder{
			Field:     ProgramHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditProgramHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ProgramMembershipHistory", "History") {
		// map AuditLogWhereInput to ProgramMembershipHistoryWhereInput
		whereInput := &ProgramMembershipHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ProgramMembershipHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ProgramMembershipHistoryOrder{
			Field:     ProgramMembershipHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditProgramMembershipHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("RiskHistory", "History") {
		// map AuditLogWhereInput to RiskHistoryWhereInput
		whereInput := &RiskHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to RiskHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &RiskHistoryOrder{
			Field:     RiskHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditRiskHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ScanHistory", "History") {
		// map AuditLogWhereInput to ScanHistoryWhereInput
		whereInput := &ScanHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ScanHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ScanHistoryOrder{
			Field:     ScanHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditScanHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("ScheduledJobHistory", "History") {
		// map AuditLogWhereInput to ScheduledJobHistoryWhereInput
		whereInput := &ScheduledJobHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to ScheduledJobHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &ScheduledJobHistoryOrder{
			Field:     ScheduledJobHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditScheduledJobHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("StandardHistory", "History") {
		// map AuditLogWhereInput to StandardHistoryWhereInput
		whereInput := &StandardHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to StandardHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &StandardHistoryOrder{
			Field:     StandardHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditStandardHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("SubcontrolHistory", "History") {
		// map AuditLogWhereInput to SubcontrolHistoryWhereInput
		whereInput := &SubcontrolHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to SubcontrolHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &SubcontrolHistoryOrder{
			Field:     SubcontrolHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditSubcontrolHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("SubprocessorHistory", "History") {
		// map AuditLogWhereInput to SubprocessorHistoryWhereInput
		whereInput := &SubprocessorHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to SubprocessorHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &SubprocessorHistoryOrder{
			Field:     SubprocessorHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditSubprocessorHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TaskHistory", "History") {
		// map AuditLogWhereInput to TaskHistoryWhereInput
		whereInput := &TaskHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TaskHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TaskHistoryOrder{
			Field:     TaskHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTaskHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TemplateHistory", "History") {
		// map AuditLogWhereInput to TemplateHistoryWhereInput
		whereInput := &TemplateHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TemplateHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TemplateHistoryOrder{
			Field:     TemplateHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTemplateHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterComplianceHistory", "History") {
		// map AuditLogWhereInput to TrustCenterComplianceHistoryWhereInput
		whereInput := &TrustCenterComplianceHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterComplianceHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterComplianceHistoryOrder{
			Field:     TrustCenterComplianceHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterComplianceHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterHistory", "History") {
		// map AuditLogWhereInput to TrustCenterHistoryWhereInput
		whereInput := &TrustCenterHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterHistoryOrder{
			Field:     TrustCenterHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterSettingHistory", "History") {
		// map AuditLogWhereInput to TrustCenterSettingHistoryWhereInput
		whereInput := &TrustCenterSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterSettingHistoryOrder{
			Field:     TrustCenterSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("TrustCenterSubprocessorHistory", "History") {
		// map AuditLogWhereInput to TrustCenterSubprocessorHistoryWhereInput
		whereInput := &TrustCenterSubprocessorHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to TrustCenterSubprocessorHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &TrustCenterSubprocessorHistoryOrder{
			Field:     TrustCenterSubprocessorHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditTrustCenterSubprocessorHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("UserHistory", "History") {
		// map AuditLogWhereInput to UserHistoryWhereInput
		whereInput := &UserHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to UserHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &UserHistoryOrder{
			Field:     UserHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditUserHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}
	if where.Table == strings.TrimSuffix("UserSettingHistory", "History") {
		// map AuditLogWhereInput to UserSettingHistoryWhereInput
		whereInput := &UserSettingHistoryWhereInput{}
		if where.RefID != nil {
			whereInput.RefEqualFold = where.RefID
		}

		if where.UpdatedBy != nil {
			whereInput.UpdatedBy = where.UpdatedBy
		}

		if where.Operation != nil {
			whereInput.Operation = where.Operation
		}

		if where.Before != nil {
			whereInput.HistoryTimeLT = where.Before
		}

		if where.After != nil {
			whereInput.HistoryTimeGT = where.After
		}

		// map AuditLogOrder to UserSettingHistoryOrder
		// default to ordering by HistoryTime desc
		orderByInput := &UserSettingHistoryOrder{
			Field:     UserSettingHistoryOrderFieldHistoryTime,
			Direction: entgql.OrderDirectionDesc,
		}

		if orderBy != nil {
			orderByInput.Direction = orderBy.Direction
		}

		result, err = auditUserSettingHistory(ctx, c.config, after, first, before, last, orderByInput, whereInput)
		if err != nil {
			return nil, err
		}

		return
	}

	return
}

func (r *AuditLog) toRow() []string {
	row := make([]string, 6)

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefID)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	if r.UpdatedBy != "" {
		row[5] = fmt.Sprintf("%v", r.UpdatedBy)
	}
	return row
}

type actionplanhistoryref struct {
	Ref string
}

func auditActionPlanHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ActionPlanHistoryOrder, where *ActionPlanHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ActionPlanHistoryPaginateOption{
		WithActionPlanHistoryOrder(orderBy),
		WithActionPlanHistoryFilter(where.Filter),
	}

	client := NewActionPlanHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ActionPlanHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ActionPlanHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ActionPlanHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					actionplanhistory.Ref(curr.Node.Ref),
					actionplanhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(actionplanhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ActionPlanHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type assethistoryref struct {
	Ref string
}

func auditAssetHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *AssetHistoryOrder, where *AssetHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []AssetHistoryPaginateOption{
		WithAssetHistoryOrder(orderBy),
		WithAssetHistoryFilter(where.Filter),
	}

	client := NewAssetHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "AssetHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&AssetHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&AssetHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					assethistory.Ref(curr.Node.Ref),
					assethistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(assethistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &AssetHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type contacthistoryref struct {
	Ref string
}

func auditContactHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ContactHistoryOrder, where *ContactHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ContactHistoryPaginateOption{
		WithContactHistoryOrder(orderBy),
		WithContactHistoryFilter(where.Filter),
	}

	client := NewContactHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ContactHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ContactHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ContactHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					contacthistory.Ref(curr.Node.Ref),
					contacthistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(contacthistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ContactHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlhistoryref struct {
	Ref string
}

func auditControlHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlHistoryOrder, where *ControlHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlHistoryPaginateOption{
		WithControlHistoryOrder(orderBy),
		WithControlHistoryFilter(where.Filter),
	}

	client := NewControlHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlhistory.Ref(curr.Node.Ref),
					controlhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlimplementationhistoryref struct {
	Ref string
}

func auditControlImplementationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlImplementationHistoryOrder, where *ControlImplementationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlImplementationHistoryPaginateOption{
		WithControlImplementationHistoryOrder(orderBy),
		WithControlImplementationHistoryFilter(where.Filter),
	}

	client := NewControlImplementationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlImplementationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlImplementationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlImplementationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlimplementationhistory.Ref(curr.Node.Ref),
					controlimplementationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlimplementationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlImplementationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlobjectivehistoryref struct {
	Ref string
}

func auditControlObjectiveHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlObjectiveHistoryOrder, where *ControlObjectiveHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlObjectiveHistoryPaginateOption{
		WithControlObjectiveHistoryOrder(orderBy),
		WithControlObjectiveHistoryFilter(where.Filter),
	}

	client := NewControlObjectiveHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlObjectiveHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlObjectiveHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlObjectiveHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlobjectivehistory.Ref(curr.Node.Ref),
					controlobjectivehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlobjectivehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlObjectiveHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type controlscheduledjobhistoryref struct {
	Ref string
}

func auditControlScheduledJobHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ControlScheduledJobHistoryOrder, where *ControlScheduledJobHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ControlScheduledJobHistoryPaginateOption{
		WithControlScheduledJobHistoryOrder(orderBy),
		WithControlScheduledJobHistoryFilter(where.Filter),
	}

	client := NewControlScheduledJobHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ControlScheduledJobHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ControlScheduledJobHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ControlScheduledJobHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					controlscheduledjobhistory.Ref(curr.Node.Ref),
					controlscheduledjobhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(controlscheduledjobhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ControlScheduledJobHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type customdomainhistoryref struct {
	Ref string
}

func auditCustomDomainHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *CustomDomainHistoryOrder, where *CustomDomainHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []CustomDomainHistoryPaginateOption{
		WithCustomDomainHistoryOrder(orderBy),
		WithCustomDomainHistoryFilter(where.Filter),
	}

	client := NewCustomDomainHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "CustomDomainHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&CustomDomainHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&CustomDomainHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					customdomainhistory.Ref(curr.Node.Ref),
					customdomainhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(customdomainhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &CustomDomainHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type dnsverificationhistoryref struct {
	Ref string
}

func auditDNSVerificationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *DNSVerificationHistoryOrder, where *DNSVerificationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []DNSVerificationHistoryPaginateOption{
		WithDNSVerificationHistoryOrder(orderBy),
		WithDNSVerificationHistoryFilter(where.Filter),
	}

	client := NewDNSVerificationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "DNSVerificationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&DNSVerificationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&DNSVerificationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					dnsverificationhistory.Ref(curr.Node.Ref),
					dnsverificationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(dnsverificationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &DNSVerificationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type documentdatahistoryref struct {
	Ref string
}

func auditDocumentDataHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *DocumentDataHistoryOrder, where *DocumentDataHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []DocumentDataHistoryPaginateOption{
		WithDocumentDataHistoryOrder(orderBy),
		WithDocumentDataHistoryFilter(where.Filter),
	}

	client := NewDocumentDataHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "DocumentDataHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&DocumentDataHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&DocumentDataHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					documentdatahistory.Ref(curr.Node.Ref),
					documentdatahistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(documentdatahistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &DocumentDataHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type entityhistoryref struct {
	Ref string
}

func auditEntityHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *EntityHistoryOrder, where *EntityHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []EntityHistoryPaginateOption{
		WithEntityHistoryOrder(orderBy),
		WithEntityHistoryFilter(where.Filter),
	}

	client := NewEntityHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "EntityHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&EntityHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&EntityHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					entityhistory.Ref(curr.Node.Ref),
					entityhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(entityhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &EntityHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type entitytypehistoryref struct {
	Ref string
}

func auditEntityTypeHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *EntityTypeHistoryOrder, where *EntityTypeHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []EntityTypeHistoryPaginateOption{
		WithEntityTypeHistoryOrder(orderBy),
		WithEntityTypeHistoryFilter(where.Filter),
	}

	client := NewEntityTypeHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "EntityTypeHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&EntityTypeHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&EntityTypeHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					entitytypehistory.Ref(curr.Node.Ref),
					entitytypehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(entitytypehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &EntityTypeHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type evidencehistoryref struct {
	Ref string
}

func auditEvidenceHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *EvidenceHistoryOrder, where *EvidenceHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []EvidenceHistoryPaginateOption{
		WithEvidenceHistoryOrder(orderBy),
		WithEvidenceHistoryFilter(where.Filter),
	}

	client := NewEvidenceHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "EvidenceHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&EvidenceHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&EvidenceHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					evidencehistory.Ref(curr.Node.Ref),
					evidencehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(evidencehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &EvidenceHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type filehistoryref struct {
	Ref string
}

func auditFileHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *FileHistoryOrder, where *FileHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []FileHistoryPaginateOption{
		WithFileHistoryOrder(orderBy),
		WithFileHistoryFilter(where.Filter),
	}

	client := NewFileHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "FileHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&FileHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&FileHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					filehistory.Ref(curr.Node.Ref),
					filehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(filehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &FileHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type grouphistoryref struct {
	Ref string
}

func auditGroupHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *GroupHistoryOrder, where *GroupHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []GroupHistoryPaginateOption{
		WithGroupHistoryOrder(orderBy),
		WithGroupHistoryFilter(where.Filter),
	}

	client := NewGroupHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "GroupHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&GroupHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&GroupHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					grouphistory.Ref(curr.Node.Ref),
					grouphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(grouphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &GroupHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type groupmembershiphistoryref struct {
	Ref string
}

func auditGroupMembershipHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *GroupMembershipHistoryOrder, where *GroupMembershipHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []GroupMembershipHistoryPaginateOption{
		WithGroupMembershipHistoryOrder(orderBy),
		WithGroupMembershipHistoryFilter(where.Filter),
	}

	client := NewGroupMembershipHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "GroupMembershipHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&GroupMembershipHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&GroupMembershipHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					groupmembershiphistory.Ref(curr.Node.Ref),
					groupmembershiphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(groupmembershiphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &GroupMembershipHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type groupsettinghistoryref struct {
	Ref string
}

func auditGroupSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *GroupSettingHistoryOrder, where *GroupSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []GroupSettingHistoryPaginateOption{
		WithGroupSettingHistoryOrder(orderBy),
		WithGroupSettingHistoryFilter(where.Filter),
	}

	client := NewGroupSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "GroupSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&GroupSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&GroupSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					groupsettinghistory.Ref(curr.Node.Ref),
					groupsettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(groupsettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &GroupSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type hushhistoryref struct {
	Ref string
}

func auditHushHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *HushHistoryOrder, where *HushHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []HushHistoryPaginateOption{
		WithHushHistoryOrder(orderBy),
		WithHushHistoryFilter(where.Filter),
	}

	client := NewHushHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "HushHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&HushHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&HushHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					hushhistory.Ref(curr.Node.Ref),
					hushhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(hushhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &HushHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type integrationhistoryref struct {
	Ref string
}

func auditIntegrationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *IntegrationHistoryOrder, where *IntegrationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []IntegrationHistoryPaginateOption{
		WithIntegrationHistoryOrder(orderBy),
		WithIntegrationHistoryFilter(where.Filter),
	}

	client := NewIntegrationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "IntegrationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&IntegrationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&IntegrationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					integrationhistory.Ref(curr.Node.Ref),
					integrationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(integrationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &IntegrationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type internalpolicyhistoryref struct {
	Ref string
}

func auditInternalPolicyHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *InternalPolicyHistoryOrder, where *InternalPolicyHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []InternalPolicyHistoryPaginateOption{
		WithInternalPolicyHistoryOrder(orderBy),
		WithInternalPolicyHistoryFilter(where.Filter),
	}

	client := NewInternalPolicyHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "InternalPolicyHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&InternalPolicyHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&InternalPolicyHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					internalpolicyhistory.Ref(curr.Node.Ref),
					internalpolicyhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(internalpolicyhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &InternalPolicyHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type mappabledomainhistoryref struct {
	Ref string
}

func auditMappableDomainHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *MappableDomainHistoryOrder, where *MappableDomainHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []MappableDomainHistoryPaginateOption{
		WithMappableDomainHistoryOrder(orderBy),
		WithMappableDomainHistoryFilter(where.Filter),
	}

	client := NewMappableDomainHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "MappableDomainHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&MappableDomainHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&MappableDomainHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					mappabledomainhistory.Ref(curr.Node.Ref),
					mappabledomainhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(mappabledomainhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &MappableDomainHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type mappedcontrolhistoryref struct {
	Ref string
}

func auditMappedControlHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *MappedControlHistoryOrder, where *MappedControlHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []MappedControlHistoryPaginateOption{
		WithMappedControlHistoryOrder(orderBy),
		WithMappedControlHistoryFilter(where.Filter),
	}

	client := NewMappedControlHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "MappedControlHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&MappedControlHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&MappedControlHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					mappedcontrolhistory.Ref(curr.Node.Ref),
					mappedcontrolhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(mappedcontrolhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &MappedControlHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type narrativehistoryref struct {
	Ref string
}

func auditNarrativeHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *NarrativeHistoryOrder, where *NarrativeHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []NarrativeHistoryPaginateOption{
		WithNarrativeHistoryOrder(orderBy),
		WithNarrativeHistoryFilter(where.Filter),
	}

	client := NewNarrativeHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "NarrativeHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&NarrativeHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&NarrativeHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					narrativehistory.Ref(curr.Node.Ref),
					narrativehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(narrativehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &NarrativeHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type notehistoryref struct {
	Ref string
}

func auditNoteHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *NoteHistoryOrder, where *NoteHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []NoteHistoryPaginateOption{
		WithNoteHistoryOrder(orderBy),
		WithNoteHistoryFilter(where.Filter),
	}

	client := NewNoteHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "NoteHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&NoteHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&NoteHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					notehistory.Ref(curr.Node.Ref),
					notehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(notehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &NoteHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type orgmembershiphistoryref struct {
	Ref string
}

func auditOrgMembershipHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrgMembershipHistoryOrder, where *OrgMembershipHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrgMembershipHistoryPaginateOption{
		WithOrgMembershipHistoryOrder(orderBy),
		WithOrgMembershipHistoryFilter(where.Filter),
	}

	client := NewOrgMembershipHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrgMembershipHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrgMembershipHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrgMembershipHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					orgmembershiphistory.Ref(curr.Node.Ref),
					orgmembershiphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(orgmembershiphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrgMembershipHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type orgsubscriptionhistoryref struct {
	Ref string
}

func auditOrgSubscriptionHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrgSubscriptionHistoryOrder, where *OrgSubscriptionHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrgSubscriptionHistoryPaginateOption{
		WithOrgSubscriptionHistoryOrder(orderBy),
		WithOrgSubscriptionHistoryFilter(where.Filter),
	}

	client := NewOrgSubscriptionHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrgSubscriptionHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrgSubscriptionHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrgSubscriptionHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					orgsubscriptionhistory.Ref(curr.Node.Ref),
					orgsubscriptionhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(orgsubscriptionhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrgSubscriptionHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type organizationhistoryref struct {
	Ref string
}

func auditOrganizationHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrganizationHistoryOrder, where *OrganizationHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrganizationHistoryPaginateOption{
		WithOrganizationHistoryOrder(orderBy),
		WithOrganizationHistoryFilter(where.Filter),
	}

	client := NewOrganizationHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrganizationHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrganizationHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrganizationHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					organizationhistory.Ref(curr.Node.Ref),
					organizationhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(organizationhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrganizationHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type organizationsettinghistoryref struct {
	Ref string
}

func auditOrganizationSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *OrganizationSettingHistoryOrder, where *OrganizationSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []OrganizationSettingHistoryPaginateOption{
		WithOrganizationSettingHistoryOrder(orderBy),
		WithOrganizationSettingHistoryFilter(where.Filter),
	}

	client := NewOrganizationSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "OrganizationSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&OrganizationSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&OrganizationSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					organizationsettinghistory.Ref(curr.Node.Ref),
					organizationsettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(organizationsettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &OrganizationSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type procedurehistoryref struct {
	Ref string
}

func auditProcedureHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ProcedureHistoryOrder, where *ProcedureHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ProcedureHistoryPaginateOption{
		WithProcedureHistoryOrder(orderBy),
		WithProcedureHistoryFilter(where.Filter),
	}

	client := NewProcedureHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ProcedureHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ProcedureHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ProcedureHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					procedurehistory.Ref(curr.Node.Ref),
					procedurehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(procedurehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ProcedureHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type programhistoryref struct {
	Ref string
}

func auditProgramHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ProgramHistoryOrder, where *ProgramHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ProgramHistoryPaginateOption{
		WithProgramHistoryOrder(orderBy),
		WithProgramHistoryFilter(where.Filter),
	}

	client := NewProgramHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ProgramHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ProgramHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ProgramHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					programhistory.Ref(curr.Node.Ref),
					programhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(programhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ProgramHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type programmembershiphistoryref struct {
	Ref string
}

func auditProgramMembershipHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ProgramMembershipHistoryOrder, where *ProgramMembershipHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ProgramMembershipHistoryPaginateOption{
		WithProgramMembershipHistoryOrder(orderBy),
		WithProgramMembershipHistoryFilter(where.Filter),
	}

	client := NewProgramMembershipHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ProgramMembershipHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ProgramMembershipHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ProgramMembershipHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					programmembershiphistory.Ref(curr.Node.Ref),
					programmembershiphistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(programmembershiphistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ProgramMembershipHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type riskhistoryref struct {
	Ref string
}

func auditRiskHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *RiskHistoryOrder, where *RiskHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []RiskHistoryPaginateOption{
		WithRiskHistoryOrder(orderBy),
		WithRiskHistoryFilter(where.Filter),
	}

	client := NewRiskHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "RiskHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&RiskHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&RiskHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					riskhistory.Ref(curr.Node.Ref),
					riskhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(riskhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &RiskHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type scanhistoryref struct {
	Ref string
}

func auditScanHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ScanHistoryOrder, where *ScanHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ScanHistoryPaginateOption{
		WithScanHistoryOrder(orderBy),
		WithScanHistoryFilter(where.Filter),
	}

	client := NewScanHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ScanHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ScanHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ScanHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					scanhistory.Ref(curr.Node.Ref),
					scanhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(scanhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ScanHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type scheduledjobhistoryref struct {
	Ref string
}

func auditScheduledJobHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *ScheduledJobHistoryOrder, where *ScheduledJobHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []ScheduledJobHistoryPaginateOption{
		WithScheduledJobHistoryOrder(orderBy),
		WithScheduledJobHistoryFilter(where.Filter),
	}

	client := NewScheduledJobHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "ScheduledJobHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&ScheduledJobHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&ScheduledJobHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					scheduledjobhistory.Ref(curr.Node.Ref),
					scheduledjobhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(scheduledjobhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &ScheduledJobHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type standardhistoryref struct {
	Ref string
}

func auditStandardHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *StandardHistoryOrder, where *StandardHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []StandardHistoryPaginateOption{
		WithStandardHistoryOrder(orderBy),
		WithStandardHistoryFilter(where.Filter),
	}

	client := NewStandardHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "StandardHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&StandardHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&StandardHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					standardhistory.Ref(curr.Node.Ref),
					standardhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(standardhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &StandardHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type subcontrolhistoryref struct {
	Ref string
}

func auditSubcontrolHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *SubcontrolHistoryOrder, where *SubcontrolHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []SubcontrolHistoryPaginateOption{
		WithSubcontrolHistoryOrder(orderBy),
		WithSubcontrolHistoryFilter(where.Filter),
	}

	client := NewSubcontrolHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "SubcontrolHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&SubcontrolHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&SubcontrolHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					subcontrolhistory.Ref(curr.Node.Ref),
					subcontrolhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(subcontrolhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &SubcontrolHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type subprocessorhistoryref struct {
	Ref string
}

func auditSubprocessorHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *SubprocessorHistoryOrder, where *SubprocessorHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []SubprocessorHistoryPaginateOption{
		WithSubprocessorHistoryOrder(orderBy),
		WithSubprocessorHistoryFilter(where.Filter),
	}

	client := NewSubprocessorHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "SubprocessorHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&SubprocessorHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&SubprocessorHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					subprocessorhistory.Ref(curr.Node.Ref),
					subprocessorhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(subprocessorhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &SubprocessorHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type taskhistoryref struct {
	Ref string
}

func auditTaskHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TaskHistoryOrder, where *TaskHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TaskHistoryPaginateOption{
		WithTaskHistoryOrder(orderBy),
		WithTaskHistoryFilter(where.Filter),
	}

	client := NewTaskHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TaskHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TaskHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TaskHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					taskhistory.Ref(curr.Node.Ref),
					taskhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(taskhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TaskHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type templatehistoryref struct {
	Ref string
}

func auditTemplateHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TemplateHistoryOrder, where *TemplateHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TemplateHistoryPaginateOption{
		WithTemplateHistoryOrder(orderBy),
		WithTemplateHistoryFilter(where.Filter),
	}

	client := NewTemplateHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TemplateHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TemplateHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TemplateHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					templatehistory.Ref(curr.Node.Ref),
					templatehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(templatehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TemplateHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcentercompliancehistoryref struct {
	Ref string
}

func auditTrustCenterComplianceHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterComplianceHistoryOrder, where *TrustCenterComplianceHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterComplianceHistoryPaginateOption{
		WithTrustCenterComplianceHistoryOrder(orderBy),
		WithTrustCenterComplianceHistoryFilter(where.Filter),
	}

	client := NewTrustCenterComplianceHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterComplianceHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterComplianceHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterComplianceHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcentercompliancehistory.Ref(curr.Node.Ref),
					trustcentercompliancehistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcentercompliancehistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterComplianceHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcenterhistoryref struct {
	Ref string
}

func auditTrustCenterHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterHistoryOrder, where *TrustCenterHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterHistoryPaginateOption{
		WithTrustCenterHistoryOrder(orderBy),
		WithTrustCenterHistoryFilter(where.Filter),
	}

	client := NewTrustCenterHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcenterhistory.Ref(curr.Node.Ref),
					trustcenterhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcenterhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcentersettinghistoryref struct {
	Ref string
}

func auditTrustCenterSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterSettingHistoryOrder, where *TrustCenterSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterSettingHistoryPaginateOption{
		WithTrustCenterSettingHistoryOrder(orderBy),
		WithTrustCenterSettingHistoryFilter(where.Filter),
	}

	client := NewTrustCenterSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcentersettinghistory.Ref(curr.Node.Ref),
					trustcentersettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcentersettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type trustcentersubprocessorhistoryref struct {
	Ref string
}

func auditTrustCenterSubprocessorHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *TrustCenterSubprocessorHistoryOrder, where *TrustCenterSubprocessorHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []TrustCenterSubprocessorHistoryPaginateOption{
		WithTrustCenterSubprocessorHistoryOrder(orderBy),
		WithTrustCenterSubprocessorHistoryFilter(where.Filter),
	}

	client := NewTrustCenterSubprocessorHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "TrustCenterSubprocessorHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&TrustCenterSubprocessorHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&TrustCenterSubprocessorHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					trustcentersubprocessorhistory.Ref(curr.Node.Ref),
					trustcentersubprocessorhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(trustcentersubprocessorhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &TrustCenterSubprocessorHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type userhistoryref struct {
	Ref string
}

func auditUserHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *UserHistoryOrder, where *UserHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []UserHistoryPaginateOption{
		WithUserHistoryOrder(orderBy),
		WithUserHistoryFilter(where.Filter),
	}

	client := NewUserHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "UserHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&UserHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&UserHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					userhistory.Ref(curr.Node.Ref),
					userhistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(userhistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &UserHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}

type usersettinghistoryref struct {
	Ref string
}

func auditUserSettingHistory(ctx context.Context, config config, after *Cursor, first *int, before *Cursor, last *int, orderBy *UserSettingHistoryOrder, where *UserSettingHistoryWhereInput) (result *AuditLogConnection, err error) {
	result = &AuditLogConnection{
		Edges: []*AuditLogEdge{},
	}

	opts := []UserSettingHistoryPaginateOption{
		WithUserSettingHistoryOrder(orderBy),
		WithUserSettingHistoryFilter(where.Filter),
	}

	client := NewUserSettingHistoryClient(config)

	histories, err := client.Query().
		Paginate(ctx, after, first, before, last, opts...)
	if err != nil {
		return nil, err
	}

	for _, curr := range histories.Edges {
		record := &AuditLog{
			Table:       "UserSettingHistory",
			RefID:       curr.Node.Ref,
			HistoryTime: curr.Node.HistoryTime,
			Operation:   curr.Node.Operation,
			UpdatedBy:   curr.Node.UpdatedBy,
		}
		switch curr.Node.Operation {
		case history.OpTypeInsert:
			record.Changes = (&UserSettingHistory{}).changes(curr.Node)
		case history.OpTypeDelete:
			record.Changes = curr.Node.changes(&UserSettingHistory{})
		default:
			// Get the previous history entry to calculate the changes
			prev, err := client.Query().
				Where(
					usersettinghistory.Ref(curr.Node.Ref),
					usersettinghistory.HistoryTimeLT(curr.Node.HistoryTime),
				).
				Order(usersettinghistory.ByHistoryTime(sql.OrderDesc())).
				Limit(1).
				All(ctx) //there will be two when there is more than one change because we pull limit + 1 in our interceptors
			if err != nil {
				return nil, err
			}

			// this shouldn't happen because the initial change will always be an insert
			// but just in case, we will handle it gracefully
			if len(prev) == 0 {
				prev = append(prev, &UserSettingHistory{})
			}

			record.Changes = prev[0].changes(curr.Node)
		}

		edge := &AuditLogEdge{
			Node: record,
			// we only currently support pagination from the same table, so we can use the existing cursor
			Cursor: curr.Cursor,
		}

		result.Edges = append(result.Edges, edge)
	}

	result.TotalCount = histories.TotalCount
	result.PageInfo = histories.PageInfo

	return result, nil
}
