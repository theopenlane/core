// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"github.com/theopenlane/core/common/enums"
)

// ApplyFieldUpdates applies field updates from a map to a ActionPlan entity
// This is a type-safe helper for workflow field updates
func (c *ActionPlanClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Control entity
// This is a type-safe helper for workflow field updates
func (c *ControlClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "title":
			if value == nil {
				update.ClearTitle()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetTitle(v)
			applied++
		case "reference_id":
			if value == nil {
				update.ClearReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceID(v)
			applied++
		case "auditor_reference_id":
			if value == nil {
				update.ClearAuditorReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetAuditorReferenceID(v)
			applied++
		case "responsible_party_id":
			if value == nil {
				update.ClearResponsiblePartyID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetResponsiblePartyID(v)
			applied++
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.ControlStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "reference_framework":
			if value == nil {
				update.ClearReferenceFramework()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFramework(v)
			applied++
		case "reference_framework_revision":
			if value == nil {
				update.ClearReferenceFrameworkRevision()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFrameworkRevision(v)
			applied++
		case "category":
			if value == nil {
				update.ClearCategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategory(v)
			applied++
		case "category_id":
			if value == nil {
				update.ClearCategoryID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategoryID(v)
			applied++
		case "subcategory":
			if value == nil {
				update.ClearSubcategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetSubcategory(v)
			applied++
		case "control_owner_id":
			if value == nil {
				update.ClearControlOwnerID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetControlOwnerID(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Evidence entity
// This is a type-safe helper for workflow field updates
func (c *EvidenceClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a InternalPolicy entity
// This is a type-safe helper for workflow field updates
func (c *InternalPolicyClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Procedure entity
// This is a type-safe helper for workflow field updates
func (c *ProcedureClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Subcontrol entity
// This is a type-safe helper for workflow field updates
func (c *SubcontrolClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "title":
			if value == nil {
				update.ClearTitle()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetTitle(v)
			applied++
		case "reference_id":
			if value == nil {
				update.ClearReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceID(v)
			applied++
		case "auditor_reference_id":
			if value == nil {
				update.ClearAuditorReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetAuditorReferenceID(v)
			applied++
		case "responsible_party_id":
			if value == nil {
				update.ClearResponsiblePartyID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetResponsiblePartyID(v)
			applied++
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.ControlStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "reference_framework":
			if value == nil {
				update.ClearReferenceFramework()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFramework(v)
			applied++
		case "reference_framework_revision":
			if value == nil {
				update.ClearReferenceFrameworkRevision()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFrameworkRevision(v)
			applied++
		case "category":
			if value == nil {
				update.ClearCategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategory(v)
			applied++
		case "category_id":
			if value == nil {
				update.ClearCategoryID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategoryID(v)
			applied++
		case "subcategory":
			if value == nil {
				update.ClearSubcategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetSubcategory(v)
			applied++
		case "control_owner_id":
			if value == nil {
				update.ClearControlOwnerID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetControlOwnerID(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

var workflowTimeType = reflect.TypeOf(time.Time{})

func coerceWorkflowValue[T any](value any) (T, error) {
	var zero T

	if value == nil {
		return zero, fmt.Errorf("nil value")
	}

	if v, ok := value.(T); ok {
		return v, nil
	}

	targetType := reflect.TypeOf(zero)
	if targetType == nil {
		return zero, fmt.Errorf("unsupported target type")
	}

	if targetType == workflowTimeType {
		switch v := value.(type) {
		case string:
			parsed, err := time.Parse(time.RFC3339Nano, v)
			if err != nil {
				parsed, err = time.Parse(time.RFC3339, v)
			}
			if err != nil {
				return zero, err
			}
			return any(parsed).(T), nil
		case []byte:
			parsed, err := time.Parse(time.RFC3339Nano, string(v))
			if err != nil {
				parsed, err = time.Parse(time.RFC3339, string(v))
			}
			if err != nil {
				return zero, err
			}
			return any(parsed).(T), nil
		default:
			return zero, fmt.Errorf("cannot coerce %T to time.Time", value)
		}
	}

	if targetType.Kind() == reflect.String {
		switch v := value.(type) {
		case string:
			return reflect.ValueOf(v).Convert(targetType).Interface().(T), nil
		case []byte:
			return reflect.ValueOf(string(v)).Convert(targetType).Interface().(T), nil
		case fmt.Stringer:
			return reflect.ValueOf(v.String()).Convert(targetType).Interface().(T), nil
		default:
			return zero, fmt.Errorf("cannot coerce %T to %s", value, targetType)
		}
	}

	rv := reflect.ValueOf(value)
	if rv.IsValid() && rv.Type().ConvertibleTo(targetType) {
		return rv.Convert(targetType).Interface().(T), nil
	}

	return zero, fmt.Errorf("unsupported conversion from %T to %s", value, targetType)
}
