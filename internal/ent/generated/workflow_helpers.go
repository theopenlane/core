// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/common/models"
)

// ApplyFieldUpdates applies field updates from a map to a ActionPlan entity
// This is a type-safe helper for workflow field updates
func (c *ActionPlanClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.DocumentStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "details":
			if value == nil {
				update.ClearDetails()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDetails(v)
			applied++
		case "details_json":
			if value == nil {
				update.ClearDetailsJSON()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[[]interface{}](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDetailsJSON(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Campaign entity
// This is a type-safe helper for workflow field updates
func (c *CampaignClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		case "status":
			v, err := coerceWorkflowValue[enums.CampaignStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "is_active":
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetIsActive(v)
			applied++
		case "scheduled_at":
			if value == nil {
				update.ClearScheduledAt()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[models.DateTime](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetScheduledAt(v)
			applied++
		case "due_date":
			if value == nil {
				update.ClearDueDate()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[models.DateTime](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDueDate(v)
			applied++
		case "is_recurring":
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetIsRecurring(v)
			applied++
		case "recurrence_frequency":
			if value == nil {
				update.ClearRecurrenceFrequency()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.Frequency](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetRecurrenceFrequency(v)
			applied++
		case "recipient_count":
			if value == nil {
				update.ClearRecipientCount()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[int](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetRecipientCount(v)
			applied++
		case "resend_count":
			if value == nil {
				update.ClearResendCount()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[int](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetResendCount(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a CampaignTarget entity
// This is a type-safe helper for workflow field updates
func (c *CampaignTargetClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		case "status":
			v, err := coerceWorkflowValue[enums.AssessmentResponseStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "sent_at":
			if value == nil {
				update.ClearSentAt()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[models.DateTime](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetSentAt(v)
			applied++
		case "completed_at":
			if value == nil {
				update.ClearCompletedAt()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[models.DateTime](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCompletedAt(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Control entity
// This is a type-safe helper for workflow field updates
func (c *ControlClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "title":
			if value == nil {
				update.ClearTitle()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetTitle(v)
			applied++
		case "reference_id":
			if value == nil {
				update.ClearReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceID(v)
			applied++
		case "auditor_reference_id":
			if value == nil {
				update.ClearAuditorReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetAuditorReferenceID(v)
			applied++
		case "responsible_party_id":
			if value == nil {
				update.ClearResponsiblePartyID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetResponsiblePartyID(v)
			applied++
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.ControlStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "reference_framework":
			if value == nil {
				update.ClearReferenceFramework()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFramework(v)
			applied++
		case "reference_framework_revision":
			if value == nil {
				update.ClearReferenceFrameworkRevision()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFrameworkRevision(v)
			applied++
		case "category":
			if value == nil {
				update.ClearCategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategory(v)
			applied++
		case "category_id":
			if value == nil {
				update.ClearCategoryID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategoryID(v)
			applied++
		case "subcategory":
			if value == nil {
				update.ClearSubcategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetSubcategory(v)
			applied++
		case "control_owner_id":
			if value == nil {
				update.ClearControlOwnerID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetControlOwnerID(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Evidence entity
// This is a type-safe helper for workflow field updates
func (c *EvidenceClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a IdentityHolder entity
// This is a type-safe helper for workflow field updates
func (c *IdentityHolderClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		case "status":
			v, err := coerceWorkflowValue[enums.UserStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "is_active":
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetIsActive(v)
			applied++
		case "start_date":
			if value == nil {
				update.ClearStartDate()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[models.DateTime](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStartDate(v)
			applied++
		case "end_date":
			if value == nil {
				update.ClearEndDate()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[models.DateTime](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetEndDate(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a InternalPolicy entity
// This is a type-safe helper for workflow field updates
func (c *InternalPolicyClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.DocumentStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "details":
			if value == nil {
				update.ClearDetails()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDetails(v)
			applied++
		case "details_json":
			if value == nil {
				update.ClearDetailsJSON()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[[]interface{}](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDetailsJSON(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Platform entity
// This is a type-safe helper for workflow field updates
func (c *PlatformClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		case "business_purpose":
			if value == nil {
				update.ClearBusinessPurpose()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetBusinessPurpose(v)
			applied++
		case "scope_statement":
			if value == nil {
				update.ClearScopeStatement()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetScopeStatement(v)
			applied++
		case "status":
			v, err := coerceWorkflowValue[enums.PlatformStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "contains_pii":
			if value == nil {
				update.ClearContainsPii()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetContainsPii(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Procedure entity
// This is a type-safe helper for workflow field updates
func (c *ProcedureClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.DocumentStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "details":
			if value == nil {
				update.ClearDetails()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDetails(v)
			applied++
		case "details_json":
			if value == nil {
				update.ClearDetailsJSON()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[[]interface{}](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetDetailsJSON(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

// ApplyFieldUpdates applies field updates from a map to a Subcontrol entity
// This is a type-safe helper for workflow field updates
func (c *SubcontrolClient) ApplyFieldUpdates(ctx context.Context, id string, updates map[string]any) error {
	update := c.UpdateOneID(id)
	applied := 0
	for field, value := range updates {
		switch field {
		case "title":
			if value == nil {
				update.ClearTitle()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetTitle(v)
			applied++
		case "reference_id":
			if value == nil {
				update.ClearReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceID(v)
			applied++
		case "auditor_reference_id":
			if value == nil {
				update.ClearAuditorReferenceID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetAuditorReferenceID(v)
			applied++
		case "responsible_party_id":
			if value == nil {
				update.ClearResponsiblePartyID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetResponsiblePartyID(v)
			applied++
		case "status":
			if value == nil {
				update.ClearStatus()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[enums.ControlStatus](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetStatus(v)
			applied++
		case "reference_framework":
			if value == nil {
				update.ClearReferenceFramework()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFramework(v)
			applied++
		case "reference_framework_revision":
			if value == nil {
				update.ClearReferenceFrameworkRevision()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetReferenceFrameworkRevision(v)
			applied++
		case "category":
			if value == nil {
				update.ClearCategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategory(v)
			applied++
		case "category_id":
			if value == nil {
				update.ClearCategoryID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetCategoryID(v)
			applied++
		case "subcategory":
			if value == nil {
				update.ClearSubcategory()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetSubcategory(v)
			applied++
		case "control_owner_id":
			if value == nil {
				update.ClearControlOwnerID()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[string](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetControlOwnerID(v)
			applied++
		case "workflow_eligible_marker":
			if value == nil {
				update.ClearWorkflowEligibleMarker()
				applied++
				continue
			}
			v, err := coerceWorkflowValue[bool](value)
			if err != nil {
				return fmt.Errorf("workflow: invalid field update for %s: %w", field, err)
			}
			update.SetWorkflowEligibleMarker(v)
			applied++
		default:
			return fmt.Errorf("workflow: field update not eligible: %s", field)
		}
	}

	if applied == 0 {
		return nil
	}

	return update.Exec(ctx)
}

var workflowTimeType = reflect.TypeOf(time.Time{})

func coerceWorkflowValue[T any](value any) (T, error) {
	var zero T

	if value == nil {
		return zero, fmt.Errorf("nil value")
	}

	if v, ok := value.(T); ok {
		return v, nil
	}

	targetType := reflect.TypeOf(zero)
	if targetType == nil {
		return zero, fmt.Errorf("unsupported target type")
	}

	if targetType == workflowTimeType {
		switch v := value.(type) {
		case string:
			parsed, err := time.Parse(time.RFC3339Nano, v)
			if err != nil {
				parsed, err = time.Parse(time.RFC3339, v)
			}
			if err != nil {
				return zero, err
			}
			return any(parsed).(T), nil
		case []byte:
			parsed, err := time.Parse(time.RFC3339Nano, string(v))
			if err != nil {
				parsed, err = time.Parse(time.RFC3339, string(v))
			}
			if err != nil {
				return zero, err
			}
			return any(parsed).(T), nil
		default:
			return zero, fmt.Errorf("cannot coerce %T to time.Time", value)
		}
	}

	if targetType.Kind() == reflect.String {
		switch v := value.(type) {
		case string:
			return reflect.ValueOf(v).Convert(targetType).Interface().(T), nil
		case []byte:
			return reflect.ValueOf(string(v)).Convert(targetType).Interface().(T), nil
		case fmt.Stringer:
			return reflect.ValueOf(v.String()).Convert(targetType).Interface().(T), nil
		default:
			return zero, fmt.Errorf("cannot coerce %T to %s", value, targetType)
		}
	}

	rv := reflect.ValueOf(value)
	if rv.IsValid() && rv.Type().ConvertibleTo(targetType) {
		return rv.Convert(targetType).Interface().(T), nil
	}

	return zero, fmt.Errorf("unsupported conversion from %T to %s", value, targetType)
}
