// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"ariga.io/entcache"
	"github.com/theopenlane/core/internal/ent/generated/migrate"
	"github.com/theopenlane/entx"
	"github.com/theopenlane/riverboat/pkg/riverqueue"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/theopenlane/core/internal/ent/entconfig"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/assessment"
	"github.com/theopenlane/core/internal/ent/generated/assessmenthistory"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponse"
	"github.com/theopenlane/core/internal/ent/generated/assessmentresponsehistory"
	"github.com/theopenlane/core/internal/ent/generated/asset"
	"github.com/theopenlane/core/internal/ent/generated/assethistory"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementation"
	"github.com/theopenlane/core/internal/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/customdomain"
	"github.com/theopenlane/core/internal/ent/generated/customdomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/customtypeenum"
	"github.com/theopenlane/core/internal/ent/generated/dnsverification"
	"github.com/theopenlane/core/internal/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/emailverificationtoken"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/evidence"
	"github.com/theopenlane/core/internal/ent/generated/evidencehistory"
	"github.com/theopenlane/core/internal/ent/generated/export"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filedownloadtoken"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/finding"
	"github.com/theopenlane/core/internal/ent/generated/findingcontrol"
	"github.com/theopenlane/core/internal/ent/generated/findingcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/findinghistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/impersonationevent"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/jobresult"
	"github.com/theopenlane/core/internal/ent/generated/jobrunner"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnerregistrationtoken"
	"github.com/theopenlane/core/internal/ent/generated/jobrunnertoken"
	"github.com/theopenlane/core/internal/ent/generated/jobtemplate"
	"github.com/theopenlane/core/internal/ent/generated/jobtemplatehistory"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomain"
	"github.com/theopenlane/core/internal/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrol"
	"github.com/theopenlane/core/internal/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/notification"
	"github.com/theopenlane/core/internal/ent/generated/onboarding"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmodule"
	"github.com/theopenlane/core/internal/ent/generated/orgprice"
	"github.com/theopenlane/core/internal/ent/generated/orgproduct"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscription"
	"github.com/theopenlane/core/internal/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/core/internal/ent/generated/passwordresettoken"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/remediation"
	"github.com/theopenlane/core/internal/ent/generated/remediationhistory"
	"github.com/theopenlane/core/internal/ent/generated/review"
	"github.com/theopenlane/core/internal/ent/generated/reviewhistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/scan"
	"github.com/theopenlane/core/internal/ent/generated/scanhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjob"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/core/internal/ent/generated/scheduledjobrun"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subprocessor"
	"github.com/theopenlane/core/internal/ent/generated/subprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/tagdefinition"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcenter"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliance"
	"github.com/theopenlane/core/internal/ent/generated/trustcentercompliancehistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdoc"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterdochistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersetting"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessor"
	"github.com/theopenlane/core/internal/ent/generated/trustcentersubprocessorhistory"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfig"
	"github.com/theopenlane/core/internal/ent/generated/trustcenterwatermarkconfighistory"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/vulnerability"
	"github.com/theopenlane/core/internal/ent/generated/vulnerabilityhistory"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/theopenlane/core/internal/ent/validator"
	"github.com/theopenlane/core/internal/objects"
	"github.com/theopenlane/core/pkg/entitlements"
	"github.com/theopenlane/core/pkg/events/soiree"
	"github.com/theopenlane/core/pkg/summarizer"
	"github.com/theopenlane/core/pkg/windmill"
	"github.com/theopenlane/emailtemplates"
	"github.com/theopenlane/iam/fgax"
	"github.com/theopenlane/iam/sessions"
	"github.com/theopenlane/iam/tokens"
	"github.com/theopenlane/iam/totp"
	"gocloud.dev/secrets"

	"github.com/theopenlane/iam/entfga"

	stdsql "database/sql"

	"github.com/theopenlane/core/internal/ent/generated/internal"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIToken is the client for interacting with the APIToken builders.
	APIToken *APITokenClient
	// ActionPlan is the client for interacting with the ActionPlan builders.
	ActionPlan *ActionPlanClient
	// ActionPlanHistory is the client for interacting with the ActionPlanHistory builders.
	ActionPlanHistory *ActionPlanHistoryClient
	// Assessment is the client for interacting with the Assessment builders.
	Assessment *AssessmentClient
	// AssessmentHistory is the client for interacting with the AssessmentHistory builders.
	AssessmentHistory *AssessmentHistoryClient
	// AssessmentResponse is the client for interacting with the AssessmentResponse builders.
	AssessmentResponse *AssessmentResponseClient
	// AssessmentResponseHistory is the client for interacting with the AssessmentResponseHistory builders.
	AssessmentResponseHistory *AssessmentResponseHistoryClient
	// Asset is the client for interacting with the Asset builders.
	Asset *AssetClient
	// AssetHistory is the client for interacting with the AssetHistory builders.
	AssetHistory *AssetHistoryClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// ContactHistory is the client for interacting with the ContactHistory builders.
	ContactHistory *ContactHistoryClient
	// Control is the client for interacting with the Control builders.
	Control *ControlClient
	// ControlHistory is the client for interacting with the ControlHistory builders.
	ControlHistory *ControlHistoryClient
	// ControlImplementation is the client for interacting with the ControlImplementation builders.
	ControlImplementation *ControlImplementationClient
	// ControlImplementationHistory is the client for interacting with the ControlImplementationHistory builders.
	ControlImplementationHistory *ControlImplementationHistoryClient
	// ControlObjective is the client for interacting with the ControlObjective builders.
	ControlObjective *ControlObjectiveClient
	// ControlObjectiveHistory is the client for interacting with the ControlObjectiveHistory builders.
	ControlObjectiveHistory *ControlObjectiveHistoryClient
	// CustomDomain is the client for interacting with the CustomDomain builders.
	CustomDomain *CustomDomainClient
	// CustomDomainHistory is the client for interacting with the CustomDomainHistory builders.
	CustomDomainHistory *CustomDomainHistoryClient
	// CustomTypeEnum is the client for interacting with the CustomTypeEnum builders.
	CustomTypeEnum *CustomTypeEnumClient
	// DNSVerification is the client for interacting with the DNSVerification builders.
	DNSVerification *DNSVerificationClient
	// DNSVerificationHistory is the client for interacting with the DNSVerificationHistory builders.
	DNSVerificationHistory *DNSVerificationHistoryClient
	// DocumentData is the client for interacting with the DocumentData builders.
	DocumentData *DocumentDataClient
	// DocumentDataHistory is the client for interacting with the DocumentDataHistory builders.
	DocumentDataHistory *DocumentDataHistoryClient
	// EmailVerificationToken is the client for interacting with the EmailVerificationToken builders.
	EmailVerificationToken *EmailVerificationTokenClient
	// Entity is the client for interacting with the Entity builders.
	Entity *EntityClient
	// EntityHistory is the client for interacting with the EntityHistory builders.
	EntityHistory *EntityHistoryClient
	// EntityType is the client for interacting with the EntityType builders.
	EntityType *EntityTypeClient
	// EntityTypeHistory is the client for interacting with the EntityTypeHistory builders.
	EntityTypeHistory *EntityTypeHistoryClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// Evidence is the client for interacting with the Evidence builders.
	Evidence *EvidenceClient
	// EvidenceHistory is the client for interacting with the EvidenceHistory builders.
	EvidenceHistory *EvidenceHistoryClient
	// Export is the client for interacting with the Export builders.
	Export *ExportClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// FileDownloadToken is the client for interacting with the FileDownloadToken builders.
	FileDownloadToken *FileDownloadTokenClient
	// FileHistory is the client for interacting with the FileHistory builders.
	FileHistory *FileHistoryClient
	// Finding is the client for interacting with the Finding builders.
	Finding *FindingClient
	// FindingControl is the client for interacting with the FindingControl builders.
	FindingControl *FindingControlClient
	// FindingControlHistory is the client for interacting with the FindingControlHistory builders.
	FindingControlHistory *FindingControlHistoryClient
	// FindingHistory is the client for interacting with the FindingHistory builders.
	FindingHistory *FindingHistoryClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// GroupHistory is the client for interacting with the GroupHistory builders.
	GroupHistory *GroupHistoryClient
	// GroupMembership is the client for interacting with the GroupMembership builders.
	GroupMembership *GroupMembershipClient
	// GroupMembershipHistory is the client for interacting with the GroupMembershipHistory builders.
	GroupMembershipHistory *GroupMembershipHistoryClient
	// GroupSetting is the client for interacting with the GroupSetting builders.
	GroupSetting *GroupSettingClient
	// GroupSettingHistory is the client for interacting with the GroupSettingHistory builders.
	GroupSettingHistory *GroupSettingHistoryClient
	// Hush is the client for interacting with the Hush builders.
	Hush *HushClient
	// HushHistory is the client for interacting with the HushHistory builders.
	HushHistory *HushHistoryClient
	// ImpersonationEvent is the client for interacting with the ImpersonationEvent builders.
	ImpersonationEvent *ImpersonationEventClient
	// Integration is the client for interacting with the Integration builders.
	Integration *IntegrationClient
	// IntegrationHistory is the client for interacting with the IntegrationHistory builders.
	IntegrationHistory *IntegrationHistoryClient
	// InternalPolicy is the client for interacting with the InternalPolicy builders.
	InternalPolicy *InternalPolicyClient
	// InternalPolicyHistory is the client for interacting with the InternalPolicyHistory builders.
	InternalPolicyHistory *InternalPolicyHistoryClient
	// Invite is the client for interacting with the Invite builders.
	Invite *InviteClient
	// JobResult is the client for interacting with the JobResult builders.
	JobResult *JobResultClient
	// JobRunner is the client for interacting with the JobRunner builders.
	JobRunner *JobRunnerClient
	// JobRunnerRegistrationToken is the client for interacting with the JobRunnerRegistrationToken builders.
	JobRunnerRegistrationToken *JobRunnerRegistrationTokenClient
	// JobRunnerToken is the client for interacting with the JobRunnerToken builders.
	JobRunnerToken *JobRunnerTokenClient
	// JobTemplate is the client for interacting with the JobTemplate builders.
	JobTemplate *JobTemplateClient
	// JobTemplateHistory is the client for interacting with the JobTemplateHistory builders.
	JobTemplateHistory *JobTemplateHistoryClient
	// MappableDomain is the client for interacting with the MappableDomain builders.
	MappableDomain *MappableDomainClient
	// MappableDomainHistory is the client for interacting with the MappableDomainHistory builders.
	MappableDomainHistory *MappableDomainHistoryClient
	// MappedControl is the client for interacting with the MappedControl builders.
	MappedControl *MappedControlClient
	// MappedControlHistory is the client for interacting with the MappedControlHistory builders.
	MappedControlHistory *MappedControlHistoryClient
	// Narrative is the client for interacting with the Narrative builders.
	Narrative *NarrativeClient
	// NarrativeHistory is the client for interacting with the NarrativeHistory builders.
	NarrativeHistory *NarrativeHistoryClient
	// Note is the client for interacting with the Note builders.
	Note *NoteClient
	// NoteHistory is the client for interacting with the NoteHistory builders.
	NoteHistory *NoteHistoryClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// Onboarding is the client for interacting with the Onboarding builders.
	Onboarding *OnboardingClient
	// OrgMembership is the client for interacting with the OrgMembership builders.
	OrgMembership *OrgMembershipClient
	// OrgMembershipHistory is the client for interacting with the OrgMembershipHistory builders.
	OrgMembershipHistory *OrgMembershipHistoryClient
	// OrgModule is the client for interacting with the OrgModule builders.
	OrgModule *OrgModuleClient
	// OrgPrice is the client for interacting with the OrgPrice builders.
	OrgPrice *OrgPriceClient
	// OrgProduct is the client for interacting with the OrgProduct builders.
	OrgProduct *OrgProductClient
	// OrgSubscription is the client for interacting with the OrgSubscription builders.
	OrgSubscription *OrgSubscriptionClient
	// OrgSubscriptionHistory is the client for interacting with the OrgSubscriptionHistory builders.
	OrgSubscriptionHistory *OrgSubscriptionHistoryClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// OrganizationHistory is the client for interacting with the OrganizationHistory builders.
	OrganizationHistory *OrganizationHistoryClient
	// OrganizationSetting is the client for interacting with the OrganizationSetting builders.
	OrganizationSetting *OrganizationSettingClient
	// OrganizationSettingHistory is the client for interacting with the OrganizationSettingHistory builders.
	OrganizationSettingHistory *OrganizationSettingHistoryClient
	// PasswordResetToken is the client for interacting with the PasswordResetToken builders.
	PasswordResetToken *PasswordResetTokenClient
	// PersonalAccessToken is the client for interacting with the PersonalAccessToken builders.
	PersonalAccessToken *PersonalAccessTokenClient
	// Procedure is the client for interacting with the Procedure builders.
	Procedure *ProcedureClient
	// ProcedureHistory is the client for interacting with the ProcedureHistory builders.
	ProcedureHistory *ProcedureHistoryClient
	// Program is the client for interacting with the Program builders.
	Program *ProgramClient
	// ProgramHistory is the client for interacting with the ProgramHistory builders.
	ProgramHistory *ProgramHistoryClient
	// ProgramMembership is the client for interacting with the ProgramMembership builders.
	ProgramMembership *ProgramMembershipClient
	// ProgramMembershipHistory is the client for interacting with the ProgramMembershipHistory builders.
	ProgramMembershipHistory *ProgramMembershipHistoryClient
	// Remediation is the client for interacting with the Remediation builders.
	Remediation *RemediationClient
	// RemediationHistory is the client for interacting with the RemediationHistory builders.
	RemediationHistory *RemediationHistoryClient
	// Review is the client for interacting with the Review builders.
	Review *ReviewClient
	// ReviewHistory is the client for interacting with the ReviewHistory builders.
	ReviewHistory *ReviewHistoryClient
	// Risk is the client for interacting with the Risk builders.
	Risk *RiskClient
	// RiskHistory is the client for interacting with the RiskHistory builders.
	RiskHistory *RiskHistoryClient
	// Scan is the client for interacting with the Scan builders.
	Scan *ScanClient
	// ScanHistory is the client for interacting with the ScanHistory builders.
	ScanHistory *ScanHistoryClient
	// ScheduledJob is the client for interacting with the ScheduledJob builders.
	ScheduledJob *ScheduledJobClient
	// ScheduledJobHistory is the client for interacting with the ScheduledJobHistory builders.
	ScheduledJobHistory *ScheduledJobHistoryClient
	// ScheduledJobRun is the client for interacting with the ScheduledJobRun builders.
	ScheduledJobRun *ScheduledJobRunClient
	// Standard is the client for interacting with the Standard builders.
	Standard *StandardClient
	// StandardHistory is the client for interacting with the StandardHistory builders.
	StandardHistory *StandardHistoryClient
	// Subcontrol is the client for interacting with the Subcontrol builders.
	Subcontrol *SubcontrolClient
	// SubcontrolHistory is the client for interacting with the SubcontrolHistory builders.
	SubcontrolHistory *SubcontrolHistoryClient
	// Subprocessor is the client for interacting with the Subprocessor builders.
	Subprocessor *SubprocessorClient
	// SubprocessorHistory is the client for interacting with the SubprocessorHistory builders.
	SubprocessorHistory *SubprocessorHistoryClient
	// Subscriber is the client for interacting with the Subscriber builders.
	Subscriber *SubscriberClient
	// TFASetting is the client for interacting with the TFASetting builders.
	TFASetting *TFASettingClient
	// TagDefinition is the client for interacting with the TagDefinition builders.
	TagDefinition *TagDefinitionClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// TaskHistory is the client for interacting with the TaskHistory builders.
	TaskHistory *TaskHistoryClient
	// Template is the client for interacting with the Template builders.
	Template *TemplateClient
	// TemplateHistory is the client for interacting with the TemplateHistory builders.
	TemplateHistory *TemplateHistoryClient
	// TrustCenter is the client for interacting with the TrustCenter builders.
	TrustCenter *TrustCenterClient
	// TrustCenterCompliance is the client for interacting with the TrustCenterCompliance builders.
	TrustCenterCompliance *TrustCenterComplianceClient
	// TrustCenterComplianceHistory is the client for interacting with the TrustCenterComplianceHistory builders.
	TrustCenterComplianceHistory *TrustCenterComplianceHistoryClient
	// TrustCenterDoc is the client for interacting with the TrustCenterDoc builders.
	TrustCenterDoc *TrustCenterDocClient
	// TrustCenterDocHistory is the client for interacting with the TrustCenterDocHistory builders.
	TrustCenterDocHistory *TrustCenterDocHistoryClient
	// TrustCenterHistory is the client for interacting with the TrustCenterHistory builders.
	TrustCenterHistory *TrustCenterHistoryClient
	// TrustCenterSetting is the client for interacting with the TrustCenterSetting builders.
	TrustCenterSetting *TrustCenterSettingClient
	// TrustCenterSettingHistory is the client for interacting with the TrustCenterSettingHistory builders.
	TrustCenterSettingHistory *TrustCenterSettingHistoryClient
	// TrustCenterSubprocessor is the client for interacting with the TrustCenterSubprocessor builders.
	TrustCenterSubprocessor *TrustCenterSubprocessorClient
	// TrustCenterSubprocessorHistory is the client for interacting with the TrustCenterSubprocessorHistory builders.
	TrustCenterSubprocessorHistory *TrustCenterSubprocessorHistoryClient
	// TrustCenterWatermarkConfig is the client for interacting with the TrustCenterWatermarkConfig builders.
	TrustCenterWatermarkConfig *TrustCenterWatermarkConfigClient
	// TrustCenterWatermarkConfigHistory is the client for interacting with the TrustCenterWatermarkConfigHistory builders.
	TrustCenterWatermarkConfigHistory *TrustCenterWatermarkConfigHistoryClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserHistory is the client for interacting with the UserHistory builders.
	UserHistory *UserHistoryClient
	// UserSetting is the client for interacting with the UserSetting builders.
	UserSetting *UserSettingClient
	// UserSettingHistory is the client for interacting with the UserSettingHistory builders.
	UserSettingHistory *UserSettingHistoryClient
	// Vulnerability is the client for interacting with the Vulnerability builders.
	Vulnerability *VulnerabilityClient
	// VulnerabilityHistory is the client for interacting with the VulnerabilityHistory builders.
	VulnerabilityHistory *VulnerabilityHistoryClient
	// Webauthn is the client for interacting with the Webauthn builders.
	Webauthn *WebauthnClient

	// authzActivated determines if the authz hooks have already been activated
	authzActivated bool

	// Config is the db client configuration
	Config *entx.EntClientConfig

	// Job is the job client to insert jobs into the queue.
	Job riverqueue.JobClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIToken = NewAPITokenClient(c.config)
	c.ActionPlan = NewActionPlanClient(c.config)
	c.ActionPlanHistory = NewActionPlanHistoryClient(c.config)
	c.Assessment = NewAssessmentClient(c.config)
	c.AssessmentHistory = NewAssessmentHistoryClient(c.config)
	c.AssessmentResponse = NewAssessmentResponseClient(c.config)
	c.AssessmentResponseHistory = NewAssessmentResponseHistoryClient(c.config)
	c.Asset = NewAssetClient(c.config)
	c.AssetHistory = NewAssetHistoryClient(c.config)
	c.Contact = NewContactClient(c.config)
	c.ContactHistory = NewContactHistoryClient(c.config)
	c.Control = NewControlClient(c.config)
	c.ControlHistory = NewControlHistoryClient(c.config)
	c.ControlImplementation = NewControlImplementationClient(c.config)
	c.ControlImplementationHistory = NewControlImplementationHistoryClient(c.config)
	c.ControlObjective = NewControlObjectiveClient(c.config)
	c.ControlObjectiveHistory = NewControlObjectiveHistoryClient(c.config)
	c.CustomDomain = NewCustomDomainClient(c.config)
	c.CustomDomainHistory = NewCustomDomainHistoryClient(c.config)
	c.CustomTypeEnum = NewCustomTypeEnumClient(c.config)
	c.DNSVerification = NewDNSVerificationClient(c.config)
	c.DNSVerificationHistory = NewDNSVerificationHistoryClient(c.config)
	c.DocumentData = NewDocumentDataClient(c.config)
	c.DocumentDataHistory = NewDocumentDataHistoryClient(c.config)
	c.EmailVerificationToken = NewEmailVerificationTokenClient(c.config)
	c.Entity = NewEntityClient(c.config)
	c.EntityHistory = NewEntityHistoryClient(c.config)
	c.EntityType = NewEntityTypeClient(c.config)
	c.EntityTypeHistory = NewEntityTypeHistoryClient(c.config)
	c.Event = NewEventClient(c.config)
	c.Evidence = NewEvidenceClient(c.config)
	c.EvidenceHistory = NewEvidenceHistoryClient(c.config)
	c.Export = NewExportClient(c.config)
	c.File = NewFileClient(c.config)
	c.FileDownloadToken = NewFileDownloadTokenClient(c.config)
	c.FileHistory = NewFileHistoryClient(c.config)
	c.Finding = NewFindingClient(c.config)
	c.FindingControl = NewFindingControlClient(c.config)
	c.FindingControlHistory = NewFindingControlHistoryClient(c.config)
	c.FindingHistory = NewFindingHistoryClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.GroupHistory = NewGroupHistoryClient(c.config)
	c.GroupMembership = NewGroupMembershipClient(c.config)
	c.GroupMembershipHistory = NewGroupMembershipHistoryClient(c.config)
	c.GroupSetting = NewGroupSettingClient(c.config)
	c.GroupSettingHistory = NewGroupSettingHistoryClient(c.config)
	c.Hush = NewHushClient(c.config)
	c.HushHistory = NewHushHistoryClient(c.config)
	c.ImpersonationEvent = NewImpersonationEventClient(c.config)
	c.Integration = NewIntegrationClient(c.config)
	c.IntegrationHistory = NewIntegrationHistoryClient(c.config)
	c.InternalPolicy = NewInternalPolicyClient(c.config)
	c.InternalPolicyHistory = NewInternalPolicyHistoryClient(c.config)
	c.Invite = NewInviteClient(c.config)
	c.JobResult = NewJobResultClient(c.config)
	c.JobRunner = NewJobRunnerClient(c.config)
	c.JobRunnerRegistrationToken = NewJobRunnerRegistrationTokenClient(c.config)
	c.JobRunnerToken = NewJobRunnerTokenClient(c.config)
	c.JobTemplate = NewJobTemplateClient(c.config)
	c.JobTemplateHistory = NewJobTemplateHistoryClient(c.config)
	c.MappableDomain = NewMappableDomainClient(c.config)
	c.MappableDomainHistory = NewMappableDomainHistoryClient(c.config)
	c.MappedControl = NewMappedControlClient(c.config)
	c.MappedControlHistory = NewMappedControlHistoryClient(c.config)
	c.Narrative = NewNarrativeClient(c.config)
	c.NarrativeHistory = NewNarrativeHistoryClient(c.config)
	c.Note = NewNoteClient(c.config)
	c.NoteHistory = NewNoteHistoryClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.Onboarding = NewOnboardingClient(c.config)
	c.OrgMembership = NewOrgMembershipClient(c.config)
	c.OrgMembershipHistory = NewOrgMembershipHistoryClient(c.config)
	c.OrgModule = NewOrgModuleClient(c.config)
	c.OrgPrice = NewOrgPriceClient(c.config)
	c.OrgProduct = NewOrgProductClient(c.config)
	c.OrgSubscription = NewOrgSubscriptionClient(c.config)
	c.OrgSubscriptionHistory = NewOrgSubscriptionHistoryClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.OrganizationHistory = NewOrganizationHistoryClient(c.config)
	c.OrganizationSetting = NewOrganizationSettingClient(c.config)
	c.OrganizationSettingHistory = NewOrganizationSettingHistoryClient(c.config)
	c.PasswordResetToken = NewPasswordResetTokenClient(c.config)
	c.PersonalAccessToken = NewPersonalAccessTokenClient(c.config)
	c.Procedure = NewProcedureClient(c.config)
	c.ProcedureHistory = NewProcedureHistoryClient(c.config)
	c.Program = NewProgramClient(c.config)
	c.ProgramHistory = NewProgramHistoryClient(c.config)
	c.ProgramMembership = NewProgramMembershipClient(c.config)
	c.ProgramMembershipHistory = NewProgramMembershipHistoryClient(c.config)
	c.Remediation = NewRemediationClient(c.config)
	c.RemediationHistory = NewRemediationHistoryClient(c.config)
	c.Review = NewReviewClient(c.config)
	c.ReviewHistory = NewReviewHistoryClient(c.config)
	c.Risk = NewRiskClient(c.config)
	c.RiskHistory = NewRiskHistoryClient(c.config)
	c.Scan = NewScanClient(c.config)
	c.ScanHistory = NewScanHistoryClient(c.config)
	c.ScheduledJob = NewScheduledJobClient(c.config)
	c.ScheduledJobHistory = NewScheduledJobHistoryClient(c.config)
	c.ScheduledJobRun = NewScheduledJobRunClient(c.config)
	c.Standard = NewStandardClient(c.config)
	c.StandardHistory = NewStandardHistoryClient(c.config)
	c.Subcontrol = NewSubcontrolClient(c.config)
	c.SubcontrolHistory = NewSubcontrolHistoryClient(c.config)
	c.Subprocessor = NewSubprocessorClient(c.config)
	c.SubprocessorHistory = NewSubprocessorHistoryClient(c.config)
	c.Subscriber = NewSubscriberClient(c.config)
	c.TFASetting = NewTFASettingClient(c.config)
	c.TagDefinition = NewTagDefinitionClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.TaskHistory = NewTaskHistoryClient(c.config)
	c.Template = NewTemplateClient(c.config)
	c.TemplateHistory = NewTemplateHistoryClient(c.config)
	c.TrustCenter = NewTrustCenterClient(c.config)
	c.TrustCenterCompliance = NewTrustCenterComplianceClient(c.config)
	c.TrustCenterComplianceHistory = NewTrustCenterComplianceHistoryClient(c.config)
	c.TrustCenterDoc = NewTrustCenterDocClient(c.config)
	c.TrustCenterDocHistory = NewTrustCenterDocHistoryClient(c.config)
	c.TrustCenterHistory = NewTrustCenterHistoryClient(c.config)
	c.TrustCenterSetting = NewTrustCenterSettingClient(c.config)
	c.TrustCenterSettingHistory = NewTrustCenterSettingHistoryClient(c.config)
	c.TrustCenterSubprocessor = NewTrustCenterSubprocessorClient(c.config)
	c.TrustCenterSubprocessorHistory = NewTrustCenterSubprocessorHistoryClient(c.config)
	c.TrustCenterWatermarkConfig = NewTrustCenterWatermarkConfigClient(c.config)
	c.TrustCenterWatermarkConfigHistory = NewTrustCenterWatermarkConfigHistoryClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserHistory = NewUserHistoryClient(c.config)
	c.UserSetting = NewUserSettingClient(c.config)
	c.UserSettingHistory = NewUserSettingHistoryClient(c.config)
	c.Vulnerability = NewVulnerabilityClient(c.config)
	c.VulnerabilityHistory = NewVulnerabilityHistoryClient(c.config)
	c.Webauthn = NewWebauthnClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters             *inters
		EntConfig          *entconfig.Config
		Secrets            *secrets.Keeper
		Authz              fgax.Client
		TokenManager       *tokens.TokenManager
		SessionConfig      *sessions.SessionConfig
		Emailer            *emailtemplates.Config
		TOTP               *totp.Client
		EntitlementManager *entitlements.StripeClient
		ObjectManager      *objects.Service
		Summarizer         *summarizer.Client
		Windmill           *windmill.Client
		PondPool           *soiree.PondPool
		EmailVerifier      *validator.EmailVerifier
		// Job is the job client to insert jobs into the queue.
		Job riverqueue.JobClient

		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// EntConfig configures the EntConfig.
func EntConfig(v *entconfig.Config) Option {
	return func(c *config) {
		c.EntConfig = v
	}
}

// Secrets configures the Secrets.
func Secrets(v *secrets.Keeper) Option {
	return func(c *config) {
		c.Secrets = v
	}
}

// Authz configures the Authz.
func Authz(v fgax.Client) Option {
	return func(c *config) {
		c.Authz = v
	}
}

// TokenManager configures the TokenManager.
func TokenManager(v *tokens.TokenManager) Option {
	return func(c *config) {
		c.TokenManager = v
	}
}

// SessionConfig configures the SessionConfig.
func SessionConfig(v *sessions.SessionConfig) Option {
	return func(c *config) {
		c.SessionConfig = v
	}
}

// Emailer configures the Emailer.
func Emailer(v *emailtemplates.Config) Option {
	return func(c *config) {
		c.Emailer = v
	}
}

// TOTP configures the TOTP.
func TOTP(v *totp.Client) Option {
	return func(c *config) {
		c.TOTP = v
	}
}

// EntitlementManager configures the EntitlementManager.
func EntitlementManager(v *entitlements.StripeClient) Option {
	return func(c *config) {
		c.EntitlementManager = v
	}
}

// ObjectManager configures the ObjectManager.
func ObjectManager(v *objects.Service) Option {
	return func(c *config) {
		c.ObjectManager = v
	}
}

// Summarizer configures the Summarizer.
func Summarizer(v *summarizer.Client) Option {
	return func(c *config) {
		c.Summarizer = v
	}
}

// Windmill configures the Windmill.
func Windmill(v *windmill.Client) Option {
	return func(c *config) {
		c.Windmill = v
	}
}

// PondPool configures the PondPool.
func PondPool(v *soiree.PondPool) Option {
	return func(c *config) {
		c.PondPool = v
	}
}

// EmailVerifier configures the EmailVerifier.
func EmailVerifier(v *validator.EmailVerifier) Option {
	return func(c *config) {
		c.EmailVerifier = v
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                               ctx,
		config:                            cfg,
		APIToken:                          NewAPITokenClient(cfg),
		ActionPlan:                        NewActionPlanClient(cfg),
		ActionPlanHistory:                 NewActionPlanHistoryClient(cfg),
		Assessment:                        NewAssessmentClient(cfg),
		AssessmentHistory:                 NewAssessmentHistoryClient(cfg),
		AssessmentResponse:                NewAssessmentResponseClient(cfg),
		AssessmentResponseHistory:         NewAssessmentResponseHistoryClient(cfg),
		Asset:                             NewAssetClient(cfg),
		AssetHistory:                      NewAssetHistoryClient(cfg),
		Contact:                           NewContactClient(cfg),
		ContactHistory:                    NewContactHistoryClient(cfg),
		Control:                           NewControlClient(cfg),
		ControlHistory:                    NewControlHistoryClient(cfg),
		ControlImplementation:             NewControlImplementationClient(cfg),
		ControlImplementationHistory:      NewControlImplementationHistoryClient(cfg),
		ControlObjective:                  NewControlObjectiveClient(cfg),
		ControlObjectiveHistory:           NewControlObjectiveHistoryClient(cfg),
		CustomDomain:                      NewCustomDomainClient(cfg),
		CustomDomainHistory:               NewCustomDomainHistoryClient(cfg),
		CustomTypeEnum:                    NewCustomTypeEnumClient(cfg),
		DNSVerification:                   NewDNSVerificationClient(cfg),
		DNSVerificationHistory:            NewDNSVerificationHistoryClient(cfg),
		DocumentData:                      NewDocumentDataClient(cfg),
		DocumentDataHistory:               NewDocumentDataHistoryClient(cfg),
		EmailVerificationToken:            NewEmailVerificationTokenClient(cfg),
		Entity:                            NewEntityClient(cfg),
		EntityHistory:                     NewEntityHistoryClient(cfg),
		EntityType:                        NewEntityTypeClient(cfg),
		EntityTypeHistory:                 NewEntityTypeHistoryClient(cfg),
		Event:                             NewEventClient(cfg),
		Evidence:                          NewEvidenceClient(cfg),
		EvidenceHistory:                   NewEvidenceHistoryClient(cfg),
		Export:                            NewExportClient(cfg),
		File:                              NewFileClient(cfg),
		FileDownloadToken:                 NewFileDownloadTokenClient(cfg),
		FileHistory:                       NewFileHistoryClient(cfg),
		Finding:                           NewFindingClient(cfg),
		FindingControl:                    NewFindingControlClient(cfg),
		FindingControlHistory:             NewFindingControlHistoryClient(cfg),
		FindingHistory:                    NewFindingHistoryClient(cfg),
		Group:                             NewGroupClient(cfg),
		GroupHistory:                      NewGroupHistoryClient(cfg),
		GroupMembership:                   NewGroupMembershipClient(cfg),
		GroupMembershipHistory:            NewGroupMembershipHistoryClient(cfg),
		GroupSetting:                      NewGroupSettingClient(cfg),
		GroupSettingHistory:               NewGroupSettingHistoryClient(cfg),
		Hush:                              NewHushClient(cfg),
		HushHistory:                       NewHushHistoryClient(cfg),
		ImpersonationEvent:                NewImpersonationEventClient(cfg),
		Integration:                       NewIntegrationClient(cfg),
		IntegrationHistory:                NewIntegrationHistoryClient(cfg),
		InternalPolicy:                    NewInternalPolicyClient(cfg),
		InternalPolicyHistory:             NewInternalPolicyHistoryClient(cfg),
		Invite:                            NewInviteClient(cfg),
		JobResult:                         NewJobResultClient(cfg),
		JobRunner:                         NewJobRunnerClient(cfg),
		JobRunnerRegistrationToken:        NewJobRunnerRegistrationTokenClient(cfg),
		JobRunnerToken:                    NewJobRunnerTokenClient(cfg),
		JobTemplate:                       NewJobTemplateClient(cfg),
		JobTemplateHistory:                NewJobTemplateHistoryClient(cfg),
		MappableDomain:                    NewMappableDomainClient(cfg),
		MappableDomainHistory:             NewMappableDomainHistoryClient(cfg),
		MappedControl:                     NewMappedControlClient(cfg),
		MappedControlHistory:              NewMappedControlHistoryClient(cfg),
		Narrative:                         NewNarrativeClient(cfg),
		NarrativeHistory:                  NewNarrativeHistoryClient(cfg),
		Note:                              NewNoteClient(cfg),
		NoteHistory:                       NewNoteHistoryClient(cfg),
		Notification:                      NewNotificationClient(cfg),
		Onboarding:                        NewOnboardingClient(cfg),
		OrgMembership:                     NewOrgMembershipClient(cfg),
		OrgMembershipHistory:              NewOrgMembershipHistoryClient(cfg),
		OrgModule:                         NewOrgModuleClient(cfg),
		OrgPrice:                          NewOrgPriceClient(cfg),
		OrgProduct:                        NewOrgProductClient(cfg),
		OrgSubscription:                   NewOrgSubscriptionClient(cfg),
		OrgSubscriptionHistory:            NewOrgSubscriptionHistoryClient(cfg),
		Organization:                      NewOrganizationClient(cfg),
		OrganizationHistory:               NewOrganizationHistoryClient(cfg),
		OrganizationSetting:               NewOrganizationSettingClient(cfg),
		OrganizationSettingHistory:        NewOrganizationSettingHistoryClient(cfg),
		PasswordResetToken:                NewPasswordResetTokenClient(cfg),
		PersonalAccessToken:               NewPersonalAccessTokenClient(cfg),
		Procedure:                         NewProcedureClient(cfg),
		ProcedureHistory:                  NewProcedureHistoryClient(cfg),
		Program:                           NewProgramClient(cfg),
		ProgramHistory:                    NewProgramHistoryClient(cfg),
		ProgramMembership:                 NewProgramMembershipClient(cfg),
		ProgramMembershipHistory:          NewProgramMembershipHistoryClient(cfg),
		Remediation:                       NewRemediationClient(cfg),
		RemediationHistory:                NewRemediationHistoryClient(cfg),
		Review:                            NewReviewClient(cfg),
		ReviewHistory:                     NewReviewHistoryClient(cfg),
		Risk:                              NewRiskClient(cfg),
		RiskHistory:                       NewRiskHistoryClient(cfg),
		Scan:                              NewScanClient(cfg),
		ScanHistory:                       NewScanHistoryClient(cfg),
		ScheduledJob:                      NewScheduledJobClient(cfg),
		ScheduledJobHistory:               NewScheduledJobHistoryClient(cfg),
		ScheduledJobRun:                   NewScheduledJobRunClient(cfg),
		Standard:                          NewStandardClient(cfg),
		StandardHistory:                   NewStandardHistoryClient(cfg),
		Subcontrol:                        NewSubcontrolClient(cfg),
		SubcontrolHistory:                 NewSubcontrolHistoryClient(cfg),
		Subprocessor:                      NewSubprocessorClient(cfg),
		SubprocessorHistory:               NewSubprocessorHistoryClient(cfg),
		Subscriber:                        NewSubscriberClient(cfg),
		TFASetting:                        NewTFASettingClient(cfg),
		TagDefinition:                     NewTagDefinitionClient(cfg),
		Task:                              NewTaskClient(cfg),
		TaskHistory:                       NewTaskHistoryClient(cfg),
		Template:                          NewTemplateClient(cfg),
		TemplateHistory:                   NewTemplateHistoryClient(cfg),
		TrustCenter:                       NewTrustCenterClient(cfg),
		TrustCenterCompliance:             NewTrustCenterComplianceClient(cfg),
		TrustCenterComplianceHistory:      NewTrustCenterComplianceHistoryClient(cfg),
		TrustCenterDoc:                    NewTrustCenterDocClient(cfg),
		TrustCenterDocHistory:             NewTrustCenterDocHistoryClient(cfg),
		TrustCenterHistory:                NewTrustCenterHistoryClient(cfg),
		TrustCenterSetting:                NewTrustCenterSettingClient(cfg),
		TrustCenterSettingHistory:         NewTrustCenterSettingHistoryClient(cfg),
		TrustCenterSubprocessor:           NewTrustCenterSubprocessorClient(cfg),
		TrustCenterSubprocessorHistory:    NewTrustCenterSubprocessorHistoryClient(cfg),
		TrustCenterWatermarkConfig:        NewTrustCenterWatermarkConfigClient(cfg),
		TrustCenterWatermarkConfigHistory: NewTrustCenterWatermarkConfigHistoryClient(cfg),
		User:                              NewUserClient(cfg),
		UserHistory:                       NewUserHistoryClient(cfg),
		UserSetting:                       NewUserSettingClient(cfg),
		UserSettingHistory:                NewUserSettingHistoryClient(cfg),
		Vulnerability:                     NewVulnerabilityClient(cfg),
		VulnerabilityHistory:              NewVulnerabilityHistoryClient(cfg),
		Webauthn:                          NewWebauthnClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                               ctx,
		config:                            cfg,
		APIToken:                          NewAPITokenClient(cfg),
		ActionPlan:                        NewActionPlanClient(cfg),
		ActionPlanHistory:                 NewActionPlanHistoryClient(cfg),
		Assessment:                        NewAssessmentClient(cfg),
		AssessmentHistory:                 NewAssessmentHistoryClient(cfg),
		AssessmentResponse:                NewAssessmentResponseClient(cfg),
		AssessmentResponseHistory:         NewAssessmentResponseHistoryClient(cfg),
		Asset:                             NewAssetClient(cfg),
		AssetHistory:                      NewAssetHistoryClient(cfg),
		Contact:                           NewContactClient(cfg),
		ContactHistory:                    NewContactHistoryClient(cfg),
		Control:                           NewControlClient(cfg),
		ControlHistory:                    NewControlHistoryClient(cfg),
		ControlImplementation:             NewControlImplementationClient(cfg),
		ControlImplementationHistory:      NewControlImplementationHistoryClient(cfg),
		ControlObjective:                  NewControlObjectiveClient(cfg),
		ControlObjectiveHistory:           NewControlObjectiveHistoryClient(cfg),
		CustomDomain:                      NewCustomDomainClient(cfg),
		CustomDomainHistory:               NewCustomDomainHistoryClient(cfg),
		CustomTypeEnum:                    NewCustomTypeEnumClient(cfg),
		DNSVerification:                   NewDNSVerificationClient(cfg),
		DNSVerificationHistory:            NewDNSVerificationHistoryClient(cfg),
		DocumentData:                      NewDocumentDataClient(cfg),
		DocumentDataHistory:               NewDocumentDataHistoryClient(cfg),
		EmailVerificationToken:            NewEmailVerificationTokenClient(cfg),
		Entity:                            NewEntityClient(cfg),
		EntityHistory:                     NewEntityHistoryClient(cfg),
		EntityType:                        NewEntityTypeClient(cfg),
		EntityTypeHistory:                 NewEntityTypeHistoryClient(cfg),
		Event:                             NewEventClient(cfg),
		Evidence:                          NewEvidenceClient(cfg),
		EvidenceHistory:                   NewEvidenceHistoryClient(cfg),
		Export:                            NewExportClient(cfg),
		File:                              NewFileClient(cfg),
		FileDownloadToken:                 NewFileDownloadTokenClient(cfg),
		FileHistory:                       NewFileHistoryClient(cfg),
		Finding:                           NewFindingClient(cfg),
		FindingControl:                    NewFindingControlClient(cfg),
		FindingControlHistory:             NewFindingControlHistoryClient(cfg),
		FindingHistory:                    NewFindingHistoryClient(cfg),
		Group:                             NewGroupClient(cfg),
		GroupHistory:                      NewGroupHistoryClient(cfg),
		GroupMembership:                   NewGroupMembershipClient(cfg),
		GroupMembershipHistory:            NewGroupMembershipHistoryClient(cfg),
		GroupSetting:                      NewGroupSettingClient(cfg),
		GroupSettingHistory:               NewGroupSettingHistoryClient(cfg),
		Hush:                              NewHushClient(cfg),
		HushHistory:                       NewHushHistoryClient(cfg),
		ImpersonationEvent:                NewImpersonationEventClient(cfg),
		Integration:                       NewIntegrationClient(cfg),
		IntegrationHistory:                NewIntegrationHistoryClient(cfg),
		InternalPolicy:                    NewInternalPolicyClient(cfg),
		InternalPolicyHistory:             NewInternalPolicyHistoryClient(cfg),
		Invite:                            NewInviteClient(cfg),
		JobResult:                         NewJobResultClient(cfg),
		JobRunner:                         NewJobRunnerClient(cfg),
		JobRunnerRegistrationToken:        NewJobRunnerRegistrationTokenClient(cfg),
		JobRunnerToken:                    NewJobRunnerTokenClient(cfg),
		JobTemplate:                       NewJobTemplateClient(cfg),
		JobTemplateHistory:                NewJobTemplateHistoryClient(cfg),
		MappableDomain:                    NewMappableDomainClient(cfg),
		MappableDomainHistory:             NewMappableDomainHistoryClient(cfg),
		MappedControl:                     NewMappedControlClient(cfg),
		MappedControlHistory:              NewMappedControlHistoryClient(cfg),
		Narrative:                         NewNarrativeClient(cfg),
		NarrativeHistory:                  NewNarrativeHistoryClient(cfg),
		Note:                              NewNoteClient(cfg),
		NoteHistory:                       NewNoteHistoryClient(cfg),
		Notification:                      NewNotificationClient(cfg),
		Onboarding:                        NewOnboardingClient(cfg),
		OrgMembership:                     NewOrgMembershipClient(cfg),
		OrgMembershipHistory:              NewOrgMembershipHistoryClient(cfg),
		OrgModule:                         NewOrgModuleClient(cfg),
		OrgPrice:                          NewOrgPriceClient(cfg),
		OrgProduct:                        NewOrgProductClient(cfg),
		OrgSubscription:                   NewOrgSubscriptionClient(cfg),
		OrgSubscriptionHistory:            NewOrgSubscriptionHistoryClient(cfg),
		Organization:                      NewOrganizationClient(cfg),
		OrganizationHistory:               NewOrganizationHistoryClient(cfg),
		OrganizationSetting:               NewOrganizationSettingClient(cfg),
		OrganizationSettingHistory:        NewOrganizationSettingHistoryClient(cfg),
		PasswordResetToken:                NewPasswordResetTokenClient(cfg),
		PersonalAccessToken:               NewPersonalAccessTokenClient(cfg),
		Procedure:                         NewProcedureClient(cfg),
		ProcedureHistory:                  NewProcedureHistoryClient(cfg),
		Program:                           NewProgramClient(cfg),
		ProgramHistory:                    NewProgramHistoryClient(cfg),
		ProgramMembership:                 NewProgramMembershipClient(cfg),
		ProgramMembershipHistory:          NewProgramMembershipHistoryClient(cfg),
		Remediation:                       NewRemediationClient(cfg),
		RemediationHistory:                NewRemediationHistoryClient(cfg),
		Review:                            NewReviewClient(cfg),
		ReviewHistory:                     NewReviewHistoryClient(cfg),
		Risk:                              NewRiskClient(cfg),
		RiskHistory:                       NewRiskHistoryClient(cfg),
		Scan:                              NewScanClient(cfg),
		ScanHistory:                       NewScanHistoryClient(cfg),
		ScheduledJob:                      NewScheduledJobClient(cfg),
		ScheduledJobHistory:               NewScheduledJobHistoryClient(cfg),
		ScheduledJobRun:                   NewScheduledJobRunClient(cfg),
		Standard:                          NewStandardClient(cfg),
		StandardHistory:                   NewStandardHistoryClient(cfg),
		Subcontrol:                        NewSubcontrolClient(cfg),
		SubcontrolHistory:                 NewSubcontrolHistoryClient(cfg),
		Subprocessor:                      NewSubprocessorClient(cfg),
		SubprocessorHistory:               NewSubprocessorHistoryClient(cfg),
		Subscriber:                        NewSubscriberClient(cfg),
		TFASetting:                        NewTFASettingClient(cfg),
		TagDefinition:                     NewTagDefinitionClient(cfg),
		Task:                              NewTaskClient(cfg),
		TaskHistory:                       NewTaskHistoryClient(cfg),
		Template:                          NewTemplateClient(cfg),
		TemplateHistory:                   NewTemplateHistoryClient(cfg),
		TrustCenter:                       NewTrustCenterClient(cfg),
		TrustCenterCompliance:             NewTrustCenterComplianceClient(cfg),
		TrustCenterComplianceHistory:      NewTrustCenterComplianceHistoryClient(cfg),
		TrustCenterDoc:                    NewTrustCenterDocClient(cfg),
		TrustCenterDocHistory:             NewTrustCenterDocHistoryClient(cfg),
		TrustCenterHistory:                NewTrustCenterHistoryClient(cfg),
		TrustCenterSetting:                NewTrustCenterSettingClient(cfg),
		TrustCenterSettingHistory:         NewTrustCenterSettingHistoryClient(cfg),
		TrustCenterSubprocessor:           NewTrustCenterSubprocessorClient(cfg),
		TrustCenterSubprocessorHistory:    NewTrustCenterSubprocessorHistoryClient(cfg),
		TrustCenterWatermarkConfig:        NewTrustCenterWatermarkConfigClient(cfg),
		TrustCenterWatermarkConfigHistory: NewTrustCenterWatermarkConfigHistoryClient(cfg),
		User:                              NewUserClient(cfg),
		UserHistory:                       NewUserHistoryClient(cfg),
		UserSetting:                       NewUserSettingClient(cfg),
		UserSettingHistory:                NewUserSettingHistoryClient(cfg),
		Vulnerability:                     NewVulnerabilityClient(cfg),
		VulnerabilityHistory:              NewVulnerabilityHistoryClient(cfg),
		Webauthn:                          NewWebauthnClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIToken, c.ActionPlan, c.ActionPlanHistory, c.Assessment,
		c.AssessmentHistory, c.AssessmentResponse, c.AssessmentResponseHistory,
		c.Asset, c.AssetHistory, c.Contact, c.ContactHistory, c.Control,
		c.ControlHistory, c.ControlImplementation, c.ControlImplementationHistory,
		c.ControlObjective, c.ControlObjectiveHistory, c.CustomDomain,
		c.CustomDomainHistory, c.CustomTypeEnum, c.DNSVerification,
		c.DNSVerificationHistory, c.DocumentData, c.DocumentDataHistory,
		c.EmailVerificationToken, c.Entity, c.EntityHistory, c.EntityType,
		c.EntityTypeHistory, c.Event, c.Evidence, c.EvidenceHistory, c.Export, c.File,
		c.FileDownloadToken, c.FileHistory, c.Finding, c.FindingControl,
		c.FindingControlHistory, c.FindingHistory, c.Group, c.GroupHistory,
		c.GroupMembership, c.GroupMembershipHistory, c.GroupSetting,
		c.GroupSettingHistory, c.Hush, c.HushHistory, c.ImpersonationEvent,
		c.Integration, c.IntegrationHistory, c.InternalPolicy, c.InternalPolicyHistory,
		c.Invite, c.JobResult, c.JobRunner, c.JobRunnerRegistrationToken,
		c.JobRunnerToken, c.JobTemplate, c.JobTemplateHistory, c.MappableDomain,
		c.MappableDomainHistory, c.MappedControl, c.MappedControlHistory, c.Narrative,
		c.NarrativeHistory, c.Note, c.NoteHistory, c.Notification, c.Onboarding,
		c.OrgMembership, c.OrgMembershipHistory, c.OrgModule, c.OrgPrice, c.OrgProduct,
		c.OrgSubscription, c.OrgSubscriptionHistory, c.Organization,
		c.OrganizationHistory, c.OrganizationSetting, c.OrganizationSettingHistory,
		c.PasswordResetToken, c.PersonalAccessToken, c.Procedure, c.ProcedureHistory,
		c.Program, c.ProgramHistory, c.ProgramMembership, c.ProgramMembershipHistory,
		c.Remediation, c.RemediationHistory, c.Review, c.ReviewHistory, c.Risk,
		c.RiskHistory, c.Scan, c.ScanHistory, c.ScheduledJob, c.ScheduledJobHistory,
		c.ScheduledJobRun, c.Standard, c.StandardHistory, c.Subcontrol,
		c.SubcontrolHistory, c.Subprocessor, c.SubprocessorHistory, c.Subscriber,
		c.TFASetting, c.TagDefinition, c.Task, c.TaskHistory, c.Template,
		c.TemplateHistory, c.TrustCenter, c.TrustCenterCompliance,
		c.TrustCenterComplianceHistory, c.TrustCenterDoc, c.TrustCenterDocHistory,
		c.TrustCenterHistory, c.TrustCenterSetting, c.TrustCenterSettingHistory,
		c.TrustCenterSubprocessor, c.TrustCenterSubprocessorHistory,
		c.TrustCenterWatermarkConfig, c.TrustCenterWatermarkConfigHistory, c.User,
		c.UserHistory, c.UserSetting, c.UserSettingHistory, c.Vulnerability,
		c.VulnerabilityHistory, c.Webauthn,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIToken, c.ActionPlan, c.ActionPlanHistory, c.Assessment,
		c.AssessmentHistory, c.AssessmentResponse, c.AssessmentResponseHistory,
		c.Asset, c.AssetHistory, c.Contact, c.ContactHistory, c.Control,
		c.ControlHistory, c.ControlImplementation, c.ControlImplementationHistory,
		c.ControlObjective, c.ControlObjectiveHistory, c.CustomDomain,
		c.CustomDomainHistory, c.CustomTypeEnum, c.DNSVerification,
		c.DNSVerificationHistory, c.DocumentData, c.DocumentDataHistory,
		c.EmailVerificationToken, c.Entity, c.EntityHistory, c.EntityType,
		c.EntityTypeHistory, c.Event, c.Evidence, c.EvidenceHistory, c.Export, c.File,
		c.FileDownloadToken, c.FileHistory, c.Finding, c.FindingControl,
		c.FindingControlHistory, c.FindingHistory, c.Group, c.GroupHistory,
		c.GroupMembership, c.GroupMembershipHistory, c.GroupSetting,
		c.GroupSettingHistory, c.Hush, c.HushHistory, c.ImpersonationEvent,
		c.Integration, c.IntegrationHistory, c.InternalPolicy, c.InternalPolicyHistory,
		c.Invite, c.JobResult, c.JobRunner, c.JobRunnerRegistrationToken,
		c.JobRunnerToken, c.JobTemplate, c.JobTemplateHistory, c.MappableDomain,
		c.MappableDomainHistory, c.MappedControl, c.MappedControlHistory, c.Narrative,
		c.NarrativeHistory, c.Note, c.NoteHistory, c.Notification, c.Onboarding,
		c.OrgMembership, c.OrgMembershipHistory, c.OrgModule, c.OrgPrice, c.OrgProduct,
		c.OrgSubscription, c.OrgSubscriptionHistory, c.Organization,
		c.OrganizationHistory, c.OrganizationSetting, c.OrganizationSettingHistory,
		c.PasswordResetToken, c.PersonalAccessToken, c.Procedure, c.ProcedureHistory,
		c.Program, c.ProgramHistory, c.ProgramMembership, c.ProgramMembershipHistory,
		c.Remediation, c.RemediationHistory, c.Review, c.ReviewHistory, c.Risk,
		c.RiskHistory, c.Scan, c.ScanHistory, c.ScheduledJob, c.ScheduledJobHistory,
		c.ScheduledJobRun, c.Standard, c.StandardHistory, c.Subcontrol,
		c.SubcontrolHistory, c.Subprocessor, c.SubprocessorHistory, c.Subscriber,
		c.TFASetting, c.TagDefinition, c.Task, c.TaskHistory, c.Template,
		c.TemplateHistory, c.TrustCenter, c.TrustCenterCompliance,
		c.TrustCenterComplianceHistory, c.TrustCenterDoc, c.TrustCenterDocHistory,
		c.TrustCenterHistory, c.TrustCenterSetting, c.TrustCenterSettingHistory,
		c.TrustCenterSubprocessor, c.TrustCenterSubprocessorHistory,
		c.TrustCenterWatermarkConfig, c.TrustCenterWatermarkConfigHistory, c.User,
		c.UserHistory, c.UserSetting, c.UserSettingHistory, c.Vulnerability,
		c.VulnerabilityHistory, c.Webauthn,
	} {
		n.Intercept(interceptors...)
	}
}

// WithAuthz adds the authz hooks to the appropriate schemas - generated by entfga
func (c *Client) WithAuthz() {
	if !c.authzActivated {

		for _, hook := range entfga.AuthzHooks[*GroupMembershipMutation]() {
			c.GroupMembership.Use(hook)
		}

		for _, hook := range entfga.AuthzHooks[*OrgMembershipMutation]() {
			c.OrgMembership.Use(hook)
		}

		for _, hook := range entfga.AuthzHooks[*ProgramMembershipMutation]() {
			c.ProgramMembership.Use(hook)
		}

		c.authzActivated = true
	}
}

// CloseAll closes the all database client connections
func (c *Client) CloseAll() error {
	if err := c.Job.Close(); err != nil {
		return err
	}

	return c.Close()
}

// Dialect returns the driver dialect.
func (c *Client) Dialect() string {
	return c.driver.Dialect()
}

// Driver returns the underlying driver.
func (c *Client) Driver() dialect.Driver {
	return c.driver
}

// DB returns the underlying *sql.DB.
func (c *Client) DB() *stdsql.DB {
	switch c.driver.(type) {
	case *sql.Driver: // default
		return c.driver.(*sql.Driver).DB()
	case *entcache.Driver: // when using entcache we need to unwrap the driver
		return c.driver.(*entcache.Driver).Driver.(*sql.Driver).DB()
	case *dialect.DebugDriver: // when the ent debug driver is used
		driver := c.driver.(*dialect.DebugDriver)

		switch driver.Driver.(type) {
		case *sql.Driver: // default
			return driver.Driver.(*sql.Driver).DB()
		case *entcache.Driver: // when using entcache we need to unwrap the driver
			return driver.Driver.(*entcache.Driver).Driver.(*sql.Driver).DB()
		default:
			panic(fmt.Sprintf("ent: unknown driver type: %T", driver))
		}
	default:
		panic(fmt.Sprintf("ent: unknown driver type: %T", c.driver))
	}
}

// WithJobClient adds the job client to the database client based on the configuration.
func (c *Client) WithJobClient() {
	c.Job = NewJobClient(c.config)
}

// NewJobClient returns a new job client based on the configuration.
func NewJobClient(c config) riverqueue.JobClient {
	return c.Job
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APITokenMutation:
		return c.APIToken.mutate(ctx, m)
	case *ActionPlanMutation:
		return c.ActionPlan.mutate(ctx, m)
	case *ActionPlanHistoryMutation:
		return c.ActionPlanHistory.mutate(ctx, m)
	case *AssessmentMutation:
		return c.Assessment.mutate(ctx, m)
	case *AssessmentHistoryMutation:
		return c.AssessmentHistory.mutate(ctx, m)
	case *AssessmentResponseMutation:
		return c.AssessmentResponse.mutate(ctx, m)
	case *AssessmentResponseHistoryMutation:
		return c.AssessmentResponseHistory.mutate(ctx, m)
	case *AssetMutation:
		return c.Asset.mutate(ctx, m)
	case *AssetHistoryMutation:
		return c.AssetHistory.mutate(ctx, m)
	case *ContactMutation:
		return c.Contact.mutate(ctx, m)
	case *ContactHistoryMutation:
		return c.ContactHistory.mutate(ctx, m)
	case *ControlMutation:
		return c.Control.mutate(ctx, m)
	case *ControlHistoryMutation:
		return c.ControlHistory.mutate(ctx, m)
	case *ControlImplementationMutation:
		return c.ControlImplementation.mutate(ctx, m)
	case *ControlImplementationHistoryMutation:
		return c.ControlImplementationHistory.mutate(ctx, m)
	case *ControlObjectiveMutation:
		return c.ControlObjective.mutate(ctx, m)
	case *ControlObjectiveHistoryMutation:
		return c.ControlObjectiveHistory.mutate(ctx, m)
	case *CustomDomainMutation:
		return c.CustomDomain.mutate(ctx, m)
	case *CustomDomainHistoryMutation:
		return c.CustomDomainHistory.mutate(ctx, m)
	case *CustomTypeEnumMutation:
		return c.CustomTypeEnum.mutate(ctx, m)
	case *DNSVerificationMutation:
		return c.DNSVerification.mutate(ctx, m)
	case *DNSVerificationHistoryMutation:
		return c.DNSVerificationHistory.mutate(ctx, m)
	case *DocumentDataMutation:
		return c.DocumentData.mutate(ctx, m)
	case *DocumentDataHistoryMutation:
		return c.DocumentDataHistory.mutate(ctx, m)
	case *EmailVerificationTokenMutation:
		return c.EmailVerificationToken.mutate(ctx, m)
	case *EntityMutation:
		return c.Entity.mutate(ctx, m)
	case *EntityHistoryMutation:
		return c.EntityHistory.mutate(ctx, m)
	case *EntityTypeMutation:
		return c.EntityType.mutate(ctx, m)
	case *EntityTypeHistoryMutation:
		return c.EntityTypeHistory.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EvidenceMutation:
		return c.Evidence.mutate(ctx, m)
	case *EvidenceHistoryMutation:
		return c.EvidenceHistory.mutate(ctx, m)
	case *ExportMutation:
		return c.Export.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *FileDownloadTokenMutation:
		return c.FileDownloadToken.mutate(ctx, m)
	case *FileHistoryMutation:
		return c.FileHistory.mutate(ctx, m)
	case *FindingMutation:
		return c.Finding.mutate(ctx, m)
	case *FindingControlMutation:
		return c.FindingControl.mutate(ctx, m)
	case *FindingControlHistoryMutation:
		return c.FindingControlHistory.mutate(ctx, m)
	case *FindingHistoryMutation:
		return c.FindingHistory.mutate(ctx, m)
	case *GroupMutation:
		return c.Group.mutate(ctx, m)
	case *GroupHistoryMutation:
		return c.GroupHistory.mutate(ctx, m)
	case *GroupMembershipMutation:
		return c.GroupMembership.mutate(ctx, m)
	case *GroupMembershipHistoryMutation:
		return c.GroupMembershipHistory.mutate(ctx, m)
	case *GroupSettingMutation:
		return c.GroupSetting.mutate(ctx, m)
	case *GroupSettingHistoryMutation:
		return c.GroupSettingHistory.mutate(ctx, m)
	case *HushMutation:
		return c.Hush.mutate(ctx, m)
	case *HushHistoryMutation:
		return c.HushHistory.mutate(ctx, m)
	case *ImpersonationEventMutation:
		return c.ImpersonationEvent.mutate(ctx, m)
	case *IntegrationMutation:
		return c.Integration.mutate(ctx, m)
	case *IntegrationHistoryMutation:
		return c.IntegrationHistory.mutate(ctx, m)
	case *InternalPolicyMutation:
		return c.InternalPolicy.mutate(ctx, m)
	case *InternalPolicyHistoryMutation:
		return c.InternalPolicyHistory.mutate(ctx, m)
	case *InviteMutation:
		return c.Invite.mutate(ctx, m)
	case *JobResultMutation:
		return c.JobResult.mutate(ctx, m)
	case *JobRunnerMutation:
		return c.JobRunner.mutate(ctx, m)
	case *JobRunnerRegistrationTokenMutation:
		return c.JobRunnerRegistrationToken.mutate(ctx, m)
	case *JobRunnerTokenMutation:
		return c.JobRunnerToken.mutate(ctx, m)
	case *JobTemplateMutation:
		return c.JobTemplate.mutate(ctx, m)
	case *JobTemplateHistoryMutation:
		return c.JobTemplateHistory.mutate(ctx, m)
	case *MappableDomainMutation:
		return c.MappableDomain.mutate(ctx, m)
	case *MappableDomainHistoryMutation:
		return c.MappableDomainHistory.mutate(ctx, m)
	case *MappedControlMutation:
		return c.MappedControl.mutate(ctx, m)
	case *MappedControlHistoryMutation:
		return c.MappedControlHistory.mutate(ctx, m)
	case *NarrativeMutation:
		return c.Narrative.mutate(ctx, m)
	case *NarrativeHistoryMutation:
		return c.NarrativeHistory.mutate(ctx, m)
	case *NoteMutation:
		return c.Note.mutate(ctx, m)
	case *NoteHistoryMutation:
		return c.NoteHistory.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *OnboardingMutation:
		return c.Onboarding.mutate(ctx, m)
	case *OrgMembershipMutation:
		return c.OrgMembership.mutate(ctx, m)
	case *OrgMembershipHistoryMutation:
		return c.OrgMembershipHistory.mutate(ctx, m)
	case *OrgModuleMutation:
		return c.OrgModule.mutate(ctx, m)
	case *OrgPriceMutation:
		return c.OrgPrice.mutate(ctx, m)
	case *OrgProductMutation:
		return c.OrgProduct.mutate(ctx, m)
	case *OrgSubscriptionMutation:
		return c.OrgSubscription.mutate(ctx, m)
	case *OrgSubscriptionHistoryMutation:
		return c.OrgSubscriptionHistory.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *OrganizationHistoryMutation:
		return c.OrganizationHistory.mutate(ctx, m)
	case *OrganizationSettingMutation:
		return c.OrganizationSetting.mutate(ctx, m)
	case *OrganizationSettingHistoryMutation:
		return c.OrganizationSettingHistory.mutate(ctx, m)
	case *PasswordResetTokenMutation:
		return c.PasswordResetToken.mutate(ctx, m)
	case *PersonalAccessTokenMutation:
		return c.PersonalAccessToken.mutate(ctx, m)
	case *ProcedureMutation:
		return c.Procedure.mutate(ctx, m)
	case *ProcedureHistoryMutation:
		return c.ProcedureHistory.mutate(ctx, m)
	case *ProgramMutation:
		return c.Program.mutate(ctx, m)
	case *ProgramHistoryMutation:
		return c.ProgramHistory.mutate(ctx, m)
	case *ProgramMembershipMutation:
		return c.ProgramMembership.mutate(ctx, m)
	case *ProgramMembershipHistoryMutation:
		return c.ProgramMembershipHistory.mutate(ctx, m)
	case *RemediationMutation:
		return c.Remediation.mutate(ctx, m)
	case *RemediationHistoryMutation:
		return c.RemediationHistory.mutate(ctx, m)
	case *ReviewMutation:
		return c.Review.mutate(ctx, m)
	case *ReviewHistoryMutation:
		return c.ReviewHistory.mutate(ctx, m)
	case *RiskMutation:
		return c.Risk.mutate(ctx, m)
	case *RiskHistoryMutation:
		return c.RiskHistory.mutate(ctx, m)
	case *ScanMutation:
		return c.Scan.mutate(ctx, m)
	case *ScanHistoryMutation:
		return c.ScanHistory.mutate(ctx, m)
	case *ScheduledJobMutation:
		return c.ScheduledJob.mutate(ctx, m)
	case *ScheduledJobHistoryMutation:
		return c.ScheduledJobHistory.mutate(ctx, m)
	case *ScheduledJobRunMutation:
		return c.ScheduledJobRun.mutate(ctx, m)
	case *StandardMutation:
		return c.Standard.mutate(ctx, m)
	case *StandardHistoryMutation:
		return c.StandardHistory.mutate(ctx, m)
	case *SubcontrolMutation:
		return c.Subcontrol.mutate(ctx, m)
	case *SubcontrolHistoryMutation:
		return c.SubcontrolHistory.mutate(ctx, m)
	case *SubprocessorMutation:
		return c.Subprocessor.mutate(ctx, m)
	case *SubprocessorHistoryMutation:
		return c.SubprocessorHistory.mutate(ctx, m)
	case *SubscriberMutation:
		return c.Subscriber.mutate(ctx, m)
	case *TFASettingMutation:
		return c.TFASetting.mutate(ctx, m)
	case *TagDefinitionMutation:
		return c.TagDefinition.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TaskHistoryMutation:
		return c.TaskHistory.mutate(ctx, m)
	case *TemplateMutation:
		return c.Template.mutate(ctx, m)
	case *TemplateHistoryMutation:
		return c.TemplateHistory.mutate(ctx, m)
	case *TrustCenterMutation:
		return c.TrustCenter.mutate(ctx, m)
	case *TrustCenterComplianceMutation:
		return c.TrustCenterCompliance.mutate(ctx, m)
	case *TrustCenterComplianceHistoryMutation:
		return c.TrustCenterComplianceHistory.mutate(ctx, m)
	case *TrustCenterDocMutation:
		return c.TrustCenterDoc.mutate(ctx, m)
	case *TrustCenterDocHistoryMutation:
		return c.TrustCenterDocHistory.mutate(ctx, m)
	case *TrustCenterHistoryMutation:
		return c.TrustCenterHistory.mutate(ctx, m)
	case *TrustCenterSettingMutation:
		return c.TrustCenterSetting.mutate(ctx, m)
	case *TrustCenterSettingHistoryMutation:
		return c.TrustCenterSettingHistory.mutate(ctx, m)
	case *TrustCenterSubprocessorMutation:
		return c.TrustCenterSubprocessor.mutate(ctx, m)
	case *TrustCenterSubprocessorHistoryMutation:
		return c.TrustCenterSubprocessorHistory.mutate(ctx, m)
	case *TrustCenterWatermarkConfigMutation:
		return c.TrustCenterWatermarkConfig.mutate(ctx, m)
	case *TrustCenterWatermarkConfigHistoryMutation:
		return c.TrustCenterWatermarkConfigHistory.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserHistoryMutation:
		return c.UserHistory.mutate(ctx, m)
	case *UserSettingMutation:
		return c.UserSetting.mutate(ctx, m)
	case *UserSettingHistoryMutation:
		return c.UserSettingHistory.mutate(ctx, m)
	case *VulnerabilityMutation:
		return c.Vulnerability.mutate(ctx, m)
	case *VulnerabilityHistoryMutation:
		return c.VulnerabilityHistory.mutate(ctx, m)
	case *WebauthnMutation:
		return c.Webauthn.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// APITokenClient is a client for the APIToken schema.
type APITokenClient struct {
	config
}

// NewAPITokenClient returns a client for the APIToken from the given config.
func NewAPITokenClient(c config) *APITokenClient {
	return &APITokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apitoken.Hooks(f(g(h())))`.
func (c *APITokenClient) Use(hooks ...Hook) {
	c.hooks.APIToken = append(c.hooks.APIToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apitoken.Intercept(f(g(h())))`.
func (c *APITokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIToken = append(c.inters.APIToken, interceptors...)
}

// Create returns a builder for creating a APIToken entity.
func (c *APITokenClient) Create() *APITokenCreate {
	mutation := newAPITokenMutation(c.config, OpCreate)
	return &APITokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIToken entities.
func (c *APITokenClient) CreateBulk(builders ...*APITokenCreate) *APITokenCreateBulk {
	return &APITokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APITokenClient) MapCreateBulk(slice any, setFunc func(*APITokenCreate, int)) *APITokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APITokenCreateBulk{err: fmt.Errorf("calling to APITokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APITokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APITokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIToken.
func (c *APITokenClient) Update() *APITokenUpdate {
	mutation := newAPITokenMutation(c.config, OpUpdate)
	return &APITokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APITokenClient) UpdateOne(_m *APIToken) *APITokenUpdateOne {
	mutation := newAPITokenMutation(c.config, OpUpdateOne, withAPIToken(_m))
	return &APITokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APITokenClient) UpdateOneID(id string) *APITokenUpdateOne {
	mutation := newAPITokenMutation(c.config, OpUpdateOne, withAPITokenID(id))
	return &APITokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIToken.
func (c *APITokenClient) Delete() *APITokenDelete {
	mutation := newAPITokenMutation(c.config, OpDelete)
	return &APITokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APITokenClient) DeleteOne(_m *APIToken) *APITokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APITokenClient) DeleteOneID(id string) *APITokenDeleteOne {
	builder := c.Delete().Where(apitoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APITokenDeleteOne{builder}
}

// Query returns a query builder for APIToken.
func (c *APITokenClient) Query() *APITokenQuery {
	return &APITokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIToken},
		inters: c.Interceptors(),
	}
}

// Get returns a APIToken entity by its id.
func (c *APITokenClient) Get(ctx context.Context, id string) (*APIToken, error) {
	return c.Query().Where(apitoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APITokenClient) GetX(ctx context.Context, id string) *APIToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a APIToken.
func (c *APITokenClient) QueryOwner(_m *APIToken) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apitoken.Table, apitoken.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apitoken.OwnerTable, apitoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.APIToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APITokenClient) Hooks() []Hook {
	hooks := c.hooks.APIToken
	return append(hooks[:len(hooks):len(hooks)], apitoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *APITokenClient) Interceptors() []Interceptor {
	inters := c.inters.APIToken
	return append(inters[:len(inters):len(inters)], apitoken.Interceptors[:]...)
}

func (c *APITokenClient) mutate(ctx context.Context, m *APITokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APITokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APITokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APITokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APITokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown APIToken mutation op: %q", m.Op())
	}
}

// ActionPlanClient is a client for the ActionPlan schema.
type ActionPlanClient struct {
	config
}

// NewActionPlanClient returns a client for the ActionPlan from the given config.
func NewActionPlanClient(c config) *ActionPlanClient {
	return &ActionPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actionplan.Hooks(f(g(h())))`.
func (c *ActionPlanClient) Use(hooks ...Hook) {
	c.hooks.ActionPlan = append(c.hooks.ActionPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actionplan.Intercept(f(g(h())))`.
func (c *ActionPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionPlan = append(c.inters.ActionPlan, interceptors...)
}

// Create returns a builder for creating a ActionPlan entity.
func (c *ActionPlanClient) Create() *ActionPlanCreate {
	mutation := newActionPlanMutation(c.config, OpCreate)
	return &ActionPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionPlan entities.
func (c *ActionPlanClient) CreateBulk(builders ...*ActionPlanCreate) *ActionPlanCreateBulk {
	return &ActionPlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionPlanClient) MapCreateBulk(slice any, setFunc func(*ActionPlanCreate, int)) *ActionPlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionPlanCreateBulk{err: fmt.Errorf("calling to ActionPlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionPlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionPlan.
func (c *ActionPlanClient) Update() *ActionPlanUpdate {
	mutation := newActionPlanMutation(c.config, OpUpdate)
	return &ActionPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionPlanClient) UpdateOne(_m *ActionPlan) *ActionPlanUpdateOne {
	mutation := newActionPlanMutation(c.config, OpUpdateOne, withActionPlan(_m))
	return &ActionPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionPlanClient) UpdateOneID(id string) *ActionPlanUpdateOne {
	mutation := newActionPlanMutation(c.config, OpUpdateOne, withActionPlanID(id))
	return &ActionPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionPlan.
func (c *ActionPlanClient) Delete() *ActionPlanDelete {
	mutation := newActionPlanMutation(c.config, OpDelete)
	return &ActionPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionPlanClient) DeleteOne(_m *ActionPlan) *ActionPlanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionPlanClient) DeleteOneID(id string) *ActionPlanDeleteOne {
	builder := c.Delete().Where(actionplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionPlanDeleteOne{builder}
}

// Query returns a query builder for ActionPlan.
func (c *ActionPlanClient) Query() *ActionPlanQuery {
	return &ActionPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionPlan entity by its id.
func (c *ActionPlanClient) Get(ctx context.Context, id string) (*ActionPlan, error) {
	return c.Query().Where(actionplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionPlanClient) GetX(ctx context.Context, id string) *ActionPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApprover queries the approver edge of a ActionPlan.
func (c *ActionPlanClient) QueryApprover(_m *ActionPlan) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, actionplan.ApproverTable, actionplan.ApproverColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDelegate queries the delegate edge of a ActionPlan.
func (c *ActionPlanClient) QueryDelegate(_m *ActionPlan) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, actionplan.DelegateTable, actionplan.DelegateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a ActionPlan.
func (c *ActionPlanClient) QueryOwner(_m *ActionPlan) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, actionplan.OwnerTable, actionplan.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlanKind queries the action_plan_kind edge of a ActionPlan.
func (c *ActionPlanClient) QueryActionPlanKind(_m *ActionPlan) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, actionplan.ActionPlanKindTable, actionplan.ActionPlanKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a ActionPlan.
func (c *ActionPlanClient) QueryRisks(_m *ActionPlan) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.RisksTable, actionplan.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.RiskActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a ActionPlan.
func (c *ActionPlanClient) QueryControls(_m *ActionPlan) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.ControlsTable, actionplan.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a ActionPlan.
func (c *ActionPlanClient) QueryPrograms(_m *ActionPlan) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.ProgramsTable, actionplan.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a ActionPlan.
func (c *ActionPlanClient) QueryFindings(_m *ActionPlan) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.FindingsTable, actionplan.FindingsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.FindingActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a ActionPlan.
func (c *ActionPlanClient) QueryVulnerabilities(_m *ActionPlan) *VulnerabilityQuery {
	query := (&VulnerabilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.VulnerabilitiesTable, actionplan.VulnerabilitiesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Vulnerability
		step.Edge.Schema = schemaConfig.VulnerabilityActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a ActionPlan.
func (c *ActionPlanClient) QueryReviews(_m *ActionPlan) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.ReviewsTable, actionplan.ReviewsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Review
		step.Edge.Schema = schemaConfig.ReviewActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediations queries the remediations edge of a ActionPlan.
func (c *ActionPlanClient) QueryRemediations(_m *ActionPlan) *RemediationQuery {
	query := (&RemediationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(remediation.Table, remediation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.RemediationsTable, actionplan.RemediationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Remediation
		step.Edge.Schema = schemaConfig.RemediationActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a ActionPlan.
func (c *ActionPlanClient) QueryTasks(_m *ActionPlan) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, actionplan.TasksTable, actionplan.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ActionPlanTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a ActionPlan.
func (c *ActionPlanClient) QueryIntegrations(_m *ActionPlan) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.IntegrationsTable, actionplan.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a ActionPlan.
func (c *ActionPlanClient) QueryFile(_m *ActionPlan) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, actionplan.FileTable, actionplan.FileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionPlanClient) Hooks() []Hook {
	hooks := c.hooks.ActionPlan
	return append(hooks[:len(hooks):len(hooks)], actionplan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ActionPlanClient) Interceptors() []Interceptor {
	inters := c.inters.ActionPlan
	return append(inters[:len(inters):len(inters)], actionplan.Interceptors[:]...)
}

func (c *ActionPlanClient) mutate(ctx context.Context, m *ActionPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ActionPlan mutation op: %q", m.Op())
	}
}

// ActionPlanHistoryClient is a client for the ActionPlanHistory schema.
type ActionPlanHistoryClient struct {
	config
}

// NewActionPlanHistoryClient returns a client for the ActionPlanHistory from the given config.
func NewActionPlanHistoryClient(c config) *ActionPlanHistoryClient {
	return &ActionPlanHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actionplanhistory.Hooks(f(g(h())))`.
func (c *ActionPlanHistoryClient) Use(hooks ...Hook) {
	c.hooks.ActionPlanHistory = append(c.hooks.ActionPlanHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actionplanhistory.Intercept(f(g(h())))`.
func (c *ActionPlanHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionPlanHistory = append(c.inters.ActionPlanHistory, interceptors...)
}

// Create returns a builder for creating a ActionPlanHistory entity.
func (c *ActionPlanHistoryClient) Create() *ActionPlanHistoryCreate {
	mutation := newActionPlanHistoryMutation(c.config, OpCreate)
	return &ActionPlanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionPlanHistory entities.
func (c *ActionPlanHistoryClient) CreateBulk(builders ...*ActionPlanHistoryCreate) *ActionPlanHistoryCreateBulk {
	return &ActionPlanHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionPlanHistoryClient) MapCreateBulk(slice any, setFunc func(*ActionPlanHistoryCreate, int)) *ActionPlanHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionPlanHistoryCreateBulk{err: fmt.Errorf("calling to ActionPlanHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionPlanHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionPlanHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionPlanHistory.
func (c *ActionPlanHistoryClient) Update() *ActionPlanHistoryUpdate {
	mutation := newActionPlanHistoryMutation(c.config, OpUpdate)
	return &ActionPlanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionPlanHistoryClient) UpdateOne(_m *ActionPlanHistory) *ActionPlanHistoryUpdateOne {
	mutation := newActionPlanHistoryMutation(c.config, OpUpdateOne, withActionPlanHistory(_m))
	return &ActionPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionPlanHistoryClient) UpdateOneID(id string) *ActionPlanHistoryUpdateOne {
	mutation := newActionPlanHistoryMutation(c.config, OpUpdateOne, withActionPlanHistoryID(id))
	return &ActionPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionPlanHistory.
func (c *ActionPlanHistoryClient) Delete() *ActionPlanHistoryDelete {
	mutation := newActionPlanHistoryMutation(c.config, OpDelete)
	return &ActionPlanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionPlanHistoryClient) DeleteOne(_m *ActionPlanHistory) *ActionPlanHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionPlanHistoryClient) DeleteOneID(id string) *ActionPlanHistoryDeleteOne {
	builder := c.Delete().Where(actionplanhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionPlanHistoryDeleteOne{builder}
}

// Query returns a query builder for ActionPlanHistory.
func (c *ActionPlanHistoryClient) Query() *ActionPlanHistoryQuery {
	return &ActionPlanHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionPlanHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionPlanHistory entity by its id.
func (c *ActionPlanHistoryClient) Get(ctx context.Context, id string) (*ActionPlanHistory, error) {
	return c.Query().Where(actionplanhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionPlanHistoryClient) GetX(ctx context.Context, id string) *ActionPlanHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ActionPlanHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ActionPlanHistory
	return append(hooks[:len(hooks):len(hooks)], actionplanhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ActionPlanHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ActionPlanHistory
	return append(inters[:len(inters):len(inters)], actionplanhistory.Interceptors[:]...)
}

func (c *ActionPlanHistoryClient) mutate(ctx context.Context, m *ActionPlanHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionPlanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionPlanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionPlanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ActionPlanHistory mutation op: %q", m.Op())
	}
}

// AssessmentClient is a client for the Assessment schema.
type AssessmentClient struct {
	config
}

// NewAssessmentClient returns a client for the Assessment from the given config.
func NewAssessmentClient(c config) *AssessmentClient {
	return &AssessmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assessment.Hooks(f(g(h())))`.
func (c *AssessmentClient) Use(hooks ...Hook) {
	c.hooks.Assessment = append(c.hooks.Assessment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assessment.Intercept(f(g(h())))`.
func (c *AssessmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Assessment = append(c.inters.Assessment, interceptors...)
}

// Create returns a builder for creating a Assessment entity.
func (c *AssessmentClient) Create() *AssessmentCreate {
	mutation := newAssessmentMutation(c.config, OpCreate)
	return &AssessmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Assessment entities.
func (c *AssessmentClient) CreateBulk(builders ...*AssessmentCreate) *AssessmentCreateBulk {
	return &AssessmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssessmentClient) MapCreateBulk(slice any, setFunc func(*AssessmentCreate, int)) *AssessmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssessmentCreateBulk{err: fmt.Errorf("calling to AssessmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssessmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssessmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Assessment.
func (c *AssessmentClient) Update() *AssessmentUpdate {
	mutation := newAssessmentMutation(c.config, OpUpdate)
	return &AssessmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssessmentClient) UpdateOne(_m *Assessment) *AssessmentUpdateOne {
	mutation := newAssessmentMutation(c.config, OpUpdateOne, withAssessment(_m))
	return &AssessmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssessmentClient) UpdateOneID(id string) *AssessmentUpdateOne {
	mutation := newAssessmentMutation(c.config, OpUpdateOne, withAssessmentID(id))
	return &AssessmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Assessment.
func (c *AssessmentClient) Delete() *AssessmentDelete {
	mutation := newAssessmentMutation(c.config, OpDelete)
	return &AssessmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssessmentClient) DeleteOne(_m *Assessment) *AssessmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssessmentClient) DeleteOneID(id string) *AssessmentDeleteOne {
	builder := c.Delete().Where(assessment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssessmentDeleteOne{builder}
}

// Query returns a query builder for Assessment.
func (c *AssessmentClient) Query() *AssessmentQuery {
	return &AssessmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssessment},
		inters: c.Interceptors(),
	}
}

// Get returns a Assessment entity by its id.
func (c *AssessmentClient) Get(ctx context.Context, id string) (*Assessment, error) {
	return c.Query().Where(assessment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssessmentClient) GetX(ctx context.Context, id string) *Assessment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Assessment.
func (c *AssessmentClient) QueryOwner(_m *Assessment) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessment.Table, assessment.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assessment.OwnerTable, assessment.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Assessment
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Assessment.
func (c *AssessmentClient) QueryBlockedGroups(_m *Assessment) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessment.Table, assessment.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assessment.BlockedGroupsTable, assessment.BlockedGroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Assessment.
func (c *AssessmentClient) QueryEditors(_m *Assessment) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessment.Table, assessment.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assessment.EditorsTable, assessment.EditorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Assessment.
func (c *AssessmentClient) QueryViewers(_m *Assessment) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessment.Table, assessment.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assessment.ViewersTable, assessment.ViewersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a Assessment.
func (c *AssessmentClient) QueryTemplate(_m *Assessment) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessment.Table, assessment.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assessment.TemplateTable, assessment.TemplateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.Assessment
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssessmentResponses queries the assessment_responses edge of a Assessment.
func (c *AssessmentClient) QueryAssessmentResponses(_m *Assessment) *AssessmentResponseQuery {
	query := (&AssessmentResponseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessment.Table, assessment.FieldID, id),
			sqlgraph.To(assessmentresponse.Table, assessmentresponse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assessment.AssessmentResponsesTable, assessment.AssessmentResponsesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.AssessmentResponse
		step.Edge.Schema = schemaConfig.AssessmentResponse
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssessmentClient) Hooks() []Hook {
	hooks := c.hooks.Assessment
	return append(hooks[:len(hooks):len(hooks)], assessment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AssessmentClient) Interceptors() []Interceptor {
	inters := c.inters.Assessment
	return append(inters[:len(inters):len(inters)], assessment.Interceptors[:]...)
}

func (c *AssessmentClient) mutate(ctx context.Context, m *AssessmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssessmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssessmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssessmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssessmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Assessment mutation op: %q", m.Op())
	}
}

// AssessmentHistoryClient is a client for the AssessmentHistory schema.
type AssessmentHistoryClient struct {
	config
}

// NewAssessmentHistoryClient returns a client for the AssessmentHistory from the given config.
func NewAssessmentHistoryClient(c config) *AssessmentHistoryClient {
	return &AssessmentHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assessmenthistory.Hooks(f(g(h())))`.
func (c *AssessmentHistoryClient) Use(hooks ...Hook) {
	c.hooks.AssessmentHistory = append(c.hooks.AssessmentHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assessmenthistory.Intercept(f(g(h())))`.
func (c *AssessmentHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssessmentHistory = append(c.inters.AssessmentHistory, interceptors...)
}

// Create returns a builder for creating a AssessmentHistory entity.
func (c *AssessmentHistoryClient) Create() *AssessmentHistoryCreate {
	mutation := newAssessmentHistoryMutation(c.config, OpCreate)
	return &AssessmentHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssessmentHistory entities.
func (c *AssessmentHistoryClient) CreateBulk(builders ...*AssessmentHistoryCreate) *AssessmentHistoryCreateBulk {
	return &AssessmentHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssessmentHistoryClient) MapCreateBulk(slice any, setFunc func(*AssessmentHistoryCreate, int)) *AssessmentHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssessmentHistoryCreateBulk{err: fmt.Errorf("calling to AssessmentHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssessmentHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssessmentHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssessmentHistory.
func (c *AssessmentHistoryClient) Update() *AssessmentHistoryUpdate {
	mutation := newAssessmentHistoryMutation(c.config, OpUpdate)
	return &AssessmentHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssessmentHistoryClient) UpdateOne(_m *AssessmentHistory) *AssessmentHistoryUpdateOne {
	mutation := newAssessmentHistoryMutation(c.config, OpUpdateOne, withAssessmentHistory(_m))
	return &AssessmentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssessmentHistoryClient) UpdateOneID(id string) *AssessmentHistoryUpdateOne {
	mutation := newAssessmentHistoryMutation(c.config, OpUpdateOne, withAssessmentHistoryID(id))
	return &AssessmentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssessmentHistory.
func (c *AssessmentHistoryClient) Delete() *AssessmentHistoryDelete {
	mutation := newAssessmentHistoryMutation(c.config, OpDelete)
	return &AssessmentHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssessmentHistoryClient) DeleteOne(_m *AssessmentHistory) *AssessmentHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssessmentHistoryClient) DeleteOneID(id string) *AssessmentHistoryDeleteOne {
	builder := c.Delete().Where(assessmenthistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssessmentHistoryDeleteOne{builder}
}

// Query returns a query builder for AssessmentHistory.
func (c *AssessmentHistoryClient) Query() *AssessmentHistoryQuery {
	return &AssessmentHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssessmentHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a AssessmentHistory entity by its id.
func (c *AssessmentHistoryClient) Get(ctx context.Context, id string) (*AssessmentHistory, error) {
	return c.Query().Where(assessmenthistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssessmentHistoryClient) GetX(ctx context.Context, id string) *AssessmentHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AssessmentHistoryClient) Hooks() []Hook {
	hooks := c.hooks.AssessmentHistory
	return append(hooks[:len(hooks):len(hooks)], assessmenthistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AssessmentHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.AssessmentHistory
	return append(inters[:len(inters):len(inters)], assessmenthistory.Interceptors[:]...)
}

func (c *AssessmentHistoryClient) mutate(ctx context.Context, m *AssessmentHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssessmentHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssessmentHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssessmentHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssessmentHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AssessmentHistory mutation op: %q", m.Op())
	}
}

// AssessmentResponseClient is a client for the AssessmentResponse schema.
type AssessmentResponseClient struct {
	config
}

// NewAssessmentResponseClient returns a client for the AssessmentResponse from the given config.
func NewAssessmentResponseClient(c config) *AssessmentResponseClient {
	return &AssessmentResponseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assessmentresponse.Hooks(f(g(h())))`.
func (c *AssessmentResponseClient) Use(hooks ...Hook) {
	c.hooks.AssessmentResponse = append(c.hooks.AssessmentResponse, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assessmentresponse.Intercept(f(g(h())))`.
func (c *AssessmentResponseClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssessmentResponse = append(c.inters.AssessmentResponse, interceptors...)
}

// Create returns a builder for creating a AssessmentResponse entity.
func (c *AssessmentResponseClient) Create() *AssessmentResponseCreate {
	mutation := newAssessmentResponseMutation(c.config, OpCreate)
	return &AssessmentResponseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssessmentResponse entities.
func (c *AssessmentResponseClient) CreateBulk(builders ...*AssessmentResponseCreate) *AssessmentResponseCreateBulk {
	return &AssessmentResponseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssessmentResponseClient) MapCreateBulk(slice any, setFunc func(*AssessmentResponseCreate, int)) *AssessmentResponseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssessmentResponseCreateBulk{err: fmt.Errorf("calling to AssessmentResponseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssessmentResponseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssessmentResponseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssessmentResponse.
func (c *AssessmentResponseClient) Update() *AssessmentResponseUpdate {
	mutation := newAssessmentResponseMutation(c.config, OpUpdate)
	return &AssessmentResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssessmentResponseClient) UpdateOne(_m *AssessmentResponse) *AssessmentResponseUpdateOne {
	mutation := newAssessmentResponseMutation(c.config, OpUpdateOne, withAssessmentResponse(_m))
	return &AssessmentResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssessmentResponseClient) UpdateOneID(id string) *AssessmentResponseUpdateOne {
	mutation := newAssessmentResponseMutation(c.config, OpUpdateOne, withAssessmentResponseID(id))
	return &AssessmentResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssessmentResponse.
func (c *AssessmentResponseClient) Delete() *AssessmentResponseDelete {
	mutation := newAssessmentResponseMutation(c.config, OpDelete)
	return &AssessmentResponseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssessmentResponseClient) DeleteOne(_m *AssessmentResponse) *AssessmentResponseDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssessmentResponseClient) DeleteOneID(id string) *AssessmentResponseDeleteOne {
	builder := c.Delete().Where(assessmentresponse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssessmentResponseDeleteOne{builder}
}

// Query returns a query builder for AssessmentResponse.
func (c *AssessmentResponseClient) Query() *AssessmentResponseQuery {
	return &AssessmentResponseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssessmentResponse},
		inters: c.Interceptors(),
	}
}

// Get returns a AssessmentResponse entity by its id.
func (c *AssessmentResponseClient) Get(ctx context.Context, id string) (*AssessmentResponse, error) {
	return c.Query().Where(assessmentresponse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssessmentResponseClient) GetX(ctx context.Context, id string) *AssessmentResponse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a AssessmentResponse.
func (c *AssessmentResponseClient) QueryOwner(_m *AssessmentResponse) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessmentresponse.Table, assessmentresponse.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assessmentresponse.OwnerTable, assessmentresponse.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.AssessmentResponse
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssessment queries the assessment edge of a AssessmentResponse.
func (c *AssessmentResponseClient) QueryAssessment(_m *AssessmentResponse) *AssessmentQuery {
	query := (&AssessmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessmentresponse.Table, assessmentresponse.FieldID, id),
			sqlgraph.To(assessment.Table, assessment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assessmentresponse.AssessmentTable, assessmentresponse.AssessmentColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Assessment
		step.Edge.Schema = schemaConfig.AssessmentResponse
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocument queries the document edge of a AssessmentResponse.
func (c *AssessmentResponseClient) QueryDocument(_m *AssessmentResponse) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assessmentresponse.Table, assessmentresponse.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, assessmentresponse.DocumentTable, assessmentresponse.DocumentColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.AssessmentResponse
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssessmentResponseClient) Hooks() []Hook {
	hooks := c.hooks.AssessmentResponse
	return append(hooks[:len(hooks):len(hooks)], assessmentresponse.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AssessmentResponseClient) Interceptors() []Interceptor {
	inters := c.inters.AssessmentResponse
	return append(inters[:len(inters):len(inters)], assessmentresponse.Interceptors[:]...)
}

func (c *AssessmentResponseClient) mutate(ctx context.Context, m *AssessmentResponseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssessmentResponseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssessmentResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssessmentResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssessmentResponseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AssessmentResponse mutation op: %q", m.Op())
	}
}

// AssessmentResponseHistoryClient is a client for the AssessmentResponseHistory schema.
type AssessmentResponseHistoryClient struct {
	config
}

// NewAssessmentResponseHistoryClient returns a client for the AssessmentResponseHistory from the given config.
func NewAssessmentResponseHistoryClient(c config) *AssessmentResponseHistoryClient {
	return &AssessmentResponseHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assessmentresponsehistory.Hooks(f(g(h())))`.
func (c *AssessmentResponseHistoryClient) Use(hooks ...Hook) {
	c.hooks.AssessmentResponseHistory = append(c.hooks.AssessmentResponseHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assessmentresponsehistory.Intercept(f(g(h())))`.
func (c *AssessmentResponseHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssessmentResponseHistory = append(c.inters.AssessmentResponseHistory, interceptors...)
}

// Create returns a builder for creating a AssessmentResponseHistory entity.
func (c *AssessmentResponseHistoryClient) Create() *AssessmentResponseHistoryCreate {
	mutation := newAssessmentResponseHistoryMutation(c.config, OpCreate)
	return &AssessmentResponseHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssessmentResponseHistory entities.
func (c *AssessmentResponseHistoryClient) CreateBulk(builders ...*AssessmentResponseHistoryCreate) *AssessmentResponseHistoryCreateBulk {
	return &AssessmentResponseHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssessmentResponseHistoryClient) MapCreateBulk(slice any, setFunc func(*AssessmentResponseHistoryCreate, int)) *AssessmentResponseHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssessmentResponseHistoryCreateBulk{err: fmt.Errorf("calling to AssessmentResponseHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssessmentResponseHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssessmentResponseHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssessmentResponseHistory.
func (c *AssessmentResponseHistoryClient) Update() *AssessmentResponseHistoryUpdate {
	mutation := newAssessmentResponseHistoryMutation(c.config, OpUpdate)
	return &AssessmentResponseHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssessmentResponseHistoryClient) UpdateOne(_m *AssessmentResponseHistory) *AssessmentResponseHistoryUpdateOne {
	mutation := newAssessmentResponseHistoryMutation(c.config, OpUpdateOne, withAssessmentResponseHistory(_m))
	return &AssessmentResponseHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssessmentResponseHistoryClient) UpdateOneID(id string) *AssessmentResponseHistoryUpdateOne {
	mutation := newAssessmentResponseHistoryMutation(c.config, OpUpdateOne, withAssessmentResponseHistoryID(id))
	return &AssessmentResponseHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssessmentResponseHistory.
func (c *AssessmentResponseHistoryClient) Delete() *AssessmentResponseHistoryDelete {
	mutation := newAssessmentResponseHistoryMutation(c.config, OpDelete)
	return &AssessmentResponseHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssessmentResponseHistoryClient) DeleteOne(_m *AssessmentResponseHistory) *AssessmentResponseHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssessmentResponseHistoryClient) DeleteOneID(id string) *AssessmentResponseHistoryDeleteOne {
	builder := c.Delete().Where(assessmentresponsehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssessmentResponseHistoryDeleteOne{builder}
}

// Query returns a query builder for AssessmentResponseHistory.
func (c *AssessmentResponseHistoryClient) Query() *AssessmentResponseHistoryQuery {
	return &AssessmentResponseHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssessmentResponseHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a AssessmentResponseHistory entity by its id.
func (c *AssessmentResponseHistoryClient) Get(ctx context.Context, id string) (*AssessmentResponseHistory, error) {
	return c.Query().Where(assessmentresponsehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssessmentResponseHistoryClient) GetX(ctx context.Context, id string) *AssessmentResponseHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AssessmentResponseHistoryClient) Hooks() []Hook {
	hooks := c.hooks.AssessmentResponseHistory
	return append(hooks[:len(hooks):len(hooks)], assessmentresponsehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AssessmentResponseHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.AssessmentResponseHistory
	return append(inters[:len(inters):len(inters)], assessmentresponsehistory.Interceptors[:]...)
}

func (c *AssessmentResponseHistoryClient) mutate(ctx context.Context, m *AssessmentResponseHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssessmentResponseHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssessmentResponseHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssessmentResponseHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssessmentResponseHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AssessmentResponseHistory mutation op: %q", m.Op())
	}
}

// AssetClient is a client for the Asset schema.
type AssetClient struct {
	config
}

// NewAssetClient returns a client for the Asset from the given config.
func NewAssetClient(c config) *AssetClient {
	return &AssetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asset.Hooks(f(g(h())))`.
func (c *AssetClient) Use(hooks ...Hook) {
	c.hooks.Asset = append(c.hooks.Asset, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `asset.Intercept(f(g(h())))`.
func (c *AssetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Asset = append(c.inters.Asset, interceptors...)
}

// Create returns a builder for creating a Asset entity.
func (c *AssetClient) Create() *AssetCreate {
	mutation := newAssetMutation(c.config, OpCreate)
	return &AssetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Asset entities.
func (c *AssetClient) CreateBulk(builders ...*AssetCreate) *AssetCreateBulk {
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssetClient) MapCreateBulk(slice any, setFunc func(*AssetCreate, int)) *AssetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssetCreateBulk{err: fmt.Errorf("calling to AssetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Asset.
func (c *AssetClient) Update() *AssetUpdate {
	mutation := newAssetMutation(c.config, OpUpdate)
	return &AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetClient) UpdateOne(_m *Asset) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAsset(_m))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetClient) UpdateOneID(id string) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAssetID(id))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Asset.
func (c *AssetClient) Delete() *AssetDelete {
	mutation := newAssetMutation(c.config, OpDelete)
	return &AssetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetClient) DeleteOne(_m *Asset) *AssetDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetClient) DeleteOneID(id string) *AssetDeleteOne {
	builder := c.Delete().Where(asset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetDeleteOne{builder}
}

// Query returns a query builder for Asset.
func (c *AssetClient) Query() *AssetQuery {
	return &AssetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAsset},
		inters: c.Interceptors(),
	}
}

// Get returns a Asset entity by its id.
func (c *AssetClient) Get(ctx context.Context, id string) (*Asset, error) {
	return c.Query().Where(asset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetClient) GetX(ctx context.Context, id string) *Asset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Asset.
func (c *AssetClient) QueryOwner(_m *Asset) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.OwnerTable, asset.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Asset.
func (c *AssetClient) QueryBlockedGroups(_m *Asset) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.BlockedGroupsTable, asset.BlockedGroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Asset.
func (c *AssetClient) QueryEditors(_m *Asset) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.EditorsTable, asset.EditorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Asset.
func (c *AssetClient) QueryViewers(_m *Asset) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.ViewersTable, asset.ViewersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Asset.
func (c *AssetClient) QueryScans(_m *Asset) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.ScansTable, asset.ScansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.ScanAssets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Asset.
func (c *AssetClient) QueryEntities(_m *Asset) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.EntitiesTable, asset.EntitiesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityAssets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Asset.
func (c *AssetClient) QueryControls(_m *Asset) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.ControlsTable, asset.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlAssets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetClient) Hooks() []Hook {
	hooks := c.hooks.Asset
	return append(hooks[:len(hooks):len(hooks)], asset.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AssetClient) Interceptors() []Interceptor {
	inters := c.inters.Asset
	return append(inters[:len(inters):len(inters)], asset.Interceptors[:]...)
}

func (c *AssetClient) mutate(ctx context.Context, m *AssetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Asset mutation op: %q", m.Op())
	}
}

// AssetHistoryClient is a client for the AssetHistory schema.
type AssetHistoryClient struct {
	config
}

// NewAssetHistoryClient returns a client for the AssetHistory from the given config.
func NewAssetHistoryClient(c config) *AssetHistoryClient {
	return &AssetHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assethistory.Hooks(f(g(h())))`.
func (c *AssetHistoryClient) Use(hooks ...Hook) {
	c.hooks.AssetHistory = append(c.hooks.AssetHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assethistory.Intercept(f(g(h())))`.
func (c *AssetHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssetHistory = append(c.inters.AssetHistory, interceptors...)
}

// Create returns a builder for creating a AssetHistory entity.
func (c *AssetHistoryClient) Create() *AssetHistoryCreate {
	mutation := newAssetHistoryMutation(c.config, OpCreate)
	return &AssetHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssetHistory entities.
func (c *AssetHistoryClient) CreateBulk(builders ...*AssetHistoryCreate) *AssetHistoryCreateBulk {
	return &AssetHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssetHistoryClient) MapCreateBulk(slice any, setFunc func(*AssetHistoryCreate, int)) *AssetHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssetHistoryCreateBulk{err: fmt.Errorf("calling to AssetHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssetHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssetHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssetHistory.
func (c *AssetHistoryClient) Update() *AssetHistoryUpdate {
	mutation := newAssetHistoryMutation(c.config, OpUpdate)
	return &AssetHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetHistoryClient) UpdateOne(_m *AssetHistory) *AssetHistoryUpdateOne {
	mutation := newAssetHistoryMutation(c.config, OpUpdateOne, withAssetHistory(_m))
	return &AssetHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetHistoryClient) UpdateOneID(id string) *AssetHistoryUpdateOne {
	mutation := newAssetHistoryMutation(c.config, OpUpdateOne, withAssetHistoryID(id))
	return &AssetHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssetHistory.
func (c *AssetHistoryClient) Delete() *AssetHistoryDelete {
	mutation := newAssetHistoryMutation(c.config, OpDelete)
	return &AssetHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetHistoryClient) DeleteOne(_m *AssetHistory) *AssetHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetHistoryClient) DeleteOneID(id string) *AssetHistoryDeleteOne {
	builder := c.Delete().Where(assethistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetHistoryDeleteOne{builder}
}

// Query returns a query builder for AssetHistory.
func (c *AssetHistoryClient) Query() *AssetHistoryQuery {
	return &AssetHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssetHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a AssetHistory entity by its id.
func (c *AssetHistoryClient) Get(ctx context.Context, id string) (*AssetHistory, error) {
	return c.Query().Where(assethistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetHistoryClient) GetX(ctx context.Context, id string) *AssetHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AssetHistoryClient) Hooks() []Hook {
	hooks := c.hooks.AssetHistory
	return append(hooks[:len(hooks):len(hooks)], assethistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AssetHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.AssetHistory
	return append(inters[:len(inters):len(inters)], assethistory.Interceptors[:]...)
}

func (c *AssetHistoryClient) mutate(ctx context.Context, m *AssetHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AssetHistory mutation op: %q", m.Op())
	}
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contact.Hooks(f(g(h())))`.
func (c *ContactClient) Use(hooks ...Hook) {
	c.hooks.Contact = append(c.hooks.Contact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contact.Intercept(f(g(h())))`.
func (c *ContactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contact = append(c.inters.Contact, interceptors...)
}

// Create returns a builder for creating a Contact entity.
func (c *ContactClient) Create() *ContactCreate {
	mutation := newContactMutation(c.config, OpCreate)
	return &ContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contact entities.
func (c *ContactClient) CreateBulk(builders ...*ContactCreate) *ContactCreateBulk {
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContactClient) MapCreateBulk(slice any, setFunc func(*ContactCreate, int)) *ContactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContactCreateBulk{err: fmt.Errorf("calling to ContactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	mutation := newContactMutation(c.config, OpUpdate)
	return &ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(_m *Contact) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContact(_m))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id string) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContactID(id))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	mutation := newContactMutation(c.config, OpDelete)
	return &ContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactClient) DeleteOne(_m *Contact) *ContactDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactClient) DeleteOneID(id string) *ContactDeleteOne {
	builder := c.Delete().Where(contact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactDeleteOne{builder}
}

// Query returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContact},
		inters: c.Interceptors(),
	}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id string) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id string) *Contact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Contact.
func (c *ContactClient) QueryOwner(_m *Contact) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.OwnerTable, contact.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Contact
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Contact.
func (c *ContactClient) QueryEntities(_m *Contact) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, contact.EntitiesTable, contact.EntitiesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityContacts
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Contact.
func (c *ContactClient) QueryFiles(_m *Contact) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, contact.FilesTable, contact.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.ContactFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContactClient) Hooks() []Hook {
	hooks := c.hooks.Contact
	return append(hooks[:len(hooks):len(hooks)], contact.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ContactClient) Interceptors() []Interceptor {
	inters := c.inters.Contact
	return append(inters[:len(inters):len(inters)], contact.Interceptors[:]...)
}

func (c *ContactClient) mutate(ctx context.Context, m *ContactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Contact mutation op: %q", m.Op())
	}
}

// ContactHistoryClient is a client for the ContactHistory schema.
type ContactHistoryClient struct {
	config
}

// NewContactHistoryClient returns a client for the ContactHistory from the given config.
func NewContactHistoryClient(c config) *ContactHistoryClient {
	return &ContactHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contacthistory.Hooks(f(g(h())))`.
func (c *ContactHistoryClient) Use(hooks ...Hook) {
	c.hooks.ContactHistory = append(c.hooks.ContactHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contacthistory.Intercept(f(g(h())))`.
func (c *ContactHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContactHistory = append(c.inters.ContactHistory, interceptors...)
}

// Create returns a builder for creating a ContactHistory entity.
func (c *ContactHistoryClient) Create() *ContactHistoryCreate {
	mutation := newContactHistoryMutation(c.config, OpCreate)
	return &ContactHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContactHistory entities.
func (c *ContactHistoryClient) CreateBulk(builders ...*ContactHistoryCreate) *ContactHistoryCreateBulk {
	return &ContactHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContactHistoryClient) MapCreateBulk(slice any, setFunc func(*ContactHistoryCreate, int)) *ContactHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContactHistoryCreateBulk{err: fmt.Errorf("calling to ContactHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContactHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContactHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContactHistory.
func (c *ContactHistoryClient) Update() *ContactHistoryUpdate {
	mutation := newContactHistoryMutation(c.config, OpUpdate)
	return &ContactHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactHistoryClient) UpdateOne(_m *ContactHistory) *ContactHistoryUpdateOne {
	mutation := newContactHistoryMutation(c.config, OpUpdateOne, withContactHistory(_m))
	return &ContactHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactHistoryClient) UpdateOneID(id string) *ContactHistoryUpdateOne {
	mutation := newContactHistoryMutation(c.config, OpUpdateOne, withContactHistoryID(id))
	return &ContactHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContactHistory.
func (c *ContactHistoryClient) Delete() *ContactHistoryDelete {
	mutation := newContactHistoryMutation(c.config, OpDelete)
	return &ContactHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactHistoryClient) DeleteOne(_m *ContactHistory) *ContactHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactHistoryClient) DeleteOneID(id string) *ContactHistoryDeleteOne {
	builder := c.Delete().Where(contacthistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactHistoryDeleteOne{builder}
}

// Query returns a query builder for ContactHistory.
func (c *ContactHistoryClient) Query() *ContactHistoryQuery {
	return &ContactHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContactHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ContactHistory entity by its id.
func (c *ContactHistoryClient) Get(ctx context.Context, id string) (*ContactHistory, error) {
	return c.Query().Where(contacthistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactHistoryClient) GetX(ctx context.Context, id string) *ContactHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContactHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ContactHistory
	return append(hooks[:len(hooks):len(hooks)], contacthistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ContactHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ContactHistory
	return append(inters[:len(inters):len(inters)], contacthistory.Interceptors[:]...)
}

func (c *ContactHistoryClient) mutate(ctx context.Context, m *ContactHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContactHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContactHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContactHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContactHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ContactHistory mutation op: %q", m.Op())
	}
}

// ControlClient is a client for the Control schema.
type ControlClient struct {
	config
}

// NewControlClient returns a client for the Control from the given config.
func NewControlClient(c config) *ControlClient {
	return &ControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `control.Hooks(f(g(h())))`.
func (c *ControlClient) Use(hooks ...Hook) {
	c.hooks.Control = append(c.hooks.Control, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `control.Intercept(f(g(h())))`.
func (c *ControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.Control = append(c.inters.Control, interceptors...)
}

// Create returns a builder for creating a Control entity.
func (c *ControlClient) Create() *ControlCreate {
	mutation := newControlMutation(c.config, OpCreate)
	return &ControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Control entities.
func (c *ControlClient) CreateBulk(builders ...*ControlCreate) *ControlCreateBulk {
	return &ControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlClient) MapCreateBulk(slice any, setFunc func(*ControlCreate, int)) *ControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlCreateBulk{err: fmt.Errorf("calling to ControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Control.
func (c *ControlClient) Update() *ControlUpdate {
	mutation := newControlMutation(c.config, OpUpdate)
	return &ControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlClient) UpdateOne(_m *Control) *ControlUpdateOne {
	mutation := newControlMutation(c.config, OpUpdateOne, withControl(_m))
	return &ControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlClient) UpdateOneID(id string) *ControlUpdateOne {
	mutation := newControlMutation(c.config, OpUpdateOne, withControlID(id))
	return &ControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Control.
func (c *ControlClient) Delete() *ControlDelete {
	mutation := newControlMutation(c.config, OpDelete)
	return &ControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlClient) DeleteOne(_m *Control) *ControlDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlClient) DeleteOneID(id string) *ControlDeleteOne {
	builder := c.Delete().Where(control.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlDeleteOne{builder}
}

// Query returns a query builder for Control.
func (c *ControlClient) Query() *ControlQuery {
	return &ControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControl},
		inters: c.Interceptors(),
	}
}

// Get returns a Control entity by its id.
func (c *ControlClient) Get(ctx context.Context, id string) (*Control, error) {
	return c.Query().Where(control.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlClient) GetX(ctx context.Context, id string) *Control {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvidence queries the evidence edge of a Control.
func (c *ControlClient) QueryEvidence(_m *Control) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.EvidenceTable, control.EvidencePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.EvidenceControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a Control.
func (c *ControlClient) QueryControlObjectives(_m *Control) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.ControlObjectivesTable, control.ControlObjectivesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Control.
func (c *ControlClient) QueryTasks(_m *Control) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.TasksTable, control.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ControlTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Control.
func (c *ControlClient) QueryNarratives(_m *Control) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.NarrativesTable, control.NarrativesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ControlNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Control.
func (c *ControlClient) QueryRisks(_m *Control) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.RisksTable, control.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.ControlRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Control.
func (c *ControlClient) QueryActionPlans(_m *Control) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.ActionPlansTable, control.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ControlActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Control.
func (c *ControlClient) QueryProcedures(_m *Control) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.ProceduresTable, control.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ControlProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Control.
func (c *ControlClient) QueryInternalPolicies(_m *Control) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.InternalPoliciesTable, control.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Control.
func (c *ControlClient) QueryComments(_m *Control) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, control.CommentsTable, control.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlOwner queries the control_owner edge of a Control.
func (c *ControlClient) QueryControlOwner(_m *Control) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, control.ControlOwnerTable, control.ControlOwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDelegate queries the delegate edge of a Control.
func (c *ControlClient) QueryDelegate(_m *Control) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, control.DelegateTable, control.DelegateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResponsibleParty queries the responsible_party edge of a Control.
func (c *ControlClient) QueryResponsibleParty(_m *Control) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, control.ResponsiblePartyTable, control.ResponsiblePartyColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Control.
func (c *ControlClient) QueryOwner(_m *Control) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, control.OwnerTable, control.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Control.
func (c *ControlClient) QueryBlockedGroups(_m *Control) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.BlockedGroupsTable, control.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Control.
func (c *ControlClient) QueryEditors(_m *Control) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.EditorsTable, control.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlKind queries the control_kind edge of a Control.
func (c *ControlClient) QueryControlKind(_m *Control) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, control.ControlKindTable, control.ControlKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandard queries the standard edge of a Control.
func (c *ControlClient) QueryStandard(_m *Control) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, control.StandardTable, control.StandardColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Control.
func (c *ControlClient) QueryPrograms(_m *Control) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.ProgramsTable, control.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Control.
func (c *ControlClient) QueryAssets(_m *Control) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.AssetsTable, control.AssetsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.ControlAssets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Control.
func (c *ControlClient) QueryScans(_m *Control) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, control.ScansTable, control.ScansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a Control.
func (c *ControlClient) QueryFindings(_m *Control) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.FindingsTable, control.FindingsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementations queries the control_implementations edge of a Control.
func (c *ControlClient) QueryControlImplementations(_m *Control) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.ControlImplementationsTable, control.ControlImplementationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlControlImplementations
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Control.
func (c *ControlClient) QuerySubcontrols(_m *Control) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, control.SubcontrolsTable, control.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJobs queries the scheduled_jobs edge of a Control.
func (c *ControlClient) QueryScheduledJobs(_m *Control) *ScheduledJobQuery {
	query := (&ScheduledJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(scheduledjob.Table, scheduledjob.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.ScheduledJobsTable, control.ScheduledJobsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJob
		step.Edge.Schema = schemaConfig.ScheduledJobControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedToControls queries the mapped_to_controls edge of a Control.
func (c *ControlClient) QueryMappedToControls(_m *Control) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.MappedToControlsTable, control.MappedToControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControlToControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedFromControls queries the mapped_from_controls edge of a Control.
func (c *ControlClient) QueryMappedFromControls(_m *Control) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.MappedFromControlsTable, control.MappedFromControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControlFromControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlMappings queries the control_mappings edge of a Control.
func (c *ControlClient) QueryControlMappings(_m *Control) *FindingControlQuery {
	query := (&FindingControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(findingcontrol.Table, findingcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, control.ControlMappingsTable, control.ControlMappingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.FindingControl
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ControlClient) Hooks() []Hook {
	hooks := c.hooks.Control
	return append(hooks[:len(hooks):len(hooks)], control.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlClient) Interceptors() []Interceptor {
	inters := c.inters.Control
	return append(inters[:len(inters):len(inters)], control.Interceptors[:]...)
}

func (c *ControlClient) mutate(ctx context.Context, m *ControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Control mutation op: %q", m.Op())
	}
}

// ControlHistoryClient is a client for the ControlHistory schema.
type ControlHistoryClient struct {
	config
}

// NewControlHistoryClient returns a client for the ControlHistory from the given config.
func NewControlHistoryClient(c config) *ControlHistoryClient {
	return &ControlHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlhistory.Hooks(f(g(h())))`.
func (c *ControlHistoryClient) Use(hooks ...Hook) {
	c.hooks.ControlHistory = append(c.hooks.ControlHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlhistory.Intercept(f(g(h())))`.
func (c *ControlHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlHistory = append(c.inters.ControlHistory, interceptors...)
}

// Create returns a builder for creating a ControlHistory entity.
func (c *ControlHistoryClient) Create() *ControlHistoryCreate {
	mutation := newControlHistoryMutation(c.config, OpCreate)
	return &ControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlHistory entities.
func (c *ControlHistoryClient) CreateBulk(builders ...*ControlHistoryCreate) *ControlHistoryCreateBulk {
	return &ControlHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlHistoryClient) MapCreateBulk(slice any, setFunc func(*ControlHistoryCreate, int)) *ControlHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlHistoryCreateBulk{err: fmt.Errorf("calling to ControlHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlHistory.
func (c *ControlHistoryClient) Update() *ControlHistoryUpdate {
	mutation := newControlHistoryMutation(c.config, OpUpdate)
	return &ControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlHistoryClient) UpdateOne(_m *ControlHistory) *ControlHistoryUpdateOne {
	mutation := newControlHistoryMutation(c.config, OpUpdateOne, withControlHistory(_m))
	return &ControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlHistoryClient) UpdateOneID(id string) *ControlHistoryUpdateOne {
	mutation := newControlHistoryMutation(c.config, OpUpdateOne, withControlHistoryID(id))
	return &ControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlHistory.
func (c *ControlHistoryClient) Delete() *ControlHistoryDelete {
	mutation := newControlHistoryMutation(c.config, OpDelete)
	return &ControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlHistoryClient) DeleteOne(_m *ControlHistory) *ControlHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlHistoryClient) DeleteOneID(id string) *ControlHistoryDeleteOne {
	builder := c.Delete().Where(controlhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlHistoryDeleteOne{builder}
}

// Query returns a query builder for ControlHistory.
func (c *ControlHistoryClient) Query() *ControlHistoryQuery {
	return &ControlHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlHistory entity by its id.
func (c *ControlHistoryClient) Get(ctx context.Context, id string) (*ControlHistory, error) {
	return c.Query().Where(controlhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlHistoryClient) GetX(ctx context.Context, id string) *ControlHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ControlHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ControlHistory
	return append(hooks[:len(hooks):len(hooks)], controlhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ControlHistory
	return append(inters[:len(inters):len(inters)], controlhistory.Interceptors[:]...)
}

func (c *ControlHistoryClient) mutate(ctx context.Context, m *ControlHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlHistory mutation op: %q", m.Op())
	}
}

// ControlImplementationClient is a client for the ControlImplementation schema.
type ControlImplementationClient struct {
	config
}

// NewControlImplementationClient returns a client for the ControlImplementation from the given config.
func NewControlImplementationClient(c config) *ControlImplementationClient {
	return &ControlImplementationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlimplementation.Hooks(f(g(h())))`.
func (c *ControlImplementationClient) Use(hooks ...Hook) {
	c.hooks.ControlImplementation = append(c.hooks.ControlImplementation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlimplementation.Intercept(f(g(h())))`.
func (c *ControlImplementationClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlImplementation = append(c.inters.ControlImplementation, interceptors...)
}

// Create returns a builder for creating a ControlImplementation entity.
func (c *ControlImplementationClient) Create() *ControlImplementationCreate {
	mutation := newControlImplementationMutation(c.config, OpCreate)
	return &ControlImplementationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlImplementation entities.
func (c *ControlImplementationClient) CreateBulk(builders ...*ControlImplementationCreate) *ControlImplementationCreateBulk {
	return &ControlImplementationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlImplementationClient) MapCreateBulk(slice any, setFunc func(*ControlImplementationCreate, int)) *ControlImplementationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlImplementationCreateBulk{err: fmt.Errorf("calling to ControlImplementationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlImplementationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlImplementationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlImplementation.
func (c *ControlImplementationClient) Update() *ControlImplementationUpdate {
	mutation := newControlImplementationMutation(c.config, OpUpdate)
	return &ControlImplementationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlImplementationClient) UpdateOne(_m *ControlImplementation) *ControlImplementationUpdateOne {
	mutation := newControlImplementationMutation(c.config, OpUpdateOne, withControlImplementation(_m))
	return &ControlImplementationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlImplementationClient) UpdateOneID(id string) *ControlImplementationUpdateOne {
	mutation := newControlImplementationMutation(c.config, OpUpdateOne, withControlImplementationID(id))
	return &ControlImplementationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlImplementation.
func (c *ControlImplementationClient) Delete() *ControlImplementationDelete {
	mutation := newControlImplementationMutation(c.config, OpDelete)
	return &ControlImplementationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlImplementationClient) DeleteOne(_m *ControlImplementation) *ControlImplementationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlImplementationClient) DeleteOneID(id string) *ControlImplementationDeleteOne {
	builder := c.Delete().Where(controlimplementation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlImplementationDeleteOne{builder}
}

// Query returns a query builder for ControlImplementation.
func (c *ControlImplementationClient) Query() *ControlImplementationQuery {
	return &ControlImplementationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlImplementation},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlImplementation entity by its id.
func (c *ControlImplementationClient) Get(ctx context.Context, id string) (*ControlImplementation, error) {
	return c.Query().Where(controlimplementation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlImplementationClient) GetX(ctx context.Context, id string) *ControlImplementation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a ControlImplementation.
func (c *ControlImplementationClient) QueryOwner(_m *ControlImplementation) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, controlimplementation.OwnerTable, controlimplementation.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.ControlImplementation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a ControlImplementation.
func (c *ControlImplementationClient) QueryBlockedGroups(_m *ControlImplementation) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlimplementation.BlockedGroupsTable, controlimplementation.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlImplementationBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a ControlImplementation.
func (c *ControlImplementationClient) QueryEditors(_m *ControlImplementation) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlimplementation.EditorsTable, controlimplementation.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlImplementationEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a ControlImplementation.
func (c *ControlImplementationClient) QueryViewers(_m *ControlImplementation) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlimplementation.ViewersTable, controlimplementation.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlImplementationViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a ControlImplementation.
func (c *ControlImplementationClient) QueryControls(_m *ControlImplementation) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlimplementation.ControlsTable, controlimplementation.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlControlImplementations
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a ControlImplementation.
func (c *ControlImplementationClient) QuerySubcontrols(_m *ControlImplementation) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlimplementation.SubcontrolsTable, controlimplementation.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.SubcontrolControlImplementations
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a ControlImplementation.
func (c *ControlImplementationClient) QueryTasks(_m *ControlImplementation) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlimplementation.Table, controlimplementation.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlimplementation.TasksTable, controlimplementation.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ControlImplementationTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ControlImplementationClient) Hooks() []Hook {
	hooks := c.hooks.ControlImplementation
	return append(hooks[:len(hooks):len(hooks)], controlimplementation.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlImplementationClient) Interceptors() []Interceptor {
	inters := c.inters.ControlImplementation
	return append(inters[:len(inters):len(inters)], controlimplementation.Interceptors[:]...)
}

func (c *ControlImplementationClient) mutate(ctx context.Context, m *ControlImplementationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlImplementationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlImplementationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlImplementationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlImplementationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlImplementation mutation op: %q", m.Op())
	}
}

// ControlImplementationHistoryClient is a client for the ControlImplementationHistory schema.
type ControlImplementationHistoryClient struct {
	config
}

// NewControlImplementationHistoryClient returns a client for the ControlImplementationHistory from the given config.
func NewControlImplementationHistoryClient(c config) *ControlImplementationHistoryClient {
	return &ControlImplementationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlimplementationhistory.Hooks(f(g(h())))`.
func (c *ControlImplementationHistoryClient) Use(hooks ...Hook) {
	c.hooks.ControlImplementationHistory = append(c.hooks.ControlImplementationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlimplementationhistory.Intercept(f(g(h())))`.
func (c *ControlImplementationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlImplementationHistory = append(c.inters.ControlImplementationHistory, interceptors...)
}

// Create returns a builder for creating a ControlImplementationHistory entity.
func (c *ControlImplementationHistoryClient) Create() *ControlImplementationHistoryCreate {
	mutation := newControlImplementationHistoryMutation(c.config, OpCreate)
	return &ControlImplementationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlImplementationHistory entities.
func (c *ControlImplementationHistoryClient) CreateBulk(builders ...*ControlImplementationHistoryCreate) *ControlImplementationHistoryCreateBulk {
	return &ControlImplementationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlImplementationHistoryClient) MapCreateBulk(slice any, setFunc func(*ControlImplementationHistoryCreate, int)) *ControlImplementationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlImplementationHistoryCreateBulk{err: fmt.Errorf("calling to ControlImplementationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlImplementationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlImplementationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlImplementationHistory.
func (c *ControlImplementationHistoryClient) Update() *ControlImplementationHistoryUpdate {
	mutation := newControlImplementationHistoryMutation(c.config, OpUpdate)
	return &ControlImplementationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlImplementationHistoryClient) UpdateOne(_m *ControlImplementationHistory) *ControlImplementationHistoryUpdateOne {
	mutation := newControlImplementationHistoryMutation(c.config, OpUpdateOne, withControlImplementationHistory(_m))
	return &ControlImplementationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlImplementationHistoryClient) UpdateOneID(id string) *ControlImplementationHistoryUpdateOne {
	mutation := newControlImplementationHistoryMutation(c.config, OpUpdateOne, withControlImplementationHistoryID(id))
	return &ControlImplementationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlImplementationHistory.
func (c *ControlImplementationHistoryClient) Delete() *ControlImplementationHistoryDelete {
	mutation := newControlImplementationHistoryMutation(c.config, OpDelete)
	return &ControlImplementationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlImplementationHistoryClient) DeleteOne(_m *ControlImplementationHistory) *ControlImplementationHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlImplementationHistoryClient) DeleteOneID(id string) *ControlImplementationHistoryDeleteOne {
	builder := c.Delete().Where(controlimplementationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlImplementationHistoryDeleteOne{builder}
}

// Query returns a query builder for ControlImplementationHistory.
func (c *ControlImplementationHistoryClient) Query() *ControlImplementationHistoryQuery {
	return &ControlImplementationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlImplementationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlImplementationHistory entity by its id.
func (c *ControlImplementationHistoryClient) Get(ctx context.Context, id string) (*ControlImplementationHistory, error) {
	return c.Query().Where(controlimplementationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlImplementationHistoryClient) GetX(ctx context.Context, id string) *ControlImplementationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ControlImplementationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ControlImplementationHistory
	return append(hooks[:len(hooks):len(hooks)], controlimplementationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlImplementationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ControlImplementationHistory
	return append(inters[:len(inters):len(inters)], controlimplementationhistory.Interceptors[:]...)
}

func (c *ControlImplementationHistoryClient) mutate(ctx context.Context, m *ControlImplementationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlImplementationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlImplementationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlImplementationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlImplementationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlImplementationHistory mutation op: %q", m.Op())
	}
}

// ControlObjectiveClient is a client for the ControlObjective schema.
type ControlObjectiveClient struct {
	config
}

// NewControlObjectiveClient returns a client for the ControlObjective from the given config.
func NewControlObjectiveClient(c config) *ControlObjectiveClient {
	return &ControlObjectiveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlobjective.Hooks(f(g(h())))`.
func (c *ControlObjectiveClient) Use(hooks ...Hook) {
	c.hooks.ControlObjective = append(c.hooks.ControlObjective, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlobjective.Intercept(f(g(h())))`.
func (c *ControlObjectiveClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlObjective = append(c.inters.ControlObjective, interceptors...)
}

// Create returns a builder for creating a ControlObjective entity.
func (c *ControlObjectiveClient) Create() *ControlObjectiveCreate {
	mutation := newControlObjectiveMutation(c.config, OpCreate)
	return &ControlObjectiveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlObjective entities.
func (c *ControlObjectiveClient) CreateBulk(builders ...*ControlObjectiveCreate) *ControlObjectiveCreateBulk {
	return &ControlObjectiveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlObjectiveClient) MapCreateBulk(slice any, setFunc func(*ControlObjectiveCreate, int)) *ControlObjectiveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlObjectiveCreateBulk{err: fmt.Errorf("calling to ControlObjectiveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlObjectiveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlObjectiveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlObjective.
func (c *ControlObjectiveClient) Update() *ControlObjectiveUpdate {
	mutation := newControlObjectiveMutation(c.config, OpUpdate)
	return &ControlObjectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlObjectiveClient) UpdateOne(_m *ControlObjective) *ControlObjectiveUpdateOne {
	mutation := newControlObjectiveMutation(c.config, OpUpdateOne, withControlObjective(_m))
	return &ControlObjectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlObjectiveClient) UpdateOneID(id string) *ControlObjectiveUpdateOne {
	mutation := newControlObjectiveMutation(c.config, OpUpdateOne, withControlObjectiveID(id))
	return &ControlObjectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlObjective.
func (c *ControlObjectiveClient) Delete() *ControlObjectiveDelete {
	mutation := newControlObjectiveMutation(c.config, OpDelete)
	return &ControlObjectiveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlObjectiveClient) DeleteOne(_m *ControlObjective) *ControlObjectiveDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlObjectiveClient) DeleteOneID(id string) *ControlObjectiveDeleteOne {
	builder := c.Delete().Where(controlobjective.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlObjectiveDeleteOne{builder}
}

// Query returns a query builder for ControlObjective.
func (c *ControlObjectiveClient) Query() *ControlObjectiveQuery {
	return &ControlObjectiveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlObjective},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlObjective entity by its id.
func (c *ControlObjectiveClient) Get(ctx context.Context, id string) (*ControlObjective, error) {
	return c.Query().Where(controlobjective.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlObjectiveClient) GetX(ctx context.Context, id string) *ControlObjective {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryOwner(_m *ControlObjective) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, controlobjective.OwnerTable, controlobjective.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.ControlObjective
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryBlockedGroups(_m *ControlObjective) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlobjective.BlockedGroupsTable, controlobjective.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlObjectiveBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryEditors(_m *ControlObjective) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlobjective.EditorsTable, controlobjective.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlObjectiveEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryViewers(_m *ControlObjective) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlobjective.ViewersTable, controlobjective.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ControlObjectiveViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryPrograms(_m *ControlObjective) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.ProgramsTable, controlobjective.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidence queries the evidence edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryEvidence(_m *ControlObjective) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.EvidenceTable, controlobjective.EvidencePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.EvidenceControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryControls(_m *ControlObjective) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.ControlsTable, controlobjective.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a ControlObjective.
func (c *ControlObjectiveClient) QuerySubcontrols(_m *ControlObjective) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.SubcontrolsTable, controlobjective.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.SubcontrolControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryInternalPolicies(_m *ControlObjective) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.InternalPoliciesTable, controlobjective.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryProcedures(_m *ControlObjective) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.ProceduresTable, controlobjective.ProceduresColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryRisks(_m *ControlObjective) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.RisksTable, controlobjective.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryNarratives(_m *ControlObjective) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.NarrativesTable, controlobjective.NarrativesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.Narrative
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryTasks(_m *ControlObjective) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlobjective.TasksTable, controlobjective.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ControlObjectiveTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ControlObjectiveClient) Hooks() []Hook {
	hooks := c.hooks.ControlObjective
	return append(hooks[:len(hooks):len(hooks)], controlobjective.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlObjectiveClient) Interceptors() []Interceptor {
	inters := c.inters.ControlObjective
	return append(inters[:len(inters):len(inters)], controlobjective.Interceptors[:]...)
}

func (c *ControlObjectiveClient) mutate(ctx context.Context, m *ControlObjectiveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlObjectiveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlObjectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlObjectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlObjectiveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlObjective mutation op: %q", m.Op())
	}
}

// ControlObjectiveHistoryClient is a client for the ControlObjectiveHistory schema.
type ControlObjectiveHistoryClient struct {
	config
}

// NewControlObjectiveHistoryClient returns a client for the ControlObjectiveHistory from the given config.
func NewControlObjectiveHistoryClient(c config) *ControlObjectiveHistoryClient {
	return &ControlObjectiveHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlobjectivehistory.Hooks(f(g(h())))`.
func (c *ControlObjectiveHistoryClient) Use(hooks ...Hook) {
	c.hooks.ControlObjectiveHistory = append(c.hooks.ControlObjectiveHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlobjectivehistory.Intercept(f(g(h())))`.
func (c *ControlObjectiveHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlObjectiveHistory = append(c.inters.ControlObjectiveHistory, interceptors...)
}

// Create returns a builder for creating a ControlObjectiveHistory entity.
func (c *ControlObjectiveHistoryClient) Create() *ControlObjectiveHistoryCreate {
	mutation := newControlObjectiveHistoryMutation(c.config, OpCreate)
	return &ControlObjectiveHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlObjectiveHistory entities.
func (c *ControlObjectiveHistoryClient) CreateBulk(builders ...*ControlObjectiveHistoryCreate) *ControlObjectiveHistoryCreateBulk {
	return &ControlObjectiveHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlObjectiveHistoryClient) MapCreateBulk(slice any, setFunc func(*ControlObjectiveHistoryCreate, int)) *ControlObjectiveHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlObjectiveHistoryCreateBulk{err: fmt.Errorf("calling to ControlObjectiveHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlObjectiveHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlObjectiveHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlObjectiveHistory.
func (c *ControlObjectiveHistoryClient) Update() *ControlObjectiveHistoryUpdate {
	mutation := newControlObjectiveHistoryMutation(c.config, OpUpdate)
	return &ControlObjectiveHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlObjectiveHistoryClient) UpdateOne(_m *ControlObjectiveHistory) *ControlObjectiveHistoryUpdateOne {
	mutation := newControlObjectiveHistoryMutation(c.config, OpUpdateOne, withControlObjectiveHistory(_m))
	return &ControlObjectiveHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlObjectiveHistoryClient) UpdateOneID(id string) *ControlObjectiveHistoryUpdateOne {
	mutation := newControlObjectiveHistoryMutation(c.config, OpUpdateOne, withControlObjectiveHistoryID(id))
	return &ControlObjectiveHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlObjectiveHistory.
func (c *ControlObjectiveHistoryClient) Delete() *ControlObjectiveHistoryDelete {
	mutation := newControlObjectiveHistoryMutation(c.config, OpDelete)
	return &ControlObjectiveHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlObjectiveHistoryClient) DeleteOne(_m *ControlObjectiveHistory) *ControlObjectiveHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlObjectiveHistoryClient) DeleteOneID(id string) *ControlObjectiveHistoryDeleteOne {
	builder := c.Delete().Where(controlobjectivehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlObjectiveHistoryDeleteOne{builder}
}

// Query returns a query builder for ControlObjectiveHistory.
func (c *ControlObjectiveHistoryClient) Query() *ControlObjectiveHistoryQuery {
	return &ControlObjectiveHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlObjectiveHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlObjectiveHistory entity by its id.
func (c *ControlObjectiveHistoryClient) Get(ctx context.Context, id string) (*ControlObjectiveHistory, error) {
	return c.Query().Where(controlobjectivehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlObjectiveHistoryClient) GetX(ctx context.Context, id string) *ControlObjectiveHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ControlObjectiveHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ControlObjectiveHistory
	return append(hooks[:len(hooks):len(hooks)], controlobjectivehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlObjectiveHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ControlObjectiveHistory
	return append(inters[:len(inters):len(inters)], controlobjectivehistory.Interceptors[:]...)
}

func (c *ControlObjectiveHistoryClient) mutate(ctx context.Context, m *ControlObjectiveHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlObjectiveHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlObjectiveHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlObjectiveHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlObjectiveHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlObjectiveHistory mutation op: %q", m.Op())
	}
}

// CustomDomainClient is a client for the CustomDomain schema.
type CustomDomainClient struct {
	config
}

// NewCustomDomainClient returns a client for the CustomDomain from the given config.
func NewCustomDomainClient(c config) *CustomDomainClient {
	return &CustomDomainClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customdomain.Hooks(f(g(h())))`.
func (c *CustomDomainClient) Use(hooks ...Hook) {
	c.hooks.CustomDomain = append(c.hooks.CustomDomain, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customdomain.Intercept(f(g(h())))`.
func (c *CustomDomainClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomDomain = append(c.inters.CustomDomain, interceptors...)
}

// Create returns a builder for creating a CustomDomain entity.
func (c *CustomDomainClient) Create() *CustomDomainCreate {
	mutation := newCustomDomainMutation(c.config, OpCreate)
	return &CustomDomainCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomDomain entities.
func (c *CustomDomainClient) CreateBulk(builders ...*CustomDomainCreate) *CustomDomainCreateBulk {
	return &CustomDomainCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomDomainClient) MapCreateBulk(slice any, setFunc func(*CustomDomainCreate, int)) *CustomDomainCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomDomainCreateBulk{err: fmt.Errorf("calling to CustomDomainClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomDomainCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomDomainCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomDomain.
func (c *CustomDomainClient) Update() *CustomDomainUpdate {
	mutation := newCustomDomainMutation(c.config, OpUpdate)
	return &CustomDomainUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomDomainClient) UpdateOne(_m *CustomDomain) *CustomDomainUpdateOne {
	mutation := newCustomDomainMutation(c.config, OpUpdateOne, withCustomDomain(_m))
	return &CustomDomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomDomainClient) UpdateOneID(id string) *CustomDomainUpdateOne {
	mutation := newCustomDomainMutation(c.config, OpUpdateOne, withCustomDomainID(id))
	return &CustomDomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomDomain.
func (c *CustomDomainClient) Delete() *CustomDomainDelete {
	mutation := newCustomDomainMutation(c.config, OpDelete)
	return &CustomDomainDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomDomainClient) DeleteOne(_m *CustomDomain) *CustomDomainDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomDomainClient) DeleteOneID(id string) *CustomDomainDeleteOne {
	builder := c.Delete().Where(customdomain.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomDomainDeleteOne{builder}
}

// Query returns a query builder for CustomDomain.
func (c *CustomDomainClient) Query() *CustomDomainQuery {
	return &CustomDomainQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomDomain},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomDomain entity by its id.
func (c *CustomDomainClient) Get(ctx context.Context, id string) (*CustomDomain, error) {
	return c.Query().Where(customdomain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomDomainClient) GetX(ctx context.Context, id string) *CustomDomain {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a CustomDomain.
func (c *CustomDomainClient) QueryOwner(_m *CustomDomain) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customdomain.Table, customdomain.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customdomain.OwnerTable, customdomain.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.CustomDomain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappableDomain queries the mappable_domain edge of a CustomDomain.
func (c *CustomDomainClient) QueryMappableDomain(_m *CustomDomain) *MappableDomainQuery {
	query := (&MappableDomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customdomain.Table, customdomain.FieldID, id),
			sqlgraph.To(mappabledomain.Table, mappabledomain.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customdomain.MappableDomainTable, customdomain.MappableDomainColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappableDomain
		step.Edge.Schema = schemaConfig.CustomDomain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNSVerification queries the dns_verification edge of a CustomDomain.
func (c *CustomDomainClient) QueryDNSVerification(_m *CustomDomain) *DNSVerificationQuery {
	query := (&DNSVerificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customdomain.Table, customdomain.FieldID, id),
			sqlgraph.To(dnsverification.Table, dnsverification.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customdomain.DNSVerificationTable, customdomain.DNSVerificationColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DNSVerification
		step.Edge.Schema = schemaConfig.CustomDomain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomDomainClient) Hooks() []Hook {
	hooks := c.hooks.CustomDomain
	return append(hooks[:len(hooks):len(hooks)], customdomain.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CustomDomainClient) Interceptors() []Interceptor {
	inters := c.inters.CustomDomain
	return append(inters[:len(inters):len(inters)], customdomain.Interceptors[:]...)
}

func (c *CustomDomainClient) mutate(ctx context.Context, m *CustomDomainMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomDomainCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomDomainUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomDomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomDomainDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CustomDomain mutation op: %q", m.Op())
	}
}

// CustomDomainHistoryClient is a client for the CustomDomainHistory schema.
type CustomDomainHistoryClient struct {
	config
}

// NewCustomDomainHistoryClient returns a client for the CustomDomainHistory from the given config.
func NewCustomDomainHistoryClient(c config) *CustomDomainHistoryClient {
	return &CustomDomainHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customdomainhistory.Hooks(f(g(h())))`.
func (c *CustomDomainHistoryClient) Use(hooks ...Hook) {
	c.hooks.CustomDomainHistory = append(c.hooks.CustomDomainHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customdomainhistory.Intercept(f(g(h())))`.
func (c *CustomDomainHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomDomainHistory = append(c.inters.CustomDomainHistory, interceptors...)
}

// Create returns a builder for creating a CustomDomainHistory entity.
func (c *CustomDomainHistoryClient) Create() *CustomDomainHistoryCreate {
	mutation := newCustomDomainHistoryMutation(c.config, OpCreate)
	return &CustomDomainHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomDomainHistory entities.
func (c *CustomDomainHistoryClient) CreateBulk(builders ...*CustomDomainHistoryCreate) *CustomDomainHistoryCreateBulk {
	return &CustomDomainHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomDomainHistoryClient) MapCreateBulk(slice any, setFunc func(*CustomDomainHistoryCreate, int)) *CustomDomainHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomDomainHistoryCreateBulk{err: fmt.Errorf("calling to CustomDomainHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomDomainHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomDomainHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomDomainHistory.
func (c *CustomDomainHistoryClient) Update() *CustomDomainHistoryUpdate {
	mutation := newCustomDomainHistoryMutation(c.config, OpUpdate)
	return &CustomDomainHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomDomainHistoryClient) UpdateOne(_m *CustomDomainHistory) *CustomDomainHistoryUpdateOne {
	mutation := newCustomDomainHistoryMutation(c.config, OpUpdateOne, withCustomDomainHistory(_m))
	return &CustomDomainHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomDomainHistoryClient) UpdateOneID(id string) *CustomDomainHistoryUpdateOne {
	mutation := newCustomDomainHistoryMutation(c.config, OpUpdateOne, withCustomDomainHistoryID(id))
	return &CustomDomainHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomDomainHistory.
func (c *CustomDomainHistoryClient) Delete() *CustomDomainHistoryDelete {
	mutation := newCustomDomainHistoryMutation(c.config, OpDelete)
	return &CustomDomainHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomDomainHistoryClient) DeleteOne(_m *CustomDomainHistory) *CustomDomainHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomDomainHistoryClient) DeleteOneID(id string) *CustomDomainHistoryDeleteOne {
	builder := c.Delete().Where(customdomainhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomDomainHistoryDeleteOne{builder}
}

// Query returns a query builder for CustomDomainHistory.
func (c *CustomDomainHistoryClient) Query() *CustomDomainHistoryQuery {
	return &CustomDomainHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomDomainHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomDomainHistory entity by its id.
func (c *CustomDomainHistoryClient) Get(ctx context.Context, id string) (*CustomDomainHistory, error) {
	return c.Query().Where(customdomainhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomDomainHistoryClient) GetX(ctx context.Context, id string) *CustomDomainHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CustomDomainHistoryClient) Hooks() []Hook {
	hooks := c.hooks.CustomDomainHistory
	return append(hooks[:len(hooks):len(hooks)], customdomainhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CustomDomainHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.CustomDomainHistory
	return append(inters[:len(inters):len(inters)], customdomainhistory.Interceptors[:]...)
}

func (c *CustomDomainHistoryClient) mutate(ctx context.Context, m *CustomDomainHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomDomainHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomDomainHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomDomainHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomDomainHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CustomDomainHistory mutation op: %q", m.Op())
	}
}

// CustomTypeEnumClient is a client for the CustomTypeEnum schema.
type CustomTypeEnumClient struct {
	config
}

// NewCustomTypeEnumClient returns a client for the CustomTypeEnum from the given config.
func NewCustomTypeEnumClient(c config) *CustomTypeEnumClient {
	return &CustomTypeEnumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customtypeenum.Hooks(f(g(h())))`.
func (c *CustomTypeEnumClient) Use(hooks ...Hook) {
	c.hooks.CustomTypeEnum = append(c.hooks.CustomTypeEnum, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customtypeenum.Intercept(f(g(h())))`.
func (c *CustomTypeEnumClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomTypeEnum = append(c.inters.CustomTypeEnum, interceptors...)
}

// Create returns a builder for creating a CustomTypeEnum entity.
func (c *CustomTypeEnumClient) Create() *CustomTypeEnumCreate {
	mutation := newCustomTypeEnumMutation(c.config, OpCreate)
	return &CustomTypeEnumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomTypeEnum entities.
func (c *CustomTypeEnumClient) CreateBulk(builders ...*CustomTypeEnumCreate) *CustomTypeEnumCreateBulk {
	return &CustomTypeEnumCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomTypeEnumClient) MapCreateBulk(slice any, setFunc func(*CustomTypeEnumCreate, int)) *CustomTypeEnumCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomTypeEnumCreateBulk{err: fmt.Errorf("calling to CustomTypeEnumClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomTypeEnumCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomTypeEnumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomTypeEnum.
func (c *CustomTypeEnumClient) Update() *CustomTypeEnumUpdate {
	mutation := newCustomTypeEnumMutation(c.config, OpUpdate)
	return &CustomTypeEnumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomTypeEnumClient) UpdateOne(_m *CustomTypeEnum) *CustomTypeEnumUpdateOne {
	mutation := newCustomTypeEnumMutation(c.config, OpUpdateOne, withCustomTypeEnum(_m))
	return &CustomTypeEnumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomTypeEnumClient) UpdateOneID(id string) *CustomTypeEnumUpdateOne {
	mutation := newCustomTypeEnumMutation(c.config, OpUpdateOne, withCustomTypeEnumID(id))
	return &CustomTypeEnumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomTypeEnum.
func (c *CustomTypeEnumClient) Delete() *CustomTypeEnumDelete {
	mutation := newCustomTypeEnumMutation(c.config, OpDelete)
	return &CustomTypeEnumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomTypeEnumClient) DeleteOne(_m *CustomTypeEnum) *CustomTypeEnumDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomTypeEnumClient) DeleteOneID(id string) *CustomTypeEnumDeleteOne {
	builder := c.Delete().Where(customtypeenum.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomTypeEnumDeleteOne{builder}
}

// Query returns a query builder for CustomTypeEnum.
func (c *CustomTypeEnumClient) Query() *CustomTypeEnumQuery {
	return &CustomTypeEnumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomTypeEnum},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomTypeEnum entity by its id.
func (c *CustomTypeEnumClient) Get(ctx context.Context, id string) (*CustomTypeEnum, error) {
	return c.Query().Where(customtypeenum.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomTypeEnumClient) GetX(ctx context.Context, id string) *CustomTypeEnum {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryOwner(_m *CustomTypeEnum) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customtypeenum.OwnerTable, customtypeenum.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.CustomTypeEnum
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryTasks(_m *CustomTypeEnum) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.TasksTable, customtypeenum.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryControls(_m *CustomTypeEnum) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.ControlsTable, customtypeenum.ControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QuerySubcontrols(_m *CustomTypeEnum) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.SubcontrolsTable, customtypeenum.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryRisks(_m *CustomTypeEnum) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.RisksTable, customtypeenum.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskCategories queries the risk_categories edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryRiskCategories(_m *CustomTypeEnum) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.RiskCategoriesTable, customtypeenum.RiskCategoriesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryInternalPolicies(_m *CustomTypeEnum) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.InternalPoliciesTable, customtypeenum.InternalPoliciesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryProcedures(_m *CustomTypeEnum) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.ProceduresTable, customtypeenum.ProceduresColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryActionPlans(_m *CustomTypeEnum) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.ActionPlansTable, customtypeenum.ActionPlansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a CustomTypeEnum.
func (c *CustomTypeEnumClient) QueryPrograms(_m *CustomTypeEnum) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customtypeenum.Table, customtypeenum.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customtypeenum.ProgramsTable, customtypeenum.ProgramsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomTypeEnumClient) Hooks() []Hook {
	hooks := c.hooks.CustomTypeEnum
	return append(hooks[:len(hooks):len(hooks)], customtypeenum.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CustomTypeEnumClient) Interceptors() []Interceptor {
	inters := c.inters.CustomTypeEnum
	return append(inters[:len(inters):len(inters)], customtypeenum.Interceptors[:]...)
}

func (c *CustomTypeEnumClient) mutate(ctx context.Context, m *CustomTypeEnumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomTypeEnumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomTypeEnumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomTypeEnumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomTypeEnumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CustomTypeEnum mutation op: %q", m.Op())
	}
}

// DNSVerificationClient is a client for the DNSVerification schema.
type DNSVerificationClient struct {
	config
}

// NewDNSVerificationClient returns a client for the DNSVerification from the given config.
func NewDNSVerificationClient(c config) *DNSVerificationClient {
	return &DNSVerificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dnsverification.Hooks(f(g(h())))`.
func (c *DNSVerificationClient) Use(hooks ...Hook) {
	c.hooks.DNSVerification = append(c.hooks.DNSVerification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dnsverification.Intercept(f(g(h())))`.
func (c *DNSVerificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNSVerification = append(c.inters.DNSVerification, interceptors...)
}

// Create returns a builder for creating a DNSVerification entity.
func (c *DNSVerificationClient) Create() *DNSVerificationCreate {
	mutation := newDNSVerificationMutation(c.config, OpCreate)
	return &DNSVerificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNSVerification entities.
func (c *DNSVerificationClient) CreateBulk(builders ...*DNSVerificationCreate) *DNSVerificationCreateBulk {
	return &DNSVerificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSVerificationClient) MapCreateBulk(slice any, setFunc func(*DNSVerificationCreate, int)) *DNSVerificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSVerificationCreateBulk{err: fmt.Errorf("calling to DNSVerificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSVerificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSVerificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNSVerification.
func (c *DNSVerificationClient) Update() *DNSVerificationUpdate {
	mutation := newDNSVerificationMutation(c.config, OpUpdate)
	return &DNSVerificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSVerificationClient) UpdateOne(_m *DNSVerification) *DNSVerificationUpdateOne {
	mutation := newDNSVerificationMutation(c.config, OpUpdateOne, withDNSVerification(_m))
	return &DNSVerificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSVerificationClient) UpdateOneID(id string) *DNSVerificationUpdateOne {
	mutation := newDNSVerificationMutation(c.config, OpUpdateOne, withDNSVerificationID(id))
	return &DNSVerificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNSVerification.
func (c *DNSVerificationClient) Delete() *DNSVerificationDelete {
	mutation := newDNSVerificationMutation(c.config, OpDelete)
	return &DNSVerificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSVerificationClient) DeleteOne(_m *DNSVerification) *DNSVerificationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSVerificationClient) DeleteOneID(id string) *DNSVerificationDeleteOne {
	builder := c.Delete().Where(dnsverification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSVerificationDeleteOne{builder}
}

// Query returns a query builder for DNSVerification.
func (c *DNSVerificationClient) Query() *DNSVerificationQuery {
	return &DNSVerificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNSVerification},
		inters: c.Interceptors(),
	}
}

// Get returns a DNSVerification entity by its id.
func (c *DNSVerificationClient) Get(ctx context.Context, id string) (*DNSVerification, error) {
	return c.Query().Where(dnsverification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSVerificationClient) GetX(ctx context.Context, id string) *DNSVerification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a DNSVerification.
func (c *DNSVerificationClient) QueryOwner(_m *DNSVerification) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dnsverification.Table, dnsverification.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dnsverification.OwnerTable, dnsverification.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.DNSVerification
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomDomains queries the custom_domains edge of a DNSVerification.
func (c *DNSVerificationClient) QueryCustomDomains(_m *DNSVerification) *CustomDomainQuery {
	query := (&CustomDomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dnsverification.Table, dnsverification.FieldID, id),
			sqlgraph.To(customdomain.Table, customdomain.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dnsverification.CustomDomainsTable, dnsverification.CustomDomainsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomDomain
		step.Edge.Schema = schemaConfig.CustomDomain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DNSVerificationClient) Hooks() []Hook {
	hooks := c.hooks.DNSVerification
	return append(hooks[:len(hooks):len(hooks)], dnsverification.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DNSVerificationClient) Interceptors() []Interceptor {
	inters := c.inters.DNSVerification
	return append(inters[:len(inters):len(inters)], dnsverification.Interceptors[:]...)
}

func (c *DNSVerificationClient) mutate(ctx context.Context, m *DNSVerificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSVerificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSVerificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSVerificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSVerificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DNSVerification mutation op: %q", m.Op())
	}
}

// DNSVerificationHistoryClient is a client for the DNSVerificationHistory schema.
type DNSVerificationHistoryClient struct {
	config
}

// NewDNSVerificationHistoryClient returns a client for the DNSVerificationHistory from the given config.
func NewDNSVerificationHistoryClient(c config) *DNSVerificationHistoryClient {
	return &DNSVerificationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dnsverificationhistory.Hooks(f(g(h())))`.
func (c *DNSVerificationHistoryClient) Use(hooks ...Hook) {
	c.hooks.DNSVerificationHistory = append(c.hooks.DNSVerificationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dnsverificationhistory.Intercept(f(g(h())))`.
func (c *DNSVerificationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNSVerificationHistory = append(c.inters.DNSVerificationHistory, interceptors...)
}

// Create returns a builder for creating a DNSVerificationHistory entity.
func (c *DNSVerificationHistoryClient) Create() *DNSVerificationHistoryCreate {
	mutation := newDNSVerificationHistoryMutation(c.config, OpCreate)
	return &DNSVerificationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNSVerificationHistory entities.
func (c *DNSVerificationHistoryClient) CreateBulk(builders ...*DNSVerificationHistoryCreate) *DNSVerificationHistoryCreateBulk {
	return &DNSVerificationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSVerificationHistoryClient) MapCreateBulk(slice any, setFunc func(*DNSVerificationHistoryCreate, int)) *DNSVerificationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSVerificationHistoryCreateBulk{err: fmt.Errorf("calling to DNSVerificationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSVerificationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSVerificationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNSVerificationHistory.
func (c *DNSVerificationHistoryClient) Update() *DNSVerificationHistoryUpdate {
	mutation := newDNSVerificationHistoryMutation(c.config, OpUpdate)
	return &DNSVerificationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSVerificationHistoryClient) UpdateOne(_m *DNSVerificationHistory) *DNSVerificationHistoryUpdateOne {
	mutation := newDNSVerificationHistoryMutation(c.config, OpUpdateOne, withDNSVerificationHistory(_m))
	return &DNSVerificationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSVerificationHistoryClient) UpdateOneID(id string) *DNSVerificationHistoryUpdateOne {
	mutation := newDNSVerificationHistoryMutation(c.config, OpUpdateOne, withDNSVerificationHistoryID(id))
	return &DNSVerificationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNSVerificationHistory.
func (c *DNSVerificationHistoryClient) Delete() *DNSVerificationHistoryDelete {
	mutation := newDNSVerificationHistoryMutation(c.config, OpDelete)
	return &DNSVerificationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSVerificationHistoryClient) DeleteOne(_m *DNSVerificationHistory) *DNSVerificationHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSVerificationHistoryClient) DeleteOneID(id string) *DNSVerificationHistoryDeleteOne {
	builder := c.Delete().Where(dnsverificationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSVerificationHistoryDeleteOne{builder}
}

// Query returns a query builder for DNSVerificationHistory.
func (c *DNSVerificationHistoryClient) Query() *DNSVerificationHistoryQuery {
	return &DNSVerificationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNSVerificationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a DNSVerificationHistory entity by its id.
func (c *DNSVerificationHistoryClient) Get(ctx context.Context, id string) (*DNSVerificationHistory, error) {
	return c.Query().Where(dnsverificationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSVerificationHistoryClient) GetX(ctx context.Context, id string) *DNSVerificationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DNSVerificationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.DNSVerificationHistory
	return append(hooks[:len(hooks):len(hooks)], dnsverificationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DNSVerificationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.DNSVerificationHistory
	return append(inters[:len(inters):len(inters)], dnsverificationhistory.Interceptors[:]...)
}

func (c *DNSVerificationHistoryClient) mutate(ctx context.Context, m *DNSVerificationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSVerificationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSVerificationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSVerificationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSVerificationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DNSVerificationHistory mutation op: %q", m.Op())
	}
}

// DocumentDataClient is a client for the DocumentData schema.
type DocumentDataClient struct {
	config
}

// NewDocumentDataClient returns a client for the DocumentData from the given config.
func NewDocumentDataClient(c config) *DocumentDataClient {
	return &DocumentDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documentdata.Hooks(f(g(h())))`.
func (c *DocumentDataClient) Use(hooks ...Hook) {
	c.hooks.DocumentData = append(c.hooks.DocumentData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documentdata.Intercept(f(g(h())))`.
func (c *DocumentDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentData = append(c.inters.DocumentData, interceptors...)
}

// Create returns a builder for creating a DocumentData entity.
func (c *DocumentDataClient) Create() *DocumentDataCreate {
	mutation := newDocumentDataMutation(c.config, OpCreate)
	return &DocumentDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentData entities.
func (c *DocumentDataClient) CreateBulk(builders ...*DocumentDataCreate) *DocumentDataCreateBulk {
	return &DocumentDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentDataClient) MapCreateBulk(slice any, setFunc func(*DocumentDataCreate, int)) *DocumentDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentDataCreateBulk{err: fmt.Errorf("calling to DocumentDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentData.
func (c *DocumentDataClient) Update() *DocumentDataUpdate {
	mutation := newDocumentDataMutation(c.config, OpUpdate)
	return &DocumentDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentDataClient) UpdateOne(_m *DocumentData) *DocumentDataUpdateOne {
	mutation := newDocumentDataMutation(c.config, OpUpdateOne, withDocumentData(_m))
	return &DocumentDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentDataClient) UpdateOneID(id string) *DocumentDataUpdateOne {
	mutation := newDocumentDataMutation(c.config, OpUpdateOne, withDocumentDataID(id))
	return &DocumentDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentData.
func (c *DocumentDataClient) Delete() *DocumentDataDelete {
	mutation := newDocumentDataMutation(c.config, OpDelete)
	return &DocumentDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentDataClient) DeleteOne(_m *DocumentData) *DocumentDataDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentDataClient) DeleteOneID(id string) *DocumentDataDeleteOne {
	builder := c.Delete().Where(documentdata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDataDeleteOne{builder}
}

// Query returns a query builder for DocumentData.
func (c *DocumentDataClient) Query() *DocumentDataQuery {
	return &DocumentDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentData},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentData entity by its id.
func (c *DocumentDataClient) Get(ctx context.Context, id string) (*DocumentData, error) {
	return c.Query().Where(documentdata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentDataClient) GetX(ctx context.Context, id string) *DocumentData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a DocumentData.
func (c *DocumentDataClient) QueryOwner(_m *DocumentData) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, documentdata.OwnerTable, documentdata.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a DocumentData.
func (c *DocumentDataClient) QueryTemplate(_m *DocumentData) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, documentdata.TemplateTable, documentdata.TemplateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a DocumentData.
func (c *DocumentDataClient) QueryEntities(_m *DocumentData) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, documentdata.EntitiesTable, documentdata.EntitiesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityDocuments
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a DocumentData.
func (c *DocumentDataClient) QueryFiles(_m *DocumentData) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, documentdata.FilesTable, documentdata.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.DocumentDataFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentDataClient) Hooks() []Hook {
	hooks := c.hooks.DocumentData
	return append(hooks[:len(hooks):len(hooks)], documentdata.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DocumentDataClient) Interceptors() []Interceptor {
	inters := c.inters.DocumentData
	return append(inters[:len(inters):len(inters)], documentdata.Interceptors[:]...)
}

func (c *DocumentDataClient) mutate(ctx context.Context, m *DocumentDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DocumentData mutation op: %q", m.Op())
	}
}

// DocumentDataHistoryClient is a client for the DocumentDataHistory schema.
type DocumentDataHistoryClient struct {
	config
}

// NewDocumentDataHistoryClient returns a client for the DocumentDataHistory from the given config.
func NewDocumentDataHistoryClient(c config) *DocumentDataHistoryClient {
	return &DocumentDataHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documentdatahistory.Hooks(f(g(h())))`.
func (c *DocumentDataHistoryClient) Use(hooks ...Hook) {
	c.hooks.DocumentDataHistory = append(c.hooks.DocumentDataHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documentdatahistory.Intercept(f(g(h())))`.
func (c *DocumentDataHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentDataHistory = append(c.inters.DocumentDataHistory, interceptors...)
}

// Create returns a builder for creating a DocumentDataHistory entity.
func (c *DocumentDataHistoryClient) Create() *DocumentDataHistoryCreate {
	mutation := newDocumentDataHistoryMutation(c.config, OpCreate)
	return &DocumentDataHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentDataHistory entities.
func (c *DocumentDataHistoryClient) CreateBulk(builders ...*DocumentDataHistoryCreate) *DocumentDataHistoryCreateBulk {
	return &DocumentDataHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentDataHistoryClient) MapCreateBulk(slice any, setFunc func(*DocumentDataHistoryCreate, int)) *DocumentDataHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentDataHistoryCreateBulk{err: fmt.Errorf("calling to DocumentDataHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentDataHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentDataHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentDataHistory.
func (c *DocumentDataHistoryClient) Update() *DocumentDataHistoryUpdate {
	mutation := newDocumentDataHistoryMutation(c.config, OpUpdate)
	return &DocumentDataHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentDataHistoryClient) UpdateOne(_m *DocumentDataHistory) *DocumentDataHistoryUpdateOne {
	mutation := newDocumentDataHistoryMutation(c.config, OpUpdateOne, withDocumentDataHistory(_m))
	return &DocumentDataHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentDataHistoryClient) UpdateOneID(id string) *DocumentDataHistoryUpdateOne {
	mutation := newDocumentDataHistoryMutation(c.config, OpUpdateOne, withDocumentDataHistoryID(id))
	return &DocumentDataHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentDataHistory.
func (c *DocumentDataHistoryClient) Delete() *DocumentDataHistoryDelete {
	mutation := newDocumentDataHistoryMutation(c.config, OpDelete)
	return &DocumentDataHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentDataHistoryClient) DeleteOne(_m *DocumentDataHistory) *DocumentDataHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentDataHistoryClient) DeleteOneID(id string) *DocumentDataHistoryDeleteOne {
	builder := c.Delete().Where(documentdatahistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDataHistoryDeleteOne{builder}
}

// Query returns a query builder for DocumentDataHistory.
func (c *DocumentDataHistoryClient) Query() *DocumentDataHistoryQuery {
	return &DocumentDataHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentDataHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentDataHistory entity by its id.
func (c *DocumentDataHistoryClient) Get(ctx context.Context, id string) (*DocumentDataHistory, error) {
	return c.Query().Where(documentdatahistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentDataHistoryClient) GetX(ctx context.Context, id string) *DocumentDataHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DocumentDataHistoryClient) Hooks() []Hook {
	hooks := c.hooks.DocumentDataHistory
	return append(hooks[:len(hooks):len(hooks)], documentdatahistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DocumentDataHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.DocumentDataHistory
	return append(inters[:len(inters):len(inters)], documentdatahistory.Interceptors[:]...)
}

func (c *DocumentDataHistoryClient) mutate(ctx context.Context, m *DocumentDataHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentDataHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentDataHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentDataHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDataHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DocumentDataHistory mutation op: %q", m.Op())
	}
}

// EmailVerificationTokenClient is a client for the EmailVerificationToken schema.
type EmailVerificationTokenClient struct {
	config
}

// NewEmailVerificationTokenClient returns a client for the EmailVerificationToken from the given config.
func NewEmailVerificationTokenClient(c config) *EmailVerificationTokenClient {
	return &EmailVerificationTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailverificationtoken.Hooks(f(g(h())))`.
func (c *EmailVerificationTokenClient) Use(hooks ...Hook) {
	c.hooks.EmailVerificationToken = append(c.hooks.EmailVerificationToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailverificationtoken.Intercept(f(g(h())))`.
func (c *EmailVerificationTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailVerificationToken = append(c.inters.EmailVerificationToken, interceptors...)
}

// Create returns a builder for creating a EmailVerificationToken entity.
func (c *EmailVerificationTokenClient) Create() *EmailVerificationTokenCreate {
	mutation := newEmailVerificationTokenMutation(c.config, OpCreate)
	return &EmailVerificationTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailVerificationToken entities.
func (c *EmailVerificationTokenClient) CreateBulk(builders ...*EmailVerificationTokenCreate) *EmailVerificationTokenCreateBulk {
	return &EmailVerificationTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailVerificationTokenClient) MapCreateBulk(slice any, setFunc func(*EmailVerificationTokenCreate, int)) *EmailVerificationTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailVerificationTokenCreateBulk{err: fmt.Errorf("calling to EmailVerificationTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailVerificationTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailVerificationTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailVerificationToken.
func (c *EmailVerificationTokenClient) Update() *EmailVerificationTokenUpdate {
	mutation := newEmailVerificationTokenMutation(c.config, OpUpdate)
	return &EmailVerificationTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailVerificationTokenClient) UpdateOne(_m *EmailVerificationToken) *EmailVerificationTokenUpdateOne {
	mutation := newEmailVerificationTokenMutation(c.config, OpUpdateOne, withEmailVerificationToken(_m))
	return &EmailVerificationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailVerificationTokenClient) UpdateOneID(id string) *EmailVerificationTokenUpdateOne {
	mutation := newEmailVerificationTokenMutation(c.config, OpUpdateOne, withEmailVerificationTokenID(id))
	return &EmailVerificationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailVerificationToken.
func (c *EmailVerificationTokenClient) Delete() *EmailVerificationTokenDelete {
	mutation := newEmailVerificationTokenMutation(c.config, OpDelete)
	return &EmailVerificationTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailVerificationTokenClient) DeleteOne(_m *EmailVerificationToken) *EmailVerificationTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailVerificationTokenClient) DeleteOneID(id string) *EmailVerificationTokenDeleteOne {
	builder := c.Delete().Where(emailverificationtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailVerificationTokenDeleteOne{builder}
}

// Query returns a query builder for EmailVerificationToken.
func (c *EmailVerificationTokenClient) Query() *EmailVerificationTokenQuery {
	return &EmailVerificationTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailVerificationToken},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailVerificationToken entity by its id.
func (c *EmailVerificationTokenClient) Get(ctx context.Context, id string) (*EmailVerificationToken, error) {
	return c.Query().Where(emailverificationtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailVerificationTokenClient) GetX(ctx context.Context, id string) *EmailVerificationToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a EmailVerificationToken.
func (c *EmailVerificationTokenClient) QueryOwner(_m *EmailVerificationToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailverificationtoken.Table, emailverificationtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailverificationtoken.OwnerTable, emailverificationtoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.EmailVerificationToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailVerificationTokenClient) Hooks() []Hook {
	hooks := c.hooks.EmailVerificationToken
	return append(hooks[:len(hooks):len(hooks)], emailverificationtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EmailVerificationTokenClient) Interceptors() []Interceptor {
	inters := c.inters.EmailVerificationToken
	return append(inters[:len(inters):len(inters)], emailverificationtoken.Interceptors[:]...)
}

func (c *EmailVerificationTokenClient) mutate(ctx context.Context, m *EmailVerificationTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailVerificationTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailVerificationTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailVerificationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailVerificationTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EmailVerificationToken mutation op: %q", m.Op())
	}
}

// EntityClient is a client for the Entity schema.
type EntityClient struct {
	config
}

// NewEntityClient returns a client for the Entity from the given config.
func NewEntityClient(c config) *EntityClient {
	return &EntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entity.Hooks(f(g(h())))`.
func (c *EntityClient) Use(hooks ...Hook) {
	c.hooks.Entity = append(c.hooks.Entity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entity.Intercept(f(g(h())))`.
func (c *EntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entity = append(c.inters.Entity, interceptors...)
}

// Create returns a builder for creating a Entity entity.
func (c *EntityClient) Create() *EntityCreate {
	mutation := newEntityMutation(c.config, OpCreate)
	return &EntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entity entities.
func (c *EntityClient) CreateBulk(builders ...*EntityCreate) *EntityCreateBulk {
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityClient) MapCreateBulk(slice any, setFunc func(*EntityCreate, int)) *EntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityCreateBulk{err: fmt.Errorf("calling to EntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entity.
func (c *EntityClient) Update() *EntityUpdate {
	mutation := newEntityMutation(c.config, OpUpdate)
	return &EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityClient) UpdateOne(_m *Entity) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntity(_m))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityClient) UpdateOneID(id string) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntityID(id))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entity.
func (c *EntityClient) Delete() *EntityDelete {
	mutation := newEntityMutation(c.config, OpDelete)
	return &EntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityClient) DeleteOne(_m *Entity) *EntityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityClient) DeleteOneID(id string) *EntityDeleteOne {
	builder := c.Delete().Where(entity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityDeleteOne{builder}
}

// Query returns a query builder for Entity.
func (c *EntityClient) Query() *EntityQuery {
	return &EntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a Entity entity by its id.
func (c *EntityClient) Get(ctx context.Context, id string) (*Entity, error) {
	return c.Query().Where(entity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityClient) GetX(ctx context.Context, id string) *Entity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Entity.
func (c *EntityClient) QueryOwner(_m *Entity) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entity.OwnerTable, entity.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Entity.
func (c *EntityClient) QueryBlockedGroups(_m *Entity) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.BlockedGroupsTable, entity.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.EntityBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Entity.
func (c *EntityClient) QueryEditors(_m *Entity) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.EditorsTable, entity.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.EntityEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Entity.
func (c *EntityClient) QueryViewers(_m *Entity) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.ViewersTable, entity.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.EntityViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Entity.
func (c *EntityClient) QueryContacts(_m *Entity) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.ContactsTable, entity.ContactsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Contact
		step.Edge.Schema = schemaConfig.EntityContacts
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Entity.
func (c *EntityClient) QueryDocuments(_m *Entity) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.DocumentsTable, entity.DocumentsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.EntityDocuments
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Entity.
func (c *EntityClient) QueryNotes(_m *Entity) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.NotesTable, entity.NotesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Entity.
func (c *EntityClient) QueryFiles(_m *Entity) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.FilesTable, entity.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.EntityFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Entity.
func (c *EntityClient) QueryAssets(_m *Entity) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.AssetsTable, entity.AssetsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.EntityAssets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Entity.
func (c *EntityClient) QueryScans(_m *Entity) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.ScansTable, entity.ScansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntityType queries the entity_type edge of a Entity.
func (c *EntityClient) QueryEntityType(_m *Entity) *EntityTypeQuery {
	query := (&EntityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(entitytype.Table, entitytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, entity.EntityTypeTable, entity.EntityTypeColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.EntityType
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityClient) Hooks() []Hook {
	hooks := c.hooks.Entity
	return append(hooks[:len(hooks):len(hooks)], entity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityClient) Interceptors() []Interceptor {
	inters := c.inters.Entity
	return append(inters[:len(inters):len(inters)], entity.Interceptors[:]...)
}

func (c *EntityClient) mutate(ctx context.Context, m *EntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Entity mutation op: %q", m.Op())
	}
}

// EntityHistoryClient is a client for the EntityHistory schema.
type EntityHistoryClient struct {
	config
}

// NewEntityHistoryClient returns a client for the EntityHistory from the given config.
func NewEntityHistoryClient(c config) *EntityHistoryClient {
	return &EntityHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entityhistory.Hooks(f(g(h())))`.
func (c *EntityHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntityHistory = append(c.hooks.EntityHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entityhistory.Intercept(f(g(h())))`.
func (c *EntityHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntityHistory = append(c.inters.EntityHistory, interceptors...)
}

// Create returns a builder for creating a EntityHistory entity.
func (c *EntityHistoryClient) Create() *EntityHistoryCreate {
	mutation := newEntityHistoryMutation(c.config, OpCreate)
	return &EntityHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntityHistory entities.
func (c *EntityHistoryClient) CreateBulk(builders ...*EntityHistoryCreate) *EntityHistoryCreateBulk {
	return &EntityHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityHistoryClient) MapCreateBulk(slice any, setFunc func(*EntityHistoryCreate, int)) *EntityHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityHistoryCreateBulk{err: fmt.Errorf("calling to EntityHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntityHistory.
func (c *EntityHistoryClient) Update() *EntityHistoryUpdate {
	mutation := newEntityHistoryMutation(c.config, OpUpdate)
	return &EntityHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityHistoryClient) UpdateOne(_m *EntityHistory) *EntityHistoryUpdateOne {
	mutation := newEntityHistoryMutation(c.config, OpUpdateOne, withEntityHistory(_m))
	return &EntityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityHistoryClient) UpdateOneID(id string) *EntityHistoryUpdateOne {
	mutation := newEntityHistoryMutation(c.config, OpUpdateOne, withEntityHistoryID(id))
	return &EntityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntityHistory.
func (c *EntityHistoryClient) Delete() *EntityHistoryDelete {
	mutation := newEntityHistoryMutation(c.config, OpDelete)
	return &EntityHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityHistoryClient) DeleteOne(_m *EntityHistory) *EntityHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityHistoryClient) DeleteOneID(id string) *EntityHistoryDeleteOne {
	builder := c.Delete().Where(entityhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityHistoryDeleteOne{builder}
}

// Query returns a query builder for EntityHistory.
func (c *EntityHistoryClient) Query() *EntityHistoryQuery {
	return &EntityHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntityHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntityHistory entity by its id.
func (c *EntityHistoryClient) Get(ctx context.Context, id string) (*EntityHistory, error) {
	return c.Query().Where(entityhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityHistoryClient) GetX(ctx context.Context, id string) *EntityHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntityHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntityHistory
	return append(hooks[:len(hooks):len(hooks)], entityhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntityHistory
	return append(inters[:len(inters):len(inters)], entityhistory.Interceptors[:]...)
}

func (c *EntityHistoryClient) mutate(ctx context.Context, m *EntityHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntityHistory mutation op: %q", m.Op())
	}
}

// EntityTypeClient is a client for the EntityType schema.
type EntityTypeClient struct {
	config
}

// NewEntityTypeClient returns a client for the EntityType from the given config.
func NewEntityTypeClient(c config) *EntityTypeClient {
	return &EntityTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitytype.Hooks(f(g(h())))`.
func (c *EntityTypeClient) Use(hooks ...Hook) {
	c.hooks.EntityType = append(c.hooks.EntityType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitytype.Intercept(f(g(h())))`.
func (c *EntityTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntityType = append(c.inters.EntityType, interceptors...)
}

// Create returns a builder for creating a EntityType entity.
func (c *EntityTypeClient) Create() *EntityTypeCreate {
	mutation := newEntityTypeMutation(c.config, OpCreate)
	return &EntityTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntityType entities.
func (c *EntityTypeClient) CreateBulk(builders ...*EntityTypeCreate) *EntityTypeCreateBulk {
	return &EntityTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityTypeClient) MapCreateBulk(slice any, setFunc func(*EntityTypeCreate, int)) *EntityTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityTypeCreateBulk{err: fmt.Errorf("calling to EntityTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntityType.
func (c *EntityTypeClient) Update() *EntityTypeUpdate {
	mutation := newEntityTypeMutation(c.config, OpUpdate)
	return &EntityTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityTypeClient) UpdateOne(_m *EntityType) *EntityTypeUpdateOne {
	mutation := newEntityTypeMutation(c.config, OpUpdateOne, withEntityType(_m))
	return &EntityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityTypeClient) UpdateOneID(id string) *EntityTypeUpdateOne {
	mutation := newEntityTypeMutation(c.config, OpUpdateOne, withEntityTypeID(id))
	return &EntityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntityType.
func (c *EntityTypeClient) Delete() *EntityTypeDelete {
	mutation := newEntityTypeMutation(c.config, OpDelete)
	return &EntityTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityTypeClient) DeleteOne(_m *EntityType) *EntityTypeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityTypeClient) DeleteOneID(id string) *EntityTypeDeleteOne {
	builder := c.Delete().Where(entitytype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityTypeDeleteOne{builder}
}

// Query returns a query builder for EntityType.
func (c *EntityTypeClient) Query() *EntityTypeQuery {
	return &EntityTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntityType},
		inters: c.Interceptors(),
	}
}

// Get returns a EntityType entity by its id.
func (c *EntityTypeClient) Get(ctx context.Context, id string) (*EntityType, error) {
	return c.Query().Where(entitytype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityTypeClient) GetX(ctx context.Context, id string) *EntityType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a EntityType.
func (c *EntityTypeClient) QueryOwner(_m *EntityType) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitytype.Table, entitytype.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitytype.OwnerTable, entitytype.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.EntityType
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a EntityType.
func (c *EntityTypeClient) QueryEntities(_m *EntityType) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitytype.Table, entitytype.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entitytype.EntitiesTable, entitytype.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityTypeClient) Hooks() []Hook {
	hooks := c.hooks.EntityType
	return append(hooks[:len(hooks):len(hooks)], entitytype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityTypeClient) Interceptors() []Interceptor {
	inters := c.inters.EntityType
	return append(inters[:len(inters):len(inters)], entitytype.Interceptors[:]...)
}

func (c *EntityTypeClient) mutate(ctx context.Context, m *EntityTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntityType mutation op: %q", m.Op())
	}
}

// EntityTypeHistoryClient is a client for the EntityTypeHistory schema.
type EntityTypeHistoryClient struct {
	config
}

// NewEntityTypeHistoryClient returns a client for the EntityTypeHistory from the given config.
func NewEntityTypeHistoryClient(c config) *EntityTypeHistoryClient {
	return &EntityTypeHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitytypehistory.Hooks(f(g(h())))`.
func (c *EntityTypeHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntityTypeHistory = append(c.hooks.EntityTypeHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitytypehistory.Intercept(f(g(h())))`.
func (c *EntityTypeHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntityTypeHistory = append(c.inters.EntityTypeHistory, interceptors...)
}

// Create returns a builder for creating a EntityTypeHistory entity.
func (c *EntityTypeHistoryClient) Create() *EntityTypeHistoryCreate {
	mutation := newEntityTypeHistoryMutation(c.config, OpCreate)
	return &EntityTypeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntityTypeHistory entities.
func (c *EntityTypeHistoryClient) CreateBulk(builders ...*EntityTypeHistoryCreate) *EntityTypeHistoryCreateBulk {
	return &EntityTypeHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityTypeHistoryClient) MapCreateBulk(slice any, setFunc func(*EntityTypeHistoryCreate, int)) *EntityTypeHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityTypeHistoryCreateBulk{err: fmt.Errorf("calling to EntityTypeHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityTypeHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityTypeHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntityTypeHistory.
func (c *EntityTypeHistoryClient) Update() *EntityTypeHistoryUpdate {
	mutation := newEntityTypeHistoryMutation(c.config, OpUpdate)
	return &EntityTypeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityTypeHistoryClient) UpdateOne(_m *EntityTypeHistory) *EntityTypeHistoryUpdateOne {
	mutation := newEntityTypeHistoryMutation(c.config, OpUpdateOne, withEntityTypeHistory(_m))
	return &EntityTypeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityTypeHistoryClient) UpdateOneID(id string) *EntityTypeHistoryUpdateOne {
	mutation := newEntityTypeHistoryMutation(c.config, OpUpdateOne, withEntityTypeHistoryID(id))
	return &EntityTypeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntityTypeHistory.
func (c *EntityTypeHistoryClient) Delete() *EntityTypeHistoryDelete {
	mutation := newEntityTypeHistoryMutation(c.config, OpDelete)
	return &EntityTypeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityTypeHistoryClient) DeleteOne(_m *EntityTypeHistory) *EntityTypeHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityTypeHistoryClient) DeleteOneID(id string) *EntityTypeHistoryDeleteOne {
	builder := c.Delete().Where(entitytypehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityTypeHistoryDeleteOne{builder}
}

// Query returns a query builder for EntityTypeHistory.
func (c *EntityTypeHistoryClient) Query() *EntityTypeHistoryQuery {
	return &EntityTypeHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntityTypeHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntityTypeHistory entity by its id.
func (c *EntityTypeHistoryClient) Get(ctx context.Context, id string) (*EntityTypeHistory, error) {
	return c.Query().Where(entitytypehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityTypeHistoryClient) GetX(ctx context.Context, id string) *EntityTypeHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntityTypeHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntityTypeHistory
	return append(hooks[:len(hooks):len(hooks)], entitytypehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityTypeHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntityTypeHistory
	return append(inters[:len(inters):len(inters)], entitytypehistory.Interceptors[:]...)
}

func (c *EntityTypeHistoryClient) mutate(ctx context.Context, m *EntityTypeHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityTypeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityTypeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityTypeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityTypeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntityTypeHistory mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(_m *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(_m))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id string) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(_m *Event) *EventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id string) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id string) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id string) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Event.
func (c *EventClient) QueryUsers(_m *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.UsersTable, event.UsersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Event.
func (c *EventClient) QueryGroups(_m *Event) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.GroupsTable, event.GroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Event.
func (c *EventClient) QueryIntegrations(_m *Event) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.IntegrationsTable, event.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a Event.
func (c *EventClient) QueryOrganizations(_m *Event) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.OrganizationsTable, event.OrganizationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvites queries the invites edge of a Event.
func (c *EventClient) QueryInvites(_m *Event) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.InvitesTable, event.InvitesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Invite
		step.Edge.Schema = schemaConfig.InviteEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonalAccessTokens queries the personal_access_tokens edge of a Event.
func (c *EventClient) QueryPersonalAccessTokens(_m *Event) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.PersonalAccessTokensTable, event.PersonalAccessTokensPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PersonalAccessToken
		step.Edge.Schema = schemaConfig.PersonalAccessTokenEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySecrets queries the secrets edge of a Event.
func (c *EventClient) QuerySecrets(_m *Event) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.SecretsTable, event.SecretsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.HushEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgMemberships queries the org_memberships edge of a Event.
func (c *EventClient) QueryOrgMemberships(_m *Event) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.OrgMembershipsTable, event.OrgMembershipsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.OrgMembershipEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMemberships queries the group_memberships edge of a Event.
func (c *EventClient) QueryGroupMemberships(_m *Event) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.GroupMembershipsTable, event.GroupMembershipsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.GroupMembership
		step.Edge.Schema = schemaConfig.GroupMembershipEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribers queries the subscribers edge of a Event.
func (c *EventClient) QuerySubscribers(_m *Event) *SubscriberQuery {
	query := (&SubscriberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(subscriber.Table, subscriber.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.SubscribersTable, event.SubscribersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subscriber
		step.Edge.Schema = schemaConfig.SubscriberEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Event.
func (c *EventClient) QueryFiles(_m *Event) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.FilesTable, event.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.FileEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgSubscriptions queries the org_subscriptions edge of a Event.
func (c *EventClient) QueryOrgSubscriptions(_m *Event) *OrgSubscriptionQuery {
	query := (&OrgSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(orgsubscription.Table, orgsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.OrgSubscriptionsTable, event.OrgSubscriptionsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgSubscription
		step.Edge.Schema = schemaConfig.OrgSubscriptionEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	hooks := c.hooks.Event
	return append(hooks[:len(hooks):len(hooks)], event.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Event mutation op: %q", m.Op())
	}
}

// EvidenceClient is a client for the Evidence schema.
type EvidenceClient struct {
	config
}

// NewEvidenceClient returns a client for the Evidence from the given config.
func NewEvidenceClient(c config) *EvidenceClient {
	return &EvidenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `evidence.Hooks(f(g(h())))`.
func (c *EvidenceClient) Use(hooks ...Hook) {
	c.hooks.Evidence = append(c.hooks.Evidence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `evidence.Intercept(f(g(h())))`.
func (c *EvidenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Evidence = append(c.inters.Evidence, interceptors...)
}

// Create returns a builder for creating a Evidence entity.
func (c *EvidenceClient) Create() *EvidenceCreate {
	mutation := newEvidenceMutation(c.config, OpCreate)
	return &EvidenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Evidence entities.
func (c *EvidenceClient) CreateBulk(builders ...*EvidenceCreate) *EvidenceCreateBulk {
	return &EvidenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EvidenceClient) MapCreateBulk(slice any, setFunc func(*EvidenceCreate, int)) *EvidenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EvidenceCreateBulk{err: fmt.Errorf("calling to EvidenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EvidenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EvidenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Evidence.
func (c *EvidenceClient) Update() *EvidenceUpdate {
	mutation := newEvidenceMutation(c.config, OpUpdate)
	return &EvidenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EvidenceClient) UpdateOne(_m *Evidence) *EvidenceUpdateOne {
	mutation := newEvidenceMutation(c.config, OpUpdateOne, withEvidence(_m))
	return &EvidenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EvidenceClient) UpdateOneID(id string) *EvidenceUpdateOne {
	mutation := newEvidenceMutation(c.config, OpUpdateOne, withEvidenceID(id))
	return &EvidenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Evidence.
func (c *EvidenceClient) Delete() *EvidenceDelete {
	mutation := newEvidenceMutation(c.config, OpDelete)
	return &EvidenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EvidenceClient) DeleteOne(_m *Evidence) *EvidenceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EvidenceClient) DeleteOneID(id string) *EvidenceDeleteOne {
	builder := c.Delete().Where(evidence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EvidenceDeleteOne{builder}
}

// Query returns a query builder for Evidence.
func (c *EvidenceClient) Query() *EvidenceQuery {
	return &EvidenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvidence},
		inters: c.Interceptors(),
	}
}

// Get returns a Evidence entity by its id.
func (c *EvidenceClient) Get(ctx context.Context, id string) (*Evidence, error) {
	return c.Query().Where(evidence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EvidenceClient) GetX(ctx context.Context, id string) *Evidence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Evidence.
func (c *EvidenceClient) QueryOwner(_m *Evidence) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, evidence.OwnerTable, evidence.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Evidence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Evidence.
func (c *EvidenceClient) QueryControls(_m *Evidence) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, evidence.ControlsTable, evidence.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.EvidenceControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Evidence.
func (c *EvidenceClient) QuerySubcontrols(_m *Evidence) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, evidence.SubcontrolsTable, evidence.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.EvidenceSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a Evidence.
func (c *EvidenceClient) QueryControlObjectives(_m *Evidence) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, evidence.ControlObjectivesTable, evidence.ControlObjectivesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.EvidenceControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementations queries the control_implementations edge of a Evidence.
func (c *EvidenceClient) QueryControlImplementations(_m *Evidence) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, evidence.ControlImplementationsTable, evidence.ControlImplementationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Evidence.
func (c *EvidenceClient) QueryFiles(_m *Evidence) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, evidence.FilesTable, evidence.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.EvidenceFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Evidence.
func (c *EvidenceClient) QueryPrograms(_m *Evidence) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, evidence.ProgramsTable, evidence.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramEvidence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Evidence.
func (c *EvidenceClient) QueryTasks(_m *Evidence) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evidence.Table, evidence.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, evidence.TasksTable, evidence.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.TaskEvidence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EvidenceClient) Hooks() []Hook {
	hooks := c.hooks.Evidence
	return append(hooks[:len(hooks):len(hooks)], evidence.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EvidenceClient) Interceptors() []Interceptor {
	inters := c.inters.Evidence
	return append(inters[:len(inters):len(inters)], evidence.Interceptors[:]...)
}

func (c *EvidenceClient) mutate(ctx context.Context, m *EvidenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EvidenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EvidenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EvidenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EvidenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Evidence mutation op: %q", m.Op())
	}
}

// EvidenceHistoryClient is a client for the EvidenceHistory schema.
type EvidenceHistoryClient struct {
	config
}

// NewEvidenceHistoryClient returns a client for the EvidenceHistory from the given config.
func NewEvidenceHistoryClient(c config) *EvidenceHistoryClient {
	return &EvidenceHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `evidencehistory.Hooks(f(g(h())))`.
func (c *EvidenceHistoryClient) Use(hooks ...Hook) {
	c.hooks.EvidenceHistory = append(c.hooks.EvidenceHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `evidencehistory.Intercept(f(g(h())))`.
func (c *EvidenceHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EvidenceHistory = append(c.inters.EvidenceHistory, interceptors...)
}

// Create returns a builder for creating a EvidenceHistory entity.
func (c *EvidenceHistoryClient) Create() *EvidenceHistoryCreate {
	mutation := newEvidenceHistoryMutation(c.config, OpCreate)
	return &EvidenceHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EvidenceHistory entities.
func (c *EvidenceHistoryClient) CreateBulk(builders ...*EvidenceHistoryCreate) *EvidenceHistoryCreateBulk {
	return &EvidenceHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EvidenceHistoryClient) MapCreateBulk(slice any, setFunc func(*EvidenceHistoryCreate, int)) *EvidenceHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EvidenceHistoryCreateBulk{err: fmt.Errorf("calling to EvidenceHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EvidenceHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EvidenceHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EvidenceHistory.
func (c *EvidenceHistoryClient) Update() *EvidenceHistoryUpdate {
	mutation := newEvidenceHistoryMutation(c.config, OpUpdate)
	return &EvidenceHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EvidenceHistoryClient) UpdateOne(_m *EvidenceHistory) *EvidenceHistoryUpdateOne {
	mutation := newEvidenceHistoryMutation(c.config, OpUpdateOne, withEvidenceHistory(_m))
	return &EvidenceHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EvidenceHistoryClient) UpdateOneID(id string) *EvidenceHistoryUpdateOne {
	mutation := newEvidenceHistoryMutation(c.config, OpUpdateOne, withEvidenceHistoryID(id))
	return &EvidenceHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EvidenceHistory.
func (c *EvidenceHistoryClient) Delete() *EvidenceHistoryDelete {
	mutation := newEvidenceHistoryMutation(c.config, OpDelete)
	return &EvidenceHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EvidenceHistoryClient) DeleteOne(_m *EvidenceHistory) *EvidenceHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EvidenceHistoryClient) DeleteOneID(id string) *EvidenceHistoryDeleteOne {
	builder := c.Delete().Where(evidencehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EvidenceHistoryDeleteOne{builder}
}

// Query returns a query builder for EvidenceHistory.
func (c *EvidenceHistoryClient) Query() *EvidenceHistoryQuery {
	return &EvidenceHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvidenceHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EvidenceHistory entity by its id.
func (c *EvidenceHistoryClient) Get(ctx context.Context, id string) (*EvidenceHistory, error) {
	return c.Query().Where(evidencehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EvidenceHistoryClient) GetX(ctx context.Context, id string) *EvidenceHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EvidenceHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EvidenceHistory
	return append(hooks[:len(hooks):len(hooks)], evidencehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EvidenceHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EvidenceHistory
	return append(inters[:len(inters):len(inters)], evidencehistory.Interceptors[:]...)
}

func (c *EvidenceHistoryClient) mutate(ctx context.Context, m *EvidenceHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EvidenceHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EvidenceHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EvidenceHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EvidenceHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EvidenceHistory mutation op: %q", m.Op())
	}
}

// ExportClient is a client for the Export schema.
type ExportClient struct {
	config
}

// NewExportClient returns a client for the Export from the given config.
func NewExportClient(c config) *ExportClient {
	return &ExportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `export.Hooks(f(g(h())))`.
func (c *ExportClient) Use(hooks ...Hook) {
	c.hooks.Export = append(c.hooks.Export, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `export.Intercept(f(g(h())))`.
func (c *ExportClient) Intercept(interceptors ...Interceptor) {
	c.inters.Export = append(c.inters.Export, interceptors...)
}

// Create returns a builder for creating a Export entity.
func (c *ExportClient) Create() *ExportCreate {
	mutation := newExportMutation(c.config, OpCreate)
	return &ExportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Export entities.
func (c *ExportClient) CreateBulk(builders ...*ExportCreate) *ExportCreateBulk {
	return &ExportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExportClient) MapCreateBulk(slice any, setFunc func(*ExportCreate, int)) *ExportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExportCreateBulk{err: fmt.Errorf("calling to ExportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Export.
func (c *ExportClient) Update() *ExportUpdate {
	mutation := newExportMutation(c.config, OpUpdate)
	return &ExportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExportClient) UpdateOne(_m *Export) *ExportUpdateOne {
	mutation := newExportMutation(c.config, OpUpdateOne, withExport(_m))
	return &ExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExportClient) UpdateOneID(id string) *ExportUpdateOne {
	mutation := newExportMutation(c.config, OpUpdateOne, withExportID(id))
	return &ExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Export.
func (c *ExportClient) Delete() *ExportDelete {
	mutation := newExportMutation(c.config, OpDelete)
	return &ExportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExportClient) DeleteOne(_m *Export) *ExportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExportClient) DeleteOneID(id string) *ExportDeleteOne {
	builder := c.Delete().Where(export.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExportDeleteOne{builder}
}

// Query returns a query builder for Export.
func (c *ExportClient) Query() *ExportQuery {
	return &ExportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExport},
		inters: c.Interceptors(),
	}
}

// Get returns a Export entity by its id.
func (c *ExportClient) Get(ctx context.Context, id string) (*Export, error) {
	return c.Query().Where(export.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExportClient) GetX(ctx context.Context, id string) *Export {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Export.
func (c *ExportClient) QueryOwner(_m *Export) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(export.Table, export.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, export.OwnerTable, export.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Export
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Export.
func (c *ExportClient) QueryEvents(_m *Export) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(export.Table, export.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, export.EventsTable, export.EventsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.Event
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Export.
func (c *ExportClient) QueryFiles(_m *Export) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(export.Table, export.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, export.FilesTable, export.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExportClient) Hooks() []Hook {
	hooks := c.hooks.Export
	return append(hooks[:len(hooks):len(hooks)], export.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ExportClient) Interceptors() []Interceptor {
	inters := c.inters.Export
	return append(inters[:len(inters):len(inters)], export.Interceptors[:]...)
}

func (c *ExportClient) mutate(ctx context.Context, m *ExportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Export mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(_m *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(_m))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id string) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(_m *File) *FileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id string) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id string) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id string) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a File.
func (c *FileClient) QueryUser(_m *File) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.UserTable, file.UserPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a File.
func (c *FileClient) QueryOrganization(_m *File) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.OrganizationTable, file.OrganizationPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a File.
func (c *FileClient) QueryGroups(_m *File) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.GroupsTable, file.GroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContact queries the contact edge of a File.
func (c *FileClient) QueryContact(_m *File) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.ContactTable, file.ContactPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Contact
		step.Edge.Schema = schemaConfig.ContactFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntity queries the entity edge of a File.
func (c *FileClient) QueryEntity(_m *File) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.EntityTable, file.EntityPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserSetting queries the user_setting edge of a File.
func (c *FileClient) QueryUserSetting(_m *File) *UserSettingQuery {
	query := (&UserSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(usersetting.Table, usersetting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.UserSettingTable, file.UserSettingPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.UserSetting
		step.Edge.Schema = schemaConfig.UserSettingFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationSetting queries the organization_setting edge of a File.
func (c *FileClient) QueryOrganizationSetting(_m *File) *OrganizationSettingQuery {
	query := (&OrganizationSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(organizationsetting.Table, organizationsetting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.OrganizationSettingTable, file.OrganizationSettingPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrganizationSetting
		step.Edge.Schema = schemaConfig.OrganizationSettingFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a File.
func (c *FileClient) QueryTemplate(_m *File) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.TemplateTable, file.TemplatePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.TemplateFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocument queries the document edge of a File.
func (c *FileClient) QueryDocument(_m *File) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.DocumentTable, file.DocumentPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.DocumentDataFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a File.
func (c *FileClient) QueryProgram(_m *File) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.ProgramTable, file.ProgramPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidence queries the evidence edge of a File.
func (c *FileClient) QueryEvidence(_m *File) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.EvidenceTable, file.EvidencePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.EvidenceFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a File.
func (c *FileClient) QueryEvents(_m *File) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, file.EventsTable, file.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.FileEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterSetting queries the trust_center_setting edge of a File.
func (c *FileClient) QueryTrustCenterSetting(_m *File) *TrustCenterSettingQuery {
	query := (&TrustCenterSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(trustcentersetting.Table, trustcentersetting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.TrustCenterSettingTable, file.TrustCenterSettingPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterSetting
		step.Edge.Schema = schemaConfig.TrustCenterSettingFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubprocessor queries the subprocessor edge of a File.
func (c *FileClient) QuerySubprocessor(_m *File) *SubprocessorQuery {
	query := (&SubprocessorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(subprocessor.Table, subprocessor.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.SubprocessorTable, file.SubprocessorPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subprocessor
		step.Edge.Schema = schemaConfig.SubprocessorFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a File.
func (c *FileClient) QueryIntegrations(_m *File) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, file.IntegrationsTable, file.IntegrationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySecrets queries the secrets edge of a File.
func (c *FileClient) QuerySecrets(_m *File) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, file.SecretsTable, file.SecretsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.FileSecrets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	hooks := c.hooks.File
	return append(hooks[:len(hooks):len(hooks)], file.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	inters := c.inters.File
	return append(inters[:len(inters):len(inters)], file.Interceptors[:]...)
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown File mutation op: %q", m.Op())
	}
}

// FileDownloadTokenClient is a client for the FileDownloadToken schema.
type FileDownloadTokenClient struct {
	config
}

// NewFileDownloadTokenClient returns a client for the FileDownloadToken from the given config.
func NewFileDownloadTokenClient(c config) *FileDownloadTokenClient {
	return &FileDownloadTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filedownloadtoken.Hooks(f(g(h())))`.
func (c *FileDownloadTokenClient) Use(hooks ...Hook) {
	c.hooks.FileDownloadToken = append(c.hooks.FileDownloadToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filedownloadtoken.Intercept(f(g(h())))`.
func (c *FileDownloadTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileDownloadToken = append(c.inters.FileDownloadToken, interceptors...)
}

// Create returns a builder for creating a FileDownloadToken entity.
func (c *FileDownloadTokenClient) Create() *FileDownloadTokenCreate {
	mutation := newFileDownloadTokenMutation(c.config, OpCreate)
	return &FileDownloadTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileDownloadToken entities.
func (c *FileDownloadTokenClient) CreateBulk(builders ...*FileDownloadTokenCreate) *FileDownloadTokenCreateBulk {
	return &FileDownloadTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileDownloadTokenClient) MapCreateBulk(slice any, setFunc func(*FileDownloadTokenCreate, int)) *FileDownloadTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileDownloadTokenCreateBulk{err: fmt.Errorf("calling to FileDownloadTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileDownloadTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileDownloadTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileDownloadToken.
func (c *FileDownloadTokenClient) Update() *FileDownloadTokenUpdate {
	mutation := newFileDownloadTokenMutation(c.config, OpUpdate)
	return &FileDownloadTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileDownloadTokenClient) UpdateOne(_m *FileDownloadToken) *FileDownloadTokenUpdateOne {
	mutation := newFileDownloadTokenMutation(c.config, OpUpdateOne, withFileDownloadToken(_m))
	return &FileDownloadTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileDownloadTokenClient) UpdateOneID(id string) *FileDownloadTokenUpdateOne {
	mutation := newFileDownloadTokenMutation(c.config, OpUpdateOne, withFileDownloadTokenID(id))
	return &FileDownloadTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileDownloadToken.
func (c *FileDownloadTokenClient) Delete() *FileDownloadTokenDelete {
	mutation := newFileDownloadTokenMutation(c.config, OpDelete)
	return &FileDownloadTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileDownloadTokenClient) DeleteOne(_m *FileDownloadToken) *FileDownloadTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileDownloadTokenClient) DeleteOneID(id string) *FileDownloadTokenDeleteOne {
	builder := c.Delete().Where(filedownloadtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDownloadTokenDeleteOne{builder}
}

// Query returns a query builder for FileDownloadToken.
func (c *FileDownloadTokenClient) Query() *FileDownloadTokenQuery {
	return &FileDownloadTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileDownloadToken},
		inters: c.Interceptors(),
	}
}

// Get returns a FileDownloadToken entity by its id.
func (c *FileDownloadTokenClient) Get(ctx context.Context, id string) (*FileDownloadToken, error) {
	return c.Query().Where(filedownloadtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileDownloadTokenClient) GetX(ctx context.Context, id string) *FileDownloadToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a FileDownloadToken.
func (c *FileDownloadTokenClient) QueryOwner(_m *FileDownloadToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filedownloadtoken.Table, filedownloadtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filedownloadtoken.OwnerTable, filedownloadtoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.FileDownloadToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileDownloadTokenClient) Hooks() []Hook {
	hooks := c.hooks.FileDownloadToken
	return append(hooks[:len(hooks):len(hooks)], filedownloadtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileDownloadTokenClient) Interceptors() []Interceptor {
	inters := c.inters.FileDownloadToken
	return append(inters[:len(inters):len(inters)], filedownloadtoken.Interceptors[:]...)
}

func (c *FileDownloadTokenClient) mutate(ctx context.Context, m *FileDownloadTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileDownloadTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileDownloadTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileDownloadTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDownloadTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FileDownloadToken mutation op: %q", m.Op())
	}
}

// FileHistoryClient is a client for the FileHistory schema.
type FileHistoryClient struct {
	config
}

// NewFileHistoryClient returns a client for the FileHistory from the given config.
func NewFileHistoryClient(c config) *FileHistoryClient {
	return &FileHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filehistory.Hooks(f(g(h())))`.
func (c *FileHistoryClient) Use(hooks ...Hook) {
	c.hooks.FileHistory = append(c.hooks.FileHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filehistory.Intercept(f(g(h())))`.
func (c *FileHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileHistory = append(c.inters.FileHistory, interceptors...)
}

// Create returns a builder for creating a FileHistory entity.
func (c *FileHistoryClient) Create() *FileHistoryCreate {
	mutation := newFileHistoryMutation(c.config, OpCreate)
	return &FileHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileHistory entities.
func (c *FileHistoryClient) CreateBulk(builders ...*FileHistoryCreate) *FileHistoryCreateBulk {
	return &FileHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileHistoryClient) MapCreateBulk(slice any, setFunc func(*FileHistoryCreate, int)) *FileHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileHistoryCreateBulk{err: fmt.Errorf("calling to FileHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileHistory.
func (c *FileHistoryClient) Update() *FileHistoryUpdate {
	mutation := newFileHistoryMutation(c.config, OpUpdate)
	return &FileHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileHistoryClient) UpdateOne(_m *FileHistory) *FileHistoryUpdateOne {
	mutation := newFileHistoryMutation(c.config, OpUpdateOne, withFileHistory(_m))
	return &FileHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileHistoryClient) UpdateOneID(id string) *FileHistoryUpdateOne {
	mutation := newFileHistoryMutation(c.config, OpUpdateOne, withFileHistoryID(id))
	return &FileHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileHistory.
func (c *FileHistoryClient) Delete() *FileHistoryDelete {
	mutation := newFileHistoryMutation(c.config, OpDelete)
	return &FileHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileHistoryClient) DeleteOne(_m *FileHistory) *FileHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileHistoryClient) DeleteOneID(id string) *FileHistoryDeleteOne {
	builder := c.Delete().Where(filehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileHistoryDeleteOne{builder}
}

// Query returns a query builder for FileHistory.
func (c *FileHistoryClient) Query() *FileHistoryQuery {
	return &FileHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a FileHistory entity by its id.
func (c *FileHistoryClient) Get(ctx context.Context, id string) (*FileHistory, error) {
	return c.Query().Where(filehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileHistoryClient) GetX(ctx context.Context, id string) *FileHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FileHistoryClient) Hooks() []Hook {
	hooks := c.hooks.FileHistory
	return append(hooks[:len(hooks):len(hooks)], filehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.FileHistory
	return append(inters[:len(inters):len(inters)], filehistory.Interceptors[:]...)
}

func (c *FileHistoryClient) mutate(ctx context.Context, m *FileHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FileHistory mutation op: %q", m.Op())
	}
}

// FindingClient is a client for the Finding schema.
type FindingClient struct {
	config
}

// NewFindingClient returns a client for the Finding from the given config.
func NewFindingClient(c config) *FindingClient {
	return &FindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `finding.Hooks(f(g(h())))`.
func (c *FindingClient) Use(hooks ...Hook) {
	c.hooks.Finding = append(c.hooks.Finding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `finding.Intercept(f(g(h())))`.
func (c *FindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Finding = append(c.inters.Finding, interceptors...)
}

// Create returns a builder for creating a Finding entity.
func (c *FindingClient) Create() *FindingCreate {
	mutation := newFindingMutation(c.config, OpCreate)
	return &FindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Finding entities.
func (c *FindingClient) CreateBulk(builders ...*FindingCreate) *FindingCreateBulk {
	return &FindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FindingClient) MapCreateBulk(slice any, setFunc func(*FindingCreate, int)) *FindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FindingCreateBulk{err: fmt.Errorf("calling to FindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Finding.
func (c *FindingClient) Update() *FindingUpdate {
	mutation := newFindingMutation(c.config, OpUpdate)
	return &FindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FindingClient) UpdateOne(_m *Finding) *FindingUpdateOne {
	mutation := newFindingMutation(c.config, OpUpdateOne, withFinding(_m))
	return &FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FindingClient) UpdateOneID(id string) *FindingUpdateOne {
	mutation := newFindingMutation(c.config, OpUpdateOne, withFindingID(id))
	return &FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Finding.
func (c *FindingClient) Delete() *FindingDelete {
	mutation := newFindingMutation(c.config, OpDelete)
	return &FindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FindingClient) DeleteOne(_m *Finding) *FindingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FindingClient) DeleteOneID(id string) *FindingDeleteOne {
	builder := c.Delete().Where(finding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FindingDeleteOne{builder}
}

// Query returns a query builder for Finding.
func (c *FindingClient) Query() *FindingQuery {
	return &FindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinding},
		inters: c.Interceptors(),
	}
}

// Get returns a Finding entity by its id.
func (c *FindingClient) Get(ctx context.Context, id string) (*Finding, error) {
	return c.Query().Where(finding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FindingClient) GetX(ctx context.Context, id string) *Finding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Finding.
func (c *FindingClient) QueryOwner(_m *Finding) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finding.OwnerTable, finding.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Finding
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Finding.
func (c *FindingClient) QueryBlockedGroups(_m *Finding) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.BlockedGroupsTable, finding.BlockedGroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Finding.
func (c *FindingClient) QueryEditors(_m *Finding) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.EditorsTable, finding.EditorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Finding.
func (c *FindingClient) QueryViewers(_m *Finding) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.ViewersTable, finding.ViewersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Finding.
func (c *FindingClient) QueryIntegrations(_m *Finding) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, finding.IntegrationsTable, finding.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationFindings
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Finding.
func (c *FindingClient) QueryVulnerabilities(_m *Finding) *VulnerabilityQuery {
	query := (&VulnerabilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.VulnerabilitiesTable, finding.VulnerabilitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Vulnerability
		step.Edge.Schema = schemaConfig.Vulnerability
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Finding.
func (c *FindingClient) QueryActionPlans(_m *Finding) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, finding.ActionPlansTable, finding.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.FindingActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Finding.
func (c *FindingClient) QueryControls(_m *Finding) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, finding.ControlsTable, finding.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Finding.
func (c *FindingClient) QuerySubcontrols(_m *Finding) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.SubcontrolsTable, finding.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Finding.
func (c *FindingClient) QueryRisks(_m *Finding) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.RisksTable, finding.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Finding.
func (c *FindingClient) QueryPrograms(_m *Finding) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.ProgramsTable, finding.ProgramsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Finding.
func (c *FindingClient) QueryAssets(_m *Finding) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.AssetsTable, finding.AssetsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Finding.
func (c *FindingClient) QueryEntities(_m *Finding) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.EntitiesTable, finding.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Finding.
func (c *FindingClient) QueryScans(_m *Finding) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.ScansTable, finding.ScansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Finding.
func (c *FindingClient) QueryTasks(_m *Finding) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.TasksTable, finding.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediations queries the remediations edge of a Finding.
func (c *FindingClient) QueryRemediations(_m *Finding) *RemediationQuery {
	query := (&RemediationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(remediation.Table, remediation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.RemediationsTable, finding.RemediationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Remediation
		step.Edge.Schema = schemaConfig.Remediation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Finding.
func (c *FindingClient) QueryReviews(_m *Finding) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.ReviewsTable, finding.ReviewsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Review
		step.Edge.Schema = schemaConfig.Review
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Finding.
func (c *FindingClient) QueryComments(_m *Finding) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.CommentsTable, finding.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Finding.
func (c *FindingClient) QueryFiles(_m *Finding) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.FilesTable, finding.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlMappings queries the control_mappings edge of a Finding.
func (c *FindingClient) QueryControlMappings(_m *Finding) *FindingControlQuery {
	query := (&FindingControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(findingcontrol.Table, findingcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, finding.ControlMappingsTable, finding.ControlMappingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.FindingControl
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FindingClient) Hooks() []Hook {
	hooks := c.hooks.Finding
	return append(hooks[:len(hooks):len(hooks)], finding.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FindingClient) Interceptors() []Interceptor {
	inters := c.inters.Finding
	return append(inters[:len(inters):len(inters)], finding.Interceptors[:]...)
}

func (c *FindingClient) mutate(ctx context.Context, m *FindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Finding mutation op: %q", m.Op())
	}
}

// FindingControlClient is a client for the FindingControl schema.
type FindingControlClient struct {
	config
}

// NewFindingControlClient returns a client for the FindingControl from the given config.
func NewFindingControlClient(c config) *FindingControlClient {
	return &FindingControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `findingcontrol.Hooks(f(g(h())))`.
func (c *FindingControlClient) Use(hooks ...Hook) {
	c.hooks.FindingControl = append(c.hooks.FindingControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `findingcontrol.Intercept(f(g(h())))`.
func (c *FindingControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.FindingControl = append(c.inters.FindingControl, interceptors...)
}

// Create returns a builder for creating a FindingControl entity.
func (c *FindingControlClient) Create() *FindingControlCreate {
	mutation := newFindingControlMutation(c.config, OpCreate)
	return &FindingControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FindingControl entities.
func (c *FindingControlClient) CreateBulk(builders ...*FindingControlCreate) *FindingControlCreateBulk {
	return &FindingControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FindingControlClient) MapCreateBulk(slice any, setFunc func(*FindingControlCreate, int)) *FindingControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FindingControlCreateBulk{err: fmt.Errorf("calling to FindingControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FindingControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FindingControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FindingControl.
func (c *FindingControlClient) Update() *FindingControlUpdate {
	mutation := newFindingControlMutation(c.config, OpUpdate)
	return &FindingControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FindingControlClient) UpdateOne(_m *FindingControl) *FindingControlUpdateOne {
	mutation := newFindingControlMutation(c.config, OpUpdateOne, withFindingControl(_m))
	return &FindingControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FindingControlClient) UpdateOneID(id string) *FindingControlUpdateOne {
	mutation := newFindingControlMutation(c.config, OpUpdateOne, withFindingControlID(id))
	return &FindingControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FindingControl.
func (c *FindingControlClient) Delete() *FindingControlDelete {
	mutation := newFindingControlMutation(c.config, OpDelete)
	return &FindingControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FindingControlClient) DeleteOne(_m *FindingControl) *FindingControlDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FindingControlClient) DeleteOneID(id string) *FindingControlDeleteOne {
	builder := c.Delete().Where(findingcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FindingControlDeleteOne{builder}
}

// Query returns a query builder for FindingControl.
func (c *FindingControlClient) Query() *FindingControlQuery {
	return &FindingControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFindingControl},
		inters: c.Interceptors(),
	}
}

// Get returns a FindingControl entity by its id.
func (c *FindingControlClient) Get(ctx context.Context, id string) (*FindingControl, error) {
	return c.Query().Where(findingcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FindingControlClient) GetX(ctx context.Context, id string) *FindingControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFinding queries the finding edge of a FindingControl.
func (c *FindingControlClient) QueryFinding(_m *FindingControl) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(findingcontrol.Table, findingcontrol.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, findingcontrol.FindingTable, findingcontrol.FindingColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a FindingControl.
func (c *FindingControlClient) QueryControl(_m *FindingControl) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(findingcontrol.Table, findingcontrol.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, findingcontrol.ControlTable, findingcontrol.ControlColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandard queries the standard edge of a FindingControl.
func (c *FindingControlClient) QueryStandard(_m *FindingControl) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(findingcontrol.Table, findingcontrol.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, findingcontrol.StandardTable, findingcontrol.StandardColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.FindingControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FindingControlClient) Hooks() []Hook {
	hooks := c.hooks.FindingControl
	return append(hooks[:len(hooks):len(hooks)], findingcontrol.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FindingControlClient) Interceptors() []Interceptor {
	inters := c.inters.FindingControl
	return append(inters[:len(inters):len(inters)], findingcontrol.Interceptors[:]...)
}

func (c *FindingControlClient) mutate(ctx context.Context, m *FindingControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FindingControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FindingControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FindingControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FindingControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FindingControl mutation op: %q", m.Op())
	}
}

// FindingControlHistoryClient is a client for the FindingControlHistory schema.
type FindingControlHistoryClient struct {
	config
}

// NewFindingControlHistoryClient returns a client for the FindingControlHistory from the given config.
func NewFindingControlHistoryClient(c config) *FindingControlHistoryClient {
	return &FindingControlHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `findingcontrolhistory.Hooks(f(g(h())))`.
func (c *FindingControlHistoryClient) Use(hooks ...Hook) {
	c.hooks.FindingControlHistory = append(c.hooks.FindingControlHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `findingcontrolhistory.Intercept(f(g(h())))`.
func (c *FindingControlHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.FindingControlHistory = append(c.inters.FindingControlHistory, interceptors...)
}

// Create returns a builder for creating a FindingControlHistory entity.
func (c *FindingControlHistoryClient) Create() *FindingControlHistoryCreate {
	mutation := newFindingControlHistoryMutation(c.config, OpCreate)
	return &FindingControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FindingControlHistory entities.
func (c *FindingControlHistoryClient) CreateBulk(builders ...*FindingControlHistoryCreate) *FindingControlHistoryCreateBulk {
	return &FindingControlHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FindingControlHistoryClient) MapCreateBulk(slice any, setFunc func(*FindingControlHistoryCreate, int)) *FindingControlHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FindingControlHistoryCreateBulk{err: fmt.Errorf("calling to FindingControlHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FindingControlHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FindingControlHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FindingControlHistory.
func (c *FindingControlHistoryClient) Update() *FindingControlHistoryUpdate {
	mutation := newFindingControlHistoryMutation(c.config, OpUpdate)
	return &FindingControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FindingControlHistoryClient) UpdateOne(_m *FindingControlHistory) *FindingControlHistoryUpdateOne {
	mutation := newFindingControlHistoryMutation(c.config, OpUpdateOne, withFindingControlHistory(_m))
	return &FindingControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FindingControlHistoryClient) UpdateOneID(id string) *FindingControlHistoryUpdateOne {
	mutation := newFindingControlHistoryMutation(c.config, OpUpdateOne, withFindingControlHistoryID(id))
	return &FindingControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FindingControlHistory.
func (c *FindingControlHistoryClient) Delete() *FindingControlHistoryDelete {
	mutation := newFindingControlHistoryMutation(c.config, OpDelete)
	return &FindingControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FindingControlHistoryClient) DeleteOne(_m *FindingControlHistory) *FindingControlHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FindingControlHistoryClient) DeleteOneID(id string) *FindingControlHistoryDeleteOne {
	builder := c.Delete().Where(findingcontrolhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FindingControlHistoryDeleteOne{builder}
}

// Query returns a query builder for FindingControlHistory.
func (c *FindingControlHistoryClient) Query() *FindingControlHistoryQuery {
	return &FindingControlHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFindingControlHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a FindingControlHistory entity by its id.
func (c *FindingControlHistoryClient) Get(ctx context.Context, id string) (*FindingControlHistory, error) {
	return c.Query().Where(findingcontrolhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FindingControlHistoryClient) GetX(ctx context.Context, id string) *FindingControlHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FindingControlHistoryClient) Hooks() []Hook {
	hooks := c.hooks.FindingControlHistory
	return append(hooks[:len(hooks):len(hooks)], findingcontrolhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FindingControlHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.FindingControlHistory
	return append(inters[:len(inters):len(inters)], findingcontrolhistory.Interceptors[:]...)
}

func (c *FindingControlHistoryClient) mutate(ctx context.Context, m *FindingControlHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FindingControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FindingControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FindingControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FindingControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FindingControlHistory mutation op: %q", m.Op())
	}
}

// FindingHistoryClient is a client for the FindingHistory schema.
type FindingHistoryClient struct {
	config
}

// NewFindingHistoryClient returns a client for the FindingHistory from the given config.
func NewFindingHistoryClient(c config) *FindingHistoryClient {
	return &FindingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `findinghistory.Hooks(f(g(h())))`.
func (c *FindingHistoryClient) Use(hooks ...Hook) {
	c.hooks.FindingHistory = append(c.hooks.FindingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `findinghistory.Intercept(f(g(h())))`.
func (c *FindingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.FindingHistory = append(c.inters.FindingHistory, interceptors...)
}

// Create returns a builder for creating a FindingHistory entity.
func (c *FindingHistoryClient) Create() *FindingHistoryCreate {
	mutation := newFindingHistoryMutation(c.config, OpCreate)
	return &FindingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FindingHistory entities.
func (c *FindingHistoryClient) CreateBulk(builders ...*FindingHistoryCreate) *FindingHistoryCreateBulk {
	return &FindingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FindingHistoryClient) MapCreateBulk(slice any, setFunc func(*FindingHistoryCreate, int)) *FindingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FindingHistoryCreateBulk{err: fmt.Errorf("calling to FindingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FindingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FindingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FindingHistory.
func (c *FindingHistoryClient) Update() *FindingHistoryUpdate {
	mutation := newFindingHistoryMutation(c.config, OpUpdate)
	return &FindingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FindingHistoryClient) UpdateOne(_m *FindingHistory) *FindingHistoryUpdateOne {
	mutation := newFindingHistoryMutation(c.config, OpUpdateOne, withFindingHistory(_m))
	return &FindingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FindingHistoryClient) UpdateOneID(id string) *FindingHistoryUpdateOne {
	mutation := newFindingHistoryMutation(c.config, OpUpdateOne, withFindingHistoryID(id))
	return &FindingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FindingHistory.
func (c *FindingHistoryClient) Delete() *FindingHistoryDelete {
	mutation := newFindingHistoryMutation(c.config, OpDelete)
	return &FindingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FindingHistoryClient) DeleteOne(_m *FindingHistory) *FindingHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FindingHistoryClient) DeleteOneID(id string) *FindingHistoryDeleteOne {
	builder := c.Delete().Where(findinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FindingHistoryDeleteOne{builder}
}

// Query returns a query builder for FindingHistory.
func (c *FindingHistoryClient) Query() *FindingHistoryQuery {
	return &FindingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFindingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a FindingHistory entity by its id.
func (c *FindingHistoryClient) Get(ctx context.Context, id string) (*FindingHistory, error) {
	return c.Query().Where(findinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FindingHistoryClient) GetX(ctx context.Context, id string) *FindingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FindingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.FindingHistory
	return append(hooks[:len(hooks):len(hooks)], findinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FindingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.FindingHistory
	return append(inters[:len(inters):len(inters)], findinghistory.Interceptors[:]...)
}

func (c *FindingHistoryClient) mutate(ctx context.Context, m *FindingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FindingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FindingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FindingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FindingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FindingHistory mutation op: %q", m.Op())
	}
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `group.Intercept(f(g(h())))`.
func (c *GroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.Group = append(c.inters.Group, interceptors...)
}

// Create returns a builder for creating a Group entity.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupClient) MapCreateBulk(slice any, setFunc func(*GroupCreate, int)) *GroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupCreateBulk{err: fmt.Errorf("calling to GroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(_m *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(_m))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id string) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupClient) DeleteOne(_m *Group) *GroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupClient) DeleteOneID(id string) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id string) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id string) *Group {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Group.
func (c *GroupClient) QueryOwner(_m *Group) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, group.OwnerTable, group.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramEditors queries the program_editors edge of a Group.
func (c *GroupClient) QueryProgramEditors(_m *Group) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ProgramEditorsTable, group.ProgramEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramBlockedGroups queries the program_blocked_groups edge of a Group.
func (c *GroupClient) QueryProgramBlockedGroups(_m *Group) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ProgramBlockedGroupsTable, group.ProgramBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramViewers queries the program_viewers edge of a Group.
func (c *GroupClient) QueryProgramViewers(_m *Group) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ProgramViewersTable, group.ProgramViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskEditors queries the risk_editors edge of a Group.
func (c *GroupClient) QueryRiskEditors(_m *Group) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.RiskEditorsTable, group.RiskEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.RiskEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskBlockedGroups queries the risk_blocked_groups edge of a Group.
func (c *GroupClient) QueryRiskBlockedGroups(_m *Group) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.RiskBlockedGroupsTable, group.RiskBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.RiskBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskViewers queries the risk_viewers edge of a Group.
func (c *GroupClient) QueryRiskViewers(_m *Group) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.RiskViewersTable, group.RiskViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.RiskViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectiveEditors queries the control_objective_editors edge of a Group.
func (c *GroupClient) QueryControlObjectiveEditors(_m *Group) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlObjectiveEditorsTable, group.ControlObjectiveEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjectiveEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectiveBlockedGroups queries the control_objective_blocked_groups edge of a Group.
func (c *GroupClient) QueryControlObjectiveBlockedGroups(_m *Group) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlObjectiveBlockedGroupsTable, group.ControlObjectiveBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjectiveBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectiveViewers queries the control_objective_viewers edge of a Group.
func (c *GroupClient) QueryControlObjectiveViewers(_m *Group) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlObjectiveViewersTable, group.ControlObjectiveViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjectiveViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarrativeEditors queries the narrative_editors edge of a Group.
func (c *GroupClient) QueryNarrativeEditors(_m *Group) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.NarrativeEditorsTable, group.NarrativeEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.NarrativeEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarrativeBlockedGroups queries the narrative_blocked_groups edge of a Group.
func (c *GroupClient) QueryNarrativeBlockedGroups(_m *Group) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.NarrativeBlockedGroupsTable, group.NarrativeBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.NarrativeBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarrativeViewers queries the narrative_viewers edge of a Group.
func (c *GroupClient) QueryNarrativeViewers(_m *Group) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.NarrativeViewersTable, group.NarrativeViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.NarrativeViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementationEditors queries the control_implementation_editors edge of a Group.
func (c *GroupClient) QueryControlImplementationEditors(_m *Group) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlImplementationEditorsTable, group.ControlImplementationEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementationEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementationBlockedGroups queries the control_implementation_blocked_groups edge of a Group.
func (c *GroupClient) QueryControlImplementationBlockedGroups(_m *Group) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlImplementationBlockedGroupsTable, group.ControlImplementationBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementationBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementationViewers queries the control_implementation_viewers edge of a Group.
func (c *GroupClient) QueryControlImplementationViewers(_m *Group) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlImplementationViewersTable, group.ControlImplementationViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementationViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScanEditors queries the scan_editors edge of a Group.
func (c *GroupClient) QueryScanEditors(_m *Group) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ScanEditorsTable, group.ScanEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.ScanEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScanBlockedGroups queries the scan_blocked_groups edge of a Group.
func (c *GroupClient) QueryScanBlockedGroups(_m *Group) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ScanBlockedGroupsTable, group.ScanBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.ScanBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScanViewers queries the scan_viewers edge of a Group.
func (c *GroupClient) QueryScanViewers(_m *Group) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ScanViewersTable, group.ScanViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.ScanViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntityEditors queries the entity_editors edge of a Group.
func (c *GroupClient) QueryEntityEditors(_m *Group) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.EntityEditorsTable, group.EntityEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntityBlockedGroups queries the entity_blocked_groups edge of a Group.
func (c *GroupClient) QueryEntityBlockedGroups(_m *Group) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.EntityBlockedGroupsTable, group.EntityBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntityViewers queries the entity_viewers edge of a Group.
func (c *GroupClient) QueryEntityViewers(_m *Group) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.EntityViewersTable, group.EntityViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedureEditors queries the procedure_editors edge of a Group.
func (c *GroupClient) QueryProcedureEditors(_m *Group) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ProcedureEditorsTable, group.ProcedureEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedureBlockedGroups queries the procedure_blocked_groups edge of a Group.
func (c *GroupClient) QueryProcedureBlockedGroups(_m *Group) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ProcedureBlockedGroupsTable, group.ProcedureBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicyEditors queries the internal_policy_editors edge of a Group.
func (c *GroupClient) QueryInternalPolicyEditors(_m *Group) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.InternalPolicyEditorsTable, group.InternalPolicyEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicyBlockedGroups queries the internal_policy_blocked_groups edge of a Group.
func (c *GroupClient) QueryInternalPolicyBlockedGroups(_m *Group) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.InternalPolicyBlockedGroupsTable, group.InternalPolicyBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlEditors queries the control_editors edge of a Group.
func (c *GroupClient) QueryControlEditors(_m *Group) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlEditorsTable, group.ControlEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlBlockedGroups queries the control_blocked_groups edge of a Group.
func (c *GroupClient) QueryControlBlockedGroups(_m *Group) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.ControlBlockedGroupsTable, group.ControlBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedControlEditors queries the mapped_control_editors edge of a Group.
func (c *GroupClient) QueryMappedControlEditors(_m *Group) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.MappedControlEditorsTable, group.MappedControlEditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControlEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedControlBlockedGroups queries the mapped_control_blocked_groups edge of a Group.
func (c *GroupClient) QueryMappedControlBlockedGroups(_m *Group) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.MappedControlBlockedGroupsTable, group.MappedControlBlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControlBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a Group.
func (c *GroupClient) QuerySetting(_m *Group) *GroupSettingQuery {
	query := (&GroupSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(groupsetting.Table, groupsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, group.SettingTable, group.SettingColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.GroupSetting
		step.Edge.Schema = schemaConfig.GroupSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(_m *Group) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.UsersTable, group.UsersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Group.
func (c *GroupClient) QueryEvents(_m *Group) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.EventsTable, group.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.GroupEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Group.
func (c *GroupClient) QueryIntegrations(_m *Group) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, group.IntegrationsTable, group.IntegrationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Group.
func (c *GroupClient) QueryFiles(_m *Group) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.FilesTable, group.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.GroupFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Group.
func (c *GroupClient) QueryTasks(_m *Group) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.TasksTable, group.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.GroupTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvites queries the invites edge of a Group.
func (c *GroupClient) QueryInvites(_m *Group) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.InvitesTable, group.InvitesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Invite
		step.Edge.Schema = schemaConfig.InviteGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Group.
func (c *GroupClient) QueryMembers(_m *Group) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, group.MembersTable, group.MembersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.GroupMembership
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	hooks := c.hooks.Group
	return append(hooks[:len(hooks):len(hooks)], group.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupClient) Interceptors() []Interceptor {
	inters := c.inters.Group
	return append(inters[:len(inters):len(inters)], group.Interceptors[:]...)
}

func (c *GroupClient) mutate(ctx context.Context, m *GroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Group mutation op: %q", m.Op())
	}
}

// GroupHistoryClient is a client for the GroupHistory schema.
type GroupHistoryClient struct {
	config
}

// NewGroupHistoryClient returns a client for the GroupHistory from the given config.
func NewGroupHistoryClient(c config) *GroupHistoryClient {
	return &GroupHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grouphistory.Hooks(f(g(h())))`.
func (c *GroupHistoryClient) Use(hooks ...Hook) {
	c.hooks.GroupHistory = append(c.hooks.GroupHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grouphistory.Intercept(f(g(h())))`.
func (c *GroupHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupHistory = append(c.inters.GroupHistory, interceptors...)
}

// Create returns a builder for creating a GroupHistory entity.
func (c *GroupHistoryClient) Create() *GroupHistoryCreate {
	mutation := newGroupHistoryMutation(c.config, OpCreate)
	return &GroupHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupHistory entities.
func (c *GroupHistoryClient) CreateBulk(builders ...*GroupHistoryCreate) *GroupHistoryCreateBulk {
	return &GroupHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupHistoryClient) MapCreateBulk(slice any, setFunc func(*GroupHistoryCreate, int)) *GroupHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupHistoryCreateBulk{err: fmt.Errorf("calling to GroupHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupHistory.
func (c *GroupHistoryClient) Update() *GroupHistoryUpdate {
	mutation := newGroupHistoryMutation(c.config, OpUpdate)
	return &GroupHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupHistoryClient) UpdateOne(_m *GroupHistory) *GroupHistoryUpdateOne {
	mutation := newGroupHistoryMutation(c.config, OpUpdateOne, withGroupHistory(_m))
	return &GroupHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupHistoryClient) UpdateOneID(id string) *GroupHistoryUpdateOne {
	mutation := newGroupHistoryMutation(c.config, OpUpdateOne, withGroupHistoryID(id))
	return &GroupHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupHistory.
func (c *GroupHistoryClient) Delete() *GroupHistoryDelete {
	mutation := newGroupHistoryMutation(c.config, OpDelete)
	return &GroupHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupHistoryClient) DeleteOne(_m *GroupHistory) *GroupHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupHistoryClient) DeleteOneID(id string) *GroupHistoryDeleteOne {
	builder := c.Delete().Where(grouphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupHistoryDeleteOne{builder}
}

// Query returns a query builder for GroupHistory.
func (c *GroupHistoryClient) Query() *GroupHistoryQuery {
	return &GroupHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupHistory entity by its id.
func (c *GroupHistoryClient) Get(ctx context.Context, id string) (*GroupHistory, error) {
	return c.Query().Where(grouphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupHistoryClient) GetX(ctx context.Context, id string) *GroupHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupHistoryClient) Hooks() []Hook {
	hooks := c.hooks.GroupHistory
	return append(hooks[:len(hooks):len(hooks)], grouphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.GroupHistory
	return append(inters[:len(inters):len(inters)], grouphistory.Interceptors[:]...)
}

func (c *GroupHistoryClient) mutate(ctx context.Context, m *GroupHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupHistory mutation op: %q", m.Op())
	}
}

// GroupMembershipClient is a client for the GroupMembership schema.
type GroupMembershipClient struct {
	config
}

// NewGroupMembershipClient returns a client for the GroupMembership from the given config.
func NewGroupMembershipClient(c config) *GroupMembershipClient {
	return &GroupMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupmembership.Hooks(f(g(h())))`.
func (c *GroupMembershipClient) Use(hooks ...Hook) {
	c.hooks.GroupMembership = append(c.hooks.GroupMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupmembership.Intercept(f(g(h())))`.
func (c *GroupMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupMembership = append(c.inters.GroupMembership, interceptors...)
}

// Create returns a builder for creating a GroupMembership entity.
func (c *GroupMembershipClient) Create() *GroupMembershipCreate {
	mutation := newGroupMembershipMutation(c.config, OpCreate)
	return &GroupMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupMembership entities.
func (c *GroupMembershipClient) CreateBulk(builders ...*GroupMembershipCreate) *GroupMembershipCreateBulk {
	return &GroupMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupMembershipClient) MapCreateBulk(slice any, setFunc func(*GroupMembershipCreate, int)) *GroupMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupMembershipCreateBulk{err: fmt.Errorf("calling to GroupMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupMembership.
func (c *GroupMembershipClient) Update() *GroupMembershipUpdate {
	mutation := newGroupMembershipMutation(c.config, OpUpdate)
	return &GroupMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupMembershipClient) UpdateOne(_m *GroupMembership) *GroupMembershipUpdateOne {
	mutation := newGroupMembershipMutation(c.config, OpUpdateOne, withGroupMembership(_m))
	return &GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupMembershipClient) UpdateOneID(id string) *GroupMembershipUpdateOne {
	mutation := newGroupMembershipMutation(c.config, OpUpdateOne, withGroupMembershipID(id))
	return &GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupMembership.
func (c *GroupMembershipClient) Delete() *GroupMembershipDelete {
	mutation := newGroupMembershipMutation(c.config, OpDelete)
	return &GroupMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupMembershipClient) DeleteOne(_m *GroupMembership) *GroupMembershipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupMembershipClient) DeleteOneID(id string) *GroupMembershipDeleteOne {
	builder := c.Delete().Where(groupmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupMembershipDeleteOne{builder}
}

// Query returns a query builder for GroupMembership.
func (c *GroupMembershipClient) Query() *GroupMembershipQuery {
	return &GroupMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupMembership entity by its id.
func (c *GroupMembershipClient) Get(ctx context.Context, id string) (*GroupMembership, error) {
	return c.Query().Where(groupmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupMembershipClient) GetX(ctx context.Context, id string) *GroupMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a GroupMembership.
func (c *GroupMembershipClient) QueryGroup(_m *GroupMembership) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.GroupTable, groupmembership.GroupColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a GroupMembership.
func (c *GroupMembershipClient) QueryUser(_m *GroupMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.UserTable, groupmembership.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgMembership queries the org_membership edge of a GroupMembership.
func (c *GroupMembershipClient) QueryOrgMembership(_m *GroupMembership) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.OrgMembershipTable, groupmembership.OrgMembershipColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a GroupMembership.
func (c *GroupMembershipClient) QueryEvents(_m *GroupMembership) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, groupmembership.EventsTable, groupmembership.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.GroupMembershipEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupMembershipClient) Hooks() []Hook {
	hooks := c.hooks.GroupMembership
	return append(hooks[:len(hooks):len(hooks)], groupmembership.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupMembershipClient) Interceptors() []Interceptor {
	inters := c.inters.GroupMembership
	return append(inters[:len(inters):len(inters)], groupmembership.Interceptors[:]...)
}

func (c *GroupMembershipClient) mutate(ctx context.Context, m *GroupMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupMembership mutation op: %q", m.Op())
	}
}

// GroupMembershipHistoryClient is a client for the GroupMembershipHistory schema.
type GroupMembershipHistoryClient struct {
	config
}

// NewGroupMembershipHistoryClient returns a client for the GroupMembershipHistory from the given config.
func NewGroupMembershipHistoryClient(c config) *GroupMembershipHistoryClient {
	return &GroupMembershipHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupmembershiphistory.Hooks(f(g(h())))`.
func (c *GroupMembershipHistoryClient) Use(hooks ...Hook) {
	c.hooks.GroupMembershipHistory = append(c.hooks.GroupMembershipHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupmembershiphistory.Intercept(f(g(h())))`.
func (c *GroupMembershipHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupMembershipHistory = append(c.inters.GroupMembershipHistory, interceptors...)
}

// Create returns a builder for creating a GroupMembershipHistory entity.
func (c *GroupMembershipHistoryClient) Create() *GroupMembershipHistoryCreate {
	mutation := newGroupMembershipHistoryMutation(c.config, OpCreate)
	return &GroupMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupMembershipHistory entities.
func (c *GroupMembershipHistoryClient) CreateBulk(builders ...*GroupMembershipHistoryCreate) *GroupMembershipHistoryCreateBulk {
	return &GroupMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupMembershipHistoryClient) MapCreateBulk(slice any, setFunc func(*GroupMembershipHistoryCreate, int)) *GroupMembershipHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupMembershipHistoryCreateBulk{err: fmt.Errorf("calling to GroupMembershipHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupMembershipHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupMembershipHistory.
func (c *GroupMembershipHistoryClient) Update() *GroupMembershipHistoryUpdate {
	mutation := newGroupMembershipHistoryMutation(c.config, OpUpdate)
	return &GroupMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupMembershipHistoryClient) UpdateOne(_m *GroupMembershipHistory) *GroupMembershipHistoryUpdateOne {
	mutation := newGroupMembershipHistoryMutation(c.config, OpUpdateOne, withGroupMembershipHistory(_m))
	return &GroupMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupMembershipHistoryClient) UpdateOneID(id string) *GroupMembershipHistoryUpdateOne {
	mutation := newGroupMembershipHistoryMutation(c.config, OpUpdateOne, withGroupMembershipHistoryID(id))
	return &GroupMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupMembershipHistory.
func (c *GroupMembershipHistoryClient) Delete() *GroupMembershipHistoryDelete {
	mutation := newGroupMembershipHistoryMutation(c.config, OpDelete)
	return &GroupMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupMembershipHistoryClient) DeleteOne(_m *GroupMembershipHistory) *GroupMembershipHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupMembershipHistoryClient) DeleteOneID(id string) *GroupMembershipHistoryDeleteOne {
	builder := c.Delete().Where(groupmembershiphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupMembershipHistoryDeleteOne{builder}
}

// Query returns a query builder for GroupMembershipHistory.
func (c *GroupMembershipHistoryClient) Query() *GroupMembershipHistoryQuery {
	return &GroupMembershipHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupMembershipHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupMembershipHistory entity by its id.
func (c *GroupMembershipHistoryClient) Get(ctx context.Context, id string) (*GroupMembershipHistory, error) {
	return c.Query().Where(groupmembershiphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupMembershipHistoryClient) GetX(ctx context.Context, id string) *GroupMembershipHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupMembershipHistoryClient) Hooks() []Hook {
	hooks := c.hooks.GroupMembershipHistory
	return append(hooks[:len(hooks):len(hooks)], groupmembershiphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupMembershipHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.GroupMembershipHistory
	return append(inters[:len(inters):len(inters)], groupmembershiphistory.Interceptors[:]...)
}

func (c *GroupMembershipHistoryClient) mutate(ctx context.Context, m *GroupMembershipHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupMembershipHistory mutation op: %q", m.Op())
	}
}

// GroupSettingClient is a client for the GroupSetting schema.
type GroupSettingClient struct {
	config
}

// NewGroupSettingClient returns a client for the GroupSetting from the given config.
func NewGroupSettingClient(c config) *GroupSettingClient {
	return &GroupSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupsetting.Hooks(f(g(h())))`.
func (c *GroupSettingClient) Use(hooks ...Hook) {
	c.hooks.GroupSetting = append(c.hooks.GroupSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupsetting.Intercept(f(g(h())))`.
func (c *GroupSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupSetting = append(c.inters.GroupSetting, interceptors...)
}

// Create returns a builder for creating a GroupSetting entity.
func (c *GroupSettingClient) Create() *GroupSettingCreate {
	mutation := newGroupSettingMutation(c.config, OpCreate)
	return &GroupSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupSetting entities.
func (c *GroupSettingClient) CreateBulk(builders ...*GroupSettingCreate) *GroupSettingCreateBulk {
	return &GroupSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupSettingClient) MapCreateBulk(slice any, setFunc func(*GroupSettingCreate, int)) *GroupSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupSettingCreateBulk{err: fmt.Errorf("calling to GroupSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupSetting.
func (c *GroupSettingClient) Update() *GroupSettingUpdate {
	mutation := newGroupSettingMutation(c.config, OpUpdate)
	return &GroupSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupSettingClient) UpdateOne(_m *GroupSetting) *GroupSettingUpdateOne {
	mutation := newGroupSettingMutation(c.config, OpUpdateOne, withGroupSetting(_m))
	return &GroupSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupSettingClient) UpdateOneID(id string) *GroupSettingUpdateOne {
	mutation := newGroupSettingMutation(c.config, OpUpdateOne, withGroupSettingID(id))
	return &GroupSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupSetting.
func (c *GroupSettingClient) Delete() *GroupSettingDelete {
	mutation := newGroupSettingMutation(c.config, OpDelete)
	return &GroupSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupSettingClient) DeleteOne(_m *GroupSetting) *GroupSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupSettingClient) DeleteOneID(id string) *GroupSettingDeleteOne {
	builder := c.Delete().Where(groupsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupSettingDeleteOne{builder}
}

// Query returns a query builder for GroupSetting.
func (c *GroupSettingClient) Query() *GroupSettingQuery {
	return &GroupSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupSetting entity by its id.
func (c *GroupSettingClient) Get(ctx context.Context, id string) (*GroupSetting, error) {
	return c.Query().Where(groupsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupSettingClient) GetX(ctx context.Context, id string) *GroupSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a GroupSetting.
func (c *GroupSettingClient) QueryGroup(_m *GroupSetting) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupsetting.Table, groupsetting.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, groupsetting.GroupTable, groupsetting.GroupColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupSettingClient) Hooks() []Hook {
	hooks := c.hooks.GroupSetting
	return append(hooks[:len(hooks):len(hooks)], groupsetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupSettingClient) Interceptors() []Interceptor {
	inters := c.inters.GroupSetting
	return append(inters[:len(inters):len(inters)], groupsetting.Interceptors[:]...)
}

func (c *GroupSettingClient) mutate(ctx context.Context, m *GroupSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupSetting mutation op: %q", m.Op())
	}
}

// GroupSettingHistoryClient is a client for the GroupSettingHistory schema.
type GroupSettingHistoryClient struct {
	config
}

// NewGroupSettingHistoryClient returns a client for the GroupSettingHistory from the given config.
func NewGroupSettingHistoryClient(c config) *GroupSettingHistoryClient {
	return &GroupSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupsettinghistory.Hooks(f(g(h())))`.
func (c *GroupSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.GroupSettingHistory = append(c.hooks.GroupSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupsettinghistory.Intercept(f(g(h())))`.
func (c *GroupSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupSettingHistory = append(c.inters.GroupSettingHistory, interceptors...)
}

// Create returns a builder for creating a GroupSettingHistory entity.
func (c *GroupSettingHistoryClient) Create() *GroupSettingHistoryCreate {
	mutation := newGroupSettingHistoryMutation(c.config, OpCreate)
	return &GroupSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupSettingHistory entities.
func (c *GroupSettingHistoryClient) CreateBulk(builders ...*GroupSettingHistoryCreate) *GroupSettingHistoryCreateBulk {
	return &GroupSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*GroupSettingHistoryCreate, int)) *GroupSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupSettingHistoryCreateBulk{err: fmt.Errorf("calling to GroupSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupSettingHistory.
func (c *GroupSettingHistoryClient) Update() *GroupSettingHistoryUpdate {
	mutation := newGroupSettingHistoryMutation(c.config, OpUpdate)
	return &GroupSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupSettingHistoryClient) UpdateOne(_m *GroupSettingHistory) *GroupSettingHistoryUpdateOne {
	mutation := newGroupSettingHistoryMutation(c.config, OpUpdateOne, withGroupSettingHistory(_m))
	return &GroupSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupSettingHistoryClient) UpdateOneID(id string) *GroupSettingHistoryUpdateOne {
	mutation := newGroupSettingHistoryMutation(c.config, OpUpdateOne, withGroupSettingHistoryID(id))
	return &GroupSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupSettingHistory.
func (c *GroupSettingHistoryClient) Delete() *GroupSettingHistoryDelete {
	mutation := newGroupSettingHistoryMutation(c.config, OpDelete)
	return &GroupSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupSettingHistoryClient) DeleteOne(_m *GroupSettingHistory) *GroupSettingHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupSettingHistoryClient) DeleteOneID(id string) *GroupSettingHistoryDeleteOne {
	builder := c.Delete().Where(groupsettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for GroupSettingHistory.
func (c *GroupSettingHistoryClient) Query() *GroupSettingHistoryQuery {
	return &GroupSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupSettingHistory entity by its id.
func (c *GroupSettingHistoryClient) Get(ctx context.Context, id string) (*GroupSettingHistory, error) {
	return c.Query().Where(groupsettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupSettingHistoryClient) GetX(ctx context.Context, id string) *GroupSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupSettingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.GroupSettingHistory
	return append(hooks[:len(hooks):len(hooks)], groupsettinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.GroupSettingHistory
	return append(inters[:len(inters):len(inters)], groupsettinghistory.Interceptors[:]...)
}

func (c *GroupSettingHistoryClient) mutate(ctx context.Context, m *GroupSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupSettingHistory mutation op: %q", m.Op())
	}
}

// HushClient is a client for the Hush schema.
type HushClient struct {
	config
}

// NewHushClient returns a client for the Hush from the given config.
func NewHushClient(c config) *HushClient {
	return &HushClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hush.Hooks(f(g(h())))`.
func (c *HushClient) Use(hooks ...Hook) {
	c.hooks.Hush = append(c.hooks.Hush, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hush.Intercept(f(g(h())))`.
func (c *HushClient) Intercept(interceptors ...Interceptor) {
	c.inters.Hush = append(c.inters.Hush, interceptors...)
}

// Create returns a builder for creating a Hush entity.
func (c *HushClient) Create() *HushCreate {
	mutation := newHushMutation(c.config, OpCreate)
	return &HushCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hush entities.
func (c *HushClient) CreateBulk(builders ...*HushCreate) *HushCreateBulk {
	return &HushCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HushClient) MapCreateBulk(slice any, setFunc func(*HushCreate, int)) *HushCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HushCreateBulk{err: fmt.Errorf("calling to HushClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HushCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HushCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hush.
func (c *HushClient) Update() *HushUpdate {
	mutation := newHushMutation(c.config, OpUpdate)
	return &HushUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HushClient) UpdateOne(_m *Hush) *HushUpdateOne {
	mutation := newHushMutation(c.config, OpUpdateOne, withHush(_m))
	return &HushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HushClient) UpdateOneID(id string) *HushUpdateOne {
	mutation := newHushMutation(c.config, OpUpdateOne, withHushID(id))
	return &HushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hush.
func (c *HushClient) Delete() *HushDelete {
	mutation := newHushMutation(c.config, OpDelete)
	return &HushDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HushClient) DeleteOne(_m *Hush) *HushDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HushClient) DeleteOneID(id string) *HushDeleteOne {
	builder := c.Delete().Where(hush.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HushDeleteOne{builder}
}

// Query returns a query builder for Hush.
func (c *HushClient) Query() *HushQuery {
	return &HushQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHush},
		inters: c.Interceptors(),
	}
}

// Get returns a Hush entity by its id.
func (c *HushClient) Get(ctx context.Context, id string) (*Hush, error) {
	return c.Query().Where(hush.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HushClient) GetX(ctx context.Context, id string) *Hush {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Hush.
func (c *HushClient) QueryOwner(_m *Hush) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hush.OwnerTable, hush.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Hush
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Hush.
func (c *HushClient) QueryIntegrations(_m *Hush) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, hush.IntegrationsTable, hush.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationSecrets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Hush.
func (c *HushClient) QueryFiles(_m *Hush) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, hush.FilesTable, hush.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.FileSecrets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Hush.
func (c *HushClient) QueryEvents(_m *Hush) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, hush.EventsTable, hush.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.HushEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HushClient) Hooks() []Hook {
	hooks := c.hooks.Hush
	return append(hooks[:len(hooks):len(hooks)], hush.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *HushClient) Interceptors() []Interceptor {
	inters := c.inters.Hush
	return append(inters[:len(inters):len(inters)], hush.Interceptors[:]...)
}

func (c *HushClient) mutate(ctx context.Context, m *HushMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HushCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HushUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HushDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Hush mutation op: %q", m.Op())
	}
}

// HushHistoryClient is a client for the HushHistory schema.
type HushHistoryClient struct {
	config
}

// NewHushHistoryClient returns a client for the HushHistory from the given config.
func NewHushHistoryClient(c config) *HushHistoryClient {
	return &HushHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hushhistory.Hooks(f(g(h())))`.
func (c *HushHistoryClient) Use(hooks ...Hook) {
	c.hooks.HushHistory = append(c.hooks.HushHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hushhistory.Intercept(f(g(h())))`.
func (c *HushHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.HushHistory = append(c.inters.HushHistory, interceptors...)
}

// Create returns a builder for creating a HushHistory entity.
func (c *HushHistoryClient) Create() *HushHistoryCreate {
	mutation := newHushHistoryMutation(c.config, OpCreate)
	return &HushHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HushHistory entities.
func (c *HushHistoryClient) CreateBulk(builders ...*HushHistoryCreate) *HushHistoryCreateBulk {
	return &HushHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HushHistoryClient) MapCreateBulk(slice any, setFunc func(*HushHistoryCreate, int)) *HushHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HushHistoryCreateBulk{err: fmt.Errorf("calling to HushHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HushHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HushHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HushHistory.
func (c *HushHistoryClient) Update() *HushHistoryUpdate {
	mutation := newHushHistoryMutation(c.config, OpUpdate)
	return &HushHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HushHistoryClient) UpdateOne(_m *HushHistory) *HushHistoryUpdateOne {
	mutation := newHushHistoryMutation(c.config, OpUpdateOne, withHushHistory(_m))
	return &HushHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HushHistoryClient) UpdateOneID(id string) *HushHistoryUpdateOne {
	mutation := newHushHistoryMutation(c.config, OpUpdateOne, withHushHistoryID(id))
	return &HushHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HushHistory.
func (c *HushHistoryClient) Delete() *HushHistoryDelete {
	mutation := newHushHistoryMutation(c.config, OpDelete)
	return &HushHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HushHistoryClient) DeleteOne(_m *HushHistory) *HushHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HushHistoryClient) DeleteOneID(id string) *HushHistoryDeleteOne {
	builder := c.Delete().Where(hushhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HushHistoryDeleteOne{builder}
}

// Query returns a query builder for HushHistory.
func (c *HushHistoryClient) Query() *HushHistoryQuery {
	return &HushHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHushHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a HushHistory entity by its id.
func (c *HushHistoryClient) Get(ctx context.Context, id string) (*HushHistory, error) {
	return c.Query().Where(hushhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HushHistoryClient) GetX(ctx context.Context, id string) *HushHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HushHistoryClient) Hooks() []Hook {
	hooks := c.hooks.HushHistory
	return append(hooks[:len(hooks):len(hooks)], hushhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *HushHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.HushHistory
	return append(inters[:len(inters):len(inters)], hushhistory.Interceptors[:]...)
}

func (c *HushHistoryClient) mutate(ctx context.Context, m *HushHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HushHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HushHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HushHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HushHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown HushHistory mutation op: %q", m.Op())
	}
}

// ImpersonationEventClient is a client for the ImpersonationEvent schema.
type ImpersonationEventClient struct {
	config
}

// NewImpersonationEventClient returns a client for the ImpersonationEvent from the given config.
func NewImpersonationEventClient(c config) *ImpersonationEventClient {
	return &ImpersonationEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `impersonationevent.Hooks(f(g(h())))`.
func (c *ImpersonationEventClient) Use(hooks ...Hook) {
	c.hooks.ImpersonationEvent = append(c.hooks.ImpersonationEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `impersonationevent.Intercept(f(g(h())))`.
func (c *ImpersonationEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImpersonationEvent = append(c.inters.ImpersonationEvent, interceptors...)
}

// Create returns a builder for creating a ImpersonationEvent entity.
func (c *ImpersonationEventClient) Create() *ImpersonationEventCreate {
	mutation := newImpersonationEventMutation(c.config, OpCreate)
	return &ImpersonationEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImpersonationEvent entities.
func (c *ImpersonationEventClient) CreateBulk(builders ...*ImpersonationEventCreate) *ImpersonationEventCreateBulk {
	return &ImpersonationEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImpersonationEventClient) MapCreateBulk(slice any, setFunc func(*ImpersonationEventCreate, int)) *ImpersonationEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImpersonationEventCreateBulk{err: fmt.Errorf("calling to ImpersonationEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImpersonationEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImpersonationEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImpersonationEvent.
func (c *ImpersonationEventClient) Update() *ImpersonationEventUpdate {
	mutation := newImpersonationEventMutation(c.config, OpUpdate)
	return &ImpersonationEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImpersonationEventClient) UpdateOne(_m *ImpersonationEvent) *ImpersonationEventUpdateOne {
	mutation := newImpersonationEventMutation(c.config, OpUpdateOne, withImpersonationEvent(_m))
	return &ImpersonationEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImpersonationEventClient) UpdateOneID(id string) *ImpersonationEventUpdateOne {
	mutation := newImpersonationEventMutation(c.config, OpUpdateOne, withImpersonationEventID(id))
	return &ImpersonationEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImpersonationEvent.
func (c *ImpersonationEventClient) Delete() *ImpersonationEventDelete {
	mutation := newImpersonationEventMutation(c.config, OpDelete)
	return &ImpersonationEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImpersonationEventClient) DeleteOne(_m *ImpersonationEvent) *ImpersonationEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImpersonationEventClient) DeleteOneID(id string) *ImpersonationEventDeleteOne {
	builder := c.Delete().Where(impersonationevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImpersonationEventDeleteOne{builder}
}

// Query returns a query builder for ImpersonationEvent.
func (c *ImpersonationEventClient) Query() *ImpersonationEventQuery {
	return &ImpersonationEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImpersonationEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ImpersonationEvent entity by its id.
func (c *ImpersonationEventClient) Get(ctx context.Context, id string) (*ImpersonationEvent, error) {
	return c.Query().Where(impersonationevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImpersonationEventClient) GetX(ctx context.Context, id string) *ImpersonationEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ImpersonationEvent.
func (c *ImpersonationEventClient) QueryUser(_m *ImpersonationEvent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(impersonationevent.Table, impersonationevent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, impersonationevent.UserTable, impersonationevent.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.ImpersonationEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetUser queries the target_user edge of a ImpersonationEvent.
func (c *ImpersonationEventClient) QueryTargetUser(_m *ImpersonationEvent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(impersonationevent.Table, impersonationevent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, impersonationevent.TargetUserTable, impersonationevent.TargetUserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.ImpersonationEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a ImpersonationEvent.
func (c *ImpersonationEventClient) QueryOrganization(_m *ImpersonationEvent) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(impersonationevent.Table, impersonationevent.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, impersonationevent.OrganizationTable, impersonationevent.OrganizationColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.ImpersonationEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImpersonationEventClient) Hooks() []Hook {
	hooks := c.hooks.ImpersonationEvent
	return append(hooks[:len(hooks):len(hooks)], impersonationevent.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ImpersonationEventClient) Interceptors() []Interceptor {
	inters := c.inters.ImpersonationEvent
	return append(inters[:len(inters):len(inters)], impersonationevent.Interceptors[:]...)
}

func (c *ImpersonationEventClient) mutate(ctx context.Context, m *ImpersonationEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImpersonationEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImpersonationEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImpersonationEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImpersonationEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ImpersonationEvent mutation op: %q", m.Op())
	}
}

// IntegrationClient is a client for the Integration schema.
type IntegrationClient struct {
	config
}

// NewIntegrationClient returns a client for the Integration from the given config.
func NewIntegrationClient(c config) *IntegrationClient {
	return &IntegrationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integration.Hooks(f(g(h())))`.
func (c *IntegrationClient) Use(hooks ...Hook) {
	c.hooks.Integration = append(c.hooks.Integration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integration.Intercept(f(g(h())))`.
func (c *IntegrationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Integration = append(c.inters.Integration, interceptors...)
}

// Create returns a builder for creating a Integration entity.
func (c *IntegrationClient) Create() *IntegrationCreate {
	mutation := newIntegrationMutation(c.config, OpCreate)
	return &IntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Integration entities.
func (c *IntegrationClient) CreateBulk(builders ...*IntegrationCreate) *IntegrationCreateBulk {
	return &IntegrationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationClient) MapCreateBulk(slice any, setFunc func(*IntegrationCreate, int)) *IntegrationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationCreateBulk{err: fmt.Errorf("calling to IntegrationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Integration.
func (c *IntegrationClient) Update() *IntegrationUpdate {
	mutation := newIntegrationMutation(c.config, OpUpdate)
	return &IntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationClient) UpdateOne(_m *Integration) *IntegrationUpdateOne {
	mutation := newIntegrationMutation(c.config, OpUpdateOne, withIntegration(_m))
	return &IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationClient) UpdateOneID(id string) *IntegrationUpdateOne {
	mutation := newIntegrationMutation(c.config, OpUpdateOne, withIntegrationID(id))
	return &IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Integration.
func (c *IntegrationClient) Delete() *IntegrationDelete {
	mutation := newIntegrationMutation(c.config, OpDelete)
	return &IntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationClient) DeleteOne(_m *Integration) *IntegrationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationClient) DeleteOneID(id string) *IntegrationDeleteOne {
	builder := c.Delete().Where(integration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationDeleteOne{builder}
}

// Query returns a query builder for Integration.
func (c *IntegrationClient) Query() *IntegrationQuery {
	return &IntegrationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegration},
		inters: c.Interceptors(),
	}
}

// Get returns a Integration entity by its id.
func (c *IntegrationClient) Get(ctx context.Context, id string) (*Integration, error) {
	return c.Query().Where(integration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationClient) GetX(ctx context.Context, id string) *Integration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Integration.
func (c *IntegrationClient) QueryOwner(_m *Integration) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, integration.OwnerTable, integration.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySecrets queries the secrets edge of a Integration.
func (c *IntegrationClient) QuerySecrets(_m *Integration) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.SecretsTable, integration.SecretsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.IntegrationSecrets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Integration.
func (c *IntegrationClient) QueryFiles(_m *Integration) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, integration.FilesTable, integration.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Integration.
func (c *IntegrationClient) QueryEvents(_m *Integration) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.EventsTable, integration.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.IntegrationEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a Integration.
func (c *IntegrationClient) QueryFindings(_m *Integration) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.FindingsTable, integration.FindingsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.IntegrationFindings
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Integration.
func (c *IntegrationClient) QueryVulnerabilities(_m *Integration) *VulnerabilityQuery {
	query := (&VulnerabilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.VulnerabilitiesTable, integration.VulnerabilitiesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Vulnerability
		step.Edge.Schema = schemaConfig.IntegrationVulnerabilities
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Integration.
func (c *IntegrationClient) QueryReviews(_m *Integration) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.ReviewsTable, integration.ReviewsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Review
		step.Edge.Schema = schemaConfig.IntegrationReviews
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediations queries the remediations edge of a Integration.
func (c *IntegrationClient) QueryRemediations(_m *Integration) *RemediationQuery {
	query := (&RemediationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(remediation.Table, remediation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.RemediationsTable, integration.RemediationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Remediation
		step.Edge.Schema = schemaConfig.IntegrationRemediations
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Integration.
func (c *IntegrationClient) QueryTasks(_m *Integration) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, integration.TasksTable, integration.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Integration.
func (c *IntegrationClient) QueryActionPlans(_m *Integration) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.ActionPlansTable, integration.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.IntegrationActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntegrationClient) Hooks() []Hook {
	hooks := c.hooks.Integration
	return append(hooks[:len(hooks):len(hooks)], integration.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IntegrationClient) Interceptors() []Interceptor {
	inters := c.inters.Integration
	return append(inters[:len(inters):len(inters)], integration.Interceptors[:]...)
}

func (c *IntegrationClient) mutate(ctx context.Context, m *IntegrationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Integration mutation op: %q", m.Op())
	}
}

// IntegrationHistoryClient is a client for the IntegrationHistory schema.
type IntegrationHistoryClient struct {
	config
}

// NewIntegrationHistoryClient returns a client for the IntegrationHistory from the given config.
func NewIntegrationHistoryClient(c config) *IntegrationHistoryClient {
	return &IntegrationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integrationhistory.Hooks(f(g(h())))`.
func (c *IntegrationHistoryClient) Use(hooks ...Hook) {
	c.hooks.IntegrationHistory = append(c.hooks.IntegrationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integrationhistory.Intercept(f(g(h())))`.
func (c *IntegrationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.IntegrationHistory = append(c.inters.IntegrationHistory, interceptors...)
}

// Create returns a builder for creating a IntegrationHistory entity.
func (c *IntegrationHistoryClient) Create() *IntegrationHistoryCreate {
	mutation := newIntegrationHistoryMutation(c.config, OpCreate)
	return &IntegrationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IntegrationHistory entities.
func (c *IntegrationHistoryClient) CreateBulk(builders ...*IntegrationHistoryCreate) *IntegrationHistoryCreateBulk {
	return &IntegrationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationHistoryClient) MapCreateBulk(slice any, setFunc func(*IntegrationHistoryCreate, int)) *IntegrationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationHistoryCreateBulk{err: fmt.Errorf("calling to IntegrationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IntegrationHistory.
func (c *IntegrationHistoryClient) Update() *IntegrationHistoryUpdate {
	mutation := newIntegrationHistoryMutation(c.config, OpUpdate)
	return &IntegrationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationHistoryClient) UpdateOne(_m *IntegrationHistory) *IntegrationHistoryUpdateOne {
	mutation := newIntegrationHistoryMutation(c.config, OpUpdateOne, withIntegrationHistory(_m))
	return &IntegrationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationHistoryClient) UpdateOneID(id string) *IntegrationHistoryUpdateOne {
	mutation := newIntegrationHistoryMutation(c.config, OpUpdateOne, withIntegrationHistoryID(id))
	return &IntegrationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IntegrationHistory.
func (c *IntegrationHistoryClient) Delete() *IntegrationHistoryDelete {
	mutation := newIntegrationHistoryMutation(c.config, OpDelete)
	return &IntegrationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationHistoryClient) DeleteOne(_m *IntegrationHistory) *IntegrationHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationHistoryClient) DeleteOneID(id string) *IntegrationHistoryDeleteOne {
	builder := c.Delete().Where(integrationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationHistoryDeleteOne{builder}
}

// Query returns a query builder for IntegrationHistory.
func (c *IntegrationHistoryClient) Query() *IntegrationHistoryQuery {
	return &IntegrationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegrationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a IntegrationHistory entity by its id.
func (c *IntegrationHistoryClient) Get(ctx context.Context, id string) (*IntegrationHistory, error) {
	return c.Query().Where(integrationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationHistoryClient) GetX(ctx context.Context, id string) *IntegrationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IntegrationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.IntegrationHistory
	return append(hooks[:len(hooks):len(hooks)], integrationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IntegrationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.IntegrationHistory
	return append(inters[:len(inters):len(inters)], integrationhistory.Interceptors[:]...)
}

func (c *IntegrationHistoryClient) mutate(ctx context.Context, m *IntegrationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown IntegrationHistory mutation op: %q", m.Op())
	}
}

// InternalPolicyClient is a client for the InternalPolicy schema.
type InternalPolicyClient struct {
	config
}

// NewInternalPolicyClient returns a client for the InternalPolicy from the given config.
func NewInternalPolicyClient(c config) *InternalPolicyClient {
	return &InternalPolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `internalpolicy.Hooks(f(g(h())))`.
func (c *InternalPolicyClient) Use(hooks ...Hook) {
	c.hooks.InternalPolicy = append(c.hooks.InternalPolicy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `internalpolicy.Intercept(f(g(h())))`.
func (c *InternalPolicyClient) Intercept(interceptors ...Interceptor) {
	c.inters.InternalPolicy = append(c.inters.InternalPolicy, interceptors...)
}

// Create returns a builder for creating a InternalPolicy entity.
func (c *InternalPolicyClient) Create() *InternalPolicyCreate {
	mutation := newInternalPolicyMutation(c.config, OpCreate)
	return &InternalPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InternalPolicy entities.
func (c *InternalPolicyClient) CreateBulk(builders ...*InternalPolicyCreate) *InternalPolicyCreateBulk {
	return &InternalPolicyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InternalPolicyClient) MapCreateBulk(slice any, setFunc func(*InternalPolicyCreate, int)) *InternalPolicyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InternalPolicyCreateBulk{err: fmt.Errorf("calling to InternalPolicyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InternalPolicyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InternalPolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InternalPolicy.
func (c *InternalPolicyClient) Update() *InternalPolicyUpdate {
	mutation := newInternalPolicyMutation(c.config, OpUpdate)
	return &InternalPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InternalPolicyClient) UpdateOne(_m *InternalPolicy) *InternalPolicyUpdateOne {
	mutation := newInternalPolicyMutation(c.config, OpUpdateOne, withInternalPolicy(_m))
	return &InternalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InternalPolicyClient) UpdateOneID(id string) *InternalPolicyUpdateOne {
	mutation := newInternalPolicyMutation(c.config, OpUpdateOne, withInternalPolicyID(id))
	return &InternalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InternalPolicy.
func (c *InternalPolicyClient) Delete() *InternalPolicyDelete {
	mutation := newInternalPolicyMutation(c.config, OpDelete)
	return &InternalPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InternalPolicyClient) DeleteOne(_m *InternalPolicy) *InternalPolicyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InternalPolicyClient) DeleteOneID(id string) *InternalPolicyDeleteOne {
	builder := c.Delete().Where(internalpolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InternalPolicyDeleteOne{builder}
}

// Query returns a query builder for InternalPolicy.
func (c *InternalPolicyClient) Query() *InternalPolicyQuery {
	return &InternalPolicyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInternalPolicy},
		inters: c.Interceptors(),
	}
}

// Get returns a InternalPolicy entity by its id.
func (c *InternalPolicyClient) Get(ctx context.Context, id string) (*InternalPolicy, error) {
	return c.Query().Where(internalpolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InternalPolicyClient) GetX(ctx context.Context, id string) *InternalPolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryOwner(_m *InternalPolicy) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, internalpolicy.OwnerTable, internalpolicy.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryBlockedGroups(_m *InternalPolicy) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.BlockedGroupsTable, internalpolicy.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.InternalPolicyBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryEditors(_m *InternalPolicy) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.EditorsTable, internalpolicy.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.InternalPolicyEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprover queries the approver edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryApprover(_m *InternalPolicy) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, internalpolicy.ApproverTable, internalpolicy.ApproverColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDelegate queries the delegate edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryDelegate(_m *InternalPolicy) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, internalpolicy.DelegateTable, internalpolicy.DelegateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicyKind queries the internal_policy_kind edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryInternalPolicyKind(_m *InternalPolicy) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, internalpolicy.InternalPolicyKindTable, internalpolicy.InternalPolicyKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryControlObjectives(_m *InternalPolicy) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.ControlObjectivesTable, internalpolicy.ControlObjectivesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.InternalPolicyControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementations queries the control_implementations edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryControlImplementations(_m *InternalPolicy) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, internalpolicy.ControlImplementationsTable, internalpolicy.ControlImplementationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryControls(_m *InternalPolicy) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.ControlsTable, internalpolicy.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.InternalPolicyControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a InternalPolicy.
func (c *InternalPolicyClient) QuerySubcontrols(_m *InternalPolicy) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.SubcontrolsTable, internalpolicy.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.InternalPolicySubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryProcedures(_m *InternalPolicy) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.ProceduresTable, internalpolicy.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.InternalPolicyProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryNarratives(_m *InternalPolicy) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.NarrativesTable, internalpolicy.NarrativesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.InternalPolicyNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryTasks(_m *InternalPolicy) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.TasksTable, internalpolicy.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.InternalPolicyTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryRisks(_m *InternalPolicy) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.RisksTable, internalpolicy.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.InternalPolicyRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryPrograms(_m *InternalPolicy) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, internalpolicy.ProgramsTable, internalpolicy.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramInternalPolicies
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryFile(_m *InternalPolicy) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, internalpolicy.FileTable, internalpolicy.FileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryComments(_m *InternalPolicy) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, internalpolicy.CommentsTable, internalpolicy.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InternalPolicyClient) Hooks() []Hook {
	hooks := c.hooks.InternalPolicy
	return append(hooks[:len(hooks):len(hooks)], internalpolicy.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InternalPolicyClient) Interceptors() []Interceptor {
	inters := c.inters.InternalPolicy
	return append(inters[:len(inters):len(inters)], internalpolicy.Interceptors[:]...)
}

func (c *InternalPolicyClient) mutate(ctx context.Context, m *InternalPolicyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InternalPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InternalPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InternalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InternalPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown InternalPolicy mutation op: %q", m.Op())
	}
}

// InternalPolicyHistoryClient is a client for the InternalPolicyHistory schema.
type InternalPolicyHistoryClient struct {
	config
}

// NewInternalPolicyHistoryClient returns a client for the InternalPolicyHistory from the given config.
func NewInternalPolicyHistoryClient(c config) *InternalPolicyHistoryClient {
	return &InternalPolicyHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `internalpolicyhistory.Hooks(f(g(h())))`.
func (c *InternalPolicyHistoryClient) Use(hooks ...Hook) {
	c.hooks.InternalPolicyHistory = append(c.hooks.InternalPolicyHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `internalpolicyhistory.Intercept(f(g(h())))`.
func (c *InternalPolicyHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.InternalPolicyHistory = append(c.inters.InternalPolicyHistory, interceptors...)
}

// Create returns a builder for creating a InternalPolicyHistory entity.
func (c *InternalPolicyHistoryClient) Create() *InternalPolicyHistoryCreate {
	mutation := newInternalPolicyHistoryMutation(c.config, OpCreate)
	return &InternalPolicyHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InternalPolicyHistory entities.
func (c *InternalPolicyHistoryClient) CreateBulk(builders ...*InternalPolicyHistoryCreate) *InternalPolicyHistoryCreateBulk {
	return &InternalPolicyHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InternalPolicyHistoryClient) MapCreateBulk(slice any, setFunc func(*InternalPolicyHistoryCreate, int)) *InternalPolicyHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InternalPolicyHistoryCreateBulk{err: fmt.Errorf("calling to InternalPolicyHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InternalPolicyHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InternalPolicyHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InternalPolicyHistory.
func (c *InternalPolicyHistoryClient) Update() *InternalPolicyHistoryUpdate {
	mutation := newInternalPolicyHistoryMutation(c.config, OpUpdate)
	return &InternalPolicyHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InternalPolicyHistoryClient) UpdateOne(_m *InternalPolicyHistory) *InternalPolicyHistoryUpdateOne {
	mutation := newInternalPolicyHistoryMutation(c.config, OpUpdateOne, withInternalPolicyHistory(_m))
	return &InternalPolicyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InternalPolicyHistoryClient) UpdateOneID(id string) *InternalPolicyHistoryUpdateOne {
	mutation := newInternalPolicyHistoryMutation(c.config, OpUpdateOne, withInternalPolicyHistoryID(id))
	return &InternalPolicyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InternalPolicyHistory.
func (c *InternalPolicyHistoryClient) Delete() *InternalPolicyHistoryDelete {
	mutation := newInternalPolicyHistoryMutation(c.config, OpDelete)
	return &InternalPolicyHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InternalPolicyHistoryClient) DeleteOne(_m *InternalPolicyHistory) *InternalPolicyHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InternalPolicyHistoryClient) DeleteOneID(id string) *InternalPolicyHistoryDeleteOne {
	builder := c.Delete().Where(internalpolicyhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InternalPolicyHistoryDeleteOne{builder}
}

// Query returns a query builder for InternalPolicyHistory.
func (c *InternalPolicyHistoryClient) Query() *InternalPolicyHistoryQuery {
	return &InternalPolicyHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInternalPolicyHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a InternalPolicyHistory entity by its id.
func (c *InternalPolicyHistoryClient) Get(ctx context.Context, id string) (*InternalPolicyHistory, error) {
	return c.Query().Where(internalpolicyhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InternalPolicyHistoryClient) GetX(ctx context.Context, id string) *InternalPolicyHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InternalPolicyHistoryClient) Hooks() []Hook {
	hooks := c.hooks.InternalPolicyHistory
	return append(hooks[:len(hooks):len(hooks)], internalpolicyhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InternalPolicyHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.InternalPolicyHistory
	return append(inters[:len(inters):len(inters)], internalpolicyhistory.Interceptors[:]...)
}

func (c *InternalPolicyHistoryClient) mutate(ctx context.Context, m *InternalPolicyHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InternalPolicyHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InternalPolicyHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InternalPolicyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InternalPolicyHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown InternalPolicyHistory mutation op: %q", m.Op())
	}
}

// InviteClient is a client for the Invite schema.
type InviteClient struct {
	config
}

// NewInviteClient returns a client for the Invite from the given config.
func NewInviteClient(c config) *InviteClient {
	return &InviteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invite.Hooks(f(g(h())))`.
func (c *InviteClient) Use(hooks ...Hook) {
	c.hooks.Invite = append(c.hooks.Invite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invite.Intercept(f(g(h())))`.
func (c *InviteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invite = append(c.inters.Invite, interceptors...)
}

// Create returns a builder for creating a Invite entity.
func (c *InviteClient) Create() *InviteCreate {
	mutation := newInviteMutation(c.config, OpCreate)
	return &InviteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invite entities.
func (c *InviteClient) CreateBulk(builders ...*InviteCreate) *InviteCreateBulk {
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InviteClient) MapCreateBulk(slice any, setFunc func(*InviteCreate, int)) *InviteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InviteCreateBulk{err: fmt.Errorf("calling to InviteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InviteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invite.
func (c *InviteClient) Update() *InviteUpdate {
	mutation := newInviteMutation(c.config, OpUpdate)
	return &InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InviteClient) UpdateOne(_m *Invite) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInvite(_m))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InviteClient) UpdateOneID(id string) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInviteID(id))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invite.
func (c *InviteClient) Delete() *InviteDelete {
	mutation := newInviteMutation(c.config, OpDelete)
	return &InviteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InviteClient) DeleteOne(_m *Invite) *InviteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InviteClient) DeleteOneID(id string) *InviteDeleteOne {
	builder := c.Delete().Where(invite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InviteDeleteOne{builder}
}

// Query returns a query builder for Invite.
func (c *InviteClient) Query() *InviteQuery {
	return &InviteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvite},
		inters: c.Interceptors(),
	}
}

// Get returns a Invite entity by its id.
func (c *InviteClient) Get(ctx context.Context, id string) (*Invite, error) {
	return c.Query().Where(invite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InviteClient) GetX(ctx context.Context, id string) *Invite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Invite.
func (c *InviteClient) QueryOwner(_m *Invite) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite.OwnerTable, invite.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Invite
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Invite.
func (c *InviteClient) QueryEvents(_m *Invite) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, invite.EventsTable, invite.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.InviteEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Invite.
func (c *InviteClient) QueryGroups(_m *Invite) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, invite.GroupsTable, invite.GroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.InviteGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InviteClient) Hooks() []Hook {
	hooks := c.hooks.Invite
	return append(hooks[:len(hooks):len(hooks)], invite.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InviteClient) Interceptors() []Interceptor {
	inters := c.inters.Invite
	return append(inters[:len(inters):len(inters)], invite.Interceptors[:]...)
}

func (c *InviteClient) mutate(ctx context.Context, m *InviteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InviteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InviteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Invite mutation op: %q", m.Op())
	}
}

// JobResultClient is a client for the JobResult schema.
type JobResultClient struct {
	config
}

// NewJobResultClient returns a client for the JobResult from the given config.
func NewJobResultClient(c config) *JobResultClient {
	return &JobResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobresult.Hooks(f(g(h())))`.
func (c *JobResultClient) Use(hooks ...Hook) {
	c.hooks.JobResult = append(c.hooks.JobResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobresult.Intercept(f(g(h())))`.
func (c *JobResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobResult = append(c.inters.JobResult, interceptors...)
}

// Create returns a builder for creating a JobResult entity.
func (c *JobResultClient) Create() *JobResultCreate {
	mutation := newJobResultMutation(c.config, OpCreate)
	return &JobResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobResult entities.
func (c *JobResultClient) CreateBulk(builders ...*JobResultCreate) *JobResultCreateBulk {
	return &JobResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobResultClient) MapCreateBulk(slice any, setFunc func(*JobResultCreate, int)) *JobResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobResultCreateBulk{err: fmt.Errorf("calling to JobResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobResult.
func (c *JobResultClient) Update() *JobResultUpdate {
	mutation := newJobResultMutation(c.config, OpUpdate)
	return &JobResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobResultClient) UpdateOne(_m *JobResult) *JobResultUpdateOne {
	mutation := newJobResultMutation(c.config, OpUpdateOne, withJobResult(_m))
	return &JobResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobResultClient) UpdateOneID(id string) *JobResultUpdateOne {
	mutation := newJobResultMutation(c.config, OpUpdateOne, withJobResultID(id))
	return &JobResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobResult.
func (c *JobResultClient) Delete() *JobResultDelete {
	mutation := newJobResultMutation(c.config, OpDelete)
	return &JobResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobResultClient) DeleteOne(_m *JobResult) *JobResultDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobResultClient) DeleteOneID(id string) *JobResultDeleteOne {
	builder := c.Delete().Where(jobresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobResultDeleteOne{builder}
}

// Query returns a query builder for JobResult.
func (c *JobResultClient) Query() *JobResultQuery {
	return &JobResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobResult},
		inters: c.Interceptors(),
	}
}

// Get returns a JobResult entity by its id.
func (c *JobResultClient) Get(ctx context.Context, id string) (*JobResult, error) {
	return c.Query().Where(jobresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobResultClient) GetX(ctx context.Context, id string) *JobResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a JobResult.
func (c *JobResultClient) QueryOwner(_m *JobResult) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobresult.Table, jobresult.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobresult.OwnerTable, jobresult.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.JobResult
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJob queries the scheduled_job edge of a JobResult.
func (c *JobResultClient) QueryScheduledJob(_m *JobResult) *ScheduledJobQuery {
	query := (&ScheduledJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobresult.Table, jobresult.FieldID, id),
			sqlgraph.To(scheduledjob.Table, scheduledjob.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, jobresult.ScheduledJobTable, jobresult.ScheduledJobColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJob
		step.Edge.Schema = schemaConfig.JobResult
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a JobResult.
func (c *JobResultClient) QueryFile(_m *JobResult) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobresult.Table, jobresult.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, jobresult.FileTable, jobresult.FileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.JobResult
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobResultClient) Hooks() []Hook {
	hooks := c.hooks.JobResult
	return append(hooks[:len(hooks):len(hooks)], jobresult.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *JobResultClient) Interceptors() []Interceptor {
	inters := c.inters.JobResult
	return append(inters[:len(inters):len(inters)], jobresult.Interceptors[:]...)
}

func (c *JobResultClient) mutate(ctx context.Context, m *JobResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown JobResult mutation op: %q", m.Op())
	}
}

// JobRunnerClient is a client for the JobRunner schema.
type JobRunnerClient struct {
	config
}

// NewJobRunnerClient returns a client for the JobRunner from the given config.
func NewJobRunnerClient(c config) *JobRunnerClient {
	return &JobRunnerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobrunner.Hooks(f(g(h())))`.
func (c *JobRunnerClient) Use(hooks ...Hook) {
	c.hooks.JobRunner = append(c.hooks.JobRunner, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobrunner.Intercept(f(g(h())))`.
func (c *JobRunnerClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobRunner = append(c.inters.JobRunner, interceptors...)
}

// Create returns a builder for creating a JobRunner entity.
func (c *JobRunnerClient) Create() *JobRunnerCreate {
	mutation := newJobRunnerMutation(c.config, OpCreate)
	return &JobRunnerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobRunner entities.
func (c *JobRunnerClient) CreateBulk(builders ...*JobRunnerCreate) *JobRunnerCreateBulk {
	return &JobRunnerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobRunnerClient) MapCreateBulk(slice any, setFunc func(*JobRunnerCreate, int)) *JobRunnerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobRunnerCreateBulk{err: fmt.Errorf("calling to JobRunnerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobRunnerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobRunnerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobRunner.
func (c *JobRunnerClient) Update() *JobRunnerUpdate {
	mutation := newJobRunnerMutation(c.config, OpUpdate)
	return &JobRunnerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobRunnerClient) UpdateOne(_m *JobRunner) *JobRunnerUpdateOne {
	mutation := newJobRunnerMutation(c.config, OpUpdateOne, withJobRunner(_m))
	return &JobRunnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobRunnerClient) UpdateOneID(id string) *JobRunnerUpdateOne {
	mutation := newJobRunnerMutation(c.config, OpUpdateOne, withJobRunnerID(id))
	return &JobRunnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobRunner.
func (c *JobRunnerClient) Delete() *JobRunnerDelete {
	mutation := newJobRunnerMutation(c.config, OpDelete)
	return &JobRunnerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobRunnerClient) DeleteOne(_m *JobRunner) *JobRunnerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobRunnerClient) DeleteOneID(id string) *JobRunnerDeleteOne {
	builder := c.Delete().Where(jobrunner.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobRunnerDeleteOne{builder}
}

// Query returns a query builder for JobRunner.
func (c *JobRunnerClient) Query() *JobRunnerQuery {
	return &JobRunnerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobRunner},
		inters: c.Interceptors(),
	}
}

// Get returns a JobRunner entity by its id.
func (c *JobRunnerClient) Get(ctx context.Context, id string) (*JobRunner, error) {
	return c.Query().Where(jobrunner.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobRunnerClient) GetX(ctx context.Context, id string) *JobRunner {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a JobRunner.
func (c *JobRunnerClient) QueryOwner(_m *JobRunner) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobrunner.Table, jobrunner.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobrunner.OwnerTable, jobrunner.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.JobRunner
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunnerTokens queries the job_runner_tokens edge of a JobRunner.
func (c *JobRunnerClient) QueryJobRunnerTokens(_m *JobRunner) *JobRunnerTokenQuery {
	query := (&JobRunnerTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobrunner.Table, jobrunner.FieldID, id),
			sqlgraph.To(jobrunnertoken.Table, jobrunnertoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, jobrunner.JobRunnerTokensTable, jobrunner.JobRunnerTokensPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunnerToken
		step.Edge.Schema = schemaConfig.JobRunnerJobRunnerTokens
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobRunnerClient) Hooks() []Hook {
	hooks := c.hooks.JobRunner
	return append(hooks[:len(hooks):len(hooks)], jobrunner.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *JobRunnerClient) Interceptors() []Interceptor {
	inters := c.inters.JobRunner
	return append(inters[:len(inters):len(inters)], jobrunner.Interceptors[:]...)
}

func (c *JobRunnerClient) mutate(ctx context.Context, m *JobRunnerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobRunnerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobRunnerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobRunnerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobRunnerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown JobRunner mutation op: %q", m.Op())
	}
}

// JobRunnerRegistrationTokenClient is a client for the JobRunnerRegistrationToken schema.
type JobRunnerRegistrationTokenClient struct {
	config
}

// NewJobRunnerRegistrationTokenClient returns a client for the JobRunnerRegistrationToken from the given config.
func NewJobRunnerRegistrationTokenClient(c config) *JobRunnerRegistrationTokenClient {
	return &JobRunnerRegistrationTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobrunnerregistrationtoken.Hooks(f(g(h())))`.
func (c *JobRunnerRegistrationTokenClient) Use(hooks ...Hook) {
	c.hooks.JobRunnerRegistrationToken = append(c.hooks.JobRunnerRegistrationToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobrunnerregistrationtoken.Intercept(f(g(h())))`.
func (c *JobRunnerRegistrationTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobRunnerRegistrationToken = append(c.inters.JobRunnerRegistrationToken, interceptors...)
}

// Create returns a builder for creating a JobRunnerRegistrationToken entity.
func (c *JobRunnerRegistrationTokenClient) Create() *JobRunnerRegistrationTokenCreate {
	mutation := newJobRunnerRegistrationTokenMutation(c.config, OpCreate)
	return &JobRunnerRegistrationTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobRunnerRegistrationToken entities.
func (c *JobRunnerRegistrationTokenClient) CreateBulk(builders ...*JobRunnerRegistrationTokenCreate) *JobRunnerRegistrationTokenCreateBulk {
	return &JobRunnerRegistrationTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobRunnerRegistrationTokenClient) MapCreateBulk(slice any, setFunc func(*JobRunnerRegistrationTokenCreate, int)) *JobRunnerRegistrationTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobRunnerRegistrationTokenCreateBulk{err: fmt.Errorf("calling to JobRunnerRegistrationTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobRunnerRegistrationTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobRunnerRegistrationTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobRunnerRegistrationToken.
func (c *JobRunnerRegistrationTokenClient) Update() *JobRunnerRegistrationTokenUpdate {
	mutation := newJobRunnerRegistrationTokenMutation(c.config, OpUpdate)
	return &JobRunnerRegistrationTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobRunnerRegistrationTokenClient) UpdateOne(_m *JobRunnerRegistrationToken) *JobRunnerRegistrationTokenUpdateOne {
	mutation := newJobRunnerRegistrationTokenMutation(c.config, OpUpdateOne, withJobRunnerRegistrationToken(_m))
	return &JobRunnerRegistrationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobRunnerRegistrationTokenClient) UpdateOneID(id string) *JobRunnerRegistrationTokenUpdateOne {
	mutation := newJobRunnerRegistrationTokenMutation(c.config, OpUpdateOne, withJobRunnerRegistrationTokenID(id))
	return &JobRunnerRegistrationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobRunnerRegistrationToken.
func (c *JobRunnerRegistrationTokenClient) Delete() *JobRunnerRegistrationTokenDelete {
	mutation := newJobRunnerRegistrationTokenMutation(c.config, OpDelete)
	return &JobRunnerRegistrationTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobRunnerRegistrationTokenClient) DeleteOne(_m *JobRunnerRegistrationToken) *JobRunnerRegistrationTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobRunnerRegistrationTokenClient) DeleteOneID(id string) *JobRunnerRegistrationTokenDeleteOne {
	builder := c.Delete().Where(jobrunnerregistrationtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobRunnerRegistrationTokenDeleteOne{builder}
}

// Query returns a query builder for JobRunnerRegistrationToken.
func (c *JobRunnerRegistrationTokenClient) Query() *JobRunnerRegistrationTokenQuery {
	return &JobRunnerRegistrationTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobRunnerRegistrationToken},
		inters: c.Interceptors(),
	}
}

// Get returns a JobRunnerRegistrationToken entity by its id.
func (c *JobRunnerRegistrationTokenClient) Get(ctx context.Context, id string) (*JobRunnerRegistrationToken, error) {
	return c.Query().Where(jobrunnerregistrationtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobRunnerRegistrationTokenClient) GetX(ctx context.Context, id string) *JobRunnerRegistrationToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a JobRunnerRegistrationToken.
func (c *JobRunnerRegistrationTokenClient) QueryOwner(_m *JobRunnerRegistrationToken) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobrunnerregistrationtoken.Table, jobrunnerregistrationtoken.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobrunnerregistrationtoken.OwnerTable, jobrunnerregistrationtoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.JobRunnerRegistrationToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunner queries the job_runner edge of a JobRunnerRegistrationToken.
func (c *JobRunnerRegistrationTokenClient) QueryJobRunner(_m *JobRunnerRegistrationToken) *JobRunnerQuery {
	query := (&JobRunnerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobrunnerregistrationtoken.Table, jobrunnerregistrationtoken.FieldID, id),
			sqlgraph.To(jobrunner.Table, jobrunner.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, jobrunnerregistrationtoken.JobRunnerTable, jobrunnerregistrationtoken.JobRunnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunner
		step.Edge.Schema = schemaConfig.JobRunnerRegistrationToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobRunnerRegistrationTokenClient) Hooks() []Hook {
	hooks := c.hooks.JobRunnerRegistrationToken
	return append(hooks[:len(hooks):len(hooks)], jobrunnerregistrationtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *JobRunnerRegistrationTokenClient) Interceptors() []Interceptor {
	inters := c.inters.JobRunnerRegistrationToken
	return append(inters[:len(inters):len(inters)], jobrunnerregistrationtoken.Interceptors[:]...)
}

func (c *JobRunnerRegistrationTokenClient) mutate(ctx context.Context, m *JobRunnerRegistrationTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobRunnerRegistrationTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobRunnerRegistrationTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobRunnerRegistrationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobRunnerRegistrationTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown JobRunnerRegistrationToken mutation op: %q", m.Op())
	}
}

// JobRunnerTokenClient is a client for the JobRunnerToken schema.
type JobRunnerTokenClient struct {
	config
}

// NewJobRunnerTokenClient returns a client for the JobRunnerToken from the given config.
func NewJobRunnerTokenClient(c config) *JobRunnerTokenClient {
	return &JobRunnerTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobrunnertoken.Hooks(f(g(h())))`.
func (c *JobRunnerTokenClient) Use(hooks ...Hook) {
	c.hooks.JobRunnerToken = append(c.hooks.JobRunnerToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobrunnertoken.Intercept(f(g(h())))`.
func (c *JobRunnerTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobRunnerToken = append(c.inters.JobRunnerToken, interceptors...)
}

// Create returns a builder for creating a JobRunnerToken entity.
func (c *JobRunnerTokenClient) Create() *JobRunnerTokenCreate {
	mutation := newJobRunnerTokenMutation(c.config, OpCreate)
	return &JobRunnerTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobRunnerToken entities.
func (c *JobRunnerTokenClient) CreateBulk(builders ...*JobRunnerTokenCreate) *JobRunnerTokenCreateBulk {
	return &JobRunnerTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobRunnerTokenClient) MapCreateBulk(slice any, setFunc func(*JobRunnerTokenCreate, int)) *JobRunnerTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobRunnerTokenCreateBulk{err: fmt.Errorf("calling to JobRunnerTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobRunnerTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobRunnerTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobRunnerToken.
func (c *JobRunnerTokenClient) Update() *JobRunnerTokenUpdate {
	mutation := newJobRunnerTokenMutation(c.config, OpUpdate)
	return &JobRunnerTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobRunnerTokenClient) UpdateOne(_m *JobRunnerToken) *JobRunnerTokenUpdateOne {
	mutation := newJobRunnerTokenMutation(c.config, OpUpdateOne, withJobRunnerToken(_m))
	return &JobRunnerTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobRunnerTokenClient) UpdateOneID(id string) *JobRunnerTokenUpdateOne {
	mutation := newJobRunnerTokenMutation(c.config, OpUpdateOne, withJobRunnerTokenID(id))
	return &JobRunnerTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobRunnerToken.
func (c *JobRunnerTokenClient) Delete() *JobRunnerTokenDelete {
	mutation := newJobRunnerTokenMutation(c.config, OpDelete)
	return &JobRunnerTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobRunnerTokenClient) DeleteOne(_m *JobRunnerToken) *JobRunnerTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobRunnerTokenClient) DeleteOneID(id string) *JobRunnerTokenDeleteOne {
	builder := c.Delete().Where(jobrunnertoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobRunnerTokenDeleteOne{builder}
}

// Query returns a query builder for JobRunnerToken.
func (c *JobRunnerTokenClient) Query() *JobRunnerTokenQuery {
	return &JobRunnerTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobRunnerToken},
		inters: c.Interceptors(),
	}
}

// Get returns a JobRunnerToken entity by its id.
func (c *JobRunnerTokenClient) Get(ctx context.Context, id string) (*JobRunnerToken, error) {
	return c.Query().Where(jobrunnertoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobRunnerTokenClient) GetX(ctx context.Context, id string) *JobRunnerToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a JobRunnerToken.
func (c *JobRunnerTokenClient) QueryOwner(_m *JobRunnerToken) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobrunnertoken.Table, jobrunnertoken.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobrunnertoken.OwnerTable, jobrunnertoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.JobRunnerToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunners queries the job_runners edge of a JobRunnerToken.
func (c *JobRunnerTokenClient) QueryJobRunners(_m *JobRunnerToken) *JobRunnerQuery {
	query := (&JobRunnerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobrunnertoken.Table, jobrunnertoken.FieldID, id),
			sqlgraph.To(jobrunner.Table, jobrunner.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, jobrunnertoken.JobRunnersTable, jobrunnertoken.JobRunnersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunner
		step.Edge.Schema = schemaConfig.JobRunnerJobRunnerTokens
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobRunnerTokenClient) Hooks() []Hook {
	hooks := c.hooks.JobRunnerToken
	return append(hooks[:len(hooks):len(hooks)], jobrunnertoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *JobRunnerTokenClient) Interceptors() []Interceptor {
	inters := c.inters.JobRunnerToken
	return append(inters[:len(inters):len(inters)], jobrunnertoken.Interceptors[:]...)
}

func (c *JobRunnerTokenClient) mutate(ctx context.Context, m *JobRunnerTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobRunnerTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobRunnerTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobRunnerTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobRunnerTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown JobRunnerToken mutation op: %q", m.Op())
	}
}

// JobTemplateClient is a client for the JobTemplate schema.
type JobTemplateClient struct {
	config
}

// NewJobTemplateClient returns a client for the JobTemplate from the given config.
func NewJobTemplateClient(c config) *JobTemplateClient {
	return &JobTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobtemplate.Hooks(f(g(h())))`.
func (c *JobTemplateClient) Use(hooks ...Hook) {
	c.hooks.JobTemplate = append(c.hooks.JobTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobtemplate.Intercept(f(g(h())))`.
func (c *JobTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobTemplate = append(c.inters.JobTemplate, interceptors...)
}

// Create returns a builder for creating a JobTemplate entity.
func (c *JobTemplateClient) Create() *JobTemplateCreate {
	mutation := newJobTemplateMutation(c.config, OpCreate)
	return &JobTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobTemplate entities.
func (c *JobTemplateClient) CreateBulk(builders ...*JobTemplateCreate) *JobTemplateCreateBulk {
	return &JobTemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobTemplateClient) MapCreateBulk(slice any, setFunc func(*JobTemplateCreate, int)) *JobTemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobTemplateCreateBulk{err: fmt.Errorf("calling to JobTemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobTemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobTemplate.
func (c *JobTemplateClient) Update() *JobTemplateUpdate {
	mutation := newJobTemplateMutation(c.config, OpUpdate)
	return &JobTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobTemplateClient) UpdateOne(_m *JobTemplate) *JobTemplateUpdateOne {
	mutation := newJobTemplateMutation(c.config, OpUpdateOne, withJobTemplate(_m))
	return &JobTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobTemplateClient) UpdateOneID(id string) *JobTemplateUpdateOne {
	mutation := newJobTemplateMutation(c.config, OpUpdateOne, withJobTemplateID(id))
	return &JobTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobTemplate.
func (c *JobTemplateClient) Delete() *JobTemplateDelete {
	mutation := newJobTemplateMutation(c.config, OpDelete)
	return &JobTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobTemplateClient) DeleteOne(_m *JobTemplate) *JobTemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobTemplateClient) DeleteOneID(id string) *JobTemplateDeleteOne {
	builder := c.Delete().Where(jobtemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobTemplateDeleteOne{builder}
}

// Query returns a query builder for JobTemplate.
func (c *JobTemplateClient) Query() *JobTemplateQuery {
	return &JobTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a JobTemplate entity by its id.
func (c *JobTemplateClient) Get(ctx context.Context, id string) (*JobTemplate, error) {
	return c.Query().Where(jobtemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobTemplateClient) GetX(ctx context.Context, id string) *JobTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a JobTemplate.
func (c *JobTemplateClient) QueryOwner(_m *JobTemplate) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobtemplate.Table, jobtemplate.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobtemplate.OwnerTable, jobtemplate.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.JobTemplate
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJobs queries the scheduled_jobs edge of a JobTemplate.
func (c *JobTemplateClient) QueryScheduledJobs(_m *JobTemplate) *ScheduledJobQuery {
	query := (&ScheduledJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobtemplate.Table, jobtemplate.FieldID, id),
			sqlgraph.To(scheduledjob.Table, scheduledjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, jobtemplate.ScheduledJobsTable, jobtemplate.ScheduledJobsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJob
		step.Edge.Schema = schemaConfig.ScheduledJob
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobTemplateClient) Hooks() []Hook {
	hooks := c.hooks.JobTemplate
	return append(hooks[:len(hooks):len(hooks)], jobtemplate.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *JobTemplateClient) Interceptors() []Interceptor {
	inters := c.inters.JobTemplate
	return append(inters[:len(inters):len(inters)], jobtemplate.Interceptors[:]...)
}

func (c *JobTemplateClient) mutate(ctx context.Context, m *JobTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown JobTemplate mutation op: %q", m.Op())
	}
}

// JobTemplateHistoryClient is a client for the JobTemplateHistory schema.
type JobTemplateHistoryClient struct {
	config
}

// NewJobTemplateHistoryClient returns a client for the JobTemplateHistory from the given config.
func NewJobTemplateHistoryClient(c config) *JobTemplateHistoryClient {
	return &JobTemplateHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobtemplatehistory.Hooks(f(g(h())))`.
func (c *JobTemplateHistoryClient) Use(hooks ...Hook) {
	c.hooks.JobTemplateHistory = append(c.hooks.JobTemplateHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobtemplatehistory.Intercept(f(g(h())))`.
func (c *JobTemplateHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobTemplateHistory = append(c.inters.JobTemplateHistory, interceptors...)
}

// Create returns a builder for creating a JobTemplateHistory entity.
func (c *JobTemplateHistoryClient) Create() *JobTemplateHistoryCreate {
	mutation := newJobTemplateHistoryMutation(c.config, OpCreate)
	return &JobTemplateHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobTemplateHistory entities.
func (c *JobTemplateHistoryClient) CreateBulk(builders ...*JobTemplateHistoryCreate) *JobTemplateHistoryCreateBulk {
	return &JobTemplateHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobTemplateHistoryClient) MapCreateBulk(slice any, setFunc func(*JobTemplateHistoryCreate, int)) *JobTemplateHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobTemplateHistoryCreateBulk{err: fmt.Errorf("calling to JobTemplateHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobTemplateHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobTemplateHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobTemplateHistory.
func (c *JobTemplateHistoryClient) Update() *JobTemplateHistoryUpdate {
	mutation := newJobTemplateHistoryMutation(c.config, OpUpdate)
	return &JobTemplateHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobTemplateHistoryClient) UpdateOne(_m *JobTemplateHistory) *JobTemplateHistoryUpdateOne {
	mutation := newJobTemplateHistoryMutation(c.config, OpUpdateOne, withJobTemplateHistory(_m))
	return &JobTemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobTemplateHistoryClient) UpdateOneID(id string) *JobTemplateHistoryUpdateOne {
	mutation := newJobTemplateHistoryMutation(c.config, OpUpdateOne, withJobTemplateHistoryID(id))
	return &JobTemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobTemplateHistory.
func (c *JobTemplateHistoryClient) Delete() *JobTemplateHistoryDelete {
	mutation := newJobTemplateHistoryMutation(c.config, OpDelete)
	return &JobTemplateHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobTemplateHistoryClient) DeleteOne(_m *JobTemplateHistory) *JobTemplateHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobTemplateHistoryClient) DeleteOneID(id string) *JobTemplateHistoryDeleteOne {
	builder := c.Delete().Where(jobtemplatehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobTemplateHistoryDeleteOne{builder}
}

// Query returns a query builder for JobTemplateHistory.
func (c *JobTemplateHistoryClient) Query() *JobTemplateHistoryQuery {
	return &JobTemplateHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobTemplateHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a JobTemplateHistory entity by its id.
func (c *JobTemplateHistoryClient) Get(ctx context.Context, id string) (*JobTemplateHistory, error) {
	return c.Query().Where(jobtemplatehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobTemplateHistoryClient) GetX(ctx context.Context, id string) *JobTemplateHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *JobTemplateHistoryClient) Hooks() []Hook {
	hooks := c.hooks.JobTemplateHistory
	return append(hooks[:len(hooks):len(hooks)], jobtemplatehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *JobTemplateHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.JobTemplateHistory
	return append(inters[:len(inters):len(inters)], jobtemplatehistory.Interceptors[:]...)
}

func (c *JobTemplateHistoryClient) mutate(ctx context.Context, m *JobTemplateHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobTemplateHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobTemplateHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobTemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobTemplateHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown JobTemplateHistory mutation op: %q", m.Op())
	}
}

// MappableDomainClient is a client for the MappableDomain schema.
type MappableDomainClient struct {
	config
}

// NewMappableDomainClient returns a client for the MappableDomain from the given config.
func NewMappableDomainClient(c config) *MappableDomainClient {
	return &MappableDomainClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mappabledomain.Hooks(f(g(h())))`.
func (c *MappableDomainClient) Use(hooks ...Hook) {
	c.hooks.MappableDomain = append(c.hooks.MappableDomain, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mappabledomain.Intercept(f(g(h())))`.
func (c *MappableDomainClient) Intercept(interceptors ...Interceptor) {
	c.inters.MappableDomain = append(c.inters.MappableDomain, interceptors...)
}

// Create returns a builder for creating a MappableDomain entity.
func (c *MappableDomainClient) Create() *MappableDomainCreate {
	mutation := newMappableDomainMutation(c.config, OpCreate)
	return &MappableDomainCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MappableDomain entities.
func (c *MappableDomainClient) CreateBulk(builders ...*MappableDomainCreate) *MappableDomainCreateBulk {
	return &MappableDomainCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MappableDomainClient) MapCreateBulk(slice any, setFunc func(*MappableDomainCreate, int)) *MappableDomainCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MappableDomainCreateBulk{err: fmt.Errorf("calling to MappableDomainClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MappableDomainCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MappableDomainCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MappableDomain.
func (c *MappableDomainClient) Update() *MappableDomainUpdate {
	mutation := newMappableDomainMutation(c.config, OpUpdate)
	return &MappableDomainUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MappableDomainClient) UpdateOne(_m *MappableDomain) *MappableDomainUpdateOne {
	mutation := newMappableDomainMutation(c.config, OpUpdateOne, withMappableDomain(_m))
	return &MappableDomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MappableDomainClient) UpdateOneID(id string) *MappableDomainUpdateOne {
	mutation := newMappableDomainMutation(c.config, OpUpdateOne, withMappableDomainID(id))
	return &MappableDomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MappableDomain.
func (c *MappableDomainClient) Delete() *MappableDomainDelete {
	mutation := newMappableDomainMutation(c.config, OpDelete)
	return &MappableDomainDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MappableDomainClient) DeleteOne(_m *MappableDomain) *MappableDomainDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MappableDomainClient) DeleteOneID(id string) *MappableDomainDeleteOne {
	builder := c.Delete().Where(mappabledomain.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MappableDomainDeleteOne{builder}
}

// Query returns a query builder for MappableDomain.
func (c *MappableDomainClient) Query() *MappableDomainQuery {
	return &MappableDomainQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMappableDomain},
		inters: c.Interceptors(),
	}
}

// Get returns a MappableDomain entity by its id.
func (c *MappableDomainClient) Get(ctx context.Context, id string) (*MappableDomain, error) {
	return c.Query().Where(mappabledomain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MappableDomainClient) GetX(ctx context.Context, id string) *MappableDomain {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomDomains queries the custom_domains edge of a MappableDomain.
func (c *MappableDomainClient) QueryCustomDomains(_m *MappableDomain) *CustomDomainQuery {
	query := (&CustomDomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappabledomain.Table, mappabledomain.FieldID, id),
			sqlgraph.To(customdomain.Table, customdomain.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mappabledomain.CustomDomainsTable, mappabledomain.CustomDomainsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomDomain
		step.Edge.Schema = schemaConfig.CustomDomain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MappableDomainClient) Hooks() []Hook {
	hooks := c.hooks.MappableDomain
	return append(hooks[:len(hooks):len(hooks)], mappabledomain.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MappableDomainClient) Interceptors() []Interceptor {
	inters := c.inters.MappableDomain
	return append(inters[:len(inters):len(inters)], mappabledomain.Interceptors[:]...)
}

func (c *MappableDomainClient) mutate(ctx context.Context, m *MappableDomainMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MappableDomainCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MappableDomainUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MappableDomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MappableDomainDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown MappableDomain mutation op: %q", m.Op())
	}
}

// MappableDomainHistoryClient is a client for the MappableDomainHistory schema.
type MappableDomainHistoryClient struct {
	config
}

// NewMappableDomainHistoryClient returns a client for the MappableDomainHistory from the given config.
func NewMappableDomainHistoryClient(c config) *MappableDomainHistoryClient {
	return &MappableDomainHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mappabledomainhistory.Hooks(f(g(h())))`.
func (c *MappableDomainHistoryClient) Use(hooks ...Hook) {
	c.hooks.MappableDomainHistory = append(c.hooks.MappableDomainHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mappabledomainhistory.Intercept(f(g(h())))`.
func (c *MappableDomainHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.MappableDomainHistory = append(c.inters.MappableDomainHistory, interceptors...)
}

// Create returns a builder for creating a MappableDomainHistory entity.
func (c *MappableDomainHistoryClient) Create() *MappableDomainHistoryCreate {
	mutation := newMappableDomainHistoryMutation(c.config, OpCreate)
	return &MappableDomainHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MappableDomainHistory entities.
func (c *MappableDomainHistoryClient) CreateBulk(builders ...*MappableDomainHistoryCreate) *MappableDomainHistoryCreateBulk {
	return &MappableDomainHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MappableDomainHistoryClient) MapCreateBulk(slice any, setFunc func(*MappableDomainHistoryCreate, int)) *MappableDomainHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MappableDomainHistoryCreateBulk{err: fmt.Errorf("calling to MappableDomainHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MappableDomainHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MappableDomainHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MappableDomainHistory.
func (c *MappableDomainHistoryClient) Update() *MappableDomainHistoryUpdate {
	mutation := newMappableDomainHistoryMutation(c.config, OpUpdate)
	return &MappableDomainHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MappableDomainHistoryClient) UpdateOne(_m *MappableDomainHistory) *MappableDomainHistoryUpdateOne {
	mutation := newMappableDomainHistoryMutation(c.config, OpUpdateOne, withMappableDomainHistory(_m))
	return &MappableDomainHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MappableDomainHistoryClient) UpdateOneID(id string) *MappableDomainHistoryUpdateOne {
	mutation := newMappableDomainHistoryMutation(c.config, OpUpdateOne, withMappableDomainHistoryID(id))
	return &MappableDomainHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MappableDomainHistory.
func (c *MappableDomainHistoryClient) Delete() *MappableDomainHistoryDelete {
	mutation := newMappableDomainHistoryMutation(c.config, OpDelete)
	return &MappableDomainHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MappableDomainHistoryClient) DeleteOne(_m *MappableDomainHistory) *MappableDomainHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MappableDomainHistoryClient) DeleteOneID(id string) *MappableDomainHistoryDeleteOne {
	builder := c.Delete().Where(mappabledomainhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MappableDomainHistoryDeleteOne{builder}
}

// Query returns a query builder for MappableDomainHistory.
func (c *MappableDomainHistoryClient) Query() *MappableDomainHistoryQuery {
	return &MappableDomainHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMappableDomainHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a MappableDomainHistory entity by its id.
func (c *MappableDomainHistoryClient) Get(ctx context.Context, id string) (*MappableDomainHistory, error) {
	return c.Query().Where(mappabledomainhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MappableDomainHistoryClient) GetX(ctx context.Context, id string) *MappableDomainHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MappableDomainHistoryClient) Hooks() []Hook {
	hooks := c.hooks.MappableDomainHistory
	return append(hooks[:len(hooks):len(hooks)], mappabledomainhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MappableDomainHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.MappableDomainHistory
	return append(inters[:len(inters):len(inters)], mappabledomainhistory.Interceptors[:]...)
}

func (c *MappableDomainHistoryClient) mutate(ctx context.Context, m *MappableDomainHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MappableDomainHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MappableDomainHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MappableDomainHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MappableDomainHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown MappableDomainHistory mutation op: %q", m.Op())
	}
}

// MappedControlClient is a client for the MappedControl schema.
type MappedControlClient struct {
	config
}

// NewMappedControlClient returns a client for the MappedControl from the given config.
func NewMappedControlClient(c config) *MappedControlClient {
	return &MappedControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mappedcontrol.Hooks(f(g(h())))`.
func (c *MappedControlClient) Use(hooks ...Hook) {
	c.hooks.MappedControl = append(c.hooks.MappedControl, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mappedcontrol.Intercept(f(g(h())))`.
func (c *MappedControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.MappedControl = append(c.inters.MappedControl, interceptors...)
}

// Create returns a builder for creating a MappedControl entity.
func (c *MappedControlClient) Create() *MappedControlCreate {
	mutation := newMappedControlMutation(c.config, OpCreate)
	return &MappedControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MappedControl entities.
func (c *MappedControlClient) CreateBulk(builders ...*MappedControlCreate) *MappedControlCreateBulk {
	return &MappedControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MappedControlClient) MapCreateBulk(slice any, setFunc func(*MappedControlCreate, int)) *MappedControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MappedControlCreateBulk{err: fmt.Errorf("calling to MappedControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MappedControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MappedControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MappedControl.
func (c *MappedControlClient) Update() *MappedControlUpdate {
	mutation := newMappedControlMutation(c.config, OpUpdate)
	return &MappedControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MappedControlClient) UpdateOne(_m *MappedControl) *MappedControlUpdateOne {
	mutation := newMappedControlMutation(c.config, OpUpdateOne, withMappedControl(_m))
	return &MappedControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MappedControlClient) UpdateOneID(id string) *MappedControlUpdateOne {
	mutation := newMappedControlMutation(c.config, OpUpdateOne, withMappedControlID(id))
	return &MappedControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MappedControl.
func (c *MappedControlClient) Delete() *MappedControlDelete {
	mutation := newMappedControlMutation(c.config, OpDelete)
	return &MappedControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MappedControlClient) DeleteOne(_m *MappedControl) *MappedControlDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MappedControlClient) DeleteOneID(id string) *MappedControlDeleteOne {
	builder := c.Delete().Where(mappedcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MappedControlDeleteOne{builder}
}

// Query returns a query builder for MappedControl.
func (c *MappedControlClient) Query() *MappedControlQuery {
	return &MappedControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMappedControl},
		inters: c.Interceptors(),
	}
}

// Get returns a MappedControl entity by its id.
func (c *MappedControlClient) Get(ctx context.Context, id string) (*MappedControl, error) {
	return c.Query().Where(mappedcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MappedControlClient) GetX(ctx context.Context, id string) *MappedControl {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a MappedControl.
func (c *MappedControlClient) QueryOwner(_m *MappedControl) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mappedcontrol.OwnerTable, mappedcontrol.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.MappedControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a MappedControl.
func (c *MappedControlClient) QueryBlockedGroups(_m *MappedControl) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, mappedcontrol.BlockedGroupsTable, mappedcontrol.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.MappedControlBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a MappedControl.
func (c *MappedControlClient) QueryEditors(_m *MappedControl) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, mappedcontrol.EditorsTable, mappedcontrol.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.MappedControlEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFromControls queries the from_controls edge of a MappedControl.
func (c *MappedControlClient) QueryFromControls(_m *MappedControl) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, mappedcontrol.FromControlsTable, mappedcontrol.FromControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.MappedControlFromControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToControls queries the to_controls edge of a MappedControl.
func (c *MappedControlClient) QueryToControls(_m *MappedControl) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, mappedcontrol.ToControlsTable, mappedcontrol.ToControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.MappedControlToControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFromSubcontrols queries the from_subcontrols edge of a MappedControl.
func (c *MappedControlClient) QueryFromSubcontrols(_m *MappedControl) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, mappedcontrol.FromSubcontrolsTable, mappedcontrol.FromSubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.MappedControlFromSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToSubcontrols queries the to_subcontrols edge of a MappedControl.
func (c *MappedControlClient) QueryToSubcontrols(_m *MappedControl) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mappedcontrol.Table, mappedcontrol.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, mappedcontrol.ToSubcontrolsTable, mappedcontrol.ToSubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.MappedControlToSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MappedControlClient) Hooks() []Hook {
	hooks := c.hooks.MappedControl
	return append(hooks[:len(hooks):len(hooks)], mappedcontrol.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MappedControlClient) Interceptors() []Interceptor {
	inters := c.inters.MappedControl
	return append(inters[:len(inters):len(inters)], mappedcontrol.Interceptors[:]...)
}

func (c *MappedControlClient) mutate(ctx context.Context, m *MappedControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MappedControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MappedControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MappedControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MappedControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown MappedControl mutation op: %q", m.Op())
	}
}

// MappedControlHistoryClient is a client for the MappedControlHistory schema.
type MappedControlHistoryClient struct {
	config
}

// NewMappedControlHistoryClient returns a client for the MappedControlHistory from the given config.
func NewMappedControlHistoryClient(c config) *MappedControlHistoryClient {
	return &MappedControlHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mappedcontrolhistory.Hooks(f(g(h())))`.
func (c *MappedControlHistoryClient) Use(hooks ...Hook) {
	c.hooks.MappedControlHistory = append(c.hooks.MappedControlHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mappedcontrolhistory.Intercept(f(g(h())))`.
func (c *MappedControlHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.MappedControlHistory = append(c.inters.MappedControlHistory, interceptors...)
}

// Create returns a builder for creating a MappedControlHistory entity.
func (c *MappedControlHistoryClient) Create() *MappedControlHistoryCreate {
	mutation := newMappedControlHistoryMutation(c.config, OpCreate)
	return &MappedControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MappedControlHistory entities.
func (c *MappedControlHistoryClient) CreateBulk(builders ...*MappedControlHistoryCreate) *MappedControlHistoryCreateBulk {
	return &MappedControlHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MappedControlHistoryClient) MapCreateBulk(slice any, setFunc func(*MappedControlHistoryCreate, int)) *MappedControlHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MappedControlHistoryCreateBulk{err: fmt.Errorf("calling to MappedControlHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MappedControlHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MappedControlHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MappedControlHistory.
func (c *MappedControlHistoryClient) Update() *MappedControlHistoryUpdate {
	mutation := newMappedControlHistoryMutation(c.config, OpUpdate)
	return &MappedControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MappedControlHistoryClient) UpdateOne(_m *MappedControlHistory) *MappedControlHistoryUpdateOne {
	mutation := newMappedControlHistoryMutation(c.config, OpUpdateOne, withMappedControlHistory(_m))
	return &MappedControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MappedControlHistoryClient) UpdateOneID(id string) *MappedControlHistoryUpdateOne {
	mutation := newMappedControlHistoryMutation(c.config, OpUpdateOne, withMappedControlHistoryID(id))
	return &MappedControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MappedControlHistory.
func (c *MappedControlHistoryClient) Delete() *MappedControlHistoryDelete {
	mutation := newMappedControlHistoryMutation(c.config, OpDelete)
	return &MappedControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MappedControlHistoryClient) DeleteOne(_m *MappedControlHistory) *MappedControlHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MappedControlHistoryClient) DeleteOneID(id string) *MappedControlHistoryDeleteOne {
	builder := c.Delete().Where(mappedcontrolhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MappedControlHistoryDeleteOne{builder}
}

// Query returns a query builder for MappedControlHistory.
func (c *MappedControlHistoryClient) Query() *MappedControlHistoryQuery {
	return &MappedControlHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMappedControlHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a MappedControlHistory entity by its id.
func (c *MappedControlHistoryClient) Get(ctx context.Context, id string) (*MappedControlHistory, error) {
	return c.Query().Where(mappedcontrolhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MappedControlHistoryClient) GetX(ctx context.Context, id string) *MappedControlHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MappedControlHistoryClient) Hooks() []Hook {
	hooks := c.hooks.MappedControlHistory
	return append(hooks[:len(hooks):len(hooks)], mappedcontrolhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MappedControlHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.MappedControlHistory
	return append(inters[:len(inters):len(inters)], mappedcontrolhistory.Interceptors[:]...)
}

func (c *MappedControlHistoryClient) mutate(ctx context.Context, m *MappedControlHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MappedControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MappedControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MappedControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MappedControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown MappedControlHistory mutation op: %q", m.Op())
	}
}

// NarrativeClient is a client for the Narrative schema.
type NarrativeClient struct {
	config
}

// NewNarrativeClient returns a client for the Narrative from the given config.
func NewNarrativeClient(c config) *NarrativeClient {
	return &NarrativeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `narrative.Hooks(f(g(h())))`.
func (c *NarrativeClient) Use(hooks ...Hook) {
	c.hooks.Narrative = append(c.hooks.Narrative, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `narrative.Intercept(f(g(h())))`.
func (c *NarrativeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Narrative = append(c.inters.Narrative, interceptors...)
}

// Create returns a builder for creating a Narrative entity.
func (c *NarrativeClient) Create() *NarrativeCreate {
	mutation := newNarrativeMutation(c.config, OpCreate)
	return &NarrativeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Narrative entities.
func (c *NarrativeClient) CreateBulk(builders ...*NarrativeCreate) *NarrativeCreateBulk {
	return &NarrativeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NarrativeClient) MapCreateBulk(slice any, setFunc func(*NarrativeCreate, int)) *NarrativeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NarrativeCreateBulk{err: fmt.Errorf("calling to NarrativeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NarrativeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NarrativeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Narrative.
func (c *NarrativeClient) Update() *NarrativeUpdate {
	mutation := newNarrativeMutation(c.config, OpUpdate)
	return &NarrativeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NarrativeClient) UpdateOne(_m *Narrative) *NarrativeUpdateOne {
	mutation := newNarrativeMutation(c.config, OpUpdateOne, withNarrative(_m))
	return &NarrativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NarrativeClient) UpdateOneID(id string) *NarrativeUpdateOne {
	mutation := newNarrativeMutation(c.config, OpUpdateOne, withNarrativeID(id))
	return &NarrativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Narrative.
func (c *NarrativeClient) Delete() *NarrativeDelete {
	mutation := newNarrativeMutation(c.config, OpDelete)
	return &NarrativeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NarrativeClient) DeleteOne(_m *Narrative) *NarrativeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NarrativeClient) DeleteOneID(id string) *NarrativeDeleteOne {
	builder := c.Delete().Where(narrative.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NarrativeDeleteOne{builder}
}

// Query returns a query builder for Narrative.
func (c *NarrativeClient) Query() *NarrativeQuery {
	return &NarrativeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNarrative},
		inters: c.Interceptors(),
	}
}

// Get returns a Narrative entity by its id.
func (c *NarrativeClient) Get(ctx context.Context, id string) (*Narrative, error) {
	return c.Query().Where(narrative.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NarrativeClient) GetX(ctx context.Context, id string) *Narrative {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Narrative.
func (c *NarrativeClient) QueryOwner(_m *Narrative) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, narrative.OwnerTable, narrative.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Narrative
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Narrative.
func (c *NarrativeClient) QueryBlockedGroups(_m *Narrative) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, narrative.BlockedGroupsTable, narrative.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.NarrativeBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Narrative.
func (c *NarrativeClient) QueryEditors(_m *Narrative) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, narrative.EditorsTable, narrative.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.NarrativeEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Narrative.
func (c *NarrativeClient) QueryViewers(_m *Narrative) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, narrative.ViewersTable, narrative.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.NarrativeViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySatisfies queries the satisfies edge of a Narrative.
func (c *NarrativeClient) QuerySatisfies(_m *Narrative) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.SatisfiesTable, narrative.SatisfiesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Narrative.
func (c *NarrativeClient) QueryPrograms(_m *Narrative) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.ProgramsTable, narrative.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Narrative.
func (c *NarrativeClient) QueryInternalPolicies(_m *Narrative) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.InternalPoliciesTable, narrative.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Narrative.
func (c *NarrativeClient) QueryProcedures(_m *Narrative) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.ProceduresTable, narrative.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NarrativeClient) Hooks() []Hook {
	hooks := c.hooks.Narrative
	return append(hooks[:len(hooks):len(hooks)], narrative.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NarrativeClient) Interceptors() []Interceptor {
	inters := c.inters.Narrative
	return append(inters[:len(inters):len(inters)], narrative.Interceptors[:]...)
}

func (c *NarrativeClient) mutate(ctx context.Context, m *NarrativeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NarrativeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NarrativeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NarrativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NarrativeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Narrative mutation op: %q", m.Op())
	}
}

// NarrativeHistoryClient is a client for the NarrativeHistory schema.
type NarrativeHistoryClient struct {
	config
}

// NewNarrativeHistoryClient returns a client for the NarrativeHistory from the given config.
func NewNarrativeHistoryClient(c config) *NarrativeHistoryClient {
	return &NarrativeHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `narrativehistory.Hooks(f(g(h())))`.
func (c *NarrativeHistoryClient) Use(hooks ...Hook) {
	c.hooks.NarrativeHistory = append(c.hooks.NarrativeHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `narrativehistory.Intercept(f(g(h())))`.
func (c *NarrativeHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.NarrativeHistory = append(c.inters.NarrativeHistory, interceptors...)
}

// Create returns a builder for creating a NarrativeHistory entity.
func (c *NarrativeHistoryClient) Create() *NarrativeHistoryCreate {
	mutation := newNarrativeHistoryMutation(c.config, OpCreate)
	return &NarrativeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NarrativeHistory entities.
func (c *NarrativeHistoryClient) CreateBulk(builders ...*NarrativeHistoryCreate) *NarrativeHistoryCreateBulk {
	return &NarrativeHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NarrativeHistoryClient) MapCreateBulk(slice any, setFunc func(*NarrativeHistoryCreate, int)) *NarrativeHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NarrativeHistoryCreateBulk{err: fmt.Errorf("calling to NarrativeHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NarrativeHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NarrativeHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NarrativeHistory.
func (c *NarrativeHistoryClient) Update() *NarrativeHistoryUpdate {
	mutation := newNarrativeHistoryMutation(c.config, OpUpdate)
	return &NarrativeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NarrativeHistoryClient) UpdateOne(_m *NarrativeHistory) *NarrativeHistoryUpdateOne {
	mutation := newNarrativeHistoryMutation(c.config, OpUpdateOne, withNarrativeHistory(_m))
	return &NarrativeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NarrativeHistoryClient) UpdateOneID(id string) *NarrativeHistoryUpdateOne {
	mutation := newNarrativeHistoryMutation(c.config, OpUpdateOne, withNarrativeHistoryID(id))
	return &NarrativeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NarrativeHistory.
func (c *NarrativeHistoryClient) Delete() *NarrativeHistoryDelete {
	mutation := newNarrativeHistoryMutation(c.config, OpDelete)
	return &NarrativeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NarrativeHistoryClient) DeleteOne(_m *NarrativeHistory) *NarrativeHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NarrativeHistoryClient) DeleteOneID(id string) *NarrativeHistoryDeleteOne {
	builder := c.Delete().Where(narrativehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NarrativeHistoryDeleteOne{builder}
}

// Query returns a query builder for NarrativeHistory.
func (c *NarrativeHistoryClient) Query() *NarrativeHistoryQuery {
	return &NarrativeHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNarrativeHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a NarrativeHistory entity by its id.
func (c *NarrativeHistoryClient) Get(ctx context.Context, id string) (*NarrativeHistory, error) {
	return c.Query().Where(narrativehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NarrativeHistoryClient) GetX(ctx context.Context, id string) *NarrativeHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NarrativeHistoryClient) Hooks() []Hook {
	hooks := c.hooks.NarrativeHistory
	return append(hooks[:len(hooks):len(hooks)], narrativehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NarrativeHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.NarrativeHistory
	return append(inters[:len(inters):len(inters)], narrativehistory.Interceptors[:]...)
}

func (c *NarrativeHistoryClient) mutate(ctx context.Context, m *NarrativeHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NarrativeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NarrativeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NarrativeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NarrativeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown NarrativeHistory mutation op: %q", m.Op())
	}
}

// NoteClient is a client for the Note schema.
type NoteClient struct {
	config
}

// NewNoteClient returns a client for the Note from the given config.
func NewNoteClient(c config) *NoteClient {
	return &NoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `note.Hooks(f(g(h())))`.
func (c *NoteClient) Use(hooks ...Hook) {
	c.hooks.Note = append(c.hooks.Note, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `note.Intercept(f(g(h())))`.
func (c *NoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Note = append(c.inters.Note, interceptors...)
}

// Create returns a builder for creating a Note entity.
func (c *NoteClient) Create() *NoteCreate {
	mutation := newNoteMutation(c.config, OpCreate)
	return &NoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Note entities.
func (c *NoteClient) CreateBulk(builders ...*NoteCreate) *NoteCreateBulk {
	return &NoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NoteClient) MapCreateBulk(slice any, setFunc func(*NoteCreate, int)) *NoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NoteCreateBulk{err: fmt.Errorf("calling to NoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Note.
func (c *NoteClient) Update() *NoteUpdate {
	mutation := newNoteMutation(c.config, OpUpdate)
	return &NoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NoteClient) UpdateOne(_m *Note) *NoteUpdateOne {
	mutation := newNoteMutation(c.config, OpUpdateOne, withNote(_m))
	return &NoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NoteClient) UpdateOneID(id string) *NoteUpdateOne {
	mutation := newNoteMutation(c.config, OpUpdateOne, withNoteID(id))
	return &NoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Note.
func (c *NoteClient) Delete() *NoteDelete {
	mutation := newNoteMutation(c.config, OpDelete)
	return &NoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NoteClient) DeleteOne(_m *Note) *NoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NoteClient) DeleteOneID(id string) *NoteDeleteOne {
	builder := c.Delete().Where(note.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NoteDeleteOne{builder}
}

// Query returns a query builder for Note.
func (c *NoteClient) Query() *NoteQuery {
	return &NoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNote},
		inters: c.Interceptors(),
	}
}

// Get returns a Note entity by its id.
func (c *NoteClient) Get(ctx context.Context, id string) (*Note, error) {
	return c.Query().Where(note.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NoteClient) GetX(ctx context.Context, id string) *Note {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Note.
func (c *NoteClient) QueryOwner(_m *Note) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.OwnerTable, note.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a Note.
func (c *NoteClient) QueryTask(_m *Note) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.TaskTable, note.TaskColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a Note.
func (c *NoteClient) QueryControl(_m *Note) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.ControlTable, note.ControlColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrol queries the subcontrol edge of a Note.
func (c *NoteClient) QuerySubcontrol(_m *Note) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.SubcontrolTable, note.SubcontrolColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedure queries the procedure edge of a Note.
func (c *NoteClient) QueryProcedure(_m *Note) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.ProcedureTable, note.ProcedureColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisk queries the risk edge of a Note.
func (c *NoteClient) QueryRisk(_m *Note) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.RiskTable, note.RiskColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicy queries the internal_policy edge of a Note.
func (c *NoteClient) QueryInternalPolicy(_m *Note) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.InternalPolicyTable, note.InternalPolicyColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenter queries the trust_center edge of a Note.
func (c *NoteClient) QueryTrustCenter(_m *Note) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.TrustCenterTable, note.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Note.
func (c *NoteClient) QueryFiles(_m *Note) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, note.FilesTable, note.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NoteClient) Hooks() []Hook {
	hooks := c.hooks.Note
	return append(hooks[:len(hooks):len(hooks)], note.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NoteClient) Interceptors() []Interceptor {
	inters := c.inters.Note
	return append(inters[:len(inters):len(inters)], note.Interceptors[:]...)
}

func (c *NoteClient) mutate(ctx context.Context, m *NoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Note mutation op: %q", m.Op())
	}
}

// NoteHistoryClient is a client for the NoteHistory schema.
type NoteHistoryClient struct {
	config
}

// NewNoteHistoryClient returns a client for the NoteHistory from the given config.
func NewNoteHistoryClient(c config) *NoteHistoryClient {
	return &NoteHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notehistory.Hooks(f(g(h())))`.
func (c *NoteHistoryClient) Use(hooks ...Hook) {
	c.hooks.NoteHistory = append(c.hooks.NoteHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notehistory.Intercept(f(g(h())))`.
func (c *NoteHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.NoteHistory = append(c.inters.NoteHistory, interceptors...)
}

// Create returns a builder for creating a NoteHistory entity.
func (c *NoteHistoryClient) Create() *NoteHistoryCreate {
	mutation := newNoteHistoryMutation(c.config, OpCreate)
	return &NoteHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NoteHistory entities.
func (c *NoteHistoryClient) CreateBulk(builders ...*NoteHistoryCreate) *NoteHistoryCreateBulk {
	return &NoteHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NoteHistoryClient) MapCreateBulk(slice any, setFunc func(*NoteHistoryCreate, int)) *NoteHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NoteHistoryCreateBulk{err: fmt.Errorf("calling to NoteHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NoteHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NoteHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NoteHistory.
func (c *NoteHistoryClient) Update() *NoteHistoryUpdate {
	mutation := newNoteHistoryMutation(c.config, OpUpdate)
	return &NoteHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NoteHistoryClient) UpdateOne(_m *NoteHistory) *NoteHistoryUpdateOne {
	mutation := newNoteHistoryMutation(c.config, OpUpdateOne, withNoteHistory(_m))
	return &NoteHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NoteHistoryClient) UpdateOneID(id string) *NoteHistoryUpdateOne {
	mutation := newNoteHistoryMutation(c.config, OpUpdateOne, withNoteHistoryID(id))
	return &NoteHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NoteHistory.
func (c *NoteHistoryClient) Delete() *NoteHistoryDelete {
	mutation := newNoteHistoryMutation(c.config, OpDelete)
	return &NoteHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NoteHistoryClient) DeleteOne(_m *NoteHistory) *NoteHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NoteHistoryClient) DeleteOneID(id string) *NoteHistoryDeleteOne {
	builder := c.Delete().Where(notehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NoteHistoryDeleteOne{builder}
}

// Query returns a query builder for NoteHistory.
func (c *NoteHistoryClient) Query() *NoteHistoryQuery {
	return &NoteHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNoteHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a NoteHistory entity by its id.
func (c *NoteHistoryClient) Get(ctx context.Context, id string) (*NoteHistory, error) {
	return c.Query().Where(notehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NoteHistoryClient) GetX(ctx context.Context, id string) *NoteHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NoteHistoryClient) Hooks() []Hook {
	hooks := c.hooks.NoteHistory
	return append(hooks[:len(hooks):len(hooks)], notehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NoteHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.NoteHistory
	return append(inters[:len(inters):len(inters)], notehistory.Interceptors[:]...)
}

func (c *NoteHistoryClient) mutate(ctx context.Context, m *NoteHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NoteHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NoteHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NoteHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NoteHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown NoteHistory mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(_m *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(_m))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id string) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(_m *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id string) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id string) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id string) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Notification.
func (c *NotificationClient) QueryOwner(_m *Notification) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.OwnerTable, notification.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Notification
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Notification.
func (c *NotificationClient) QueryUser(_m *Notification) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.UserTable, notification.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Notification
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	hooks := c.hooks.Notification
	return append(hooks[:len(hooks):len(hooks)], notification.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	inters := c.inters.Notification
	return append(inters[:len(inters):len(inters)], notification.Interceptors[:]...)
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Notification mutation op: %q", m.Op())
	}
}

// OnboardingClient is a client for the Onboarding schema.
type OnboardingClient struct {
	config
}

// NewOnboardingClient returns a client for the Onboarding from the given config.
func NewOnboardingClient(c config) *OnboardingClient {
	return &OnboardingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `onboarding.Hooks(f(g(h())))`.
func (c *OnboardingClient) Use(hooks ...Hook) {
	c.hooks.Onboarding = append(c.hooks.Onboarding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `onboarding.Intercept(f(g(h())))`.
func (c *OnboardingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Onboarding = append(c.inters.Onboarding, interceptors...)
}

// Create returns a builder for creating a Onboarding entity.
func (c *OnboardingClient) Create() *OnboardingCreate {
	mutation := newOnboardingMutation(c.config, OpCreate)
	return &OnboardingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Onboarding entities.
func (c *OnboardingClient) CreateBulk(builders ...*OnboardingCreate) *OnboardingCreateBulk {
	return &OnboardingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OnboardingClient) MapCreateBulk(slice any, setFunc func(*OnboardingCreate, int)) *OnboardingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OnboardingCreateBulk{err: fmt.Errorf("calling to OnboardingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OnboardingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OnboardingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Onboarding.
func (c *OnboardingClient) Update() *OnboardingUpdate {
	mutation := newOnboardingMutation(c.config, OpUpdate)
	return &OnboardingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OnboardingClient) UpdateOne(_m *Onboarding) *OnboardingUpdateOne {
	mutation := newOnboardingMutation(c.config, OpUpdateOne, withOnboarding(_m))
	return &OnboardingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OnboardingClient) UpdateOneID(id string) *OnboardingUpdateOne {
	mutation := newOnboardingMutation(c.config, OpUpdateOne, withOnboardingID(id))
	return &OnboardingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Onboarding.
func (c *OnboardingClient) Delete() *OnboardingDelete {
	mutation := newOnboardingMutation(c.config, OpDelete)
	return &OnboardingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OnboardingClient) DeleteOne(_m *Onboarding) *OnboardingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OnboardingClient) DeleteOneID(id string) *OnboardingDeleteOne {
	builder := c.Delete().Where(onboarding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OnboardingDeleteOne{builder}
}

// Query returns a query builder for Onboarding.
func (c *OnboardingClient) Query() *OnboardingQuery {
	return &OnboardingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOnboarding},
		inters: c.Interceptors(),
	}
}

// Get returns a Onboarding entity by its id.
func (c *OnboardingClient) Get(ctx context.Context, id string) (*Onboarding, error) {
	return c.Query().Where(onboarding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OnboardingClient) GetX(ctx context.Context, id string) *Onboarding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a Onboarding.
func (c *OnboardingClient) QueryOrganization(_m *Onboarding) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(onboarding.Table, onboarding.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, onboarding.OrganizationTable, onboarding.OrganizationColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Onboarding
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OnboardingClient) Hooks() []Hook {
	hooks := c.hooks.Onboarding
	return append(hooks[:len(hooks):len(hooks)], onboarding.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OnboardingClient) Interceptors() []Interceptor {
	inters := c.inters.Onboarding
	return append(inters[:len(inters):len(inters)], onboarding.Interceptors[:]...)
}

func (c *OnboardingClient) mutate(ctx context.Context, m *OnboardingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OnboardingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OnboardingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OnboardingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OnboardingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Onboarding mutation op: %q", m.Op())
	}
}

// OrgMembershipClient is a client for the OrgMembership schema.
type OrgMembershipClient struct {
	config
}

// NewOrgMembershipClient returns a client for the OrgMembership from the given config.
func NewOrgMembershipClient(c config) *OrgMembershipClient {
	return &OrgMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmembership.Hooks(f(g(h())))`.
func (c *OrgMembershipClient) Use(hooks ...Hook) {
	c.hooks.OrgMembership = append(c.hooks.OrgMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmembership.Intercept(f(g(h())))`.
func (c *OrgMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgMembership = append(c.inters.OrgMembership, interceptors...)
}

// Create returns a builder for creating a OrgMembership entity.
func (c *OrgMembershipClient) Create() *OrgMembershipCreate {
	mutation := newOrgMembershipMutation(c.config, OpCreate)
	return &OrgMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgMembership entities.
func (c *OrgMembershipClient) CreateBulk(builders ...*OrgMembershipCreate) *OrgMembershipCreateBulk {
	return &OrgMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgMembershipClient) MapCreateBulk(slice any, setFunc func(*OrgMembershipCreate, int)) *OrgMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgMembershipCreateBulk{err: fmt.Errorf("calling to OrgMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgMembership.
func (c *OrgMembershipClient) Update() *OrgMembershipUpdate {
	mutation := newOrgMembershipMutation(c.config, OpUpdate)
	return &OrgMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgMembershipClient) UpdateOne(_m *OrgMembership) *OrgMembershipUpdateOne {
	mutation := newOrgMembershipMutation(c.config, OpUpdateOne, withOrgMembership(_m))
	return &OrgMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgMembershipClient) UpdateOneID(id string) *OrgMembershipUpdateOne {
	mutation := newOrgMembershipMutation(c.config, OpUpdateOne, withOrgMembershipID(id))
	return &OrgMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgMembership.
func (c *OrgMembershipClient) Delete() *OrgMembershipDelete {
	mutation := newOrgMembershipMutation(c.config, OpDelete)
	return &OrgMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgMembershipClient) DeleteOne(_m *OrgMembership) *OrgMembershipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgMembershipClient) DeleteOneID(id string) *OrgMembershipDeleteOne {
	builder := c.Delete().Where(orgmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgMembershipDeleteOne{builder}
}

// Query returns a query builder for OrgMembership.
func (c *OrgMembershipClient) Query() *OrgMembershipQuery {
	return &OrgMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgMembership entity by its id.
func (c *OrgMembershipClient) Get(ctx context.Context, id string) (*OrgMembership, error) {
	return c.Query().Where(orgmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgMembershipClient) GetX(ctx context.Context, id string) *OrgMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrgMembership.
func (c *OrgMembershipClient) QueryOrganization(_m *OrgMembership) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmembership.Table, orgmembership.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orgmembership.OrganizationTable, orgmembership.OrganizationColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OrgMembership.
func (c *OrgMembershipClient) QueryUser(_m *OrgMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmembership.Table, orgmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orgmembership.UserTable, orgmembership.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a OrgMembership.
func (c *OrgMembershipClient) QueryEvents(_m *OrgMembership) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmembership.Table, orgmembership.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orgmembership.EventsTable, orgmembership.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.OrgMembershipEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgMembershipClient) Hooks() []Hook {
	hooks := c.hooks.OrgMembership
	return append(hooks[:len(hooks):len(hooks)], orgmembership.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgMembershipClient) Interceptors() []Interceptor {
	inters := c.inters.OrgMembership
	return append(inters[:len(inters):len(inters)], orgmembership.Interceptors[:]...)
}

func (c *OrgMembershipClient) mutate(ctx context.Context, m *OrgMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgMembership mutation op: %q", m.Op())
	}
}

// OrgMembershipHistoryClient is a client for the OrgMembershipHistory schema.
type OrgMembershipHistoryClient struct {
	config
}

// NewOrgMembershipHistoryClient returns a client for the OrgMembershipHistory from the given config.
func NewOrgMembershipHistoryClient(c config) *OrgMembershipHistoryClient {
	return &OrgMembershipHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmembershiphistory.Hooks(f(g(h())))`.
func (c *OrgMembershipHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrgMembershipHistory = append(c.hooks.OrgMembershipHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmembershiphistory.Intercept(f(g(h())))`.
func (c *OrgMembershipHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgMembershipHistory = append(c.inters.OrgMembershipHistory, interceptors...)
}

// Create returns a builder for creating a OrgMembershipHistory entity.
func (c *OrgMembershipHistoryClient) Create() *OrgMembershipHistoryCreate {
	mutation := newOrgMembershipHistoryMutation(c.config, OpCreate)
	return &OrgMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgMembershipHistory entities.
func (c *OrgMembershipHistoryClient) CreateBulk(builders ...*OrgMembershipHistoryCreate) *OrgMembershipHistoryCreateBulk {
	return &OrgMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgMembershipHistoryClient) MapCreateBulk(slice any, setFunc func(*OrgMembershipHistoryCreate, int)) *OrgMembershipHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgMembershipHistoryCreateBulk{err: fmt.Errorf("calling to OrgMembershipHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgMembershipHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgMembershipHistory.
func (c *OrgMembershipHistoryClient) Update() *OrgMembershipHistoryUpdate {
	mutation := newOrgMembershipHistoryMutation(c.config, OpUpdate)
	return &OrgMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgMembershipHistoryClient) UpdateOne(_m *OrgMembershipHistory) *OrgMembershipHistoryUpdateOne {
	mutation := newOrgMembershipHistoryMutation(c.config, OpUpdateOne, withOrgMembershipHistory(_m))
	return &OrgMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgMembershipHistoryClient) UpdateOneID(id string) *OrgMembershipHistoryUpdateOne {
	mutation := newOrgMembershipHistoryMutation(c.config, OpUpdateOne, withOrgMembershipHistoryID(id))
	return &OrgMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgMembershipHistory.
func (c *OrgMembershipHistoryClient) Delete() *OrgMembershipHistoryDelete {
	mutation := newOrgMembershipHistoryMutation(c.config, OpDelete)
	return &OrgMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgMembershipHistoryClient) DeleteOne(_m *OrgMembershipHistory) *OrgMembershipHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgMembershipHistoryClient) DeleteOneID(id string) *OrgMembershipHistoryDeleteOne {
	builder := c.Delete().Where(orgmembershiphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgMembershipHistoryDeleteOne{builder}
}

// Query returns a query builder for OrgMembershipHistory.
func (c *OrgMembershipHistoryClient) Query() *OrgMembershipHistoryQuery {
	return &OrgMembershipHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgMembershipHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgMembershipHistory entity by its id.
func (c *OrgMembershipHistoryClient) Get(ctx context.Context, id string) (*OrgMembershipHistory, error) {
	return c.Query().Where(orgmembershiphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgMembershipHistoryClient) GetX(ctx context.Context, id string) *OrgMembershipHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrgMembershipHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OrgMembershipHistory
	return append(hooks[:len(hooks):len(hooks)], orgmembershiphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgMembershipHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OrgMembershipHistory
	return append(inters[:len(inters):len(inters)], orgmembershiphistory.Interceptors[:]...)
}

func (c *OrgMembershipHistoryClient) mutate(ctx context.Context, m *OrgMembershipHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgMembershipHistory mutation op: %q", m.Op())
	}
}

// OrgModuleClient is a client for the OrgModule schema.
type OrgModuleClient struct {
	config
}

// NewOrgModuleClient returns a client for the OrgModule from the given config.
func NewOrgModuleClient(c config) *OrgModuleClient {
	return &OrgModuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmodule.Hooks(f(g(h())))`.
func (c *OrgModuleClient) Use(hooks ...Hook) {
	c.hooks.OrgModule = append(c.hooks.OrgModule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmodule.Intercept(f(g(h())))`.
func (c *OrgModuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgModule = append(c.inters.OrgModule, interceptors...)
}

// Create returns a builder for creating a OrgModule entity.
func (c *OrgModuleClient) Create() *OrgModuleCreate {
	mutation := newOrgModuleMutation(c.config, OpCreate)
	return &OrgModuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgModule entities.
func (c *OrgModuleClient) CreateBulk(builders ...*OrgModuleCreate) *OrgModuleCreateBulk {
	return &OrgModuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgModuleClient) MapCreateBulk(slice any, setFunc func(*OrgModuleCreate, int)) *OrgModuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgModuleCreateBulk{err: fmt.Errorf("calling to OrgModuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgModuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgModuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgModule.
func (c *OrgModuleClient) Update() *OrgModuleUpdate {
	mutation := newOrgModuleMutation(c.config, OpUpdate)
	return &OrgModuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgModuleClient) UpdateOne(_m *OrgModule) *OrgModuleUpdateOne {
	mutation := newOrgModuleMutation(c.config, OpUpdateOne, withOrgModule(_m))
	return &OrgModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgModuleClient) UpdateOneID(id string) *OrgModuleUpdateOne {
	mutation := newOrgModuleMutation(c.config, OpUpdateOne, withOrgModuleID(id))
	return &OrgModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgModule.
func (c *OrgModuleClient) Delete() *OrgModuleDelete {
	mutation := newOrgModuleMutation(c.config, OpDelete)
	return &OrgModuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgModuleClient) DeleteOne(_m *OrgModule) *OrgModuleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgModuleClient) DeleteOneID(id string) *OrgModuleDeleteOne {
	builder := c.Delete().Where(orgmodule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgModuleDeleteOne{builder}
}

// Query returns a query builder for OrgModule.
func (c *OrgModuleClient) Query() *OrgModuleQuery {
	return &OrgModuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgModule},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgModule entity by its id.
func (c *OrgModuleClient) Get(ctx context.Context, id string) (*OrgModule, error) {
	return c.Query().Where(orgmodule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgModuleClient) GetX(ctx context.Context, id string) *OrgModule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrgModule.
func (c *OrgModuleClient) QueryOwner(_m *OrgModule) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmodule.Table, orgmodule.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgmodule.OwnerTable, orgmodule.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgModule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgSubscription queries the org_subscription edge of a OrgModule.
func (c *OrgModuleClient) QueryOrgSubscription(_m *OrgModule) *OrgSubscriptionQuery {
	query := (&OrgSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmodule.Table, orgmodule.FieldID, id),
			sqlgraph.To(orgsubscription.Table, orgsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgmodule.OrgSubscriptionTable, orgmodule.OrgSubscriptionColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgSubscription
		step.Edge.Schema = schemaConfig.OrgModule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgProducts queries the org_products edge of a OrgModule.
func (c *OrgModuleClient) QueryOrgProducts(_m *OrgModule) *OrgProductQuery {
	query := (&OrgProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmodule.Table, orgmodule.FieldID, id),
			sqlgraph.To(orgproduct.Table, orgproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgmodule.OrgProductsTable, orgmodule.OrgProductsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgProduct
		step.Edge.Schema = schemaConfig.OrgProduct
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgPrices queries the org_prices edge of a OrgModule.
func (c *OrgModuleClient) QueryOrgPrices(_m *OrgModule) *OrgPriceQuery {
	query := (&OrgPriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmodule.Table, orgmodule.FieldID, id),
			sqlgraph.To(orgprice.Table, orgprice.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orgmodule.OrgPricesTable, orgmodule.OrgPricesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgPrice
		step.Edge.Schema = schemaConfig.OrgModuleOrgPrices
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgModuleClient) Hooks() []Hook {
	hooks := c.hooks.OrgModule
	return append(hooks[:len(hooks):len(hooks)], orgmodule.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgModuleClient) Interceptors() []Interceptor {
	inters := c.inters.OrgModule
	return append(inters[:len(inters):len(inters)], orgmodule.Interceptors[:]...)
}

func (c *OrgModuleClient) mutate(ctx context.Context, m *OrgModuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgModuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgModuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgModuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgModule mutation op: %q", m.Op())
	}
}

// OrgPriceClient is a client for the OrgPrice schema.
type OrgPriceClient struct {
	config
}

// NewOrgPriceClient returns a client for the OrgPrice from the given config.
func NewOrgPriceClient(c config) *OrgPriceClient {
	return &OrgPriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgprice.Hooks(f(g(h())))`.
func (c *OrgPriceClient) Use(hooks ...Hook) {
	c.hooks.OrgPrice = append(c.hooks.OrgPrice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgprice.Intercept(f(g(h())))`.
func (c *OrgPriceClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgPrice = append(c.inters.OrgPrice, interceptors...)
}

// Create returns a builder for creating a OrgPrice entity.
func (c *OrgPriceClient) Create() *OrgPriceCreate {
	mutation := newOrgPriceMutation(c.config, OpCreate)
	return &OrgPriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgPrice entities.
func (c *OrgPriceClient) CreateBulk(builders ...*OrgPriceCreate) *OrgPriceCreateBulk {
	return &OrgPriceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgPriceClient) MapCreateBulk(slice any, setFunc func(*OrgPriceCreate, int)) *OrgPriceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgPriceCreateBulk{err: fmt.Errorf("calling to OrgPriceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgPriceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgPriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgPrice.
func (c *OrgPriceClient) Update() *OrgPriceUpdate {
	mutation := newOrgPriceMutation(c.config, OpUpdate)
	return &OrgPriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgPriceClient) UpdateOne(_m *OrgPrice) *OrgPriceUpdateOne {
	mutation := newOrgPriceMutation(c.config, OpUpdateOne, withOrgPrice(_m))
	return &OrgPriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgPriceClient) UpdateOneID(id string) *OrgPriceUpdateOne {
	mutation := newOrgPriceMutation(c.config, OpUpdateOne, withOrgPriceID(id))
	return &OrgPriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgPrice.
func (c *OrgPriceClient) Delete() *OrgPriceDelete {
	mutation := newOrgPriceMutation(c.config, OpDelete)
	return &OrgPriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgPriceClient) DeleteOne(_m *OrgPrice) *OrgPriceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgPriceClient) DeleteOneID(id string) *OrgPriceDeleteOne {
	builder := c.Delete().Where(orgprice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgPriceDeleteOne{builder}
}

// Query returns a query builder for OrgPrice.
func (c *OrgPriceClient) Query() *OrgPriceQuery {
	return &OrgPriceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgPrice},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgPrice entity by its id.
func (c *OrgPriceClient) Get(ctx context.Context, id string) (*OrgPrice, error) {
	return c.Query().Where(orgprice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgPriceClient) GetX(ctx context.Context, id string) *OrgPrice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrgPrice.
func (c *OrgPriceClient) QueryOwner(_m *OrgPrice) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgprice.Table, orgprice.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgprice.OwnerTable, orgprice.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgPrice
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgProducts queries the org_products edge of a OrgPrice.
func (c *OrgPriceClient) QueryOrgProducts(_m *OrgPrice) *OrgProductQuery {
	query := (&OrgProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgprice.Table, orgprice.FieldID, id),
			sqlgraph.To(orgproduct.Table, orgproduct.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, orgprice.OrgProductsTable, orgprice.OrgProductsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgProduct
		step.Edge.Schema = schemaConfig.OrgProductOrgPrices
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgModules queries the org_modules edge of a OrgPrice.
func (c *OrgPriceClient) QueryOrgModules(_m *OrgPrice) *OrgModuleQuery {
	query := (&OrgModuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgprice.Table, orgprice.FieldID, id),
			sqlgraph.To(orgmodule.Table, orgmodule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, orgprice.OrgModulesTable, orgprice.OrgModulesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgModule
		step.Edge.Schema = schemaConfig.OrgModuleOrgPrices
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgSubscription queries the org_subscription edge of a OrgPrice.
func (c *OrgPriceClient) QueryOrgSubscription(_m *OrgPrice) *OrgSubscriptionQuery {
	query := (&OrgSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgprice.Table, orgprice.FieldID, id),
			sqlgraph.To(orgsubscription.Table, orgsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgprice.OrgSubscriptionTable, orgprice.OrgSubscriptionColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgSubscription
		step.Edge.Schema = schemaConfig.OrgPrice
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgPriceClient) Hooks() []Hook {
	hooks := c.hooks.OrgPrice
	return append(hooks[:len(hooks):len(hooks)], orgprice.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgPriceClient) Interceptors() []Interceptor {
	inters := c.inters.OrgPrice
	return append(inters[:len(inters):len(inters)], orgprice.Interceptors[:]...)
}

func (c *OrgPriceClient) mutate(ctx context.Context, m *OrgPriceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgPriceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgPriceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgPriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgPriceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgPrice mutation op: %q", m.Op())
	}
}

// OrgProductClient is a client for the OrgProduct schema.
type OrgProductClient struct {
	config
}

// NewOrgProductClient returns a client for the OrgProduct from the given config.
func NewOrgProductClient(c config) *OrgProductClient {
	return &OrgProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgproduct.Hooks(f(g(h())))`.
func (c *OrgProductClient) Use(hooks ...Hook) {
	c.hooks.OrgProduct = append(c.hooks.OrgProduct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgproduct.Intercept(f(g(h())))`.
func (c *OrgProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgProduct = append(c.inters.OrgProduct, interceptors...)
}

// Create returns a builder for creating a OrgProduct entity.
func (c *OrgProductClient) Create() *OrgProductCreate {
	mutation := newOrgProductMutation(c.config, OpCreate)
	return &OrgProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgProduct entities.
func (c *OrgProductClient) CreateBulk(builders ...*OrgProductCreate) *OrgProductCreateBulk {
	return &OrgProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgProductClient) MapCreateBulk(slice any, setFunc func(*OrgProductCreate, int)) *OrgProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgProductCreateBulk{err: fmt.Errorf("calling to OrgProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgProduct.
func (c *OrgProductClient) Update() *OrgProductUpdate {
	mutation := newOrgProductMutation(c.config, OpUpdate)
	return &OrgProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgProductClient) UpdateOne(_m *OrgProduct) *OrgProductUpdateOne {
	mutation := newOrgProductMutation(c.config, OpUpdateOne, withOrgProduct(_m))
	return &OrgProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgProductClient) UpdateOneID(id string) *OrgProductUpdateOne {
	mutation := newOrgProductMutation(c.config, OpUpdateOne, withOrgProductID(id))
	return &OrgProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgProduct.
func (c *OrgProductClient) Delete() *OrgProductDelete {
	mutation := newOrgProductMutation(c.config, OpDelete)
	return &OrgProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgProductClient) DeleteOne(_m *OrgProduct) *OrgProductDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgProductClient) DeleteOneID(id string) *OrgProductDeleteOne {
	builder := c.Delete().Where(orgproduct.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgProductDeleteOne{builder}
}

// Query returns a query builder for OrgProduct.
func (c *OrgProductClient) Query() *OrgProductQuery {
	return &OrgProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgProduct entity by its id.
func (c *OrgProductClient) Get(ctx context.Context, id string) (*OrgProduct, error) {
	return c.Query().Where(orgproduct.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgProductClient) GetX(ctx context.Context, id string) *OrgProduct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrgProduct.
func (c *OrgProductClient) QueryOwner(_m *OrgProduct) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgproduct.Table, orgproduct.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgproduct.OwnerTable, orgproduct.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgProduct
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgSubscription queries the org_subscription edge of a OrgProduct.
func (c *OrgProductClient) QueryOrgSubscription(_m *OrgProduct) *OrgSubscriptionQuery {
	query := (&OrgSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgproduct.Table, orgproduct.FieldID, id),
			sqlgraph.To(orgsubscription.Table, orgsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgproduct.OrgSubscriptionTable, orgproduct.OrgSubscriptionColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgSubscription
		step.Edge.Schema = schemaConfig.OrgProduct
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgPrices queries the org_prices edge of a OrgProduct.
func (c *OrgProductClient) QueryOrgPrices(_m *OrgProduct) *OrgPriceQuery {
	query := (&OrgPriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgproduct.Table, orgproduct.FieldID, id),
			sqlgraph.To(orgprice.Table, orgprice.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orgproduct.OrgPricesTable, orgproduct.OrgPricesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgPrice
		step.Edge.Schema = schemaConfig.OrgProductOrgPrices
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgModules queries the org_modules edge of a OrgProduct.
func (c *OrgProductClient) QueryOrgModules(_m *OrgProduct) *OrgModuleQuery {
	query := (&OrgModuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgproduct.Table, orgproduct.FieldID, id),
			sqlgraph.To(orgmodule.Table, orgmodule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgproduct.OrgModulesTable, orgproduct.OrgModulesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgModule
		step.Edge.Schema = schemaConfig.OrgModule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgProductClient) Hooks() []Hook {
	hooks := c.hooks.OrgProduct
	return append(hooks[:len(hooks):len(hooks)], orgproduct.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgProductClient) Interceptors() []Interceptor {
	inters := c.inters.OrgProduct
	return append(inters[:len(inters):len(inters)], orgproduct.Interceptors[:]...)
}

func (c *OrgProductClient) mutate(ctx context.Context, m *OrgProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgProduct mutation op: %q", m.Op())
	}
}

// OrgSubscriptionClient is a client for the OrgSubscription schema.
type OrgSubscriptionClient struct {
	config
}

// NewOrgSubscriptionClient returns a client for the OrgSubscription from the given config.
func NewOrgSubscriptionClient(c config) *OrgSubscriptionClient {
	return &OrgSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgsubscription.Hooks(f(g(h())))`.
func (c *OrgSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.OrgSubscription = append(c.hooks.OrgSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgsubscription.Intercept(f(g(h())))`.
func (c *OrgSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgSubscription = append(c.inters.OrgSubscription, interceptors...)
}

// Create returns a builder for creating a OrgSubscription entity.
func (c *OrgSubscriptionClient) Create() *OrgSubscriptionCreate {
	mutation := newOrgSubscriptionMutation(c.config, OpCreate)
	return &OrgSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgSubscription entities.
func (c *OrgSubscriptionClient) CreateBulk(builders ...*OrgSubscriptionCreate) *OrgSubscriptionCreateBulk {
	return &OrgSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgSubscriptionClient) MapCreateBulk(slice any, setFunc func(*OrgSubscriptionCreate, int)) *OrgSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgSubscriptionCreateBulk{err: fmt.Errorf("calling to OrgSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgSubscription.
func (c *OrgSubscriptionClient) Update() *OrgSubscriptionUpdate {
	mutation := newOrgSubscriptionMutation(c.config, OpUpdate)
	return &OrgSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgSubscriptionClient) UpdateOne(_m *OrgSubscription) *OrgSubscriptionUpdateOne {
	mutation := newOrgSubscriptionMutation(c.config, OpUpdateOne, withOrgSubscription(_m))
	return &OrgSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgSubscriptionClient) UpdateOneID(id string) *OrgSubscriptionUpdateOne {
	mutation := newOrgSubscriptionMutation(c.config, OpUpdateOne, withOrgSubscriptionID(id))
	return &OrgSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgSubscription.
func (c *OrgSubscriptionClient) Delete() *OrgSubscriptionDelete {
	mutation := newOrgSubscriptionMutation(c.config, OpDelete)
	return &OrgSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgSubscriptionClient) DeleteOne(_m *OrgSubscription) *OrgSubscriptionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgSubscriptionClient) DeleteOneID(id string) *OrgSubscriptionDeleteOne {
	builder := c.Delete().Where(orgsubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgSubscriptionDeleteOne{builder}
}

// Query returns a query builder for OrgSubscription.
func (c *OrgSubscriptionClient) Query() *OrgSubscriptionQuery {
	return &OrgSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgSubscription entity by its id.
func (c *OrgSubscriptionClient) Get(ctx context.Context, id string) (*OrgSubscription, error) {
	return c.Query().Where(orgsubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgSubscriptionClient) GetX(ctx context.Context, id string) *OrgSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OrgSubscription.
func (c *OrgSubscriptionClient) QueryOwner(_m *OrgSubscription) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgsubscription.Table, orgsubscription.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgsubscription.OwnerTable, orgsubscription.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgSubscription
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a OrgSubscription.
func (c *OrgSubscriptionClient) QueryEvents(_m *OrgSubscription) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgsubscription.Table, orgsubscription.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orgsubscription.EventsTable, orgsubscription.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.OrgSubscriptionEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModules queries the modules edge of a OrgSubscription.
func (c *OrgSubscriptionClient) QueryModules(_m *OrgSubscription) *OrgModuleQuery {
	query := (&OrgModuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgsubscription.Table, orgsubscription.FieldID, id),
			sqlgraph.To(orgmodule.Table, orgmodule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgsubscription.ModulesTable, orgsubscription.ModulesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgModule
		step.Edge.Schema = schemaConfig.OrgModule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProducts queries the products edge of a OrgSubscription.
func (c *OrgSubscriptionClient) QueryProducts(_m *OrgSubscription) *OrgProductQuery {
	query := (&OrgProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgsubscription.Table, orgsubscription.FieldID, id),
			sqlgraph.To(orgproduct.Table, orgproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgsubscription.ProductsTable, orgsubscription.ProductsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgProduct
		step.Edge.Schema = schemaConfig.OrgProduct
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrices queries the prices edge of a OrgSubscription.
func (c *OrgSubscriptionClient) QueryPrices(_m *OrgSubscription) *OrgPriceQuery {
	query := (&OrgPriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgsubscription.Table, orgsubscription.FieldID, id),
			sqlgraph.To(orgprice.Table, orgprice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgsubscription.PricesTable, orgsubscription.PricesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgPrice
		step.Edge.Schema = schemaConfig.OrgPrice
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgSubscriptionClient) Hooks() []Hook {
	hooks := c.hooks.OrgSubscription
	return append(hooks[:len(hooks):len(hooks)], orgsubscription.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgSubscriptionClient) Interceptors() []Interceptor {
	inters := c.inters.OrgSubscription
	return append(inters[:len(inters):len(inters)], orgsubscription.Interceptors[:]...)
}

func (c *OrgSubscriptionClient) mutate(ctx context.Context, m *OrgSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgSubscription mutation op: %q", m.Op())
	}
}

// OrgSubscriptionHistoryClient is a client for the OrgSubscriptionHistory schema.
type OrgSubscriptionHistoryClient struct {
	config
}

// NewOrgSubscriptionHistoryClient returns a client for the OrgSubscriptionHistory from the given config.
func NewOrgSubscriptionHistoryClient(c config) *OrgSubscriptionHistoryClient {
	return &OrgSubscriptionHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgsubscriptionhistory.Hooks(f(g(h())))`.
func (c *OrgSubscriptionHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrgSubscriptionHistory = append(c.hooks.OrgSubscriptionHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgsubscriptionhistory.Intercept(f(g(h())))`.
func (c *OrgSubscriptionHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgSubscriptionHistory = append(c.inters.OrgSubscriptionHistory, interceptors...)
}

// Create returns a builder for creating a OrgSubscriptionHistory entity.
func (c *OrgSubscriptionHistoryClient) Create() *OrgSubscriptionHistoryCreate {
	mutation := newOrgSubscriptionHistoryMutation(c.config, OpCreate)
	return &OrgSubscriptionHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgSubscriptionHistory entities.
func (c *OrgSubscriptionHistoryClient) CreateBulk(builders ...*OrgSubscriptionHistoryCreate) *OrgSubscriptionHistoryCreateBulk {
	return &OrgSubscriptionHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgSubscriptionHistoryClient) MapCreateBulk(slice any, setFunc func(*OrgSubscriptionHistoryCreate, int)) *OrgSubscriptionHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgSubscriptionHistoryCreateBulk{err: fmt.Errorf("calling to OrgSubscriptionHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgSubscriptionHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgSubscriptionHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgSubscriptionHistory.
func (c *OrgSubscriptionHistoryClient) Update() *OrgSubscriptionHistoryUpdate {
	mutation := newOrgSubscriptionHistoryMutation(c.config, OpUpdate)
	return &OrgSubscriptionHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgSubscriptionHistoryClient) UpdateOne(_m *OrgSubscriptionHistory) *OrgSubscriptionHistoryUpdateOne {
	mutation := newOrgSubscriptionHistoryMutation(c.config, OpUpdateOne, withOrgSubscriptionHistory(_m))
	return &OrgSubscriptionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgSubscriptionHistoryClient) UpdateOneID(id string) *OrgSubscriptionHistoryUpdateOne {
	mutation := newOrgSubscriptionHistoryMutation(c.config, OpUpdateOne, withOrgSubscriptionHistoryID(id))
	return &OrgSubscriptionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgSubscriptionHistory.
func (c *OrgSubscriptionHistoryClient) Delete() *OrgSubscriptionHistoryDelete {
	mutation := newOrgSubscriptionHistoryMutation(c.config, OpDelete)
	return &OrgSubscriptionHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgSubscriptionHistoryClient) DeleteOne(_m *OrgSubscriptionHistory) *OrgSubscriptionHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgSubscriptionHistoryClient) DeleteOneID(id string) *OrgSubscriptionHistoryDeleteOne {
	builder := c.Delete().Where(orgsubscriptionhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgSubscriptionHistoryDeleteOne{builder}
}

// Query returns a query builder for OrgSubscriptionHistory.
func (c *OrgSubscriptionHistoryClient) Query() *OrgSubscriptionHistoryQuery {
	return &OrgSubscriptionHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgSubscriptionHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgSubscriptionHistory entity by its id.
func (c *OrgSubscriptionHistoryClient) Get(ctx context.Context, id string) (*OrgSubscriptionHistory, error) {
	return c.Query().Where(orgsubscriptionhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgSubscriptionHistoryClient) GetX(ctx context.Context, id string) *OrgSubscriptionHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrgSubscriptionHistoryClient) Hooks() []Hook {
	return c.hooks.OrgSubscriptionHistory
}

// Interceptors returns the client interceptors.
func (c *OrgSubscriptionHistoryClient) Interceptors() []Interceptor {
	return c.inters.OrgSubscriptionHistory
}

func (c *OrgSubscriptionHistoryClient) mutate(ctx context.Context, m *OrgSubscriptionHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgSubscriptionHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgSubscriptionHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgSubscriptionHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgSubscriptionHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgSubscriptionHistory mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(_m *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(_m))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id string) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(_m *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id string) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id string) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id string) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryControlCreators queries the control_creators edge of a Organization.
func (c *OrganizationClient) QueryControlCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ControlCreatorsTable, organization.ControlCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementationCreators queries the control_implementation_creators edge of a Organization.
func (c *OrganizationClient) QueryControlImplementationCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ControlImplementationCreatorsTable, organization.ControlImplementationCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectiveCreators queries the control_objective_creators edge of a Organization.
func (c *OrganizationClient) QueryControlObjectiveCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ControlObjectiveCreatorsTable, organization.ControlObjectiveCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidenceCreators queries the evidence_creators edge of a Organization.
func (c *OrganizationClient) QueryEvidenceCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EvidenceCreatorsTable, organization.EvidenceCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupCreators queries the group_creators edge of a Organization.
func (c *OrganizationClient) QueryGroupCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.GroupCreatorsTable, organization.GroupCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicyCreators queries the internal_policy_creators edge of a Organization.
func (c *OrganizationClient) QueryInternalPolicyCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.InternalPolicyCreatorsTable, organization.InternalPolicyCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedControlCreators queries the mapped_control_creators edge of a Organization.
func (c *OrganizationClient) QueryMappedControlCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.MappedControlCreatorsTable, organization.MappedControlCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarrativeCreators queries the narrative_creators edge of a Organization.
func (c *OrganizationClient) QueryNarrativeCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.NarrativeCreatorsTable, organization.NarrativeCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedureCreators queries the procedure_creators edge of a Organization.
func (c *OrganizationClient) QueryProcedureCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ProcedureCreatorsTable, organization.ProcedureCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramCreators queries the program_creators edge of a Organization.
func (c *OrganizationClient) QueryProgramCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ProgramCreatorsTable, organization.ProgramCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskCreators queries the risk_creators edge of a Organization.
func (c *OrganizationClient) QueryRiskCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.RiskCreatorsTable, organization.RiskCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJobCreators queries the scheduled_job_creators edge of a Organization.
func (c *OrganizationClient) QueryScheduledJobCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ScheduledJobCreatorsTable, organization.ScheduledJobCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandardCreators queries the standard_creators edge of a Organization.
func (c *OrganizationClient) QueryStandardCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.StandardCreatorsTable, organization.StandardCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplateCreators queries the template_creators edge of a Organization.
func (c *OrganizationClient) QueryTemplateCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TemplateCreatorsTable, organization.TemplateCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssessmentCreators queries the assessment_creators edge of a Organization.
func (c *OrganizationClient) QueryAssessmentCreators(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.AssessmentCreatorsTable, organization.AssessmentCreatorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Organization.
func (c *OrganizationClient) QueryParent(_m *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.ParentTable, organization.ParentColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Organization
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Organization.
func (c *OrganizationClient) QueryChildren(_m *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ChildrenTable, organization.ChildrenColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Organization
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a Organization.
func (c *OrganizationClient) QuerySetting(_m *Organization) *OrganizationSettingQuery {
	query := (&OrganizationSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organizationsetting.Table, organizationsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, organization.SettingTable, organization.SettingColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrganizationSetting
		step.Edge.Schema = schemaConfig.OrganizationSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonalAccessTokens queries the personal_access_tokens edge of a Organization.
func (c *OrganizationClient) QueryPersonalAccessTokens(_m *Organization) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.PersonalAccessTokensTable, organization.PersonalAccessTokensPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PersonalAccessToken
		step.Edge.Schema = schemaConfig.OrganizationPersonalAccessTokens
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPITokens queries the api_tokens edge of a Organization.
func (c *OrganizationClient) QueryAPITokens(_m *Organization) *APITokenQuery {
	query := (&APITokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(apitoken.Table, apitoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.APITokensTable, organization.APITokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.APIToken
		step.Edge.Schema = schemaConfig.APIToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Organization.
func (c *OrganizationClient) QueryUsers(_m *Organization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, organization.UsersTable, organization.UsersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Organization.
func (c *OrganizationClient) QueryFiles(_m *Organization) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.FilesTable, organization.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.OrganizationFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Organization.
func (c *OrganizationClient) QueryEvents(_m *Organization) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.EventsTable, organization.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.OrganizationEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySecrets queries the secrets edge of a Organization.
func (c *OrganizationClient) QuerySecrets(_m *Organization) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.SecretsTable, organization.SecretsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.Hush
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAvatarFile queries the avatar_file edge of a Organization.
func (c *OrganizationClient) QueryAvatarFile(_m *Organization) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, organization.AvatarFileTable, organization.AvatarFileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.Organization
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Organization.
func (c *OrganizationClient) QueryGroups(_m *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.GroupsTable, organization.GroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplates queries the templates edge of a Organization.
func (c *OrganizationClient) QueryTemplates(_m *Organization) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TemplatesTable, organization.TemplatesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Organization.
func (c *OrganizationClient) QueryIntegrations(_m *Organization) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.IntegrationsTable, organization.IntegrationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Organization.
func (c *OrganizationClient) QueryDocuments(_m *Organization) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.DocumentsTable, organization.DocumentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgSubscriptions queries the org_subscriptions edge of a Organization.
func (c *OrganizationClient) QueryOrgSubscriptions(_m *Organization) *OrgSubscriptionQuery {
	query := (&OrgSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(orgsubscription.Table, orgsubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.OrgSubscriptionsTable, organization.OrgSubscriptionsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgSubscription
		step.Edge.Schema = schemaConfig.OrgSubscription
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgProducts queries the org_products edge of a Organization.
func (c *OrganizationClient) QueryOrgProducts(_m *Organization) *OrgProductQuery {
	query := (&OrgProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(orgproduct.Table, orgproduct.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.OrgProductsTable, organization.OrgProductsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgProduct
		step.Edge.Schema = schemaConfig.OrgProduct
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgPrices queries the org_prices edge of a Organization.
func (c *OrganizationClient) QueryOrgPrices(_m *Organization) *OrgPriceQuery {
	query := (&OrgPriceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(orgprice.Table, orgprice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.OrgPricesTable, organization.OrgPricesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgPrice
		step.Edge.Schema = schemaConfig.OrgPrice
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgModules queries the org_modules edge of a Organization.
func (c *OrganizationClient) QueryOrgModules(_m *Organization) *OrgModuleQuery {
	query := (&OrgModuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(orgmodule.Table, orgmodule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.OrgModulesTable, organization.OrgModulesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgModule
		step.Edge.Schema = schemaConfig.OrgModule
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvites queries the invites edge of a Organization.
func (c *OrganizationClient) QueryInvites(_m *Organization) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.InvitesTable, organization.InvitesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Invite
		step.Edge.Schema = schemaConfig.Invite
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribers queries the subscribers edge of a Organization.
func (c *OrganizationClient) QuerySubscribers(_m *Organization) *SubscriberQuery {
	query := (&SubscriberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(subscriber.Table, subscriber.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.SubscribersTable, organization.SubscribersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subscriber
		step.Edge.Schema = schemaConfig.Subscriber
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Organization.
func (c *OrganizationClient) QueryEntities(_m *Organization) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntitiesTable, organization.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntityTypes queries the entity_types edge of a Organization.
func (c *OrganizationClient) QueryEntityTypes(_m *Organization) *EntityTypeQuery {
	query := (&EntityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entitytype.Table, entitytype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntityTypesTable, organization.EntityTypesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.EntityType
		step.Edge.Schema = schemaConfig.EntityType
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Organization.
func (c *OrganizationClient) QueryContacts(_m *Organization) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ContactsTable, organization.ContactsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Contact
		step.Edge.Schema = schemaConfig.Contact
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Organization.
func (c *OrganizationClient) QueryNotes(_m *Organization) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.NotesTable, organization.NotesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Organization.
func (c *OrganizationClient) QueryTasks(_m *Organization) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TasksTable, organization.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Organization.
func (c *OrganizationClient) QueryPrograms(_m *Organization) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ProgramsTable, organization.ProgramsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Organization.
func (c *OrganizationClient) QueryProcedures(_m *Organization) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ProceduresTable, organization.ProceduresColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Organization.
func (c *OrganizationClient) QueryInternalPolicies(_m *Organization) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.InternalPoliciesTable, organization.InternalPoliciesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicy
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Organization.
func (c *OrganizationClient) QueryRisks(_m *Organization) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.RisksTable, organization.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a Organization.
func (c *OrganizationClient) QueryControlObjectives(_m *Organization) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ControlObjectivesTable, organization.ControlObjectivesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjective
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Organization.
func (c *OrganizationClient) QueryNarratives(_m *Organization) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.NarrativesTable, organization.NarrativesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.Narrative
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Organization.
func (c *OrganizationClient) QueryControls(_m *Organization) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ControlsTable, organization.ControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Organization.
func (c *OrganizationClient) QuerySubcontrols(_m *Organization) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.SubcontrolsTable, organization.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementations queries the control_implementations edge of a Organization.
func (c *OrganizationClient) QueryControlImplementations(_m *Organization) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ControlImplementationsTable, organization.ControlImplementationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedControls queries the mapped_controls edge of a Organization.
func (c *OrganizationClient) QueryMappedControls(_m *Organization) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.MappedControlsTable, organization.MappedControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControl
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidence queries the evidence edge of a Organization.
func (c *OrganizationClient) QueryEvidence(_m *Organization) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EvidenceTable, organization.EvidenceColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.Evidence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandards queries the standards edge of a Organization.
func (c *OrganizationClient) QueryStandards(_m *Organization) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.StandardsTable, organization.StandardsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.Standard
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Organization.
func (c *OrganizationClient) QueryActionPlans(_m *Organization) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ActionPlansTable, organization.ActionPlansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomDomains queries the custom_domains edge of a Organization.
func (c *OrganizationClient) QueryCustomDomains(_m *Organization) *CustomDomainQuery {
	query := (&CustomDomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(customdomain.Table, customdomain.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.CustomDomainsTable, organization.CustomDomainsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomDomain
		step.Edge.Schema = schemaConfig.CustomDomain
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunners queries the job_runners edge of a Organization.
func (c *OrganizationClient) QueryJobRunners(_m *Organization) *JobRunnerQuery {
	query := (&JobRunnerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(jobrunner.Table, jobrunner.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.JobRunnersTable, organization.JobRunnersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunner
		step.Edge.Schema = schemaConfig.JobRunner
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunnerTokens queries the job_runner_tokens edge of a Organization.
func (c *OrganizationClient) QueryJobRunnerTokens(_m *Organization) *JobRunnerTokenQuery {
	query := (&JobRunnerTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(jobrunnertoken.Table, jobrunnertoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.JobRunnerTokensTable, organization.JobRunnerTokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunnerToken
		step.Edge.Schema = schemaConfig.JobRunnerToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunnerRegistrationTokens queries the job_runner_registration_tokens edge of a Organization.
func (c *OrganizationClient) QueryJobRunnerRegistrationTokens(_m *Organization) *JobRunnerRegistrationTokenQuery {
	query := (&JobRunnerRegistrationTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(jobrunnerregistrationtoken.Table, jobrunnerregistrationtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.JobRunnerRegistrationTokensTable, organization.JobRunnerRegistrationTokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunnerRegistrationToken
		step.Edge.Schema = schemaConfig.JobRunnerRegistrationToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNSVerifications queries the dns_verifications edge of a Organization.
func (c *OrganizationClient) QueryDNSVerifications(_m *Organization) *DNSVerificationQuery {
	query := (&DNSVerificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(dnsverification.Table, dnsverification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.DNSVerificationsTable, organization.DNSVerificationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DNSVerification
		step.Edge.Schema = schemaConfig.DNSVerification
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobTemplates queries the job_templates edge of a Organization.
func (c *OrganizationClient) QueryJobTemplates(_m *Organization) *JobTemplateQuery {
	query := (&JobTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(jobtemplate.Table, jobtemplate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.JobTemplatesTable, organization.JobTemplatesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobTemplate
		step.Edge.Schema = schemaConfig.JobTemplate
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJobs queries the scheduled_jobs edge of a Organization.
func (c *OrganizationClient) QueryScheduledJobs(_m *Organization) *ScheduledJobQuery {
	query := (&ScheduledJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(scheduledjob.Table, scheduledjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ScheduledJobsTable, organization.ScheduledJobsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJob
		step.Edge.Schema = schemaConfig.ScheduledJob
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobResults queries the job_results edge of a Organization.
func (c *OrganizationClient) QueryJobResults(_m *Organization) *JobResultQuery {
	query := (&JobResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(jobresult.Table, jobresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.JobResultsTable, organization.JobResultsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobResult
		step.Edge.Schema = schemaConfig.JobResult
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJobRuns queries the scheduled_job_runs edge of a Organization.
func (c *OrganizationClient) QueryScheduledJobRuns(_m *Organization) *ScheduledJobRunQuery {
	query := (&ScheduledJobRunClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(scheduledjobrun.Table, scheduledjobrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ScheduledJobRunsTable, organization.ScheduledJobRunsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJobRun
		step.Edge.Schema = schemaConfig.ScheduledJobRun
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenters queries the trust_centers edge of a Organization.
func (c *OrganizationClient) QueryTrustCenters(_m *Organization) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TrustCentersTable, organization.TrustCentersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.TrustCenter
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Organization.
func (c *OrganizationClient) QueryAssets(_m *Organization) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.AssetsTable, organization.AssetsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Organization.
func (c *OrganizationClient) QueryScans(_m *Organization) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ScansTable, organization.ScansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubprocessors queries the subprocessors edge of a Organization.
func (c *OrganizationClient) QuerySubprocessors(_m *Organization) *SubprocessorQuery {
	query := (&SubprocessorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(subprocessor.Table, subprocessor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.SubprocessorsTable, organization.SubprocessorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subprocessor
		step.Edge.Schema = schemaConfig.Subprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExports queries the exports edge of a Organization.
func (c *OrganizationClient) QueryExports(_m *Organization) *ExportQuery {
	query := (&ExportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(export.Table, export.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ExportsTable, organization.ExportsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Export
		step.Edge.Schema = schemaConfig.Export
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterWatermarkConfigs queries the trust_center_watermark_configs edge of a Organization.
func (c *OrganizationClient) QueryTrustCenterWatermarkConfigs(_m *Organization) *TrustCenterWatermarkConfigQuery {
	query := (&TrustCenterWatermarkConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(trustcenterwatermarkconfig.Table, trustcenterwatermarkconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TrustCenterWatermarkConfigsTable, organization.TrustCenterWatermarkConfigsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterWatermarkConfig
		step.Edge.Schema = schemaConfig.TrustCenterWatermarkConfig
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImpersonationEvents queries the impersonation_events edge of a Organization.
func (c *OrganizationClient) QueryImpersonationEvents(_m *Organization) *ImpersonationEventQuery {
	query := (&ImpersonationEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(impersonationevent.Table, impersonationevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ImpersonationEventsTable, organization.ImpersonationEventsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ImpersonationEvent
		step.Edge.Schema = schemaConfig.ImpersonationEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssessments queries the assessments edge of a Organization.
func (c *OrganizationClient) QueryAssessments(_m *Organization) *AssessmentQuery {
	query := (&AssessmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(assessment.Table, assessment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.AssessmentsTable, organization.AssessmentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Assessment
		step.Edge.Schema = schemaConfig.Assessment
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssessmentResponses queries the assessment_responses edge of a Organization.
func (c *OrganizationClient) QueryAssessmentResponses(_m *Organization) *AssessmentResponseQuery {
	query := (&AssessmentResponseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(assessmentresponse.Table, assessmentresponse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.AssessmentResponsesTable, organization.AssessmentResponsesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.AssessmentResponse
		step.Edge.Schema = schemaConfig.AssessmentResponse
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomTypeEnums queries the custom_type_enums edge of a Organization.
func (c *OrganizationClient) QueryCustomTypeEnums(_m *Organization) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.CustomTypeEnumsTable, organization.CustomTypeEnumsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.CustomTypeEnum
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTagDefinitions queries the tag_definitions edge of a Organization.
func (c *OrganizationClient) QueryTagDefinitions(_m *Organization) *TagDefinitionQuery {
	query := (&TagDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(tagdefinition.Table, tagdefinition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TagDefinitionsTable, organization.TagDefinitionsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TagDefinition
		step.Edge.Schema = schemaConfig.TagDefinition
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediations queries the remediations edge of a Organization.
func (c *OrganizationClient) QueryRemediations(_m *Organization) *RemediationQuery {
	query := (&RemediationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(remediation.Table, remediation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.RemediationsTable, organization.RemediationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Remediation
		step.Edge.Schema = schemaConfig.Remediation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a Organization.
func (c *OrganizationClient) QueryFindings(_m *Organization) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.FindingsTable, organization.FindingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.Finding
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Organization.
func (c *OrganizationClient) QueryReviews(_m *Organization) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ReviewsTable, organization.ReviewsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Review
		step.Edge.Schema = schemaConfig.Review
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Organization.
func (c *OrganizationClient) QueryVulnerabilities(_m *Organization) *VulnerabilityQuery {
	query := (&VulnerabilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.VulnerabilitiesTable, organization.VulnerabilitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Vulnerability
		step.Edge.Schema = schemaConfig.Vulnerability
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Organization.
func (c *OrganizationClient) QueryNotifications(_m *Organization) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.NotificationsTable, organization.NotificationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Notification
		step.Edge.Schema = schemaConfig.Notification
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Organization.
func (c *OrganizationClient) QueryMembers(_m *Organization) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, organization.MembersTable, organization.MembersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Organization
	return append(hooks[:len(hooks):len(hooks)], organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	inters := c.inters.Organization
	return append(inters[:len(inters):len(inters)], organization.Interceptors[:]...)
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Organization mutation op: %q", m.Op())
	}
}

// OrganizationHistoryClient is a client for the OrganizationHistory schema.
type OrganizationHistoryClient struct {
	config
}

// NewOrganizationHistoryClient returns a client for the OrganizationHistory from the given config.
func NewOrganizationHistoryClient(c config) *OrganizationHistoryClient {
	return &OrganizationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationhistory.Hooks(f(g(h())))`.
func (c *OrganizationHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrganizationHistory = append(c.hooks.OrganizationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationhistory.Intercept(f(g(h())))`.
func (c *OrganizationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationHistory = append(c.inters.OrganizationHistory, interceptors...)
}

// Create returns a builder for creating a OrganizationHistory entity.
func (c *OrganizationHistoryClient) Create() *OrganizationHistoryCreate {
	mutation := newOrganizationHistoryMutation(c.config, OpCreate)
	return &OrganizationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationHistory entities.
func (c *OrganizationHistoryClient) CreateBulk(builders ...*OrganizationHistoryCreate) *OrganizationHistoryCreateBulk {
	return &OrganizationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationHistoryClient) MapCreateBulk(slice any, setFunc func(*OrganizationHistoryCreate, int)) *OrganizationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationHistoryCreateBulk{err: fmt.Errorf("calling to OrganizationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationHistory.
func (c *OrganizationHistoryClient) Update() *OrganizationHistoryUpdate {
	mutation := newOrganizationHistoryMutation(c.config, OpUpdate)
	return &OrganizationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationHistoryClient) UpdateOne(_m *OrganizationHistory) *OrganizationHistoryUpdateOne {
	mutation := newOrganizationHistoryMutation(c.config, OpUpdateOne, withOrganizationHistory(_m))
	return &OrganizationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationHistoryClient) UpdateOneID(id string) *OrganizationHistoryUpdateOne {
	mutation := newOrganizationHistoryMutation(c.config, OpUpdateOne, withOrganizationHistoryID(id))
	return &OrganizationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationHistory.
func (c *OrganizationHistoryClient) Delete() *OrganizationHistoryDelete {
	mutation := newOrganizationHistoryMutation(c.config, OpDelete)
	return &OrganizationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationHistoryClient) DeleteOne(_m *OrganizationHistory) *OrganizationHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationHistoryClient) DeleteOneID(id string) *OrganizationHistoryDeleteOne {
	builder := c.Delete().Where(organizationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationHistoryDeleteOne{builder}
}

// Query returns a query builder for OrganizationHistory.
func (c *OrganizationHistoryClient) Query() *OrganizationHistoryQuery {
	return &OrganizationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationHistory entity by its id.
func (c *OrganizationHistoryClient) Get(ctx context.Context, id string) (*OrganizationHistory, error) {
	return c.Query().Where(organizationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationHistoryClient) GetX(ctx context.Context, id string) *OrganizationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganizationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationHistory
	return append(hooks[:len(hooks):len(hooks)], organizationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OrganizationHistory
	return append(inters[:len(inters):len(inters)], organizationhistory.Interceptors[:]...)
}

func (c *OrganizationHistoryClient) mutate(ctx context.Context, m *OrganizationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrganizationHistory mutation op: %q", m.Op())
	}
}

// OrganizationSettingClient is a client for the OrganizationSetting schema.
type OrganizationSettingClient struct {
	config
}

// NewOrganizationSettingClient returns a client for the OrganizationSetting from the given config.
func NewOrganizationSettingClient(c config) *OrganizationSettingClient {
	return &OrganizationSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationsetting.Hooks(f(g(h())))`.
func (c *OrganizationSettingClient) Use(hooks ...Hook) {
	c.hooks.OrganizationSetting = append(c.hooks.OrganizationSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationsetting.Intercept(f(g(h())))`.
func (c *OrganizationSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationSetting = append(c.inters.OrganizationSetting, interceptors...)
}

// Create returns a builder for creating a OrganizationSetting entity.
func (c *OrganizationSettingClient) Create() *OrganizationSettingCreate {
	mutation := newOrganizationSettingMutation(c.config, OpCreate)
	return &OrganizationSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationSetting entities.
func (c *OrganizationSettingClient) CreateBulk(builders ...*OrganizationSettingCreate) *OrganizationSettingCreateBulk {
	return &OrganizationSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationSettingClient) MapCreateBulk(slice any, setFunc func(*OrganizationSettingCreate, int)) *OrganizationSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationSettingCreateBulk{err: fmt.Errorf("calling to OrganizationSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationSetting.
func (c *OrganizationSettingClient) Update() *OrganizationSettingUpdate {
	mutation := newOrganizationSettingMutation(c.config, OpUpdate)
	return &OrganizationSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationSettingClient) UpdateOne(_m *OrganizationSetting) *OrganizationSettingUpdateOne {
	mutation := newOrganizationSettingMutation(c.config, OpUpdateOne, withOrganizationSetting(_m))
	return &OrganizationSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationSettingClient) UpdateOneID(id string) *OrganizationSettingUpdateOne {
	mutation := newOrganizationSettingMutation(c.config, OpUpdateOne, withOrganizationSettingID(id))
	return &OrganizationSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationSetting.
func (c *OrganizationSettingClient) Delete() *OrganizationSettingDelete {
	mutation := newOrganizationSettingMutation(c.config, OpDelete)
	return &OrganizationSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationSettingClient) DeleteOne(_m *OrganizationSetting) *OrganizationSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationSettingClient) DeleteOneID(id string) *OrganizationSettingDeleteOne {
	builder := c.Delete().Where(organizationsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationSettingDeleteOne{builder}
}

// Query returns a query builder for OrganizationSetting.
func (c *OrganizationSettingClient) Query() *OrganizationSettingQuery {
	return &OrganizationSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationSetting entity by its id.
func (c *OrganizationSettingClient) Get(ctx context.Context, id string) (*OrganizationSetting, error) {
	return c.Query().Where(organizationsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationSettingClient) GetX(ctx context.Context, id string) *OrganizationSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrganizationSetting.
func (c *OrganizationSettingClient) QueryOrganization(_m *OrganizationSetting) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationsetting.Table, organizationsetting.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, organizationsetting.OrganizationTable, organizationsetting.OrganizationColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a OrganizationSetting.
func (c *OrganizationSettingClient) QueryFiles(_m *OrganizationSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationsetting.Table, organizationsetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organizationsetting.FilesTable, organizationsetting.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.OrganizationSettingFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationSettingClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationSetting
	return append(hooks[:len(hooks):len(hooks)], organizationsetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationSettingClient) Interceptors() []Interceptor {
	inters := c.inters.OrganizationSetting
	return append(inters[:len(inters):len(inters)], organizationsetting.Interceptors[:]...)
}

func (c *OrganizationSettingClient) mutate(ctx context.Context, m *OrganizationSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrganizationSetting mutation op: %q", m.Op())
	}
}

// OrganizationSettingHistoryClient is a client for the OrganizationSettingHistory schema.
type OrganizationSettingHistoryClient struct {
	config
}

// NewOrganizationSettingHistoryClient returns a client for the OrganizationSettingHistory from the given config.
func NewOrganizationSettingHistoryClient(c config) *OrganizationSettingHistoryClient {
	return &OrganizationSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationsettinghistory.Hooks(f(g(h())))`.
func (c *OrganizationSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrganizationSettingHistory = append(c.hooks.OrganizationSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationsettinghistory.Intercept(f(g(h())))`.
func (c *OrganizationSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationSettingHistory = append(c.inters.OrganizationSettingHistory, interceptors...)
}

// Create returns a builder for creating a OrganizationSettingHistory entity.
func (c *OrganizationSettingHistoryClient) Create() *OrganizationSettingHistoryCreate {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpCreate)
	return &OrganizationSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationSettingHistory entities.
func (c *OrganizationSettingHistoryClient) CreateBulk(builders ...*OrganizationSettingHistoryCreate) *OrganizationSettingHistoryCreateBulk {
	return &OrganizationSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*OrganizationSettingHistoryCreate, int)) *OrganizationSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationSettingHistoryCreateBulk{err: fmt.Errorf("calling to OrganizationSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationSettingHistory.
func (c *OrganizationSettingHistoryClient) Update() *OrganizationSettingHistoryUpdate {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpUpdate)
	return &OrganizationSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationSettingHistoryClient) UpdateOne(_m *OrganizationSettingHistory) *OrganizationSettingHistoryUpdateOne {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpUpdateOne, withOrganizationSettingHistory(_m))
	return &OrganizationSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationSettingHistoryClient) UpdateOneID(id string) *OrganizationSettingHistoryUpdateOne {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpUpdateOne, withOrganizationSettingHistoryID(id))
	return &OrganizationSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationSettingHistory.
func (c *OrganizationSettingHistoryClient) Delete() *OrganizationSettingHistoryDelete {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpDelete)
	return &OrganizationSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationSettingHistoryClient) DeleteOne(_m *OrganizationSettingHistory) *OrganizationSettingHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationSettingHistoryClient) DeleteOneID(id string) *OrganizationSettingHistoryDeleteOne {
	builder := c.Delete().Where(organizationsettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for OrganizationSettingHistory.
func (c *OrganizationSettingHistoryClient) Query() *OrganizationSettingHistoryQuery {
	return &OrganizationSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationSettingHistory entity by its id.
func (c *OrganizationSettingHistoryClient) Get(ctx context.Context, id string) (*OrganizationSettingHistory, error) {
	return c.Query().Where(organizationsettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationSettingHistoryClient) GetX(ctx context.Context, id string) *OrganizationSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganizationSettingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationSettingHistory
	return append(hooks[:len(hooks):len(hooks)], organizationsettinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OrganizationSettingHistory
	return append(inters[:len(inters):len(inters)], organizationsettinghistory.Interceptors[:]...)
}

func (c *OrganizationSettingHistoryClient) mutate(ctx context.Context, m *OrganizationSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrganizationSettingHistory mutation op: %q", m.Op())
	}
}

// PasswordResetTokenClient is a client for the PasswordResetToken schema.
type PasswordResetTokenClient struct {
	config
}

// NewPasswordResetTokenClient returns a client for the PasswordResetToken from the given config.
func NewPasswordResetTokenClient(c config) *PasswordResetTokenClient {
	return &PasswordResetTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passwordresettoken.Hooks(f(g(h())))`.
func (c *PasswordResetTokenClient) Use(hooks ...Hook) {
	c.hooks.PasswordResetToken = append(c.hooks.PasswordResetToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passwordresettoken.Intercept(f(g(h())))`.
func (c *PasswordResetTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PasswordResetToken = append(c.inters.PasswordResetToken, interceptors...)
}

// Create returns a builder for creating a PasswordResetToken entity.
func (c *PasswordResetTokenClient) Create() *PasswordResetTokenCreate {
	mutation := newPasswordResetTokenMutation(c.config, OpCreate)
	return &PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PasswordResetToken entities.
func (c *PasswordResetTokenClient) CreateBulk(builders ...*PasswordResetTokenCreate) *PasswordResetTokenCreateBulk {
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PasswordResetTokenClient) MapCreateBulk(slice any, setFunc func(*PasswordResetTokenCreate, int)) *PasswordResetTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PasswordResetTokenCreateBulk{err: fmt.Errorf("calling to PasswordResetTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PasswordResetTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Update() *PasswordResetTokenUpdate {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdate)
	return &PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PasswordResetTokenClient) UpdateOne(_m *PasswordResetToken) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetToken(_m))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PasswordResetTokenClient) UpdateOneID(id string) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetTokenID(id))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Delete() *PasswordResetTokenDelete {
	mutation := newPasswordResetTokenMutation(c.config, OpDelete)
	return &PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PasswordResetTokenClient) DeleteOne(_m *PasswordResetToken) *PasswordResetTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PasswordResetTokenClient) DeleteOneID(id string) *PasswordResetTokenDeleteOne {
	builder := c.Delete().Where(passwordresettoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PasswordResetTokenDeleteOne{builder}
}

// Query returns a query builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Query() *PasswordResetTokenQuery {
	return &PasswordResetTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePasswordResetToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PasswordResetToken entity by its id.
func (c *PasswordResetTokenClient) Get(ctx context.Context, id string) (*PasswordResetToken, error) {
	return c.Query().Where(passwordresettoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PasswordResetTokenClient) GetX(ctx context.Context, id string) *PasswordResetToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a PasswordResetToken.
func (c *PasswordResetTokenClient) QueryOwner(_m *PasswordResetToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passwordresettoken.Table, passwordresettoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, passwordresettoken.OwnerTable, passwordresettoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.PasswordResetToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PasswordResetTokenClient) Hooks() []Hook {
	hooks := c.hooks.PasswordResetToken
	return append(hooks[:len(hooks):len(hooks)], passwordresettoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PasswordResetTokenClient) Interceptors() []Interceptor {
	inters := c.inters.PasswordResetToken
	return append(inters[:len(inters):len(inters)], passwordresettoken.Interceptors[:]...)
}

func (c *PasswordResetTokenClient) mutate(ctx context.Context, m *PasswordResetTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown PasswordResetToken mutation op: %q", m.Op())
	}
}

// PersonalAccessTokenClient is a client for the PersonalAccessToken schema.
type PersonalAccessTokenClient struct {
	config
}

// NewPersonalAccessTokenClient returns a client for the PersonalAccessToken from the given config.
func NewPersonalAccessTokenClient(c config) *PersonalAccessTokenClient {
	return &PersonalAccessTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personalaccesstoken.Hooks(f(g(h())))`.
func (c *PersonalAccessTokenClient) Use(hooks ...Hook) {
	c.hooks.PersonalAccessToken = append(c.hooks.PersonalAccessToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `personalaccesstoken.Intercept(f(g(h())))`.
func (c *PersonalAccessTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PersonalAccessToken = append(c.inters.PersonalAccessToken, interceptors...)
}

// Create returns a builder for creating a PersonalAccessToken entity.
func (c *PersonalAccessTokenClient) Create() *PersonalAccessTokenCreate {
	mutation := newPersonalAccessTokenMutation(c.config, OpCreate)
	return &PersonalAccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PersonalAccessToken entities.
func (c *PersonalAccessTokenClient) CreateBulk(builders ...*PersonalAccessTokenCreate) *PersonalAccessTokenCreateBulk {
	return &PersonalAccessTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonalAccessTokenClient) MapCreateBulk(slice any, setFunc func(*PersonalAccessTokenCreate, int)) *PersonalAccessTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonalAccessTokenCreateBulk{err: fmt.Errorf("calling to PersonalAccessTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonalAccessTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonalAccessTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Update() *PersonalAccessTokenUpdate {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdate)
	return &PersonalAccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonalAccessTokenClient) UpdateOne(_m *PersonalAccessToken) *PersonalAccessTokenUpdateOne {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdateOne, withPersonalAccessToken(_m))
	return &PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonalAccessTokenClient) UpdateOneID(id string) *PersonalAccessTokenUpdateOne {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdateOne, withPersonalAccessTokenID(id))
	return &PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Delete() *PersonalAccessTokenDelete {
	mutation := newPersonalAccessTokenMutation(c.config, OpDelete)
	return &PersonalAccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonalAccessTokenClient) DeleteOne(_m *PersonalAccessToken) *PersonalAccessTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonalAccessTokenClient) DeleteOneID(id string) *PersonalAccessTokenDeleteOne {
	builder := c.Delete().Where(personalaccesstoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonalAccessTokenDeleteOne{builder}
}

// Query returns a query builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Query() *PersonalAccessTokenQuery {
	return &PersonalAccessTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePersonalAccessToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PersonalAccessToken entity by its id.
func (c *PersonalAccessTokenClient) Get(ctx context.Context, id string) (*PersonalAccessToken, error) {
	return c.Query().Where(personalaccesstoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonalAccessTokenClient) GetX(ctx context.Context, id string) *PersonalAccessToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryOwner(_m *PersonalAccessToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personalaccesstoken.OwnerTable, personalaccesstoken.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.PersonalAccessToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryOrganizations(_m *PersonalAccessToken) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, personalaccesstoken.OrganizationsTable, personalaccesstoken.OrganizationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationPersonalAccessTokens
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryEvents(_m *PersonalAccessToken) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, personalaccesstoken.EventsTable, personalaccesstoken.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.PersonalAccessTokenEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonalAccessTokenClient) Hooks() []Hook {
	hooks := c.hooks.PersonalAccessToken
	return append(hooks[:len(hooks):len(hooks)], personalaccesstoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PersonalAccessTokenClient) Interceptors() []Interceptor {
	inters := c.inters.PersonalAccessToken
	return append(inters[:len(inters):len(inters)], personalaccesstoken.Interceptors[:]...)
}

func (c *PersonalAccessTokenClient) mutate(ctx context.Context, m *PersonalAccessTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonalAccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonalAccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonalAccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown PersonalAccessToken mutation op: %q", m.Op())
	}
}

// ProcedureClient is a client for the Procedure schema.
type ProcedureClient struct {
	config
}

// NewProcedureClient returns a client for the Procedure from the given config.
func NewProcedureClient(c config) *ProcedureClient {
	return &ProcedureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `procedure.Hooks(f(g(h())))`.
func (c *ProcedureClient) Use(hooks ...Hook) {
	c.hooks.Procedure = append(c.hooks.Procedure, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `procedure.Intercept(f(g(h())))`.
func (c *ProcedureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Procedure = append(c.inters.Procedure, interceptors...)
}

// Create returns a builder for creating a Procedure entity.
func (c *ProcedureClient) Create() *ProcedureCreate {
	mutation := newProcedureMutation(c.config, OpCreate)
	return &ProcedureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Procedure entities.
func (c *ProcedureClient) CreateBulk(builders ...*ProcedureCreate) *ProcedureCreateBulk {
	return &ProcedureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProcedureClient) MapCreateBulk(slice any, setFunc func(*ProcedureCreate, int)) *ProcedureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProcedureCreateBulk{err: fmt.Errorf("calling to ProcedureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProcedureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProcedureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Procedure.
func (c *ProcedureClient) Update() *ProcedureUpdate {
	mutation := newProcedureMutation(c.config, OpUpdate)
	return &ProcedureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcedureClient) UpdateOne(_m *Procedure) *ProcedureUpdateOne {
	mutation := newProcedureMutation(c.config, OpUpdateOne, withProcedure(_m))
	return &ProcedureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcedureClient) UpdateOneID(id string) *ProcedureUpdateOne {
	mutation := newProcedureMutation(c.config, OpUpdateOne, withProcedureID(id))
	return &ProcedureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Procedure.
func (c *ProcedureClient) Delete() *ProcedureDelete {
	mutation := newProcedureMutation(c.config, OpDelete)
	return &ProcedureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcedureClient) DeleteOne(_m *Procedure) *ProcedureDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProcedureClient) DeleteOneID(id string) *ProcedureDeleteOne {
	builder := c.Delete().Where(procedure.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcedureDeleteOne{builder}
}

// Query returns a query builder for Procedure.
func (c *ProcedureClient) Query() *ProcedureQuery {
	return &ProcedureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProcedure},
		inters: c.Interceptors(),
	}
}

// Get returns a Procedure entity by its id.
func (c *ProcedureClient) Get(ctx context.Context, id string) (*Procedure, error) {
	return c.Query().Where(procedure.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcedureClient) GetX(ctx context.Context, id string) *Procedure {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Procedure.
func (c *ProcedureClient) QueryOwner(_m *Procedure) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, procedure.OwnerTable, procedure.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Procedure.
func (c *ProcedureClient) QueryBlockedGroups(_m *Procedure) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.BlockedGroupsTable, procedure.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ProcedureBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Procedure.
func (c *ProcedureClient) QueryEditors(_m *Procedure) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.EditorsTable, procedure.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ProcedureEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprover queries the approver edge of a Procedure.
func (c *ProcedureClient) QueryApprover(_m *Procedure) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, procedure.ApproverTable, procedure.ApproverColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDelegate queries the delegate edge of a Procedure.
func (c *ProcedureClient) QueryDelegate(_m *Procedure) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, procedure.DelegateTable, procedure.DelegateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedureKind queries the procedure_kind edge of a Procedure.
func (c *ProcedureClient) QueryProcedureKind(_m *Procedure) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, procedure.ProcedureKindTable, procedure.ProcedureKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Procedure.
func (c *ProcedureClient) QueryControls(_m *Procedure) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.ControlsTable, procedure.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Procedure.
func (c *ProcedureClient) QuerySubcontrols(_m *Procedure) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.SubcontrolsTable, procedure.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.SubcontrolProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Procedure.
func (c *ProcedureClient) QueryInternalPolicies(_m *Procedure) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.InternalPoliciesTable, procedure.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Procedure.
func (c *ProcedureClient) QueryPrograms(_m *Procedure) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.ProgramsTable, procedure.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Procedure.
func (c *ProcedureClient) QueryNarratives(_m *Procedure) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.NarrativesTable, procedure.NarrativesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ProcedureNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Procedure.
func (c *ProcedureClient) QueryRisks(_m *Procedure) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.RisksTable, procedure.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.ProcedureRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Procedure.
func (c *ProcedureClient) QueryTasks(_m *Procedure) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.TasksTable, procedure.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ProcedureTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Procedure.
func (c *ProcedureClient) QueryComments(_m *Procedure) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, procedure.CommentsTable, procedure.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a Procedure.
func (c *ProcedureClient) QueryFile(_m *Procedure) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, procedure.FileTable, procedure.FileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProcedureClient) Hooks() []Hook {
	hooks := c.hooks.Procedure
	return append(hooks[:len(hooks):len(hooks)], procedure.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProcedureClient) Interceptors() []Interceptor {
	inters := c.inters.Procedure
	return append(inters[:len(inters):len(inters)], procedure.Interceptors[:]...)
}

func (c *ProcedureClient) mutate(ctx context.Context, m *ProcedureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProcedureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProcedureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProcedureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProcedureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Procedure mutation op: %q", m.Op())
	}
}

// ProcedureHistoryClient is a client for the ProcedureHistory schema.
type ProcedureHistoryClient struct {
	config
}

// NewProcedureHistoryClient returns a client for the ProcedureHistory from the given config.
func NewProcedureHistoryClient(c config) *ProcedureHistoryClient {
	return &ProcedureHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `procedurehistory.Hooks(f(g(h())))`.
func (c *ProcedureHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProcedureHistory = append(c.hooks.ProcedureHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `procedurehistory.Intercept(f(g(h())))`.
func (c *ProcedureHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProcedureHistory = append(c.inters.ProcedureHistory, interceptors...)
}

// Create returns a builder for creating a ProcedureHistory entity.
func (c *ProcedureHistoryClient) Create() *ProcedureHistoryCreate {
	mutation := newProcedureHistoryMutation(c.config, OpCreate)
	return &ProcedureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcedureHistory entities.
func (c *ProcedureHistoryClient) CreateBulk(builders ...*ProcedureHistoryCreate) *ProcedureHistoryCreateBulk {
	return &ProcedureHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProcedureHistoryClient) MapCreateBulk(slice any, setFunc func(*ProcedureHistoryCreate, int)) *ProcedureHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProcedureHistoryCreateBulk{err: fmt.Errorf("calling to ProcedureHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProcedureHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProcedureHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcedureHistory.
func (c *ProcedureHistoryClient) Update() *ProcedureHistoryUpdate {
	mutation := newProcedureHistoryMutation(c.config, OpUpdate)
	return &ProcedureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcedureHistoryClient) UpdateOne(_m *ProcedureHistory) *ProcedureHistoryUpdateOne {
	mutation := newProcedureHistoryMutation(c.config, OpUpdateOne, withProcedureHistory(_m))
	return &ProcedureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcedureHistoryClient) UpdateOneID(id string) *ProcedureHistoryUpdateOne {
	mutation := newProcedureHistoryMutation(c.config, OpUpdateOne, withProcedureHistoryID(id))
	return &ProcedureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcedureHistory.
func (c *ProcedureHistoryClient) Delete() *ProcedureHistoryDelete {
	mutation := newProcedureHistoryMutation(c.config, OpDelete)
	return &ProcedureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcedureHistoryClient) DeleteOne(_m *ProcedureHistory) *ProcedureHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProcedureHistoryClient) DeleteOneID(id string) *ProcedureHistoryDeleteOne {
	builder := c.Delete().Where(procedurehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcedureHistoryDeleteOne{builder}
}

// Query returns a query builder for ProcedureHistory.
func (c *ProcedureHistoryClient) Query() *ProcedureHistoryQuery {
	return &ProcedureHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProcedureHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProcedureHistory entity by its id.
func (c *ProcedureHistoryClient) Get(ctx context.Context, id string) (*ProcedureHistory, error) {
	return c.Query().Where(procedurehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcedureHistoryClient) GetX(ctx context.Context, id string) *ProcedureHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProcedureHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ProcedureHistory
	return append(hooks[:len(hooks):len(hooks)], procedurehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProcedureHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ProcedureHistory
	return append(inters[:len(inters):len(inters)], procedurehistory.Interceptors[:]...)
}

func (c *ProcedureHistoryClient) mutate(ctx context.Context, m *ProcedureHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProcedureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProcedureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProcedureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProcedureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProcedureHistory mutation op: %q", m.Op())
	}
}

// ProgramClient is a client for the Program schema.
type ProgramClient struct {
	config
}

// NewProgramClient returns a client for the Program from the given config.
func NewProgramClient(c config) *ProgramClient {
	return &ProgramClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `program.Hooks(f(g(h())))`.
func (c *ProgramClient) Use(hooks ...Hook) {
	c.hooks.Program = append(c.hooks.Program, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `program.Intercept(f(g(h())))`.
func (c *ProgramClient) Intercept(interceptors ...Interceptor) {
	c.inters.Program = append(c.inters.Program, interceptors...)
}

// Create returns a builder for creating a Program entity.
func (c *ProgramClient) Create() *ProgramCreate {
	mutation := newProgramMutation(c.config, OpCreate)
	return &ProgramCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Program entities.
func (c *ProgramClient) CreateBulk(builders ...*ProgramCreate) *ProgramCreateBulk {
	return &ProgramCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramClient) MapCreateBulk(slice any, setFunc func(*ProgramCreate, int)) *ProgramCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramCreateBulk{err: fmt.Errorf("calling to ProgramClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Program.
func (c *ProgramClient) Update() *ProgramUpdate {
	mutation := newProgramMutation(c.config, OpUpdate)
	return &ProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramClient) UpdateOne(_m *Program) *ProgramUpdateOne {
	mutation := newProgramMutation(c.config, OpUpdateOne, withProgram(_m))
	return &ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramClient) UpdateOneID(id string) *ProgramUpdateOne {
	mutation := newProgramMutation(c.config, OpUpdateOne, withProgramID(id))
	return &ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Program.
func (c *ProgramClient) Delete() *ProgramDelete {
	mutation := newProgramMutation(c.config, OpDelete)
	return &ProgramDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramClient) DeleteOne(_m *Program) *ProgramDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramClient) DeleteOneID(id string) *ProgramDeleteOne {
	builder := c.Delete().Where(program.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramDeleteOne{builder}
}

// Query returns a query builder for Program.
func (c *ProgramClient) Query() *ProgramQuery {
	return &ProgramQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgram},
		inters: c.Interceptors(),
	}
}

// Get returns a Program entity by its id.
func (c *ProgramClient) Get(ctx context.Context, id string) (*Program, error) {
	return c.Query().Where(program.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramClient) GetX(ctx context.Context, id string) *Program {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Program.
func (c *ProgramClient) QueryOwner(_m *Program) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, program.OwnerTable, program.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Program.
func (c *ProgramClient) QueryBlockedGroups(_m *Program) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.BlockedGroupsTable, program.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ProgramBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Program.
func (c *ProgramClient) QueryEditors(_m *Program) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.EditorsTable, program.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ProgramEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Program.
func (c *ProgramClient) QueryViewers(_m *Program) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ViewersTable, program.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ProgramViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramKind queries the program_kind edge of a Program.
func (c *ProgramClient) QueryProgramKind(_m *Program) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, program.ProgramKindTable, program.ProgramKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Program.
func (c *ProgramClient) QueryControls(_m *Program) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ControlsTable, program.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ProgramControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Program.
func (c *ProgramClient) QuerySubcontrols(_m *Program) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.SubcontrolsTable, program.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a Program.
func (c *ProgramClient) QueryControlObjectives(_m *Program) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ControlObjectivesTable, program.ControlObjectivesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ProgramControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Program.
func (c *ProgramClient) QueryInternalPolicies(_m *Program) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.InternalPoliciesTable, program.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.ProgramInternalPolicies
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Program.
func (c *ProgramClient) QueryProcedures(_m *Program) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ProceduresTable, program.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProgramProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Program.
func (c *ProgramClient) QueryRisks(_m *Program) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.RisksTable, program.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.ProgramRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Program.
func (c *ProgramClient) QueryTasks(_m *Program) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.TasksTable, program.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ProgramTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Program.
func (c *ProgramClient) QueryNotes(_m *Program) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.NotesTable, program.NotesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Program.
func (c *ProgramClient) QueryFiles(_m *Program) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.FilesTable, program.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.ProgramFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidence queries the evidence edge of a Program.
func (c *ProgramClient) QueryEvidence(_m *Program) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.EvidenceTable, program.EvidencePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.ProgramEvidence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Program.
func (c *ProgramClient) QueryNarratives(_m *Program) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.NarrativesTable, program.NarrativesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ProgramNarratives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Program.
func (c *ProgramClient) QueryActionPlans(_m *Program) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ActionPlansTable, program.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ProgramActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Program.
func (c *ProgramClient) QueryUsers(_m *Program) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, program.UsersTable, program.UsersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramOwner queries the program_owner edge of a Program.
func (c *ProgramClient) QueryProgramOwner(_m *Program) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, program.ProgramOwnerTable, program.ProgramOwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Program.
func (c *ProgramClient) QueryMembers(_m *Program) *ProgramMembershipQuery {
	query := (&ProgramMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(programmembership.Table, programmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, program.MembersTable, program.MembersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ProgramMembership
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramClient) Hooks() []Hook {
	hooks := c.hooks.Program
	return append(hooks[:len(hooks):len(hooks)], program.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramClient) Interceptors() []Interceptor {
	inters := c.inters.Program
	return append(inters[:len(inters):len(inters)], program.Interceptors[:]...)
}

func (c *ProgramClient) mutate(ctx context.Context, m *ProgramMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Program mutation op: %q", m.Op())
	}
}

// ProgramHistoryClient is a client for the ProgramHistory schema.
type ProgramHistoryClient struct {
	config
}

// NewProgramHistoryClient returns a client for the ProgramHistory from the given config.
func NewProgramHistoryClient(c config) *ProgramHistoryClient {
	return &ProgramHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programhistory.Hooks(f(g(h())))`.
func (c *ProgramHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProgramHistory = append(c.hooks.ProgramHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programhistory.Intercept(f(g(h())))`.
func (c *ProgramHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramHistory = append(c.inters.ProgramHistory, interceptors...)
}

// Create returns a builder for creating a ProgramHistory entity.
func (c *ProgramHistoryClient) Create() *ProgramHistoryCreate {
	mutation := newProgramHistoryMutation(c.config, OpCreate)
	return &ProgramHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramHistory entities.
func (c *ProgramHistoryClient) CreateBulk(builders ...*ProgramHistoryCreate) *ProgramHistoryCreateBulk {
	return &ProgramHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramHistoryClient) MapCreateBulk(slice any, setFunc func(*ProgramHistoryCreate, int)) *ProgramHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramHistoryCreateBulk{err: fmt.Errorf("calling to ProgramHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramHistory.
func (c *ProgramHistoryClient) Update() *ProgramHistoryUpdate {
	mutation := newProgramHistoryMutation(c.config, OpUpdate)
	return &ProgramHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramHistoryClient) UpdateOne(_m *ProgramHistory) *ProgramHistoryUpdateOne {
	mutation := newProgramHistoryMutation(c.config, OpUpdateOne, withProgramHistory(_m))
	return &ProgramHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramHistoryClient) UpdateOneID(id string) *ProgramHistoryUpdateOne {
	mutation := newProgramHistoryMutation(c.config, OpUpdateOne, withProgramHistoryID(id))
	return &ProgramHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramHistory.
func (c *ProgramHistoryClient) Delete() *ProgramHistoryDelete {
	mutation := newProgramHistoryMutation(c.config, OpDelete)
	return &ProgramHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramHistoryClient) DeleteOne(_m *ProgramHistory) *ProgramHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramHistoryClient) DeleteOneID(id string) *ProgramHistoryDeleteOne {
	builder := c.Delete().Where(programhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramHistoryDeleteOne{builder}
}

// Query returns a query builder for ProgramHistory.
func (c *ProgramHistoryClient) Query() *ProgramHistoryQuery {
	return &ProgramHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramHistory entity by its id.
func (c *ProgramHistoryClient) Get(ctx context.Context, id string) (*ProgramHistory, error) {
	return c.Query().Where(programhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramHistoryClient) GetX(ctx context.Context, id string) *ProgramHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProgramHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ProgramHistory
	return append(hooks[:len(hooks):len(hooks)], programhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ProgramHistory
	return append(inters[:len(inters):len(inters)], programhistory.Interceptors[:]...)
}

func (c *ProgramHistoryClient) mutate(ctx context.Context, m *ProgramHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProgramHistory mutation op: %q", m.Op())
	}
}

// ProgramMembershipClient is a client for the ProgramMembership schema.
type ProgramMembershipClient struct {
	config
}

// NewProgramMembershipClient returns a client for the ProgramMembership from the given config.
func NewProgramMembershipClient(c config) *ProgramMembershipClient {
	return &ProgramMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programmembership.Hooks(f(g(h())))`.
func (c *ProgramMembershipClient) Use(hooks ...Hook) {
	c.hooks.ProgramMembership = append(c.hooks.ProgramMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programmembership.Intercept(f(g(h())))`.
func (c *ProgramMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramMembership = append(c.inters.ProgramMembership, interceptors...)
}

// Create returns a builder for creating a ProgramMembership entity.
func (c *ProgramMembershipClient) Create() *ProgramMembershipCreate {
	mutation := newProgramMembershipMutation(c.config, OpCreate)
	return &ProgramMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramMembership entities.
func (c *ProgramMembershipClient) CreateBulk(builders ...*ProgramMembershipCreate) *ProgramMembershipCreateBulk {
	return &ProgramMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramMembershipClient) MapCreateBulk(slice any, setFunc func(*ProgramMembershipCreate, int)) *ProgramMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramMembershipCreateBulk{err: fmt.Errorf("calling to ProgramMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramMembership.
func (c *ProgramMembershipClient) Update() *ProgramMembershipUpdate {
	mutation := newProgramMembershipMutation(c.config, OpUpdate)
	return &ProgramMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramMembershipClient) UpdateOne(_m *ProgramMembership) *ProgramMembershipUpdateOne {
	mutation := newProgramMembershipMutation(c.config, OpUpdateOne, withProgramMembership(_m))
	return &ProgramMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramMembershipClient) UpdateOneID(id string) *ProgramMembershipUpdateOne {
	mutation := newProgramMembershipMutation(c.config, OpUpdateOne, withProgramMembershipID(id))
	return &ProgramMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramMembership.
func (c *ProgramMembershipClient) Delete() *ProgramMembershipDelete {
	mutation := newProgramMembershipMutation(c.config, OpDelete)
	return &ProgramMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramMembershipClient) DeleteOne(_m *ProgramMembership) *ProgramMembershipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramMembershipClient) DeleteOneID(id string) *ProgramMembershipDeleteOne {
	builder := c.Delete().Where(programmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramMembershipDeleteOne{builder}
}

// Query returns a query builder for ProgramMembership.
func (c *ProgramMembershipClient) Query() *ProgramMembershipQuery {
	return &ProgramMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramMembership entity by its id.
func (c *ProgramMembershipClient) Get(ctx context.Context, id string) (*ProgramMembership, error) {
	return c.Query().Where(programmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramMembershipClient) GetX(ctx context.Context, id string) *ProgramMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a ProgramMembership.
func (c *ProgramMembershipClient) QueryProgram(_m *ProgramMembership) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programmembership.Table, programmembership.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, programmembership.ProgramTable, programmembership.ProgramColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ProgramMembership.
func (c *ProgramMembershipClient) QueryUser(_m *ProgramMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programmembership.Table, programmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, programmembership.UserTable, programmembership.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgMembership queries the org_membership edge of a ProgramMembership.
func (c *ProgramMembershipClient) QueryOrgMembership(_m *ProgramMembership) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programmembership.Table, programmembership.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, programmembership.OrgMembershipTable, programmembership.OrgMembershipColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramMembershipClient) Hooks() []Hook {
	hooks := c.hooks.ProgramMembership
	return append(hooks[:len(hooks):len(hooks)], programmembership.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramMembershipClient) Interceptors() []Interceptor {
	inters := c.inters.ProgramMembership
	return append(inters[:len(inters):len(inters)], programmembership.Interceptors[:]...)
}

func (c *ProgramMembershipClient) mutate(ctx context.Context, m *ProgramMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProgramMembership mutation op: %q", m.Op())
	}
}

// ProgramMembershipHistoryClient is a client for the ProgramMembershipHistory schema.
type ProgramMembershipHistoryClient struct {
	config
}

// NewProgramMembershipHistoryClient returns a client for the ProgramMembershipHistory from the given config.
func NewProgramMembershipHistoryClient(c config) *ProgramMembershipHistoryClient {
	return &ProgramMembershipHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programmembershiphistory.Hooks(f(g(h())))`.
func (c *ProgramMembershipHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProgramMembershipHistory = append(c.hooks.ProgramMembershipHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programmembershiphistory.Intercept(f(g(h())))`.
func (c *ProgramMembershipHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramMembershipHistory = append(c.inters.ProgramMembershipHistory, interceptors...)
}

// Create returns a builder for creating a ProgramMembershipHistory entity.
func (c *ProgramMembershipHistoryClient) Create() *ProgramMembershipHistoryCreate {
	mutation := newProgramMembershipHistoryMutation(c.config, OpCreate)
	return &ProgramMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramMembershipHistory entities.
func (c *ProgramMembershipHistoryClient) CreateBulk(builders ...*ProgramMembershipHistoryCreate) *ProgramMembershipHistoryCreateBulk {
	return &ProgramMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramMembershipHistoryClient) MapCreateBulk(slice any, setFunc func(*ProgramMembershipHistoryCreate, int)) *ProgramMembershipHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramMembershipHistoryCreateBulk{err: fmt.Errorf("calling to ProgramMembershipHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramMembershipHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramMembershipHistory.
func (c *ProgramMembershipHistoryClient) Update() *ProgramMembershipHistoryUpdate {
	mutation := newProgramMembershipHistoryMutation(c.config, OpUpdate)
	return &ProgramMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramMembershipHistoryClient) UpdateOne(_m *ProgramMembershipHistory) *ProgramMembershipHistoryUpdateOne {
	mutation := newProgramMembershipHistoryMutation(c.config, OpUpdateOne, withProgramMembershipHistory(_m))
	return &ProgramMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramMembershipHistoryClient) UpdateOneID(id string) *ProgramMembershipHistoryUpdateOne {
	mutation := newProgramMembershipHistoryMutation(c.config, OpUpdateOne, withProgramMembershipHistoryID(id))
	return &ProgramMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramMembershipHistory.
func (c *ProgramMembershipHistoryClient) Delete() *ProgramMembershipHistoryDelete {
	mutation := newProgramMembershipHistoryMutation(c.config, OpDelete)
	return &ProgramMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramMembershipHistoryClient) DeleteOne(_m *ProgramMembershipHistory) *ProgramMembershipHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramMembershipHistoryClient) DeleteOneID(id string) *ProgramMembershipHistoryDeleteOne {
	builder := c.Delete().Where(programmembershiphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramMembershipHistoryDeleteOne{builder}
}

// Query returns a query builder for ProgramMembershipHistory.
func (c *ProgramMembershipHistoryClient) Query() *ProgramMembershipHistoryQuery {
	return &ProgramMembershipHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramMembershipHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramMembershipHistory entity by its id.
func (c *ProgramMembershipHistoryClient) Get(ctx context.Context, id string) (*ProgramMembershipHistory, error) {
	return c.Query().Where(programmembershiphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramMembershipHistoryClient) GetX(ctx context.Context, id string) *ProgramMembershipHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProgramMembershipHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ProgramMembershipHistory
	return append(hooks[:len(hooks):len(hooks)], programmembershiphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramMembershipHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ProgramMembershipHistory
	return append(inters[:len(inters):len(inters)], programmembershiphistory.Interceptors[:]...)
}

func (c *ProgramMembershipHistoryClient) mutate(ctx context.Context, m *ProgramMembershipHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProgramMembershipHistory mutation op: %q", m.Op())
	}
}

// RemediationClient is a client for the Remediation schema.
type RemediationClient struct {
	config
}

// NewRemediationClient returns a client for the Remediation from the given config.
func NewRemediationClient(c config) *RemediationClient {
	return &RemediationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `remediation.Hooks(f(g(h())))`.
func (c *RemediationClient) Use(hooks ...Hook) {
	c.hooks.Remediation = append(c.hooks.Remediation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `remediation.Intercept(f(g(h())))`.
func (c *RemediationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Remediation = append(c.inters.Remediation, interceptors...)
}

// Create returns a builder for creating a Remediation entity.
func (c *RemediationClient) Create() *RemediationCreate {
	mutation := newRemediationMutation(c.config, OpCreate)
	return &RemediationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Remediation entities.
func (c *RemediationClient) CreateBulk(builders ...*RemediationCreate) *RemediationCreateBulk {
	return &RemediationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RemediationClient) MapCreateBulk(slice any, setFunc func(*RemediationCreate, int)) *RemediationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RemediationCreateBulk{err: fmt.Errorf("calling to RemediationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RemediationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RemediationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Remediation.
func (c *RemediationClient) Update() *RemediationUpdate {
	mutation := newRemediationMutation(c.config, OpUpdate)
	return &RemediationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RemediationClient) UpdateOne(_m *Remediation) *RemediationUpdateOne {
	mutation := newRemediationMutation(c.config, OpUpdateOne, withRemediation(_m))
	return &RemediationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RemediationClient) UpdateOneID(id string) *RemediationUpdateOne {
	mutation := newRemediationMutation(c.config, OpUpdateOne, withRemediationID(id))
	return &RemediationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Remediation.
func (c *RemediationClient) Delete() *RemediationDelete {
	mutation := newRemediationMutation(c.config, OpDelete)
	return &RemediationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RemediationClient) DeleteOne(_m *Remediation) *RemediationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RemediationClient) DeleteOneID(id string) *RemediationDeleteOne {
	builder := c.Delete().Where(remediation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RemediationDeleteOne{builder}
}

// Query returns a query builder for Remediation.
func (c *RemediationClient) Query() *RemediationQuery {
	return &RemediationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRemediation},
		inters: c.Interceptors(),
	}
}

// Get returns a Remediation entity by its id.
func (c *RemediationClient) Get(ctx context.Context, id string) (*Remediation, error) {
	return c.Query().Where(remediation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RemediationClient) GetX(ctx context.Context, id string) *Remediation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Remediation.
func (c *RemediationClient) QueryOwner(_m *Remediation) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, remediation.OwnerTable, remediation.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Remediation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Remediation.
func (c *RemediationClient) QueryBlockedGroups(_m *Remediation) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.BlockedGroupsTable, remediation.BlockedGroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Remediation.
func (c *RemediationClient) QueryEditors(_m *Remediation) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.EditorsTable, remediation.EditorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Remediation.
func (c *RemediationClient) QueryViewers(_m *Remediation) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.ViewersTable, remediation.ViewersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Remediation.
func (c *RemediationClient) QueryIntegrations(_m *Remediation) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, remediation.IntegrationsTable, remediation.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationRemediations
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a Remediation.
func (c *RemediationClient) QueryFindings(_m *Remediation) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.FindingsTable, remediation.FindingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.Finding
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Remediation.
func (c *RemediationClient) QueryVulnerabilities(_m *Remediation) *VulnerabilityQuery {
	query := (&VulnerabilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.VulnerabilitiesTable, remediation.VulnerabilitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Vulnerability
		step.Edge.Schema = schemaConfig.Vulnerability
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Remediation.
func (c *RemediationClient) QueryActionPlans(_m *Remediation) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, remediation.ActionPlansTable, remediation.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.RemediationActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Remediation.
func (c *RemediationClient) QueryTasks(_m *Remediation) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.TasksTable, remediation.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Remediation.
func (c *RemediationClient) QueryControls(_m *Remediation) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.ControlsTable, remediation.ControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Remediation.
func (c *RemediationClient) QuerySubcontrols(_m *Remediation) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.SubcontrolsTable, remediation.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Remediation.
func (c *RemediationClient) QueryRisks(_m *Remediation) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.RisksTable, remediation.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Remediation.
func (c *RemediationClient) QueryPrograms(_m *Remediation) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.ProgramsTable, remediation.ProgramsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Remediation.
func (c *RemediationClient) QueryAssets(_m *Remediation) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.AssetsTable, remediation.AssetsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Remediation.
func (c *RemediationClient) QueryEntities(_m *Remediation) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.EntitiesTable, remediation.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Remediation.
func (c *RemediationClient) QueryReviews(_m *Remediation) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.ReviewsTable, remediation.ReviewsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Review
		step.Edge.Schema = schemaConfig.Review
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Remediation.
func (c *RemediationClient) QueryComments(_m *Remediation) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.CommentsTable, remediation.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Remediation.
func (c *RemediationClient) QueryFiles(_m *Remediation) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediation.Table, remediation.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, remediation.FilesTable, remediation.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RemediationClient) Hooks() []Hook {
	hooks := c.hooks.Remediation
	return append(hooks[:len(hooks):len(hooks)], remediation.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RemediationClient) Interceptors() []Interceptor {
	inters := c.inters.Remediation
	return append(inters[:len(inters):len(inters)], remediation.Interceptors[:]...)
}

func (c *RemediationClient) mutate(ctx context.Context, m *RemediationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RemediationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RemediationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RemediationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RemediationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Remediation mutation op: %q", m.Op())
	}
}

// RemediationHistoryClient is a client for the RemediationHistory schema.
type RemediationHistoryClient struct {
	config
}

// NewRemediationHistoryClient returns a client for the RemediationHistory from the given config.
func NewRemediationHistoryClient(c config) *RemediationHistoryClient {
	return &RemediationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `remediationhistory.Hooks(f(g(h())))`.
func (c *RemediationHistoryClient) Use(hooks ...Hook) {
	c.hooks.RemediationHistory = append(c.hooks.RemediationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `remediationhistory.Intercept(f(g(h())))`.
func (c *RemediationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.RemediationHistory = append(c.inters.RemediationHistory, interceptors...)
}

// Create returns a builder for creating a RemediationHistory entity.
func (c *RemediationHistoryClient) Create() *RemediationHistoryCreate {
	mutation := newRemediationHistoryMutation(c.config, OpCreate)
	return &RemediationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RemediationHistory entities.
func (c *RemediationHistoryClient) CreateBulk(builders ...*RemediationHistoryCreate) *RemediationHistoryCreateBulk {
	return &RemediationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RemediationHistoryClient) MapCreateBulk(slice any, setFunc func(*RemediationHistoryCreate, int)) *RemediationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RemediationHistoryCreateBulk{err: fmt.Errorf("calling to RemediationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RemediationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RemediationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RemediationHistory.
func (c *RemediationHistoryClient) Update() *RemediationHistoryUpdate {
	mutation := newRemediationHistoryMutation(c.config, OpUpdate)
	return &RemediationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RemediationHistoryClient) UpdateOne(_m *RemediationHistory) *RemediationHistoryUpdateOne {
	mutation := newRemediationHistoryMutation(c.config, OpUpdateOne, withRemediationHistory(_m))
	return &RemediationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RemediationHistoryClient) UpdateOneID(id string) *RemediationHistoryUpdateOne {
	mutation := newRemediationHistoryMutation(c.config, OpUpdateOne, withRemediationHistoryID(id))
	return &RemediationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RemediationHistory.
func (c *RemediationHistoryClient) Delete() *RemediationHistoryDelete {
	mutation := newRemediationHistoryMutation(c.config, OpDelete)
	return &RemediationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RemediationHistoryClient) DeleteOne(_m *RemediationHistory) *RemediationHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RemediationHistoryClient) DeleteOneID(id string) *RemediationHistoryDeleteOne {
	builder := c.Delete().Where(remediationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RemediationHistoryDeleteOne{builder}
}

// Query returns a query builder for RemediationHistory.
func (c *RemediationHistoryClient) Query() *RemediationHistoryQuery {
	return &RemediationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRemediationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a RemediationHistory entity by its id.
func (c *RemediationHistoryClient) Get(ctx context.Context, id string) (*RemediationHistory, error) {
	return c.Query().Where(remediationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RemediationHistoryClient) GetX(ctx context.Context, id string) *RemediationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RemediationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.RemediationHistory
	return append(hooks[:len(hooks):len(hooks)], remediationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RemediationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.RemediationHistory
	return append(inters[:len(inters):len(inters)], remediationhistory.Interceptors[:]...)
}

func (c *RemediationHistoryClient) mutate(ctx context.Context, m *RemediationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RemediationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RemediationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RemediationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RemediationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RemediationHistory mutation op: %q", m.Op())
	}
}

// ReviewClient is a client for the Review schema.
type ReviewClient struct {
	config
}

// NewReviewClient returns a client for the Review from the given config.
func NewReviewClient(c config) *ReviewClient {
	return &ReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `review.Hooks(f(g(h())))`.
func (c *ReviewClient) Use(hooks ...Hook) {
	c.hooks.Review = append(c.hooks.Review, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `review.Intercept(f(g(h())))`.
func (c *ReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.Review = append(c.inters.Review, interceptors...)
}

// Create returns a builder for creating a Review entity.
func (c *ReviewClient) Create() *ReviewCreate {
	mutation := newReviewMutation(c.config, OpCreate)
	return &ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Review entities.
func (c *ReviewClient) CreateBulk(builders ...*ReviewCreate) *ReviewCreateBulk {
	return &ReviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReviewClient) MapCreateBulk(slice any, setFunc func(*ReviewCreate, int)) *ReviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReviewCreateBulk{err: fmt.Errorf("calling to ReviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Review.
func (c *ReviewClient) Update() *ReviewUpdate {
	mutation := newReviewMutation(c.config, OpUpdate)
	return &ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewClient) UpdateOne(_m *Review) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReview(_m))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewClient) UpdateOneID(id string) *ReviewUpdateOne {
	mutation := newReviewMutation(c.config, OpUpdateOne, withReviewID(id))
	return &ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Review.
func (c *ReviewClient) Delete() *ReviewDelete {
	mutation := newReviewMutation(c.config, OpDelete)
	return &ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReviewClient) DeleteOne(_m *Review) *ReviewDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReviewClient) DeleteOneID(id string) *ReviewDeleteOne {
	builder := c.Delete().Where(review.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewDeleteOne{builder}
}

// Query returns a query builder for Review.
func (c *ReviewClient) Query() *ReviewQuery {
	return &ReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReview},
		inters: c.Interceptors(),
	}
}

// Get returns a Review entity by its id.
func (c *ReviewClient) Get(ctx context.Context, id string) (*Review, error) {
	return c.Query().Where(review.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewClient) GetX(ctx context.Context, id string) *Review {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Review.
func (c *ReviewClient) QueryOwner(_m *Review) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, review.OwnerTable, review.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Review
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Review.
func (c *ReviewClient) QueryBlockedGroups(_m *Review) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.BlockedGroupsTable, review.BlockedGroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Review.
func (c *ReviewClient) QueryEditors(_m *Review) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.EditorsTable, review.EditorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Review.
func (c *ReviewClient) QueryViewers(_m *Review) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.ViewersTable, review.ViewersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Review.
func (c *ReviewClient) QueryIntegrations(_m *Review) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, review.IntegrationsTable, review.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationReviews
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a Review.
func (c *ReviewClient) QueryFindings(_m *Review) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.FindingsTable, review.FindingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.Finding
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Review.
func (c *ReviewClient) QueryVulnerabilities(_m *Review) *VulnerabilityQuery {
	query := (&VulnerabilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.VulnerabilitiesTable, review.VulnerabilitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Vulnerability
		step.Edge.Schema = schemaConfig.Vulnerability
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Review.
func (c *ReviewClient) QueryActionPlans(_m *Review) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, review.ActionPlansTable, review.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ReviewActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediations queries the remediations edge of a Review.
func (c *ReviewClient) QueryRemediations(_m *Review) *RemediationQuery {
	query := (&RemediationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(remediation.Table, remediation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.RemediationsTable, review.RemediationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Remediation
		step.Edge.Schema = schemaConfig.Remediation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Review.
func (c *ReviewClient) QueryControls(_m *Review) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.ControlsTable, review.ControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Review.
func (c *ReviewClient) QuerySubcontrols(_m *Review) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.SubcontrolsTable, review.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Review.
func (c *ReviewClient) QueryRisks(_m *Review) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.RisksTable, review.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Review.
func (c *ReviewClient) QueryPrograms(_m *Review) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.ProgramsTable, review.ProgramsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Review.
func (c *ReviewClient) QueryAssets(_m *Review) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.AssetsTable, review.AssetsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Review.
func (c *ReviewClient) QueryEntities(_m *Review) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.EntitiesTable, review.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Review.
func (c *ReviewClient) QueryTasks(_m *Review) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.TasksTable, review.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewer queries the reviewer edge of a Review.
func (c *ReviewClient) QueryReviewer(_m *Review) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, review.ReviewerTable, review.ReviewerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Review
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Review.
func (c *ReviewClient) QueryComments(_m *Review) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.CommentsTable, review.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Review.
func (c *ReviewClient) QueryFiles(_m *Review) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(review.Table, review.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, review.FilesTable, review.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReviewClient) Hooks() []Hook {
	hooks := c.hooks.Review
	return append(hooks[:len(hooks):len(hooks)], review.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ReviewClient) Interceptors() []Interceptor {
	inters := c.inters.Review
	return append(inters[:len(inters):len(inters)], review.Interceptors[:]...)
}

func (c *ReviewClient) mutate(ctx context.Context, m *ReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Review mutation op: %q", m.Op())
	}
}

// ReviewHistoryClient is a client for the ReviewHistory schema.
type ReviewHistoryClient struct {
	config
}

// NewReviewHistoryClient returns a client for the ReviewHistory from the given config.
func NewReviewHistoryClient(c config) *ReviewHistoryClient {
	return &ReviewHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reviewhistory.Hooks(f(g(h())))`.
func (c *ReviewHistoryClient) Use(hooks ...Hook) {
	c.hooks.ReviewHistory = append(c.hooks.ReviewHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reviewhistory.Intercept(f(g(h())))`.
func (c *ReviewHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReviewHistory = append(c.inters.ReviewHistory, interceptors...)
}

// Create returns a builder for creating a ReviewHistory entity.
func (c *ReviewHistoryClient) Create() *ReviewHistoryCreate {
	mutation := newReviewHistoryMutation(c.config, OpCreate)
	return &ReviewHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReviewHistory entities.
func (c *ReviewHistoryClient) CreateBulk(builders ...*ReviewHistoryCreate) *ReviewHistoryCreateBulk {
	return &ReviewHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReviewHistoryClient) MapCreateBulk(slice any, setFunc func(*ReviewHistoryCreate, int)) *ReviewHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReviewHistoryCreateBulk{err: fmt.Errorf("calling to ReviewHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReviewHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReviewHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReviewHistory.
func (c *ReviewHistoryClient) Update() *ReviewHistoryUpdate {
	mutation := newReviewHistoryMutation(c.config, OpUpdate)
	return &ReviewHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewHistoryClient) UpdateOne(_m *ReviewHistory) *ReviewHistoryUpdateOne {
	mutation := newReviewHistoryMutation(c.config, OpUpdateOne, withReviewHistory(_m))
	return &ReviewHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewHistoryClient) UpdateOneID(id string) *ReviewHistoryUpdateOne {
	mutation := newReviewHistoryMutation(c.config, OpUpdateOne, withReviewHistoryID(id))
	return &ReviewHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReviewHistory.
func (c *ReviewHistoryClient) Delete() *ReviewHistoryDelete {
	mutation := newReviewHistoryMutation(c.config, OpDelete)
	return &ReviewHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReviewHistoryClient) DeleteOne(_m *ReviewHistory) *ReviewHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReviewHistoryClient) DeleteOneID(id string) *ReviewHistoryDeleteOne {
	builder := c.Delete().Where(reviewhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewHistoryDeleteOne{builder}
}

// Query returns a query builder for ReviewHistory.
func (c *ReviewHistoryClient) Query() *ReviewHistoryQuery {
	return &ReviewHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReviewHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ReviewHistory entity by its id.
func (c *ReviewHistoryClient) Get(ctx context.Context, id string) (*ReviewHistory, error) {
	return c.Query().Where(reviewhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewHistoryClient) GetX(ctx context.Context, id string) *ReviewHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ReviewHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ReviewHistory
	return append(hooks[:len(hooks):len(hooks)], reviewhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ReviewHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ReviewHistory
	return append(inters[:len(inters):len(inters)], reviewhistory.Interceptors[:]...)
}

func (c *ReviewHistoryClient) mutate(ctx context.Context, m *ReviewHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReviewHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReviewHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReviewHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReviewHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ReviewHistory mutation op: %q", m.Op())
	}
}

// RiskClient is a client for the Risk schema.
type RiskClient struct {
	config
}

// NewRiskClient returns a client for the Risk from the given config.
func NewRiskClient(c config) *RiskClient {
	return &RiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `risk.Hooks(f(g(h())))`.
func (c *RiskClient) Use(hooks ...Hook) {
	c.hooks.Risk = append(c.hooks.Risk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `risk.Intercept(f(g(h())))`.
func (c *RiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Risk = append(c.inters.Risk, interceptors...)
}

// Create returns a builder for creating a Risk entity.
func (c *RiskClient) Create() *RiskCreate {
	mutation := newRiskMutation(c.config, OpCreate)
	return &RiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Risk entities.
func (c *RiskClient) CreateBulk(builders ...*RiskCreate) *RiskCreateBulk {
	return &RiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RiskClient) MapCreateBulk(slice any, setFunc func(*RiskCreate, int)) *RiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RiskCreateBulk{err: fmt.Errorf("calling to RiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Risk.
func (c *RiskClient) Update() *RiskUpdate {
	mutation := newRiskMutation(c.config, OpUpdate)
	return &RiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RiskClient) UpdateOne(_m *Risk) *RiskUpdateOne {
	mutation := newRiskMutation(c.config, OpUpdateOne, withRisk(_m))
	return &RiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RiskClient) UpdateOneID(id string) *RiskUpdateOne {
	mutation := newRiskMutation(c.config, OpUpdateOne, withRiskID(id))
	return &RiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Risk.
func (c *RiskClient) Delete() *RiskDelete {
	mutation := newRiskMutation(c.config, OpDelete)
	return &RiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RiskClient) DeleteOne(_m *Risk) *RiskDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RiskClient) DeleteOneID(id string) *RiskDeleteOne {
	builder := c.Delete().Where(risk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RiskDeleteOne{builder}
}

// Query returns a query builder for Risk.
func (c *RiskClient) Query() *RiskQuery {
	return &RiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRisk},
		inters: c.Interceptors(),
	}
}

// Get returns a Risk entity by its id.
func (c *RiskClient) Get(ctx context.Context, id string) (*Risk, error) {
	return c.Query().Where(risk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RiskClient) GetX(ctx context.Context, id string) *Risk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Risk.
func (c *RiskClient) QueryOwner(_m *Risk) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, risk.OwnerTable, risk.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Risk.
func (c *RiskClient) QueryBlockedGroups(_m *Risk) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, risk.BlockedGroupsTable, risk.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.RiskBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Risk.
func (c *RiskClient) QueryEditors(_m *Risk) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, risk.EditorsTable, risk.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.RiskEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Risk.
func (c *RiskClient) QueryViewers(_m *Risk) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, risk.ViewersTable, risk.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.RiskViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskKind queries the risk_kind edge of a Risk.
func (c *RiskClient) QueryRiskKind(_m *Risk) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, risk.RiskKindTable, risk.RiskKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRiskCategory queries the risk_category edge of a Risk.
func (c *RiskClient) QueryRiskCategory(_m *Risk) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, risk.RiskCategoryTable, risk.RiskCategoryColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Risk.
func (c *RiskClient) QueryControls(_m *Risk) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.ControlsTable, risk.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Risk.
func (c *RiskClient) QuerySubcontrols(_m *Risk) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.SubcontrolsTable, risk.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.SubcontrolRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Risk.
func (c *RiskClient) QueryProcedures(_m *Risk) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.ProceduresTable, risk.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Risk.
func (c *RiskClient) QueryInternalPolicies(_m *Risk) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.InternalPoliciesTable, risk.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Risk.
func (c *RiskClient) QueryPrograms(_m *Risk) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.ProgramsTable, risk.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Risk.
func (c *RiskClient) QueryActionPlans(_m *Risk) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, risk.ActionPlansTable, risk.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.RiskActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Risk.
func (c *RiskClient) QueryTasks(_m *Risk) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, risk.TasksTable, risk.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.RiskTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Risk.
func (c *RiskClient) QueryAssets(_m *Risk) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, risk.AssetsTable, risk.AssetsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Risk.
func (c *RiskClient) QueryEntities(_m *Risk) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, risk.EntitiesTable, risk.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Risk.
func (c *RiskClient) QueryScans(_m *Risk) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, risk.ScansTable, risk.ScansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStakeholder queries the stakeholder edge of a Risk.
func (c *RiskClient) QueryStakeholder(_m *Risk) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, risk.StakeholderTable, risk.StakeholderColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDelegate queries the delegate edge of a Risk.
func (c *RiskClient) QueryDelegate(_m *Risk) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, risk.DelegateTable, risk.DelegateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Risk.
func (c *RiskClient) QueryComments(_m *Risk) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, risk.CommentsTable, risk.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RiskClient) Hooks() []Hook {
	hooks := c.hooks.Risk
	return append(hooks[:len(hooks):len(hooks)], risk.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RiskClient) Interceptors() []Interceptor {
	inters := c.inters.Risk
	return append(inters[:len(inters):len(inters)], risk.Interceptors[:]...)
}

func (c *RiskClient) mutate(ctx context.Context, m *RiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Risk mutation op: %q", m.Op())
	}
}

// RiskHistoryClient is a client for the RiskHistory schema.
type RiskHistoryClient struct {
	config
}

// NewRiskHistoryClient returns a client for the RiskHistory from the given config.
func NewRiskHistoryClient(c config) *RiskHistoryClient {
	return &RiskHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `riskhistory.Hooks(f(g(h())))`.
func (c *RiskHistoryClient) Use(hooks ...Hook) {
	c.hooks.RiskHistory = append(c.hooks.RiskHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `riskhistory.Intercept(f(g(h())))`.
func (c *RiskHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.RiskHistory = append(c.inters.RiskHistory, interceptors...)
}

// Create returns a builder for creating a RiskHistory entity.
func (c *RiskHistoryClient) Create() *RiskHistoryCreate {
	mutation := newRiskHistoryMutation(c.config, OpCreate)
	return &RiskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RiskHistory entities.
func (c *RiskHistoryClient) CreateBulk(builders ...*RiskHistoryCreate) *RiskHistoryCreateBulk {
	return &RiskHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RiskHistoryClient) MapCreateBulk(slice any, setFunc func(*RiskHistoryCreate, int)) *RiskHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RiskHistoryCreateBulk{err: fmt.Errorf("calling to RiskHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RiskHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RiskHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RiskHistory.
func (c *RiskHistoryClient) Update() *RiskHistoryUpdate {
	mutation := newRiskHistoryMutation(c.config, OpUpdate)
	return &RiskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RiskHistoryClient) UpdateOne(_m *RiskHistory) *RiskHistoryUpdateOne {
	mutation := newRiskHistoryMutation(c.config, OpUpdateOne, withRiskHistory(_m))
	return &RiskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RiskHistoryClient) UpdateOneID(id string) *RiskHistoryUpdateOne {
	mutation := newRiskHistoryMutation(c.config, OpUpdateOne, withRiskHistoryID(id))
	return &RiskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RiskHistory.
func (c *RiskHistoryClient) Delete() *RiskHistoryDelete {
	mutation := newRiskHistoryMutation(c.config, OpDelete)
	return &RiskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RiskHistoryClient) DeleteOne(_m *RiskHistory) *RiskHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RiskHistoryClient) DeleteOneID(id string) *RiskHistoryDeleteOne {
	builder := c.Delete().Where(riskhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RiskHistoryDeleteOne{builder}
}

// Query returns a query builder for RiskHistory.
func (c *RiskHistoryClient) Query() *RiskHistoryQuery {
	return &RiskHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRiskHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a RiskHistory entity by its id.
func (c *RiskHistoryClient) Get(ctx context.Context, id string) (*RiskHistory, error) {
	return c.Query().Where(riskhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RiskHistoryClient) GetX(ctx context.Context, id string) *RiskHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RiskHistoryClient) Hooks() []Hook {
	hooks := c.hooks.RiskHistory
	return append(hooks[:len(hooks):len(hooks)], riskhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RiskHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.RiskHistory
	return append(inters[:len(inters):len(inters)], riskhistory.Interceptors[:]...)
}

func (c *RiskHistoryClient) mutate(ctx context.Context, m *RiskHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RiskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RiskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RiskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RiskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RiskHistory mutation op: %q", m.Op())
	}
}

// ScanClient is a client for the Scan schema.
type ScanClient struct {
	config
}

// NewScanClient returns a client for the Scan from the given config.
func NewScanClient(c config) *ScanClient {
	return &ScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scan.Hooks(f(g(h())))`.
func (c *ScanClient) Use(hooks ...Hook) {
	c.hooks.Scan = append(c.hooks.Scan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scan.Intercept(f(g(h())))`.
func (c *ScanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scan = append(c.inters.Scan, interceptors...)
}

// Create returns a builder for creating a Scan entity.
func (c *ScanClient) Create() *ScanCreate {
	mutation := newScanMutation(c.config, OpCreate)
	return &ScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scan entities.
func (c *ScanClient) CreateBulk(builders ...*ScanCreate) *ScanCreateBulk {
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanClient) MapCreateBulk(slice any, setFunc func(*ScanCreate, int)) *ScanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanCreateBulk{err: fmt.Errorf("calling to ScanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scan.
func (c *ScanClient) Update() *ScanUpdate {
	mutation := newScanMutation(c.config, OpUpdate)
	return &ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanClient) UpdateOne(_m *Scan) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScan(_m))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanClient) UpdateOneID(id string) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScanID(id))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scan.
func (c *ScanClient) Delete() *ScanDelete {
	mutation := newScanMutation(c.config, OpDelete)
	return &ScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanClient) DeleteOne(_m *Scan) *ScanDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanClient) DeleteOneID(id string) *ScanDeleteOne {
	builder := c.Delete().Where(scan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanDeleteOne{builder}
}

// Query returns a query builder for Scan.
func (c *ScanClient) Query() *ScanQuery {
	return &ScanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScan},
		inters: c.Interceptors(),
	}
}

// Get returns a Scan entity by its id.
func (c *ScanClient) Get(ctx context.Context, id string) (*Scan, error) {
	return c.Query().Where(scan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanClient) GetX(ctx context.Context, id string) *Scan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Scan.
func (c *ScanClient) QueryOwner(_m *Scan) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scan.OwnerTable, scan.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Scan.
func (c *ScanClient) QueryBlockedGroups(_m *Scan) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scan.BlockedGroupsTable, scan.BlockedGroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ScanBlockedGroups
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Scan.
func (c *ScanClient) QueryEditors(_m *Scan) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scan.EditorsTable, scan.EditorsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ScanEditors
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Scan.
func (c *ScanClient) QueryViewers(_m *Scan) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scan.ViewersTable, scan.ViewersPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.ScanViewers
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Scan.
func (c *ScanClient) QueryAssets(_m *Scan) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scan.AssetsTable, scan.AssetsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.ScanAssets
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Scan.
func (c *ScanClient) QueryEntities(_m *Scan) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.EntitiesTable, scan.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScanClient) Hooks() []Hook {
	hooks := c.hooks.Scan
	return append(hooks[:len(hooks):len(hooks)], scan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScanClient) Interceptors() []Interceptor {
	inters := c.inters.Scan
	return append(inters[:len(inters):len(inters)], scan.Interceptors[:]...)
}

func (c *ScanClient) mutate(ctx context.Context, m *ScanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Scan mutation op: %q", m.Op())
	}
}

// ScanHistoryClient is a client for the ScanHistory schema.
type ScanHistoryClient struct {
	config
}

// NewScanHistoryClient returns a client for the ScanHistory from the given config.
func NewScanHistoryClient(c config) *ScanHistoryClient {
	return &ScanHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scanhistory.Hooks(f(g(h())))`.
func (c *ScanHistoryClient) Use(hooks ...Hook) {
	c.hooks.ScanHistory = append(c.hooks.ScanHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scanhistory.Intercept(f(g(h())))`.
func (c *ScanHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScanHistory = append(c.inters.ScanHistory, interceptors...)
}

// Create returns a builder for creating a ScanHistory entity.
func (c *ScanHistoryClient) Create() *ScanHistoryCreate {
	mutation := newScanHistoryMutation(c.config, OpCreate)
	return &ScanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScanHistory entities.
func (c *ScanHistoryClient) CreateBulk(builders ...*ScanHistoryCreate) *ScanHistoryCreateBulk {
	return &ScanHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanHistoryClient) MapCreateBulk(slice any, setFunc func(*ScanHistoryCreate, int)) *ScanHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanHistoryCreateBulk{err: fmt.Errorf("calling to ScanHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScanHistory.
func (c *ScanHistoryClient) Update() *ScanHistoryUpdate {
	mutation := newScanHistoryMutation(c.config, OpUpdate)
	return &ScanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanHistoryClient) UpdateOne(_m *ScanHistory) *ScanHistoryUpdateOne {
	mutation := newScanHistoryMutation(c.config, OpUpdateOne, withScanHistory(_m))
	return &ScanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanHistoryClient) UpdateOneID(id string) *ScanHistoryUpdateOne {
	mutation := newScanHistoryMutation(c.config, OpUpdateOne, withScanHistoryID(id))
	return &ScanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScanHistory.
func (c *ScanHistoryClient) Delete() *ScanHistoryDelete {
	mutation := newScanHistoryMutation(c.config, OpDelete)
	return &ScanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanHistoryClient) DeleteOne(_m *ScanHistory) *ScanHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanHistoryClient) DeleteOneID(id string) *ScanHistoryDeleteOne {
	builder := c.Delete().Where(scanhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanHistoryDeleteOne{builder}
}

// Query returns a query builder for ScanHistory.
func (c *ScanHistoryClient) Query() *ScanHistoryQuery {
	return &ScanHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScanHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ScanHistory entity by its id.
func (c *ScanHistoryClient) Get(ctx context.Context, id string) (*ScanHistory, error) {
	return c.Query().Where(scanhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanHistoryClient) GetX(ctx context.Context, id string) *ScanHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ScanHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ScanHistory
	return append(hooks[:len(hooks):len(hooks)], scanhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScanHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ScanHistory
	return append(inters[:len(inters):len(inters)], scanhistory.Interceptors[:]...)
}

func (c *ScanHistoryClient) mutate(ctx context.Context, m *ScanHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ScanHistory mutation op: %q", m.Op())
	}
}

// ScheduledJobClient is a client for the ScheduledJob schema.
type ScheduledJobClient struct {
	config
}

// NewScheduledJobClient returns a client for the ScheduledJob from the given config.
func NewScheduledJobClient(c config) *ScheduledJobClient {
	return &ScheduledJobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scheduledjob.Hooks(f(g(h())))`.
func (c *ScheduledJobClient) Use(hooks ...Hook) {
	c.hooks.ScheduledJob = append(c.hooks.ScheduledJob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scheduledjob.Intercept(f(g(h())))`.
func (c *ScheduledJobClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduledJob = append(c.inters.ScheduledJob, interceptors...)
}

// Create returns a builder for creating a ScheduledJob entity.
func (c *ScheduledJobClient) Create() *ScheduledJobCreate {
	mutation := newScheduledJobMutation(c.config, OpCreate)
	return &ScheduledJobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduledJob entities.
func (c *ScheduledJobClient) CreateBulk(builders ...*ScheduledJobCreate) *ScheduledJobCreateBulk {
	return &ScheduledJobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduledJobClient) MapCreateBulk(slice any, setFunc func(*ScheduledJobCreate, int)) *ScheduledJobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduledJobCreateBulk{err: fmt.Errorf("calling to ScheduledJobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduledJobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduledJobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduledJob.
func (c *ScheduledJobClient) Update() *ScheduledJobUpdate {
	mutation := newScheduledJobMutation(c.config, OpUpdate)
	return &ScheduledJobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduledJobClient) UpdateOne(_m *ScheduledJob) *ScheduledJobUpdateOne {
	mutation := newScheduledJobMutation(c.config, OpUpdateOne, withScheduledJob(_m))
	return &ScheduledJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduledJobClient) UpdateOneID(id string) *ScheduledJobUpdateOne {
	mutation := newScheduledJobMutation(c.config, OpUpdateOne, withScheduledJobID(id))
	return &ScheduledJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduledJob.
func (c *ScheduledJobClient) Delete() *ScheduledJobDelete {
	mutation := newScheduledJobMutation(c.config, OpDelete)
	return &ScheduledJobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduledJobClient) DeleteOne(_m *ScheduledJob) *ScheduledJobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduledJobClient) DeleteOneID(id string) *ScheduledJobDeleteOne {
	builder := c.Delete().Where(scheduledjob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduledJobDeleteOne{builder}
}

// Query returns a query builder for ScheduledJob.
func (c *ScheduledJobClient) Query() *ScheduledJobQuery {
	return &ScheduledJobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduledJob},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduledJob entity by its id.
func (c *ScheduledJobClient) Get(ctx context.Context, id string) (*ScheduledJob, error) {
	return c.Query().Where(scheduledjob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduledJobClient) GetX(ctx context.Context, id string) *ScheduledJob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a ScheduledJob.
func (c *ScheduledJobClient) QueryOwner(_m *ScheduledJob) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjob.Table, scheduledjob.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scheduledjob.OwnerTable, scheduledjob.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.ScheduledJob
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobTemplate queries the job_template edge of a ScheduledJob.
func (c *ScheduledJobClient) QueryJobTemplate(_m *ScheduledJob) *JobTemplateQuery {
	query := (&JobTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjob.Table, scheduledjob.FieldID, id),
			sqlgraph.To(jobtemplate.Table, jobtemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scheduledjob.JobTemplateTable, scheduledjob.JobTemplateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobTemplate
		step.Edge.Schema = schemaConfig.ScheduledJob
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a ScheduledJob.
func (c *ScheduledJobClient) QueryControls(_m *ScheduledJob) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjob.Table, scheduledjob.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scheduledjob.ControlsTable, scheduledjob.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ScheduledJobControls
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a ScheduledJob.
func (c *ScheduledJobClient) QuerySubcontrols(_m *ScheduledJob) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjob.Table, scheduledjob.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, scheduledjob.SubcontrolsTable, scheduledjob.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.ScheduledJobSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunner queries the job_runner edge of a ScheduledJob.
func (c *ScheduledJobClient) QueryJobRunner(_m *ScheduledJob) *JobRunnerQuery {
	query := (&JobRunnerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjob.Table, scheduledjob.FieldID, id),
			sqlgraph.To(jobrunner.Table, jobrunner.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, scheduledjob.JobRunnerTable, scheduledjob.JobRunnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunner
		step.Edge.Schema = schemaConfig.ScheduledJob
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduledJobClient) Hooks() []Hook {
	hooks := c.hooks.ScheduledJob
	return append(hooks[:len(hooks):len(hooks)], scheduledjob.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScheduledJobClient) Interceptors() []Interceptor {
	inters := c.inters.ScheduledJob
	return append(inters[:len(inters):len(inters)], scheduledjob.Interceptors[:]...)
}

func (c *ScheduledJobClient) mutate(ctx context.Context, m *ScheduledJobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduledJobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduledJobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduledJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduledJobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ScheduledJob mutation op: %q", m.Op())
	}
}

// ScheduledJobHistoryClient is a client for the ScheduledJobHistory schema.
type ScheduledJobHistoryClient struct {
	config
}

// NewScheduledJobHistoryClient returns a client for the ScheduledJobHistory from the given config.
func NewScheduledJobHistoryClient(c config) *ScheduledJobHistoryClient {
	return &ScheduledJobHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scheduledjobhistory.Hooks(f(g(h())))`.
func (c *ScheduledJobHistoryClient) Use(hooks ...Hook) {
	c.hooks.ScheduledJobHistory = append(c.hooks.ScheduledJobHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scheduledjobhistory.Intercept(f(g(h())))`.
func (c *ScheduledJobHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduledJobHistory = append(c.inters.ScheduledJobHistory, interceptors...)
}

// Create returns a builder for creating a ScheduledJobHistory entity.
func (c *ScheduledJobHistoryClient) Create() *ScheduledJobHistoryCreate {
	mutation := newScheduledJobHistoryMutation(c.config, OpCreate)
	return &ScheduledJobHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduledJobHistory entities.
func (c *ScheduledJobHistoryClient) CreateBulk(builders ...*ScheduledJobHistoryCreate) *ScheduledJobHistoryCreateBulk {
	return &ScheduledJobHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduledJobHistoryClient) MapCreateBulk(slice any, setFunc func(*ScheduledJobHistoryCreate, int)) *ScheduledJobHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduledJobHistoryCreateBulk{err: fmt.Errorf("calling to ScheduledJobHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduledJobHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduledJobHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduledJobHistory.
func (c *ScheduledJobHistoryClient) Update() *ScheduledJobHistoryUpdate {
	mutation := newScheduledJobHistoryMutation(c.config, OpUpdate)
	return &ScheduledJobHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduledJobHistoryClient) UpdateOne(_m *ScheduledJobHistory) *ScheduledJobHistoryUpdateOne {
	mutation := newScheduledJobHistoryMutation(c.config, OpUpdateOne, withScheduledJobHistory(_m))
	return &ScheduledJobHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduledJobHistoryClient) UpdateOneID(id string) *ScheduledJobHistoryUpdateOne {
	mutation := newScheduledJobHistoryMutation(c.config, OpUpdateOne, withScheduledJobHistoryID(id))
	return &ScheduledJobHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduledJobHistory.
func (c *ScheduledJobHistoryClient) Delete() *ScheduledJobHistoryDelete {
	mutation := newScheduledJobHistoryMutation(c.config, OpDelete)
	return &ScheduledJobHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduledJobHistoryClient) DeleteOne(_m *ScheduledJobHistory) *ScheduledJobHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduledJobHistoryClient) DeleteOneID(id string) *ScheduledJobHistoryDeleteOne {
	builder := c.Delete().Where(scheduledjobhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduledJobHistoryDeleteOne{builder}
}

// Query returns a query builder for ScheduledJobHistory.
func (c *ScheduledJobHistoryClient) Query() *ScheduledJobHistoryQuery {
	return &ScheduledJobHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduledJobHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduledJobHistory entity by its id.
func (c *ScheduledJobHistoryClient) Get(ctx context.Context, id string) (*ScheduledJobHistory, error) {
	return c.Query().Where(scheduledjobhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduledJobHistoryClient) GetX(ctx context.Context, id string) *ScheduledJobHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ScheduledJobHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ScheduledJobHistory
	return append(hooks[:len(hooks):len(hooks)], scheduledjobhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScheduledJobHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ScheduledJobHistory
	return append(inters[:len(inters):len(inters)], scheduledjobhistory.Interceptors[:]...)
}

func (c *ScheduledJobHistoryClient) mutate(ctx context.Context, m *ScheduledJobHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduledJobHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduledJobHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduledJobHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduledJobHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ScheduledJobHistory mutation op: %q", m.Op())
	}
}

// ScheduledJobRunClient is a client for the ScheduledJobRun schema.
type ScheduledJobRunClient struct {
	config
}

// NewScheduledJobRunClient returns a client for the ScheduledJobRun from the given config.
func NewScheduledJobRunClient(c config) *ScheduledJobRunClient {
	return &ScheduledJobRunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scheduledjobrun.Hooks(f(g(h())))`.
func (c *ScheduledJobRunClient) Use(hooks ...Hook) {
	c.hooks.ScheduledJobRun = append(c.hooks.ScheduledJobRun, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scheduledjobrun.Intercept(f(g(h())))`.
func (c *ScheduledJobRunClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduledJobRun = append(c.inters.ScheduledJobRun, interceptors...)
}

// Create returns a builder for creating a ScheduledJobRun entity.
func (c *ScheduledJobRunClient) Create() *ScheduledJobRunCreate {
	mutation := newScheduledJobRunMutation(c.config, OpCreate)
	return &ScheduledJobRunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduledJobRun entities.
func (c *ScheduledJobRunClient) CreateBulk(builders ...*ScheduledJobRunCreate) *ScheduledJobRunCreateBulk {
	return &ScheduledJobRunCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduledJobRunClient) MapCreateBulk(slice any, setFunc func(*ScheduledJobRunCreate, int)) *ScheduledJobRunCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduledJobRunCreateBulk{err: fmt.Errorf("calling to ScheduledJobRunClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduledJobRunCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduledJobRunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduledJobRun.
func (c *ScheduledJobRunClient) Update() *ScheduledJobRunUpdate {
	mutation := newScheduledJobRunMutation(c.config, OpUpdate)
	return &ScheduledJobRunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduledJobRunClient) UpdateOne(_m *ScheduledJobRun) *ScheduledJobRunUpdateOne {
	mutation := newScheduledJobRunMutation(c.config, OpUpdateOne, withScheduledJobRun(_m))
	return &ScheduledJobRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduledJobRunClient) UpdateOneID(id string) *ScheduledJobRunUpdateOne {
	mutation := newScheduledJobRunMutation(c.config, OpUpdateOne, withScheduledJobRunID(id))
	return &ScheduledJobRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduledJobRun.
func (c *ScheduledJobRunClient) Delete() *ScheduledJobRunDelete {
	mutation := newScheduledJobRunMutation(c.config, OpDelete)
	return &ScheduledJobRunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduledJobRunClient) DeleteOne(_m *ScheduledJobRun) *ScheduledJobRunDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduledJobRunClient) DeleteOneID(id string) *ScheduledJobRunDeleteOne {
	builder := c.Delete().Where(scheduledjobrun.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduledJobRunDeleteOne{builder}
}

// Query returns a query builder for ScheduledJobRun.
func (c *ScheduledJobRunClient) Query() *ScheduledJobRunQuery {
	return &ScheduledJobRunQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduledJobRun},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduledJobRun entity by its id.
func (c *ScheduledJobRunClient) Get(ctx context.Context, id string) (*ScheduledJobRun, error) {
	return c.Query().Where(scheduledjobrun.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduledJobRunClient) GetX(ctx context.Context, id string) *ScheduledJobRun {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a ScheduledJobRun.
func (c *ScheduledJobRunClient) QueryOwner(_m *ScheduledJobRun) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjobrun.Table, scheduledjobrun.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scheduledjobrun.OwnerTable, scheduledjobrun.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.ScheduledJobRun
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJob queries the scheduled_job edge of a ScheduledJobRun.
func (c *ScheduledJobRunClient) QueryScheduledJob(_m *ScheduledJobRun) *ScheduledJobQuery {
	query := (&ScheduledJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjobrun.Table, scheduledjobrun.FieldID, id),
			sqlgraph.To(scheduledjob.Table, scheduledjob.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, scheduledjobrun.ScheduledJobTable, scheduledjobrun.ScheduledJobColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJob
		step.Edge.Schema = schemaConfig.ScheduledJobRun
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobRunner queries the job_runner edge of a ScheduledJobRun.
func (c *ScheduledJobRunClient) QueryJobRunner(_m *ScheduledJobRun) *JobRunnerQuery {
	query := (&JobRunnerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledjobrun.Table, scheduledjobrun.FieldID, id),
			sqlgraph.To(jobrunner.Table, jobrunner.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, scheduledjobrun.JobRunnerTable, scheduledjobrun.JobRunnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.JobRunner
		step.Edge.Schema = schemaConfig.ScheduledJobRun
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduledJobRunClient) Hooks() []Hook {
	hooks := c.hooks.ScheduledJobRun
	return append(hooks[:len(hooks):len(hooks)], scheduledjobrun.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ScheduledJobRunClient) Interceptors() []Interceptor {
	inters := c.inters.ScheduledJobRun
	return append(inters[:len(inters):len(inters)], scheduledjobrun.Interceptors[:]...)
}

func (c *ScheduledJobRunClient) mutate(ctx context.Context, m *ScheduledJobRunMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduledJobRunCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduledJobRunUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduledJobRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduledJobRunDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ScheduledJobRun mutation op: %q", m.Op())
	}
}

// StandardClient is a client for the Standard schema.
type StandardClient struct {
	config
}

// NewStandardClient returns a client for the Standard from the given config.
func NewStandardClient(c config) *StandardClient {
	return &StandardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standard.Hooks(f(g(h())))`.
func (c *StandardClient) Use(hooks ...Hook) {
	c.hooks.Standard = append(c.hooks.Standard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standard.Intercept(f(g(h())))`.
func (c *StandardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Standard = append(c.inters.Standard, interceptors...)
}

// Create returns a builder for creating a Standard entity.
func (c *StandardClient) Create() *StandardCreate {
	mutation := newStandardMutation(c.config, OpCreate)
	return &StandardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Standard entities.
func (c *StandardClient) CreateBulk(builders ...*StandardCreate) *StandardCreateBulk {
	return &StandardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardClient) MapCreateBulk(slice any, setFunc func(*StandardCreate, int)) *StandardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardCreateBulk{err: fmt.Errorf("calling to StandardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Standard.
func (c *StandardClient) Update() *StandardUpdate {
	mutation := newStandardMutation(c.config, OpUpdate)
	return &StandardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardClient) UpdateOne(_m *Standard) *StandardUpdateOne {
	mutation := newStandardMutation(c.config, OpUpdateOne, withStandard(_m))
	return &StandardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardClient) UpdateOneID(id string) *StandardUpdateOne {
	mutation := newStandardMutation(c.config, OpUpdateOne, withStandardID(id))
	return &StandardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Standard.
func (c *StandardClient) Delete() *StandardDelete {
	mutation := newStandardMutation(c.config, OpDelete)
	return &StandardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardClient) DeleteOne(_m *Standard) *StandardDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardClient) DeleteOneID(id string) *StandardDeleteOne {
	builder := c.Delete().Where(standard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardDeleteOne{builder}
}

// Query returns a query builder for Standard.
func (c *StandardClient) Query() *StandardQuery {
	return &StandardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandard},
		inters: c.Interceptors(),
	}
}

// Get returns a Standard entity by its id.
func (c *StandardClient) Get(ctx context.Context, id string) (*Standard, error) {
	return c.Query().Where(standard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardClient) GetX(ctx context.Context, id string) *Standard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Standard.
func (c *StandardClient) QueryOwner(_m *Standard) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, standard.OwnerTable, standard.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Standard
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Standard.
func (c *StandardClient) QueryControls(_m *Standard) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, standard.ControlsTable, standard.ControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterCompliances queries the trust_center_compliances edge of a Standard.
func (c *StandardClient) QueryTrustCenterCompliances(_m *Standard) *TrustCenterComplianceQuery {
	query := (&TrustCenterComplianceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(trustcentercompliance.Table, trustcentercompliance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, standard.TrustCenterCompliancesTable, standard.TrustCenterCompliancesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterCompliance
		step.Edge.Schema = schemaConfig.TrustCenterCompliance
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandardClient) Hooks() []Hook {
	hooks := c.hooks.Standard
	return append(hooks[:len(hooks):len(hooks)], standard.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StandardClient) Interceptors() []Interceptor {
	inters := c.inters.Standard
	return append(inters[:len(inters):len(inters)], standard.Interceptors[:]...)
}

func (c *StandardClient) mutate(ctx context.Context, m *StandardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Standard mutation op: %q", m.Op())
	}
}

// StandardHistoryClient is a client for the StandardHistory schema.
type StandardHistoryClient struct {
	config
}

// NewStandardHistoryClient returns a client for the StandardHistory from the given config.
func NewStandardHistoryClient(c config) *StandardHistoryClient {
	return &StandardHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standardhistory.Hooks(f(g(h())))`.
func (c *StandardHistoryClient) Use(hooks ...Hook) {
	c.hooks.StandardHistory = append(c.hooks.StandardHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standardhistory.Intercept(f(g(h())))`.
func (c *StandardHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.StandardHistory = append(c.inters.StandardHistory, interceptors...)
}

// Create returns a builder for creating a StandardHistory entity.
func (c *StandardHistoryClient) Create() *StandardHistoryCreate {
	mutation := newStandardHistoryMutation(c.config, OpCreate)
	return &StandardHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StandardHistory entities.
func (c *StandardHistoryClient) CreateBulk(builders ...*StandardHistoryCreate) *StandardHistoryCreateBulk {
	return &StandardHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardHistoryClient) MapCreateBulk(slice any, setFunc func(*StandardHistoryCreate, int)) *StandardHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardHistoryCreateBulk{err: fmt.Errorf("calling to StandardHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StandardHistory.
func (c *StandardHistoryClient) Update() *StandardHistoryUpdate {
	mutation := newStandardHistoryMutation(c.config, OpUpdate)
	return &StandardHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardHistoryClient) UpdateOne(_m *StandardHistory) *StandardHistoryUpdateOne {
	mutation := newStandardHistoryMutation(c.config, OpUpdateOne, withStandardHistory(_m))
	return &StandardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardHistoryClient) UpdateOneID(id string) *StandardHistoryUpdateOne {
	mutation := newStandardHistoryMutation(c.config, OpUpdateOne, withStandardHistoryID(id))
	return &StandardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StandardHistory.
func (c *StandardHistoryClient) Delete() *StandardHistoryDelete {
	mutation := newStandardHistoryMutation(c.config, OpDelete)
	return &StandardHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardHistoryClient) DeleteOne(_m *StandardHistory) *StandardHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardHistoryClient) DeleteOneID(id string) *StandardHistoryDeleteOne {
	builder := c.Delete().Where(standardhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardHistoryDeleteOne{builder}
}

// Query returns a query builder for StandardHistory.
func (c *StandardHistoryClient) Query() *StandardHistoryQuery {
	return &StandardHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandardHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a StandardHistory entity by its id.
func (c *StandardHistoryClient) Get(ctx context.Context, id string) (*StandardHistory, error) {
	return c.Query().Where(standardhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardHistoryClient) GetX(ctx context.Context, id string) *StandardHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StandardHistoryClient) Hooks() []Hook {
	hooks := c.hooks.StandardHistory
	return append(hooks[:len(hooks):len(hooks)], standardhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StandardHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.StandardHistory
	return append(inters[:len(inters):len(inters)], standardhistory.Interceptors[:]...)
}

func (c *StandardHistoryClient) mutate(ctx context.Context, m *StandardHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown StandardHistory mutation op: %q", m.Op())
	}
}

// SubcontrolClient is a client for the Subcontrol schema.
type SubcontrolClient struct {
	config
}

// NewSubcontrolClient returns a client for the Subcontrol from the given config.
func NewSubcontrolClient(c config) *SubcontrolClient {
	return &SubcontrolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subcontrol.Hooks(f(g(h())))`.
func (c *SubcontrolClient) Use(hooks ...Hook) {
	c.hooks.Subcontrol = append(c.hooks.Subcontrol, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subcontrol.Intercept(f(g(h())))`.
func (c *SubcontrolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subcontrol = append(c.inters.Subcontrol, interceptors...)
}

// Create returns a builder for creating a Subcontrol entity.
func (c *SubcontrolClient) Create() *SubcontrolCreate {
	mutation := newSubcontrolMutation(c.config, OpCreate)
	return &SubcontrolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subcontrol entities.
func (c *SubcontrolClient) CreateBulk(builders ...*SubcontrolCreate) *SubcontrolCreateBulk {
	return &SubcontrolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubcontrolClient) MapCreateBulk(slice any, setFunc func(*SubcontrolCreate, int)) *SubcontrolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubcontrolCreateBulk{err: fmt.Errorf("calling to SubcontrolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubcontrolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubcontrolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subcontrol.
func (c *SubcontrolClient) Update() *SubcontrolUpdate {
	mutation := newSubcontrolMutation(c.config, OpUpdate)
	return &SubcontrolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubcontrolClient) UpdateOne(_m *Subcontrol) *SubcontrolUpdateOne {
	mutation := newSubcontrolMutation(c.config, OpUpdateOne, withSubcontrol(_m))
	return &SubcontrolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubcontrolClient) UpdateOneID(id string) *SubcontrolUpdateOne {
	mutation := newSubcontrolMutation(c.config, OpUpdateOne, withSubcontrolID(id))
	return &SubcontrolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subcontrol.
func (c *SubcontrolClient) Delete() *SubcontrolDelete {
	mutation := newSubcontrolMutation(c.config, OpDelete)
	return &SubcontrolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubcontrolClient) DeleteOne(_m *Subcontrol) *SubcontrolDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubcontrolClient) DeleteOneID(id string) *SubcontrolDeleteOne {
	builder := c.Delete().Where(subcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubcontrolDeleteOne{builder}
}

// Query returns a query builder for Subcontrol.
func (c *SubcontrolClient) Query() *SubcontrolQuery {
	return &SubcontrolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubcontrol},
		inters: c.Interceptors(),
	}
}

// Get returns a Subcontrol entity by its id.
func (c *SubcontrolClient) Get(ctx context.Context, id string) (*Subcontrol, error) {
	return c.Query().Where(subcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubcontrolClient) GetX(ctx context.Context, id string) *Subcontrol {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvidence queries the evidence edge of a Subcontrol.
func (c *SubcontrolClient) QueryEvidence(_m *Subcontrol) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.EvidenceTable, subcontrol.EvidencePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.EvidenceSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a Subcontrol.
func (c *SubcontrolClient) QueryControlObjectives(_m *Subcontrol) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subcontrol.ControlObjectivesTable, subcontrol.ControlObjectivesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.SubcontrolControlObjectives
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Subcontrol.
func (c *SubcontrolClient) QueryTasks(_m *Subcontrol) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subcontrol.TasksTable, subcontrol.TasksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.SubcontrolTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Subcontrol.
func (c *SubcontrolClient) QueryNarratives(_m *Subcontrol) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subcontrol.NarrativesTable, subcontrol.NarrativesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.Narrative
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Subcontrol.
func (c *SubcontrolClient) QueryRisks(_m *Subcontrol) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subcontrol.RisksTable, subcontrol.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.SubcontrolRisks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Subcontrol.
func (c *SubcontrolClient) QueryActionPlans(_m *Subcontrol) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subcontrol.ActionPlansTable, subcontrol.ActionPlansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Subcontrol.
func (c *SubcontrolClient) QueryProcedures(_m *Subcontrol) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subcontrol.ProceduresTable, subcontrol.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.SubcontrolProcedures
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Subcontrol.
func (c *SubcontrolClient) QueryInternalPolicies(_m *Subcontrol) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.InternalPoliciesTable, subcontrol.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicySubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Subcontrol.
func (c *SubcontrolClient) QueryComments(_m *Subcontrol) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subcontrol.CommentsTable, subcontrol.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlOwner queries the control_owner edge of a Subcontrol.
func (c *SubcontrolClient) QueryControlOwner(_m *Subcontrol) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subcontrol.ControlOwnerTable, subcontrol.ControlOwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDelegate queries the delegate edge of a Subcontrol.
func (c *SubcontrolClient) QueryDelegate(_m *Subcontrol) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subcontrol.DelegateTable, subcontrol.DelegateColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResponsibleParty queries the responsible_party edge of a Subcontrol.
func (c *SubcontrolClient) QueryResponsibleParty(_m *Subcontrol) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subcontrol.ResponsiblePartyTable, subcontrol.ResponsiblePartyColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Subcontrol.
func (c *SubcontrolClient) QueryOwner(_m *Subcontrol) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subcontrol.OwnerTable, subcontrol.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrolKind queries the subcontrol_kind edge of a Subcontrol.
func (c *SubcontrolClient) QuerySubcontrolKind(_m *Subcontrol) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subcontrol.SubcontrolKindTable, subcontrol.SubcontrolKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a Subcontrol.
func (c *SubcontrolClient) QueryControl(_m *Subcontrol) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subcontrol.ControlTable, subcontrol.ControlColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementations queries the control_implementations edge of a Subcontrol.
func (c *SubcontrolClient) QueryControlImplementations(_m *Subcontrol) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subcontrol.ControlImplementationsTable, subcontrol.ControlImplementationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.SubcontrolControlImplementations
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledJobs queries the scheduled_jobs edge of a Subcontrol.
func (c *SubcontrolClient) QueryScheduledJobs(_m *Subcontrol) *ScheduledJobQuery {
	query := (&ScheduledJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(scheduledjob.Table, scheduledjob.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.ScheduledJobsTable, subcontrol.ScheduledJobsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ScheduledJob
		step.Edge.Schema = schemaConfig.ScheduledJobSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedToSubcontrols queries the mapped_to_subcontrols edge of a Subcontrol.
func (c *SubcontrolClient) QueryMappedToSubcontrols(_m *Subcontrol) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.MappedToSubcontrolsTable, subcontrol.MappedToSubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControlToSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMappedFromSubcontrols queries the mapped_from_subcontrols edge of a Subcontrol.
func (c *SubcontrolClient) QueryMappedFromSubcontrols(_m *Subcontrol) *MappedControlQuery {
	query := (&MappedControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(mappedcontrol.Table, mappedcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.MappedFromSubcontrolsTable, subcontrol.MappedFromSubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.MappedControl
		step.Edge.Schema = schemaConfig.MappedControlFromSubcontrols
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubcontrolClient) Hooks() []Hook {
	hooks := c.hooks.Subcontrol
	return append(hooks[:len(hooks):len(hooks)], subcontrol.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubcontrolClient) Interceptors() []Interceptor {
	inters := c.inters.Subcontrol
	return append(inters[:len(inters):len(inters)], subcontrol.Interceptors[:]...)
}

func (c *SubcontrolClient) mutate(ctx context.Context, m *SubcontrolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubcontrolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubcontrolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubcontrolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubcontrolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subcontrol mutation op: %q", m.Op())
	}
}

// SubcontrolHistoryClient is a client for the SubcontrolHistory schema.
type SubcontrolHistoryClient struct {
	config
}

// NewSubcontrolHistoryClient returns a client for the SubcontrolHistory from the given config.
func NewSubcontrolHistoryClient(c config) *SubcontrolHistoryClient {
	return &SubcontrolHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subcontrolhistory.Hooks(f(g(h())))`.
func (c *SubcontrolHistoryClient) Use(hooks ...Hook) {
	c.hooks.SubcontrolHistory = append(c.hooks.SubcontrolHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subcontrolhistory.Intercept(f(g(h())))`.
func (c *SubcontrolHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubcontrolHistory = append(c.inters.SubcontrolHistory, interceptors...)
}

// Create returns a builder for creating a SubcontrolHistory entity.
func (c *SubcontrolHistoryClient) Create() *SubcontrolHistoryCreate {
	mutation := newSubcontrolHistoryMutation(c.config, OpCreate)
	return &SubcontrolHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubcontrolHistory entities.
func (c *SubcontrolHistoryClient) CreateBulk(builders ...*SubcontrolHistoryCreate) *SubcontrolHistoryCreateBulk {
	return &SubcontrolHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubcontrolHistoryClient) MapCreateBulk(slice any, setFunc func(*SubcontrolHistoryCreate, int)) *SubcontrolHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubcontrolHistoryCreateBulk{err: fmt.Errorf("calling to SubcontrolHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubcontrolHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubcontrolHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubcontrolHistory.
func (c *SubcontrolHistoryClient) Update() *SubcontrolHistoryUpdate {
	mutation := newSubcontrolHistoryMutation(c.config, OpUpdate)
	return &SubcontrolHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubcontrolHistoryClient) UpdateOne(_m *SubcontrolHistory) *SubcontrolHistoryUpdateOne {
	mutation := newSubcontrolHistoryMutation(c.config, OpUpdateOne, withSubcontrolHistory(_m))
	return &SubcontrolHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubcontrolHistoryClient) UpdateOneID(id string) *SubcontrolHistoryUpdateOne {
	mutation := newSubcontrolHistoryMutation(c.config, OpUpdateOne, withSubcontrolHistoryID(id))
	return &SubcontrolHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubcontrolHistory.
func (c *SubcontrolHistoryClient) Delete() *SubcontrolHistoryDelete {
	mutation := newSubcontrolHistoryMutation(c.config, OpDelete)
	return &SubcontrolHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubcontrolHistoryClient) DeleteOne(_m *SubcontrolHistory) *SubcontrolHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubcontrolHistoryClient) DeleteOneID(id string) *SubcontrolHistoryDeleteOne {
	builder := c.Delete().Where(subcontrolhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubcontrolHistoryDeleteOne{builder}
}

// Query returns a query builder for SubcontrolHistory.
func (c *SubcontrolHistoryClient) Query() *SubcontrolHistoryQuery {
	return &SubcontrolHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubcontrolHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a SubcontrolHistory entity by its id.
func (c *SubcontrolHistoryClient) Get(ctx context.Context, id string) (*SubcontrolHistory, error) {
	return c.Query().Where(subcontrolhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubcontrolHistoryClient) GetX(ctx context.Context, id string) *SubcontrolHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubcontrolHistoryClient) Hooks() []Hook {
	hooks := c.hooks.SubcontrolHistory
	return append(hooks[:len(hooks):len(hooks)], subcontrolhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubcontrolHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.SubcontrolHistory
	return append(inters[:len(inters):len(inters)], subcontrolhistory.Interceptors[:]...)
}

func (c *SubcontrolHistoryClient) mutate(ctx context.Context, m *SubcontrolHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubcontrolHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubcontrolHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubcontrolHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubcontrolHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown SubcontrolHistory mutation op: %q", m.Op())
	}
}

// SubprocessorClient is a client for the Subprocessor schema.
type SubprocessorClient struct {
	config
}

// NewSubprocessorClient returns a client for the Subprocessor from the given config.
func NewSubprocessorClient(c config) *SubprocessorClient {
	return &SubprocessorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subprocessor.Hooks(f(g(h())))`.
func (c *SubprocessorClient) Use(hooks ...Hook) {
	c.hooks.Subprocessor = append(c.hooks.Subprocessor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subprocessor.Intercept(f(g(h())))`.
func (c *SubprocessorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subprocessor = append(c.inters.Subprocessor, interceptors...)
}

// Create returns a builder for creating a Subprocessor entity.
func (c *SubprocessorClient) Create() *SubprocessorCreate {
	mutation := newSubprocessorMutation(c.config, OpCreate)
	return &SubprocessorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subprocessor entities.
func (c *SubprocessorClient) CreateBulk(builders ...*SubprocessorCreate) *SubprocessorCreateBulk {
	return &SubprocessorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubprocessorClient) MapCreateBulk(slice any, setFunc func(*SubprocessorCreate, int)) *SubprocessorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubprocessorCreateBulk{err: fmt.Errorf("calling to SubprocessorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubprocessorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubprocessorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subprocessor.
func (c *SubprocessorClient) Update() *SubprocessorUpdate {
	mutation := newSubprocessorMutation(c.config, OpUpdate)
	return &SubprocessorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubprocessorClient) UpdateOne(_m *Subprocessor) *SubprocessorUpdateOne {
	mutation := newSubprocessorMutation(c.config, OpUpdateOne, withSubprocessor(_m))
	return &SubprocessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubprocessorClient) UpdateOneID(id string) *SubprocessorUpdateOne {
	mutation := newSubprocessorMutation(c.config, OpUpdateOne, withSubprocessorID(id))
	return &SubprocessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subprocessor.
func (c *SubprocessorClient) Delete() *SubprocessorDelete {
	mutation := newSubprocessorMutation(c.config, OpDelete)
	return &SubprocessorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubprocessorClient) DeleteOne(_m *Subprocessor) *SubprocessorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubprocessorClient) DeleteOneID(id string) *SubprocessorDeleteOne {
	builder := c.Delete().Where(subprocessor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubprocessorDeleteOne{builder}
}

// Query returns a query builder for Subprocessor.
func (c *SubprocessorClient) Query() *SubprocessorQuery {
	return &SubprocessorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubprocessor},
		inters: c.Interceptors(),
	}
}

// Get returns a Subprocessor entity by its id.
func (c *SubprocessorClient) Get(ctx context.Context, id string) (*Subprocessor, error) {
	return c.Query().Where(subprocessor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubprocessorClient) GetX(ctx context.Context, id string) *Subprocessor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Subprocessor.
func (c *SubprocessorClient) QueryOwner(_m *Subprocessor) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subprocessor.Table, subprocessor.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subprocessor.OwnerTable, subprocessor.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Subprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Subprocessor.
func (c *SubprocessorClient) QueryFiles(_m *Subprocessor) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subprocessor.Table, subprocessor.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subprocessor.FilesTable, subprocessor.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.SubprocessorFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogoFile queries the logo_file edge of a Subprocessor.
func (c *SubprocessorClient) QueryLogoFile(_m *Subprocessor) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subprocessor.Table, subprocessor.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, subprocessor.LogoFileTable, subprocessor.LogoFileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.Subprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterSubprocessors queries the trust_center_subprocessors edge of a Subprocessor.
func (c *SubprocessorClient) QueryTrustCenterSubprocessors(_m *Subprocessor) *TrustCenterSubprocessorQuery {
	query := (&TrustCenterSubprocessorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subprocessor.Table, subprocessor.FieldID, id),
			sqlgraph.To(trustcentersubprocessor.Table, trustcentersubprocessor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subprocessor.TrustCenterSubprocessorsTable, subprocessor.TrustCenterSubprocessorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterSubprocessor
		step.Edge.Schema = schemaConfig.TrustCenterSubprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubprocessorClient) Hooks() []Hook {
	hooks := c.hooks.Subprocessor
	return append(hooks[:len(hooks):len(hooks)], subprocessor.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubprocessorClient) Interceptors() []Interceptor {
	inters := c.inters.Subprocessor
	return append(inters[:len(inters):len(inters)], subprocessor.Interceptors[:]...)
}

func (c *SubprocessorClient) mutate(ctx context.Context, m *SubprocessorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubprocessorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubprocessorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubprocessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubprocessorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subprocessor mutation op: %q", m.Op())
	}
}

// SubprocessorHistoryClient is a client for the SubprocessorHistory schema.
type SubprocessorHistoryClient struct {
	config
}

// NewSubprocessorHistoryClient returns a client for the SubprocessorHistory from the given config.
func NewSubprocessorHistoryClient(c config) *SubprocessorHistoryClient {
	return &SubprocessorHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subprocessorhistory.Hooks(f(g(h())))`.
func (c *SubprocessorHistoryClient) Use(hooks ...Hook) {
	c.hooks.SubprocessorHistory = append(c.hooks.SubprocessorHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subprocessorhistory.Intercept(f(g(h())))`.
func (c *SubprocessorHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubprocessorHistory = append(c.inters.SubprocessorHistory, interceptors...)
}

// Create returns a builder for creating a SubprocessorHistory entity.
func (c *SubprocessorHistoryClient) Create() *SubprocessorHistoryCreate {
	mutation := newSubprocessorHistoryMutation(c.config, OpCreate)
	return &SubprocessorHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubprocessorHistory entities.
func (c *SubprocessorHistoryClient) CreateBulk(builders ...*SubprocessorHistoryCreate) *SubprocessorHistoryCreateBulk {
	return &SubprocessorHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubprocessorHistoryClient) MapCreateBulk(slice any, setFunc func(*SubprocessorHistoryCreate, int)) *SubprocessorHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubprocessorHistoryCreateBulk{err: fmt.Errorf("calling to SubprocessorHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubprocessorHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubprocessorHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubprocessorHistory.
func (c *SubprocessorHistoryClient) Update() *SubprocessorHistoryUpdate {
	mutation := newSubprocessorHistoryMutation(c.config, OpUpdate)
	return &SubprocessorHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubprocessorHistoryClient) UpdateOne(_m *SubprocessorHistory) *SubprocessorHistoryUpdateOne {
	mutation := newSubprocessorHistoryMutation(c.config, OpUpdateOne, withSubprocessorHistory(_m))
	return &SubprocessorHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubprocessorHistoryClient) UpdateOneID(id string) *SubprocessorHistoryUpdateOne {
	mutation := newSubprocessorHistoryMutation(c.config, OpUpdateOne, withSubprocessorHistoryID(id))
	return &SubprocessorHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubprocessorHistory.
func (c *SubprocessorHistoryClient) Delete() *SubprocessorHistoryDelete {
	mutation := newSubprocessorHistoryMutation(c.config, OpDelete)
	return &SubprocessorHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubprocessorHistoryClient) DeleteOne(_m *SubprocessorHistory) *SubprocessorHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubprocessorHistoryClient) DeleteOneID(id string) *SubprocessorHistoryDeleteOne {
	builder := c.Delete().Where(subprocessorhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubprocessorHistoryDeleteOne{builder}
}

// Query returns a query builder for SubprocessorHistory.
func (c *SubprocessorHistoryClient) Query() *SubprocessorHistoryQuery {
	return &SubprocessorHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubprocessorHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a SubprocessorHistory entity by its id.
func (c *SubprocessorHistoryClient) Get(ctx context.Context, id string) (*SubprocessorHistory, error) {
	return c.Query().Where(subprocessorhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubprocessorHistoryClient) GetX(ctx context.Context, id string) *SubprocessorHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubprocessorHistoryClient) Hooks() []Hook {
	hooks := c.hooks.SubprocessorHistory
	return append(hooks[:len(hooks):len(hooks)], subprocessorhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubprocessorHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.SubprocessorHistory
	return append(inters[:len(inters):len(inters)], subprocessorhistory.Interceptors[:]...)
}

func (c *SubprocessorHistoryClient) mutate(ctx context.Context, m *SubprocessorHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubprocessorHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubprocessorHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubprocessorHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubprocessorHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown SubprocessorHistory mutation op: %q", m.Op())
	}
}

// SubscriberClient is a client for the Subscriber schema.
type SubscriberClient struct {
	config
}

// NewSubscriberClient returns a client for the Subscriber from the given config.
func NewSubscriberClient(c config) *SubscriberClient {
	return &SubscriberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscriber.Hooks(f(g(h())))`.
func (c *SubscriberClient) Use(hooks ...Hook) {
	c.hooks.Subscriber = append(c.hooks.Subscriber, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscriber.Intercept(f(g(h())))`.
func (c *SubscriberClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscriber = append(c.inters.Subscriber, interceptors...)
}

// Create returns a builder for creating a Subscriber entity.
func (c *SubscriberClient) Create() *SubscriberCreate {
	mutation := newSubscriberMutation(c.config, OpCreate)
	return &SubscriberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscriber entities.
func (c *SubscriberClient) CreateBulk(builders ...*SubscriberCreate) *SubscriberCreateBulk {
	return &SubscriberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriberClient) MapCreateBulk(slice any, setFunc func(*SubscriberCreate, int)) *SubscriberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriberCreateBulk{err: fmt.Errorf("calling to SubscriberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscriber.
func (c *SubscriberClient) Update() *SubscriberUpdate {
	mutation := newSubscriberMutation(c.config, OpUpdate)
	return &SubscriberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriberClient) UpdateOne(_m *Subscriber) *SubscriberUpdateOne {
	mutation := newSubscriberMutation(c.config, OpUpdateOne, withSubscriber(_m))
	return &SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriberClient) UpdateOneID(id string) *SubscriberUpdateOne {
	mutation := newSubscriberMutation(c.config, OpUpdateOne, withSubscriberID(id))
	return &SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscriber.
func (c *SubscriberClient) Delete() *SubscriberDelete {
	mutation := newSubscriberMutation(c.config, OpDelete)
	return &SubscriberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriberClient) DeleteOne(_m *Subscriber) *SubscriberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriberClient) DeleteOneID(id string) *SubscriberDeleteOne {
	builder := c.Delete().Where(subscriber.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriberDeleteOne{builder}
}

// Query returns a query builder for Subscriber.
func (c *SubscriberClient) Query() *SubscriberQuery {
	return &SubscriberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscriber},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscriber entity by its id.
func (c *SubscriberClient) Get(ctx context.Context, id string) (*Subscriber, error) {
	return c.Query().Where(subscriber.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriberClient) GetX(ctx context.Context, id string) *Subscriber {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Subscriber.
func (c *SubscriberClient) QueryOwner(_m *Subscriber) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscriber.Table, subscriber.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscriber.OwnerTable, subscriber.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Subscriber
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Subscriber.
func (c *SubscriberClient) QueryEvents(_m *Subscriber) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscriber.Table, subscriber.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subscriber.EventsTable, subscriber.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.SubscriberEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriberClient) Hooks() []Hook {
	hooks := c.hooks.Subscriber
	return append(hooks[:len(hooks):len(hooks)], subscriber.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubscriberClient) Interceptors() []Interceptor {
	inters := c.inters.Subscriber
	return append(inters[:len(inters):len(inters)], subscriber.Interceptors[:]...)
}

func (c *SubscriberClient) mutate(ctx context.Context, m *SubscriberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subscriber mutation op: %q", m.Op())
	}
}

// TFASettingClient is a client for the TFASetting schema.
type TFASettingClient struct {
	config
}

// NewTFASettingClient returns a client for the TFASetting from the given config.
func NewTFASettingClient(c config) *TFASettingClient {
	return &TFASettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tfasetting.Hooks(f(g(h())))`.
func (c *TFASettingClient) Use(hooks ...Hook) {
	c.hooks.TFASetting = append(c.hooks.TFASetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tfasetting.Intercept(f(g(h())))`.
func (c *TFASettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.TFASetting = append(c.inters.TFASetting, interceptors...)
}

// Create returns a builder for creating a TFASetting entity.
func (c *TFASettingClient) Create() *TFASettingCreate {
	mutation := newTFASettingMutation(c.config, OpCreate)
	return &TFASettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TFASetting entities.
func (c *TFASettingClient) CreateBulk(builders ...*TFASettingCreate) *TFASettingCreateBulk {
	return &TFASettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TFASettingClient) MapCreateBulk(slice any, setFunc func(*TFASettingCreate, int)) *TFASettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TFASettingCreateBulk{err: fmt.Errorf("calling to TFASettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TFASettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TFASettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TFASetting.
func (c *TFASettingClient) Update() *TFASettingUpdate {
	mutation := newTFASettingMutation(c.config, OpUpdate)
	return &TFASettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TFASettingClient) UpdateOne(_m *TFASetting) *TFASettingUpdateOne {
	mutation := newTFASettingMutation(c.config, OpUpdateOne, withTFASetting(_m))
	return &TFASettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TFASettingClient) UpdateOneID(id string) *TFASettingUpdateOne {
	mutation := newTFASettingMutation(c.config, OpUpdateOne, withTFASettingID(id))
	return &TFASettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TFASetting.
func (c *TFASettingClient) Delete() *TFASettingDelete {
	mutation := newTFASettingMutation(c.config, OpDelete)
	return &TFASettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TFASettingClient) DeleteOne(_m *TFASetting) *TFASettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TFASettingClient) DeleteOneID(id string) *TFASettingDeleteOne {
	builder := c.Delete().Where(tfasetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TFASettingDeleteOne{builder}
}

// Query returns a query builder for TFASetting.
func (c *TFASettingClient) Query() *TFASettingQuery {
	return &TFASettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTFASetting},
		inters: c.Interceptors(),
	}
}

// Get returns a TFASetting entity by its id.
func (c *TFASettingClient) Get(ctx context.Context, id string) (*TFASetting, error) {
	return c.Query().Where(tfasetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TFASettingClient) GetX(ctx context.Context, id string) *TFASetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a TFASetting.
func (c *TFASettingClient) QueryOwner(_m *TFASetting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tfasetting.Table, tfasetting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tfasetting.OwnerTable, tfasetting.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.TFASetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TFASettingClient) Hooks() []Hook {
	hooks := c.hooks.TFASetting
	return append(hooks[:len(hooks):len(hooks)], tfasetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TFASettingClient) Interceptors() []Interceptor {
	inters := c.inters.TFASetting
	return append(inters[:len(inters):len(inters)], tfasetting.Interceptors[:]...)
}

func (c *TFASettingClient) mutate(ctx context.Context, m *TFASettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TFASettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TFASettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TFASettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TFASettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TFASetting mutation op: %q", m.Op())
	}
}

// TagDefinitionClient is a client for the TagDefinition schema.
type TagDefinitionClient struct {
	config
}

// NewTagDefinitionClient returns a client for the TagDefinition from the given config.
func NewTagDefinitionClient(c config) *TagDefinitionClient {
	return &TagDefinitionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tagdefinition.Hooks(f(g(h())))`.
func (c *TagDefinitionClient) Use(hooks ...Hook) {
	c.hooks.TagDefinition = append(c.hooks.TagDefinition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tagdefinition.Intercept(f(g(h())))`.
func (c *TagDefinitionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TagDefinition = append(c.inters.TagDefinition, interceptors...)
}

// Create returns a builder for creating a TagDefinition entity.
func (c *TagDefinitionClient) Create() *TagDefinitionCreate {
	mutation := newTagDefinitionMutation(c.config, OpCreate)
	return &TagDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TagDefinition entities.
func (c *TagDefinitionClient) CreateBulk(builders ...*TagDefinitionCreate) *TagDefinitionCreateBulk {
	return &TagDefinitionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagDefinitionClient) MapCreateBulk(slice any, setFunc func(*TagDefinitionCreate, int)) *TagDefinitionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagDefinitionCreateBulk{err: fmt.Errorf("calling to TagDefinitionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagDefinitionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagDefinitionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TagDefinition.
func (c *TagDefinitionClient) Update() *TagDefinitionUpdate {
	mutation := newTagDefinitionMutation(c.config, OpUpdate)
	return &TagDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagDefinitionClient) UpdateOne(_m *TagDefinition) *TagDefinitionUpdateOne {
	mutation := newTagDefinitionMutation(c.config, OpUpdateOne, withTagDefinition(_m))
	return &TagDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagDefinitionClient) UpdateOneID(id string) *TagDefinitionUpdateOne {
	mutation := newTagDefinitionMutation(c.config, OpUpdateOne, withTagDefinitionID(id))
	return &TagDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TagDefinition.
func (c *TagDefinitionClient) Delete() *TagDefinitionDelete {
	mutation := newTagDefinitionMutation(c.config, OpDelete)
	return &TagDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagDefinitionClient) DeleteOne(_m *TagDefinition) *TagDefinitionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagDefinitionClient) DeleteOneID(id string) *TagDefinitionDeleteOne {
	builder := c.Delete().Where(tagdefinition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDefinitionDeleteOne{builder}
}

// Query returns a query builder for TagDefinition.
func (c *TagDefinitionClient) Query() *TagDefinitionQuery {
	return &TagDefinitionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTagDefinition},
		inters: c.Interceptors(),
	}
}

// Get returns a TagDefinition entity by its id.
func (c *TagDefinitionClient) Get(ctx context.Context, id string) (*TagDefinition, error) {
	return c.Query().Where(tagdefinition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagDefinitionClient) GetX(ctx context.Context, id string) *TagDefinition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a TagDefinition.
func (c *TagDefinitionClient) QueryOwner(_m *TagDefinition) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tagdefinition.Table, tagdefinition.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tagdefinition.OwnerTable, tagdefinition.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.TagDefinition
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagDefinitionClient) Hooks() []Hook {
	hooks := c.hooks.TagDefinition
	return append(hooks[:len(hooks):len(hooks)], tagdefinition.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TagDefinitionClient) Interceptors() []Interceptor {
	inters := c.inters.TagDefinition
	return append(inters[:len(inters):len(inters)], tagdefinition.Interceptors[:]...)
}

func (c *TagDefinitionClient) mutate(ctx context.Context, m *TagDefinitionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TagDefinition mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(_m *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(_m))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id string) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(_m *Task) *TaskDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id string) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id string) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id string) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Task.
func (c *TaskClient) QueryOwner(_m *Task) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.OwnerTable, task.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTaskKind queries the task_kind edge of a Task.
func (c *TaskClient) QueryTaskKind(_m *Task) *CustomTypeEnumQuery {
	query := (&CustomTypeEnumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(customtypeenum.Table, customtypeenum.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, task.TaskKindTable, task.TaskKindColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomTypeEnum
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssigner queries the assigner edge of a Task.
func (c *TaskClient) QueryAssigner(_m *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AssignerTable, task.AssignerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignee queries the assignee edge of a Task.
func (c *TaskClient) QueryAssignee(_m *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AssigneeTable, task.AssigneeColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Task.
func (c *TaskClient) QueryComments(_m *Task) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.CommentsTable, task.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Task.
func (c *TaskClient) QueryGroups(_m *Task) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.GroupsTable, task.GroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalPolicies queries the internal_policies edge of a Task.
func (c *TaskClient) QueryInternalPolicies(_m *Task) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.InternalPoliciesTable, task.InternalPoliciesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Task.
func (c *TaskClient) QueryProcedures(_m *Task) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ProceduresTable, task.ProceduresPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Task.
func (c *TaskClient) QueryControls(_m *Task) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ControlsTable, task.ControlsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Task.
func (c *TaskClient) QuerySubcontrols(_m *Task) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.SubcontrolsTable, task.SubcontrolsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.SubcontrolTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjectives queries the control_objectives edge of a Task.
func (c *TaskClient) QueryControlObjectives(_m *Task) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ControlObjectivesTable, task.ControlObjectivesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjectiveTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Task.
func (c *TaskClient) QueryPrograms(_m *Task) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ProgramsTable, task.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Task.
func (c *TaskClient) QueryRisks(_m *Task) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.RisksTable, task.RisksPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.RiskTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlImplementations queries the control_implementations edge of a Task.
func (c *TaskClient) QueryControlImplementations(_m *Task) *ControlImplementationQuery {
	query := (&ControlImplementationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(controlimplementation.Table, controlimplementation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ControlImplementationsTable, task.ControlImplementationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ControlImplementation
		step.Edge.Schema = schemaConfig.ControlImplementationTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Task.
func (c *TaskClient) QueryActionPlans(_m *Task) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ActionPlansTable, task.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ActionPlanTasks
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvidence queries the evidence edge of a Task.
func (c *TaskClient) QueryEvidence(_m *Task) *EvidenceQuery {
	query := (&EvidenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(evidence.Table, evidence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, task.EvidenceTable, task.EvidencePrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Evidence
		step.Edge.Schema = schemaConfig.TaskEvidence
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	hooks := c.hooks.Task
	return append(hooks[:len(hooks):len(hooks)], task.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	inters := c.inters.Task
	return append(inters[:len(inters):len(inters)], task.Interceptors[:]...)
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Task mutation op: %q", m.Op())
	}
}

// TaskHistoryClient is a client for the TaskHistory schema.
type TaskHistoryClient struct {
	config
}

// NewTaskHistoryClient returns a client for the TaskHistory from the given config.
func NewTaskHistoryClient(c config) *TaskHistoryClient {
	return &TaskHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskhistory.Hooks(f(g(h())))`.
func (c *TaskHistoryClient) Use(hooks ...Hook) {
	c.hooks.TaskHistory = append(c.hooks.TaskHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskhistory.Intercept(f(g(h())))`.
func (c *TaskHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskHistory = append(c.inters.TaskHistory, interceptors...)
}

// Create returns a builder for creating a TaskHistory entity.
func (c *TaskHistoryClient) Create() *TaskHistoryCreate {
	mutation := newTaskHistoryMutation(c.config, OpCreate)
	return &TaskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskHistory entities.
func (c *TaskHistoryClient) CreateBulk(builders ...*TaskHistoryCreate) *TaskHistoryCreateBulk {
	return &TaskHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskHistoryClient) MapCreateBulk(slice any, setFunc func(*TaskHistoryCreate, int)) *TaskHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskHistoryCreateBulk{err: fmt.Errorf("calling to TaskHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskHistory.
func (c *TaskHistoryClient) Update() *TaskHistoryUpdate {
	mutation := newTaskHistoryMutation(c.config, OpUpdate)
	return &TaskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskHistoryClient) UpdateOne(_m *TaskHistory) *TaskHistoryUpdateOne {
	mutation := newTaskHistoryMutation(c.config, OpUpdateOne, withTaskHistory(_m))
	return &TaskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskHistoryClient) UpdateOneID(id string) *TaskHistoryUpdateOne {
	mutation := newTaskHistoryMutation(c.config, OpUpdateOne, withTaskHistoryID(id))
	return &TaskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskHistory.
func (c *TaskHistoryClient) Delete() *TaskHistoryDelete {
	mutation := newTaskHistoryMutation(c.config, OpDelete)
	return &TaskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskHistoryClient) DeleteOne(_m *TaskHistory) *TaskHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskHistoryClient) DeleteOneID(id string) *TaskHistoryDeleteOne {
	builder := c.Delete().Where(taskhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskHistoryDeleteOne{builder}
}

// Query returns a query builder for TaskHistory.
func (c *TaskHistoryClient) Query() *TaskHistoryQuery {
	return &TaskHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskHistory entity by its id.
func (c *TaskHistoryClient) Get(ctx context.Context, id string) (*TaskHistory, error) {
	return c.Query().Where(taskhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskHistoryClient) GetX(ctx context.Context, id string) *TaskHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TaskHistory
	return append(hooks[:len(hooks):len(hooks)], taskhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TaskHistory
	return append(inters[:len(inters):len(inters)], taskhistory.Interceptors[:]...)
}

func (c *TaskHistoryClient) mutate(ctx context.Context, m *TaskHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TaskHistory mutation op: %q", m.Op())
	}
}

// TemplateClient is a client for the Template schema.
type TemplateClient struct {
	config
}

// NewTemplateClient returns a client for the Template from the given config.
func NewTemplateClient(c config) *TemplateClient {
	return &TemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `template.Hooks(f(g(h())))`.
func (c *TemplateClient) Use(hooks ...Hook) {
	c.hooks.Template = append(c.hooks.Template, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `template.Intercept(f(g(h())))`.
func (c *TemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Template = append(c.inters.Template, interceptors...)
}

// Create returns a builder for creating a Template entity.
func (c *TemplateClient) Create() *TemplateCreate {
	mutation := newTemplateMutation(c.config, OpCreate)
	return &TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Template entities.
func (c *TemplateClient) CreateBulk(builders ...*TemplateCreate) *TemplateCreateBulk {
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateClient) MapCreateBulk(slice any, setFunc func(*TemplateCreate, int)) *TemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateCreateBulk{err: fmt.Errorf("calling to TemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Template.
func (c *TemplateClient) Update() *TemplateUpdate {
	mutation := newTemplateMutation(c.config, OpUpdate)
	return &TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateClient) UpdateOne(_m *Template) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplate(_m))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateClient) UpdateOneID(id string) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplateID(id))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Template.
func (c *TemplateClient) Delete() *TemplateDelete {
	mutation := newTemplateMutation(c.config, OpDelete)
	return &TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateClient) DeleteOne(_m *Template) *TemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateClient) DeleteOneID(id string) *TemplateDeleteOne {
	builder := c.Delete().Where(template.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateDeleteOne{builder}
}

// Query returns a query builder for Template.
func (c *TemplateClient) Query() *TemplateQuery {
	return &TemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a Template entity by its id.
func (c *TemplateClient) Get(ctx context.Context, id string) (*Template, error) {
	return c.Query().Where(template.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateClient) GetX(ctx context.Context, id string) *Template {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Template.
func (c *TemplateClient) QueryOwner(_m *Template) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, template.OwnerTable, template.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Template.
func (c *TemplateClient) QueryDocuments(_m *Template) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, template.DocumentsTable, template.DocumentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Template.
func (c *TemplateClient) QueryFiles(_m *Template) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, template.FilesTable, template.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TemplateFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenter queries the trust_center edge of a Template.
func (c *TemplateClient) QueryTrustCenter(_m *Template) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, template.TrustCenterTable, template.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssessments queries the assessments edge of a Template.
func (c *TemplateClient) QueryAssessments(_m *Template) *AssessmentQuery {
	query := (&AssessmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(assessment.Table, assessment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, template.AssessmentsTable, template.AssessmentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Assessment
		step.Edge.Schema = schemaConfig.Assessment
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TemplateClient) Hooks() []Hook {
	hooks := c.hooks.Template
	return append(hooks[:len(hooks):len(hooks)], template.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TemplateClient) Interceptors() []Interceptor {
	inters := c.inters.Template
	return append(inters[:len(inters):len(inters)], template.Interceptors[:]...)
}

func (c *TemplateClient) mutate(ctx context.Context, m *TemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Template mutation op: %q", m.Op())
	}
}

// TemplateHistoryClient is a client for the TemplateHistory schema.
type TemplateHistoryClient struct {
	config
}

// NewTemplateHistoryClient returns a client for the TemplateHistory from the given config.
func NewTemplateHistoryClient(c config) *TemplateHistoryClient {
	return &TemplateHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `templatehistory.Hooks(f(g(h())))`.
func (c *TemplateHistoryClient) Use(hooks ...Hook) {
	c.hooks.TemplateHistory = append(c.hooks.TemplateHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `templatehistory.Intercept(f(g(h())))`.
func (c *TemplateHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TemplateHistory = append(c.inters.TemplateHistory, interceptors...)
}

// Create returns a builder for creating a TemplateHistory entity.
func (c *TemplateHistoryClient) Create() *TemplateHistoryCreate {
	mutation := newTemplateHistoryMutation(c.config, OpCreate)
	return &TemplateHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TemplateHistory entities.
func (c *TemplateHistoryClient) CreateBulk(builders ...*TemplateHistoryCreate) *TemplateHistoryCreateBulk {
	return &TemplateHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateHistoryClient) MapCreateBulk(slice any, setFunc func(*TemplateHistoryCreate, int)) *TemplateHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateHistoryCreateBulk{err: fmt.Errorf("calling to TemplateHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TemplateHistory.
func (c *TemplateHistoryClient) Update() *TemplateHistoryUpdate {
	mutation := newTemplateHistoryMutation(c.config, OpUpdate)
	return &TemplateHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateHistoryClient) UpdateOne(_m *TemplateHistory) *TemplateHistoryUpdateOne {
	mutation := newTemplateHistoryMutation(c.config, OpUpdateOne, withTemplateHistory(_m))
	return &TemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateHistoryClient) UpdateOneID(id string) *TemplateHistoryUpdateOne {
	mutation := newTemplateHistoryMutation(c.config, OpUpdateOne, withTemplateHistoryID(id))
	return &TemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TemplateHistory.
func (c *TemplateHistoryClient) Delete() *TemplateHistoryDelete {
	mutation := newTemplateHistoryMutation(c.config, OpDelete)
	return &TemplateHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateHistoryClient) DeleteOne(_m *TemplateHistory) *TemplateHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateHistoryClient) DeleteOneID(id string) *TemplateHistoryDeleteOne {
	builder := c.Delete().Where(templatehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateHistoryDeleteOne{builder}
}

// Query returns a query builder for TemplateHistory.
func (c *TemplateHistoryClient) Query() *TemplateHistoryQuery {
	return &TemplateHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplateHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TemplateHistory entity by its id.
func (c *TemplateHistoryClient) Get(ctx context.Context, id string) (*TemplateHistory, error) {
	return c.Query().Where(templatehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateHistoryClient) GetX(ctx context.Context, id string) *TemplateHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TemplateHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TemplateHistory
	return append(hooks[:len(hooks):len(hooks)], templatehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TemplateHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TemplateHistory
	return append(inters[:len(inters):len(inters)], templatehistory.Interceptors[:]...)
}

func (c *TemplateHistoryClient) mutate(ctx context.Context, m *TemplateHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TemplateHistory mutation op: %q", m.Op())
	}
}

// TrustCenterClient is a client for the TrustCenter schema.
type TrustCenterClient struct {
	config
}

// NewTrustCenterClient returns a client for the TrustCenter from the given config.
func NewTrustCenterClient(c config) *TrustCenterClient {
	return &TrustCenterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcenter.Hooks(f(g(h())))`.
func (c *TrustCenterClient) Use(hooks ...Hook) {
	c.hooks.TrustCenter = append(c.hooks.TrustCenter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcenter.Intercept(f(g(h())))`.
func (c *TrustCenterClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenter = append(c.inters.TrustCenter, interceptors...)
}

// Create returns a builder for creating a TrustCenter entity.
func (c *TrustCenterClient) Create() *TrustCenterCreate {
	mutation := newTrustCenterMutation(c.config, OpCreate)
	return &TrustCenterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenter entities.
func (c *TrustCenterClient) CreateBulk(builders ...*TrustCenterCreate) *TrustCenterCreateBulk {
	return &TrustCenterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterClient) MapCreateBulk(slice any, setFunc func(*TrustCenterCreate, int)) *TrustCenterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterCreateBulk{err: fmt.Errorf("calling to TrustCenterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenter.
func (c *TrustCenterClient) Update() *TrustCenterUpdate {
	mutation := newTrustCenterMutation(c.config, OpUpdate)
	return &TrustCenterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterClient) UpdateOne(_m *TrustCenter) *TrustCenterUpdateOne {
	mutation := newTrustCenterMutation(c.config, OpUpdateOne, withTrustCenter(_m))
	return &TrustCenterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterClient) UpdateOneID(id string) *TrustCenterUpdateOne {
	mutation := newTrustCenterMutation(c.config, OpUpdateOne, withTrustCenterID(id))
	return &TrustCenterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenter.
func (c *TrustCenterClient) Delete() *TrustCenterDelete {
	mutation := newTrustCenterMutation(c.config, OpDelete)
	return &TrustCenterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterClient) DeleteOne(_m *TrustCenter) *TrustCenterDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterClient) DeleteOneID(id string) *TrustCenterDeleteOne {
	builder := c.Delete().Where(trustcenter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterDeleteOne{builder}
}

// Query returns a query builder for TrustCenter.
func (c *TrustCenterClient) Query() *TrustCenterQuery {
	return &TrustCenterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenter},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenter entity by its id.
func (c *TrustCenterClient) Get(ctx context.Context, id string) (*TrustCenter, error) {
	return c.Query().Where(trustcenter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterClient) GetX(ctx context.Context, id string) *TrustCenter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a TrustCenter.
func (c *TrustCenterClient) QueryOwner(_m *TrustCenter) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcenter.OwnerTable, trustcenter.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.TrustCenter
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomDomain queries the custom_domain edge of a TrustCenter.
func (c *TrustCenterClient) QueryCustomDomain(_m *TrustCenter) *CustomDomainQuery {
	query := (&CustomDomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(customdomain.Table, customdomain.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcenter.CustomDomainTable, trustcenter.CustomDomainColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.CustomDomain
		step.Edge.Schema = schemaConfig.TrustCenter
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a TrustCenter.
func (c *TrustCenterClient) QuerySetting(_m *TrustCenter) *TrustCenterSettingQuery {
	query := (&TrustCenterSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(trustcentersetting.Table, trustcentersetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, trustcenter.SettingTable, trustcenter.SettingColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterSetting
		step.Edge.Schema = schemaConfig.TrustCenterSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWatermarkConfig queries the watermark_config edge of a TrustCenter.
func (c *TrustCenterClient) QueryWatermarkConfig(_m *TrustCenter) *TrustCenterWatermarkConfigQuery {
	query := (&TrustCenterWatermarkConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(trustcenterwatermarkconfig.Table, trustcenterwatermarkconfig.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcenter.WatermarkConfigTable, trustcenter.WatermarkConfigColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterWatermarkConfig
		step.Edge.Schema = schemaConfig.TrustCenter
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterSubprocessors queries the trust_center_subprocessors edge of a TrustCenter.
func (c *TrustCenterClient) QueryTrustCenterSubprocessors(_m *TrustCenter) *TrustCenterSubprocessorQuery {
	query := (&TrustCenterSubprocessorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(trustcentersubprocessor.Table, trustcentersubprocessor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trustcenter.TrustCenterSubprocessorsTable, trustcenter.TrustCenterSubprocessorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterSubprocessor
		step.Edge.Schema = schemaConfig.TrustCenterSubprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterDocs queries the trust_center_docs edge of a TrustCenter.
func (c *TrustCenterClient) QueryTrustCenterDocs(_m *TrustCenter) *TrustCenterDocQuery {
	query := (&TrustCenterDocClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(trustcenterdoc.Table, trustcenterdoc.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trustcenter.TrustCenterDocsTable, trustcenter.TrustCenterDocsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterDoc
		step.Edge.Schema = schemaConfig.TrustCenterDoc
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenterCompliances queries the trust_center_compliances edge of a TrustCenter.
func (c *TrustCenterClient) QueryTrustCenterCompliances(_m *TrustCenter) *TrustCenterComplianceQuery {
	query := (&TrustCenterComplianceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(trustcentercompliance.Table, trustcentercompliance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trustcenter.TrustCenterCompliancesTable, trustcenter.TrustCenterCompliancesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenterCompliance
		step.Edge.Schema = schemaConfig.TrustCenterCompliance
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplates queries the templates edge of a TrustCenter.
func (c *TrustCenterClient) QueryTemplates(_m *TrustCenter) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trustcenter.TemplatesTable, trustcenter.TemplatesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a TrustCenter.
func (c *TrustCenterClient) QueryPosts(_m *TrustCenter) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenter.Table, trustcenter.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, trustcenter.PostsTable, trustcenter.PostsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustCenterClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenter
	return append(hooks[:len(hooks):len(hooks)], trustcenter.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenter
	return append(inters[:len(inters):len(inters)], trustcenter.Interceptors[:]...)
}

func (c *TrustCenterClient) mutate(ctx context.Context, m *TrustCenterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenter mutation op: %q", m.Op())
	}
}

// TrustCenterComplianceClient is a client for the TrustCenterCompliance schema.
type TrustCenterComplianceClient struct {
	config
}

// NewTrustCenterComplianceClient returns a client for the TrustCenterCompliance from the given config.
func NewTrustCenterComplianceClient(c config) *TrustCenterComplianceClient {
	return &TrustCenterComplianceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcentercompliance.Hooks(f(g(h())))`.
func (c *TrustCenterComplianceClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterCompliance = append(c.hooks.TrustCenterCompliance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcentercompliance.Intercept(f(g(h())))`.
func (c *TrustCenterComplianceClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterCompliance = append(c.inters.TrustCenterCompliance, interceptors...)
}

// Create returns a builder for creating a TrustCenterCompliance entity.
func (c *TrustCenterComplianceClient) Create() *TrustCenterComplianceCreate {
	mutation := newTrustCenterComplianceMutation(c.config, OpCreate)
	return &TrustCenterComplianceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterCompliance entities.
func (c *TrustCenterComplianceClient) CreateBulk(builders ...*TrustCenterComplianceCreate) *TrustCenterComplianceCreateBulk {
	return &TrustCenterComplianceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterComplianceClient) MapCreateBulk(slice any, setFunc func(*TrustCenterComplianceCreate, int)) *TrustCenterComplianceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterComplianceCreateBulk{err: fmt.Errorf("calling to TrustCenterComplianceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterComplianceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterComplianceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterCompliance.
func (c *TrustCenterComplianceClient) Update() *TrustCenterComplianceUpdate {
	mutation := newTrustCenterComplianceMutation(c.config, OpUpdate)
	return &TrustCenterComplianceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterComplianceClient) UpdateOne(_m *TrustCenterCompliance) *TrustCenterComplianceUpdateOne {
	mutation := newTrustCenterComplianceMutation(c.config, OpUpdateOne, withTrustCenterCompliance(_m))
	return &TrustCenterComplianceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterComplianceClient) UpdateOneID(id string) *TrustCenterComplianceUpdateOne {
	mutation := newTrustCenterComplianceMutation(c.config, OpUpdateOne, withTrustCenterComplianceID(id))
	return &TrustCenterComplianceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterCompliance.
func (c *TrustCenterComplianceClient) Delete() *TrustCenterComplianceDelete {
	mutation := newTrustCenterComplianceMutation(c.config, OpDelete)
	return &TrustCenterComplianceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterComplianceClient) DeleteOne(_m *TrustCenterCompliance) *TrustCenterComplianceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterComplianceClient) DeleteOneID(id string) *TrustCenterComplianceDeleteOne {
	builder := c.Delete().Where(trustcentercompliance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterComplianceDeleteOne{builder}
}

// Query returns a query builder for TrustCenterCompliance.
func (c *TrustCenterComplianceClient) Query() *TrustCenterComplianceQuery {
	return &TrustCenterComplianceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterCompliance},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterCompliance entity by its id.
func (c *TrustCenterComplianceClient) Get(ctx context.Context, id string) (*TrustCenterCompliance, error) {
	return c.Query().Where(trustcentercompliance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterComplianceClient) GetX(ctx context.Context, id string) *TrustCenterCompliance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTrustCenter queries the trust_center edge of a TrustCenterCompliance.
func (c *TrustCenterComplianceClient) QueryTrustCenter(_m *TrustCenterCompliance) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentercompliance.Table, trustcentercompliance.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcentercompliance.TrustCenterTable, trustcentercompliance.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.TrustCenterCompliance
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandard queries the standard edge of a TrustCenterCompliance.
func (c *TrustCenterComplianceClient) QueryStandard(_m *TrustCenterCompliance) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentercompliance.Table, trustcentercompliance.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcentercompliance.StandardTable, trustcentercompliance.StandardColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.TrustCenterCompliance
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustCenterComplianceClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterCompliance
	return append(hooks[:len(hooks):len(hooks)], trustcentercompliance.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterComplianceClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterCompliance
	return append(inters[:len(inters):len(inters)], trustcentercompliance.Interceptors[:]...)
}

func (c *TrustCenterComplianceClient) mutate(ctx context.Context, m *TrustCenterComplianceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterComplianceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterComplianceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterComplianceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterComplianceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterCompliance mutation op: %q", m.Op())
	}
}

// TrustCenterComplianceHistoryClient is a client for the TrustCenterComplianceHistory schema.
type TrustCenterComplianceHistoryClient struct {
	config
}

// NewTrustCenterComplianceHistoryClient returns a client for the TrustCenterComplianceHistory from the given config.
func NewTrustCenterComplianceHistoryClient(c config) *TrustCenterComplianceHistoryClient {
	return &TrustCenterComplianceHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcentercompliancehistory.Hooks(f(g(h())))`.
func (c *TrustCenterComplianceHistoryClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterComplianceHistory = append(c.hooks.TrustCenterComplianceHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcentercompliancehistory.Intercept(f(g(h())))`.
func (c *TrustCenterComplianceHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterComplianceHistory = append(c.inters.TrustCenterComplianceHistory, interceptors...)
}

// Create returns a builder for creating a TrustCenterComplianceHistory entity.
func (c *TrustCenterComplianceHistoryClient) Create() *TrustCenterComplianceHistoryCreate {
	mutation := newTrustCenterComplianceHistoryMutation(c.config, OpCreate)
	return &TrustCenterComplianceHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterComplianceHistory entities.
func (c *TrustCenterComplianceHistoryClient) CreateBulk(builders ...*TrustCenterComplianceHistoryCreate) *TrustCenterComplianceHistoryCreateBulk {
	return &TrustCenterComplianceHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterComplianceHistoryClient) MapCreateBulk(slice any, setFunc func(*TrustCenterComplianceHistoryCreate, int)) *TrustCenterComplianceHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterComplianceHistoryCreateBulk{err: fmt.Errorf("calling to TrustCenterComplianceHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterComplianceHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterComplianceHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterComplianceHistory.
func (c *TrustCenterComplianceHistoryClient) Update() *TrustCenterComplianceHistoryUpdate {
	mutation := newTrustCenterComplianceHistoryMutation(c.config, OpUpdate)
	return &TrustCenterComplianceHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterComplianceHistoryClient) UpdateOne(_m *TrustCenterComplianceHistory) *TrustCenterComplianceHistoryUpdateOne {
	mutation := newTrustCenterComplianceHistoryMutation(c.config, OpUpdateOne, withTrustCenterComplianceHistory(_m))
	return &TrustCenterComplianceHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterComplianceHistoryClient) UpdateOneID(id string) *TrustCenterComplianceHistoryUpdateOne {
	mutation := newTrustCenterComplianceHistoryMutation(c.config, OpUpdateOne, withTrustCenterComplianceHistoryID(id))
	return &TrustCenterComplianceHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterComplianceHistory.
func (c *TrustCenterComplianceHistoryClient) Delete() *TrustCenterComplianceHistoryDelete {
	mutation := newTrustCenterComplianceHistoryMutation(c.config, OpDelete)
	return &TrustCenterComplianceHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterComplianceHistoryClient) DeleteOne(_m *TrustCenterComplianceHistory) *TrustCenterComplianceHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterComplianceHistoryClient) DeleteOneID(id string) *TrustCenterComplianceHistoryDeleteOne {
	builder := c.Delete().Where(trustcentercompliancehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterComplianceHistoryDeleteOne{builder}
}

// Query returns a query builder for TrustCenterComplianceHistory.
func (c *TrustCenterComplianceHistoryClient) Query() *TrustCenterComplianceHistoryQuery {
	return &TrustCenterComplianceHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterComplianceHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterComplianceHistory entity by its id.
func (c *TrustCenterComplianceHistoryClient) Get(ctx context.Context, id string) (*TrustCenterComplianceHistory, error) {
	return c.Query().Where(trustcentercompliancehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterComplianceHistoryClient) GetX(ctx context.Context, id string) *TrustCenterComplianceHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrustCenterComplianceHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterComplianceHistory
	return append(hooks[:len(hooks):len(hooks)], trustcentercompliancehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterComplianceHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterComplianceHistory
	return append(inters[:len(inters):len(inters)], trustcentercompliancehistory.Interceptors[:]...)
}

func (c *TrustCenterComplianceHistoryClient) mutate(ctx context.Context, m *TrustCenterComplianceHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterComplianceHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterComplianceHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterComplianceHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterComplianceHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterComplianceHistory mutation op: %q", m.Op())
	}
}

// TrustCenterDocClient is a client for the TrustCenterDoc schema.
type TrustCenterDocClient struct {
	config
}

// NewTrustCenterDocClient returns a client for the TrustCenterDoc from the given config.
func NewTrustCenterDocClient(c config) *TrustCenterDocClient {
	return &TrustCenterDocClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcenterdoc.Hooks(f(g(h())))`.
func (c *TrustCenterDocClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterDoc = append(c.hooks.TrustCenterDoc, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcenterdoc.Intercept(f(g(h())))`.
func (c *TrustCenterDocClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterDoc = append(c.inters.TrustCenterDoc, interceptors...)
}

// Create returns a builder for creating a TrustCenterDoc entity.
func (c *TrustCenterDocClient) Create() *TrustCenterDocCreate {
	mutation := newTrustCenterDocMutation(c.config, OpCreate)
	return &TrustCenterDocCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterDoc entities.
func (c *TrustCenterDocClient) CreateBulk(builders ...*TrustCenterDocCreate) *TrustCenterDocCreateBulk {
	return &TrustCenterDocCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterDocClient) MapCreateBulk(slice any, setFunc func(*TrustCenterDocCreate, int)) *TrustCenterDocCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterDocCreateBulk{err: fmt.Errorf("calling to TrustCenterDocClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterDocCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterDocCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterDoc.
func (c *TrustCenterDocClient) Update() *TrustCenterDocUpdate {
	mutation := newTrustCenterDocMutation(c.config, OpUpdate)
	return &TrustCenterDocUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterDocClient) UpdateOne(_m *TrustCenterDoc) *TrustCenterDocUpdateOne {
	mutation := newTrustCenterDocMutation(c.config, OpUpdateOne, withTrustCenterDoc(_m))
	return &TrustCenterDocUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterDocClient) UpdateOneID(id string) *TrustCenterDocUpdateOne {
	mutation := newTrustCenterDocMutation(c.config, OpUpdateOne, withTrustCenterDocID(id))
	return &TrustCenterDocUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterDoc.
func (c *TrustCenterDocClient) Delete() *TrustCenterDocDelete {
	mutation := newTrustCenterDocMutation(c.config, OpDelete)
	return &TrustCenterDocDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterDocClient) DeleteOne(_m *TrustCenterDoc) *TrustCenterDocDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterDocClient) DeleteOneID(id string) *TrustCenterDocDeleteOne {
	builder := c.Delete().Where(trustcenterdoc.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterDocDeleteOne{builder}
}

// Query returns a query builder for TrustCenterDoc.
func (c *TrustCenterDocClient) Query() *TrustCenterDocQuery {
	return &TrustCenterDocQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterDoc},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterDoc entity by its id.
func (c *TrustCenterDocClient) Get(ctx context.Context, id string) (*TrustCenterDoc, error) {
	return c.Query().Where(trustcenterdoc.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterDocClient) GetX(ctx context.Context, id string) *TrustCenterDoc {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTrustCenter queries the trust_center edge of a TrustCenterDoc.
func (c *TrustCenterDocClient) QueryTrustCenter(_m *TrustCenterDoc) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenterdoc.Table, trustcenterdoc.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcenterdoc.TrustCenterTable, trustcenterdoc.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.TrustCenterDoc
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a TrustCenterDoc.
func (c *TrustCenterDocClient) QueryFile(_m *TrustCenterDoc) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenterdoc.Table, trustcenterdoc.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcenterdoc.FileTable, trustcenterdoc.FileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TrustCenterDoc
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOriginalFile queries the original_file edge of a TrustCenterDoc.
func (c *TrustCenterDocClient) QueryOriginalFile(_m *TrustCenterDoc) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenterdoc.Table, trustcenterdoc.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcenterdoc.OriginalFileTable, trustcenterdoc.OriginalFileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TrustCenterDoc
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustCenterDocClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterDoc
	return append(hooks[:len(hooks):len(hooks)], trustcenterdoc.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterDocClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterDoc
	return append(inters[:len(inters):len(inters)], trustcenterdoc.Interceptors[:]...)
}

func (c *TrustCenterDocClient) mutate(ctx context.Context, m *TrustCenterDocMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterDocCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterDocUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterDocUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterDocDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterDoc mutation op: %q", m.Op())
	}
}

// TrustCenterDocHistoryClient is a client for the TrustCenterDocHistory schema.
type TrustCenterDocHistoryClient struct {
	config
}

// NewTrustCenterDocHistoryClient returns a client for the TrustCenterDocHistory from the given config.
func NewTrustCenterDocHistoryClient(c config) *TrustCenterDocHistoryClient {
	return &TrustCenterDocHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcenterdochistory.Hooks(f(g(h())))`.
func (c *TrustCenterDocHistoryClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterDocHistory = append(c.hooks.TrustCenterDocHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcenterdochistory.Intercept(f(g(h())))`.
func (c *TrustCenterDocHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterDocHistory = append(c.inters.TrustCenterDocHistory, interceptors...)
}

// Create returns a builder for creating a TrustCenterDocHistory entity.
func (c *TrustCenterDocHistoryClient) Create() *TrustCenterDocHistoryCreate {
	mutation := newTrustCenterDocHistoryMutation(c.config, OpCreate)
	return &TrustCenterDocHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterDocHistory entities.
func (c *TrustCenterDocHistoryClient) CreateBulk(builders ...*TrustCenterDocHistoryCreate) *TrustCenterDocHistoryCreateBulk {
	return &TrustCenterDocHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterDocHistoryClient) MapCreateBulk(slice any, setFunc func(*TrustCenterDocHistoryCreate, int)) *TrustCenterDocHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterDocHistoryCreateBulk{err: fmt.Errorf("calling to TrustCenterDocHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterDocHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterDocHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterDocHistory.
func (c *TrustCenterDocHistoryClient) Update() *TrustCenterDocHistoryUpdate {
	mutation := newTrustCenterDocHistoryMutation(c.config, OpUpdate)
	return &TrustCenterDocHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterDocHistoryClient) UpdateOne(_m *TrustCenterDocHistory) *TrustCenterDocHistoryUpdateOne {
	mutation := newTrustCenterDocHistoryMutation(c.config, OpUpdateOne, withTrustCenterDocHistory(_m))
	return &TrustCenterDocHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterDocHistoryClient) UpdateOneID(id string) *TrustCenterDocHistoryUpdateOne {
	mutation := newTrustCenterDocHistoryMutation(c.config, OpUpdateOne, withTrustCenterDocHistoryID(id))
	return &TrustCenterDocHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterDocHistory.
func (c *TrustCenterDocHistoryClient) Delete() *TrustCenterDocHistoryDelete {
	mutation := newTrustCenterDocHistoryMutation(c.config, OpDelete)
	return &TrustCenterDocHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterDocHistoryClient) DeleteOne(_m *TrustCenterDocHistory) *TrustCenterDocHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterDocHistoryClient) DeleteOneID(id string) *TrustCenterDocHistoryDeleteOne {
	builder := c.Delete().Where(trustcenterdochistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterDocHistoryDeleteOne{builder}
}

// Query returns a query builder for TrustCenterDocHistory.
func (c *TrustCenterDocHistoryClient) Query() *TrustCenterDocHistoryQuery {
	return &TrustCenterDocHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterDocHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterDocHistory entity by its id.
func (c *TrustCenterDocHistoryClient) Get(ctx context.Context, id string) (*TrustCenterDocHistory, error) {
	return c.Query().Where(trustcenterdochistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterDocHistoryClient) GetX(ctx context.Context, id string) *TrustCenterDocHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrustCenterDocHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterDocHistory
	return append(hooks[:len(hooks):len(hooks)], trustcenterdochistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterDocHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterDocHistory
	return append(inters[:len(inters):len(inters)], trustcenterdochistory.Interceptors[:]...)
}

func (c *TrustCenterDocHistoryClient) mutate(ctx context.Context, m *TrustCenterDocHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterDocHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterDocHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterDocHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterDocHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterDocHistory mutation op: %q", m.Op())
	}
}

// TrustCenterHistoryClient is a client for the TrustCenterHistory schema.
type TrustCenterHistoryClient struct {
	config
}

// NewTrustCenterHistoryClient returns a client for the TrustCenterHistory from the given config.
func NewTrustCenterHistoryClient(c config) *TrustCenterHistoryClient {
	return &TrustCenterHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcenterhistory.Hooks(f(g(h())))`.
func (c *TrustCenterHistoryClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterHistory = append(c.hooks.TrustCenterHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcenterhistory.Intercept(f(g(h())))`.
func (c *TrustCenterHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterHistory = append(c.inters.TrustCenterHistory, interceptors...)
}

// Create returns a builder for creating a TrustCenterHistory entity.
func (c *TrustCenterHistoryClient) Create() *TrustCenterHistoryCreate {
	mutation := newTrustCenterHistoryMutation(c.config, OpCreate)
	return &TrustCenterHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterHistory entities.
func (c *TrustCenterHistoryClient) CreateBulk(builders ...*TrustCenterHistoryCreate) *TrustCenterHistoryCreateBulk {
	return &TrustCenterHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterHistoryClient) MapCreateBulk(slice any, setFunc func(*TrustCenterHistoryCreate, int)) *TrustCenterHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterHistoryCreateBulk{err: fmt.Errorf("calling to TrustCenterHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterHistory.
func (c *TrustCenterHistoryClient) Update() *TrustCenterHistoryUpdate {
	mutation := newTrustCenterHistoryMutation(c.config, OpUpdate)
	return &TrustCenterHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterHistoryClient) UpdateOne(_m *TrustCenterHistory) *TrustCenterHistoryUpdateOne {
	mutation := newTrustCenterHistoryMutation(c.config, OpUpdateOne, withTrustCenterHistory(_m))
	return &TrustCenterHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterHistoryClient) UpdateOneID(id string) *TrustCenterHistoryUpdateOne {
	mutation := newTrustCenterHistoryMutation(c.config, OpUpdateOne, withTrustCenterHistoryID(id))
	return &TrustCenterHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterHistory.
func (c *TrustCenterHistoryClient) Delete() *TrustCenterHistoryDelete {
	mutation := newTrustCenterHistoryMutation(c.config, OpDelete)
	return &TrustCenterHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterHistoryClient) DeleteOne(_m *TrustCenterHistory) *TrustCenterHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterHistoryClient) DeleteOneID(id string) *TrustCenterHistoryDeleteOne {
	builder := c.Delete().Where(trustcenterhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterHistoryDeleteOne{builder}
}

// Query returns a query builder for TrustCenterHistory.
func (c *TrustCenterHistoryClient) Query() *TrustCenterHistoryQuery {
	return &TrustCenterHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterHistory entity by its id.
func (c *TrustCenterHistoryClient) Get(ctx context.Context, id string) (*TrustCenterHistory, error) {
	return c.Query().Where(trustcenterhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterHistoryClient) GetX(ctx context.Context, id string) *TrustCenterHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrustCenterHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterHistory
	return append(hooks[:len(hooks):len(hooks)], trustcenterhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterHistory
	return append(inters[:len(inters):len(inters)], trustcenterhistory.Interceptors[:]...)
}

func (c *TrustCenterHistoryClient) mutate(ctx context.Context, m *TrustCenterHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterHistory mutation op: %q", m.Op())
	}
}

// TrustCenterSettingClient is a client for the TrustCenterSetting schema.
type TrustCenterSettingClient struct {
	config
}

// NewTrustCenterSettingClient returns a client for the TrustCenterSetting from the given config.
func NewTrustCenterSettingClient(c config) *TrustCenterSettingClient {
	return &TrustCenterSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcentersetting.Hooks(f(g(h())))`.
func (c *TrustCenterSettingClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterSetting = append(c.hooks.TrustCenterSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcentersetting.Intercept(f(g(h())))`.
func (c *TrustCenterSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterSetting = append(c.inters.TrustCenterSetting, interceptors...)
}

// Create returns a builder for creating a TrustCenterSetting entity.
func (c *TrustCenterSettingClient) Create() *TrustCenterSettingCreate {
	mutation := newTrustCenterSettingMutation(c.config, OpCreate)
	return &TrustCenterSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterSetting entities.
func (c *TrustCenterSettingClient) CreateBulk(builders ...*TrustCenterSettingCreate) *TrustCenterSettingCreateBulk {
	return &TrustCenterSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterSettingClient) MapCreateBulk(slice any, setFunc func(*TrustCenterSettingCreate, int)) *TrustCenterSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterSettingCreateBulk{err: fmt.Errorf("calling to TrustCenterSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterSetting.
func (c *TrustCenterSettingClient) Update() *TrustCenterSettingUpdate {
	mutation := newTrustCenterSettingMutation(c.config, OpUpdate)
	return &TrustCenterSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterSettingClient) UpdateOne(_m *TrustCenterSetting) *TrustCenterSettingUpdateOne {
	mutation := newTrustCenterSettingMutation(c.config, OpUpdateOne, withTrustCenterSetting(_m))
	return &TrustCenterSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterSettingClient) UpdateOneID(id string) *TrustCenterSettingUpdateOne {
	mutation := newTrustCenterSettingMutation(c.config, OpUpdateOne, withTrustCenterSettingID(id))
	return &TrustCenterSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterSetting.
func (c *TrustCenterSettingClient) Delete() *TrustCenterSettingDelete {
	mutation := newTrustCenterSettingMutation(c.config, OpDelete)
	return &TrustCenterSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterSettingClient) DeleteOne(_m *TrustCenterSetting) *TrustCenterSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterSettingClient) DeleteOneID(id string) *TrustCenterSettingDeleteOne {
	builder := c.Delete().Where(trustcentersetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterSettingDeleteOne{builder}
}

// Query returns a query builder for TrustCenterSetting.
func (c *TrustCenterSettingClient) Query() *TrustCenterSettingQuery {
	return &TrustCenterSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterSetting entity by its id.
func (c *TrustCenterSettingClient) Get(ctx context.Context, id string) (*TrustCenterSetting, error) {
	return c.Query().Where(trustcentersetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterSettingClient) GetX(ctx context.Context, id string) *TrustCenterSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTrustCenter queries the trust_center edge of a TrustCenterSetting.
func (c *TrustCenterSettingClient) QueryTrustCenter(_m *TrustCenterSetting) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentersetting.Table, trustcentersetting.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, trustcentersetting.TrustCenterTable, trustcentersetting.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.TrustCenterSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a TrustCenterSetting.
func (c *TrustCenterSettingClient) QueryFiles(_m *TrustCenterSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentersetting.Table, trustcentersetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, trustcentersetting.FilesTable, trustcentersetting.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TrustCenterSettingFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogoFile queries the logo_file edge of a TrustCenterSetting.
func (c *TrustCenterSettingClient) QueryLogoFile(_m *TrustCenterSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentersetting.Table, trustcentersetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcentersetting.LogoFileTable, trustcentersetting.LogoFileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TrustCenterSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaviconFile queries the favicon_file edge of a TrustCenterSetting.
func (c *TrustCenterSettingClient) QueryFaviconFile(_m *TrustCenterSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentersetting.Table, trustcentersetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcentersetting.FaviconFileTable, trustcentersetting.FaviconFileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TrustCenterSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustCenterSettingClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterSetting
	return append(hooks[:len(hooks):len(hooks)], trustcentersetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterSettingClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterSetting
	return append(inters[:len(inters):len(inters)], trustcentersetting.Interceptors[:]...)
}

func (c *TrustCenterSettingClient) mutate(ctx context.Context, m *TrustCenterSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterSetting mutation op: %q", m.Op())
	}
}

// TrustCenterSettingHistoryClient is a client for the TrustCenterSettingHistory schema.
type TrustCenterSettingHistoryClient struct {
	config
}

// NewTrustCenterSettingHistoryClient returns a client for the TrustCenterSettingHistory from the given config.
func NewTrustCenterSettingHistoryClient(c config) *TrustCenterSettingHistoryClient {
	return &TrustCenterSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcentersettinghistory.Hooks(f(g(h())))`.
func (c *TrustCenterSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterSettingHistory = append(c.hooks.TrustCenterSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcentersettinghistory.Intercept(f(g(h())))`.
func (c *TrustCenterSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterSettingHistory = append(c.inters.TrustCenterSettingHistory, interceptors...)
}

// Create returns a builder for creating a TrustCenterSettingHistory entity.
func (c *TrustCenterSettingHistoryClient) Create() *TrustCenterSettingHistoryCreate {
	mutation := newTrustCenterSettingHistoryMutation(c.config, OpCreate)
	return &TrustCenterSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterSettingHistory entities.
func (c *TrustCenterSettingHistoryClient) CreateBulk(builders ...*TrustCenterSettingHistoryCreate) *TrustCenterSettingHistoryCreateBulk {
	return &TrustCenterSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*TrustCenterSettingHistoryCreate, int)) *TrustCenterSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterSettingHistoryCreateBulk{err: fmt.Errorf("calling to TrustCenterSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterSettingHistory.
func (c *TrustCenterSettingHistoryClient) Update() *TrustCenterSettingHistoryUpdate {
	mutation := newTrustCenterSettingHistoryMutation(c.config, OpUpdate)
	return &TrustCenterSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterSettingHistoryClient) UpdateOne(_m *TrustCenterSettingHistory) *TrustCenterSettingHistoryUpdateOne {
	mutation := newTrustCenterSettingHistoryMutation(c.config, OpUpdateOne, withTrustCenterSettingHistory(_m))
	return &TrustCenterSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterSettingHistoryClient) UpdateOneID(id string) *TrustCenterSettingHistoryUpdateOne {
	mutation := newTrustCenterSettingHistoryMutation(c.config, OpUpdateOne, withTrustCenterSettingHistoryID(id))
	return &TrustCenterSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterSettingHistory.
func (c *TrustCenterSettingHistoryClient) Delete() *TrustCenterSettingHistoryDelete {
	mutation := newTrustCenterSettingHistoryMutation(c.config, OpDelete)
	return &TrustCenterSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterSettingHistoryClient) DeleteOne(_m *TrustCenterSettingHistory) *TrustCenterSettingHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterSettingHistoryClient) DeleteOneID(id string) *TrustCenterSettingHistoryDeleteOne {
	builder := c.Delete().Where(trustcentersettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for TrustCenterSettingHistory.
func (c *TrustCenterSettingHistoryClient) Query() *TrustCenterSettingHistoryQuery {
	return &TrustCenterSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterSettingHistory entity by its id.
func (c *TrustCenterSettingHistoryClient) Get(ctx context.Context, id string) (*TrustCenterSettingHistory, error) {
	return c.Query().Where(trustcentersettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterSettingHistoryClient) GetX(ctx context.Context, id string) *TrustCenterSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrustCenterSettingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterSettingHistory
	return append(hooks[:len(hooks):len(hooks)], trustcentersettinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterSettingHistory
	return append(inters[:len(inters):len(inters)], trustcentersettinghistory.Interceptors[:]...)
}

func (c *TrustCenterSettingHistoryClient) mutate(ctx context.Context, m *TrustCenterSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterSettingHistory mutation op: %q", m.Op())
	}
}

// TrustCenterSubprocessorClient is a client for the TrustCenterSubprocessor schema.
type TrustCenterSubprocessorClient struct {
	config
}

// NewTrustCenterSubprocessorClient returns a client for the TrustCenterSubprocessor from the given config.
func NewTrustCenterSubprocessorClient(c config) *TrustCenterSubprocessorClient {
	return &TrustCenterSubprocessorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcentersubprocessor.Hooks(f(g(h())))`.
func (c *TrustCenterSubprocessorClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterSubprocessor = append(c.hooks.TrustCenterSubprocessor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcentersubprocessor.Intercept(f(g(h())))`.
func (c *TrustCenterSubprocessorClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterSubprocessor = append(c.inters.TrustCenterSubprocessor, interceptors...)
}

// Create returns a builder for creating a TrustCenterSubprocessor entity.
func (c *TrustCenterSubprocessorClient) Create() *TrustCenterSubprocessorCreate {
	mutation := newTrustCenterSubprocessorMutation(c.config, OpCreate)
	return &TrustCenterSubprocessorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterSubprocessor entities.
func (c *TrustCenterSubprocessorClient) CreateBulk(builders ...*TrustCenterSubprocessorCreate) *TrustCenterSubprocessorCreateBulk {
	return &TrustCenterSubprocessorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterSubprocessorClient) MapCreateBulk(slice any, setFunc func(*TrustCenterSubprocessorCreate, int)) *TrustCenterSubprocessorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterSubprocessorCreateBulk{err: fmt.Errorf("calling to TrustCenterSubprocessorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterSubprocessorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterSubprocessorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterSubprocessor.
func (c *TrustCenterSubprocessorClient) Update() *TrustCenterSubprocessorUpdate {
	mutation := newTrustCenterSubprocessorMutation(c.config, OpUpdate)
	return &TrustCenterSubprocessorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterSubprocessorClient) UpdateOne(_m *TrustCenterSubprocessor) *TrustCenterSubprocessorUpdateOne {
	mutation := newTrustCenterSubprocessorMutation(c.config, OpUpdateOne, withTrustCenterSubprocessor(_m))
	return &TrustCenterSubprocessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterSubprocessorClient) UpdateOneID(id string) *TrustCenterSubprocessorUpdateOne {
	mutation := newTrustCenterSubprocessorMutation(c.config, OpUpdateOne, withTrustCenterSubprocessorID(id))
	return &TrustCenterSubprocessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterSubprocessor.
func (c *TrustCenterSubprocessorClient) Delete() *TrustCenterSubprocessorDelete {
	mutation := newTrustCenterSubprocessorMutation(c.config, OpDelete)
	return &TrustCenterSubprocessorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterSubprocessorClient) DeleteOne(_m *TrustCenterSubprocessor) *TrustCenterSubprocessorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterSubprocessorClient) DeleteOneID(id string) *TrustCenterSubprocessorDeleteOne {
	builder := c.Delete().Where(trustcentersubprocessor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterSubprocessorDeleteOne{builder}
}

// Query returns a query builder for TrustCenterSubprocessor.
func (c *TrustCenterSubprocessorClient) Query() *TrustCenterSubprocessorQuery {
	return &TrustCenterSubprocessorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterSubprocessor},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterSubprocessor entity by its id.
func (c *TrustCenterSubprocessorClient) Get(ctx context.Context, id string) (*TrustCenterSubprocessor, error) {
	return c.Query().Where(trustcentersubprocessor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterSubprocessorClient) GetX(ctx context.Context, id string) *TrustCenterSubprocessor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTrustCenter queries the trust_center edge of a TrustCenterSubprocessor.
func (c *TrustCenterSubprocessorClient) QueryTrustCenter(_m *TrustCenterSubprocessor) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentersubprocessor.Table, trustcentersubprocessor.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcentersubprocessor.TrustCenterTable, trustcentersubprocessor.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.TrustCenterSubprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubprocessor queries the subprocessor edge of a TrustCenterSubprocessor.
func (c *TrustCenterSubprocessorClient) QuerySubprocessor(_m *TrustCenterSubprocessor) *SubprocessorQuery {
	query := (&SubprocessorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcentersubprocessor.Table, trustcentersubprocessor.FieldID, id),
			sqlgraph.To(subprocessor.Table, subprocessor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcentersubprocessor.SubprocessorTable, trustcentersubprocessor.SubprocessorColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subprocessor
		step.Edge.Schema = schemaConfig.TrustCenterSubprocessor
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustCenterSubprocessorClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterSubprocessor
	return append(hooks[:len(hooks):len(hooks)], trustcentersubprocessor.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterSubprocessorClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterSubprocessor
	return append(inters[:len(inters):len(inters)], trustcentersubprocessor.Interceptors[:]...)
}

func (c *TrustCenterSubprocessorClient) mutate(ctx context.Context, m *TrustCenterSubprocessorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterSubprocessorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterSubprocessorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterSubprocessorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterSubprocessorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterSubprocessor mutation op: %q", m.Op())
	}
}

// TrustCenterSubprocessorHistoryClient is a client for the TrustCenterSubprocessorHistory schema.
type TrustCenterSubprocessorHistoryClient struct {
	config
}

// NewTrustCenterSubprocessorHistoryClient returns a client for the TrustCenterSubprocessorHistory from the given config.
func NewTrustCenterSubprocessorHistoryClient(c config) *TrustCenterSubprocessorHistoryClient {
	return &TrustCenterSubprocessorHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcentersubprocessorhistory.Hooks(f(g(h())))`.
func (c *TrustCenterSubprocessorHistoryClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterSubprocessorHistory = append(c.hooks.TrustCenterSubprocessorHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcentersubprocessorhistory.Intercept(f(g(h())))`.
func (c *TrustCenterSubprocessorHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterSubprocessorHistory = append(c.inters.TrustCenterSubprocessorHistory, interceptors...)
}

// Create returns a builder for creating a TrustCenterSubprocessorHistory entity.
func (c *TrustCenterSubprocessorHistoryClient) Create() *TrustCenterSubprocessorHistoryCreate {
	mutation := newTrustCenterSubprocessorHistoryMutation(c.config, OpCreate)
	return &TrustCenterSubprocessorHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterSubprocessorHistory entities.
func (c *TrustCenterSubprocessorHistoryClient) CreateBulk(builders ...*TrustCenterSubprocessorHistoryCreate) *TrustCenterSubprocessorHistoryCreateBulk {
	return &TrustCenterSubprocessorHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterSubprocessorHistoryClient) MapCreateBulk(slice any, setFunc func(*TrustCenterSubprocessorHistoryCreate, int)) *TrustCenterSubprocessorHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterSubprocessorHistoryCreateBulk{err: fmt.Errorf("calling to TrustCenterSubprocessorHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterSubprocessorHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterSubprocessorHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterSubprocessorHistory.
func (c *TrustCenterSubprocessorHistoryClient) Update() *TrustCenterSubprocessorHistoryUpdate {
	mutation := newTrustCenterSubprocessorHistoryMutation(c.config, OpUpdate)
	return &TrustCenterSubprocessorHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterSubprocessorHistoryClient) UpdateOne(_m *TrustCenterSubprocessorHistory) *TrustCenterSubprocessorHistoryUpdateOne {
	mutation := newTrustCenterSubprocessorHistoryMutation(c.config, OpUpdateOne, withTrustCenterSubprocessorHistory(_m))
	return &TrustCenterSubprocessorHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterSubprocessorHistoryClient) UpdateOneID(id string) *TrustCenterSubprocessorHistoryUpdateOne {
	mutation := newTrustCenterSubprocessorHistoryMutation(c.config, OpUpdateOne, withTrustCenterSubprocessorHistoryID(id))
	return &TrustCenterSubprocessorHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterSubprocessorHistory.
func (c *TrustCenterSubprocessorHistoryClient) Delete() *TrustCenterSubprocessorHistoryDelete {
	mutation := newTrustCenterSubprocessorHistoryMutation(c.config, OpDelete)
	return &TrustCenterSubprocessorHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterSubprocessorHistoryClient) DeleteOne(_m *TrustCenterSubprocessorHistory) *TrustCenterSubprocessorHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterSubprocessorHistoryClient) DeleteOneID(id string) *TrustCenterSubprocessorHistoryDeleteOne {
	builder := c.Delete().Where(trustcentersubprocessorhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterSubprocessorHistoryDeleteOne{builder}
}

// Query returns a query builder for TrustCenterSubprocessorHistory.
func (c *TrustCenterSubprocessorHistoryClient) Query() *TrustCenterSubprocessorHistoryQuery {
	return &TrustCenterSubprocessorHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterSubprocessorHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterSubprocessorHistory entity by its id.
func (c *TrustCenterSubprocessorHistoryClient) Get(ctx context.Context, id string) (*TrustCenterSubprocessorHistory, error) {
	return c.Query().Where(trustcentersubprocessorhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterSubprocessorHistoryClient) GetX(ctx context.Context, id string) *TrustCenterSubprocessorHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrustCenterSubprocessorHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterSubprocessorHistory
	return append(hooks[:len(hooks):len(hooks)], trustcentersubprocessorhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterSubprocessorHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterSubprocessorHistory
	return append(inters[:len(inters):len(inters)], trustcentersubprocessorhistory.Interceptors[:]...)
}

func (c *TrustCenterSubprocessorHistoryClient) mutate(ctx context.Context, m *TrustCenterSubprocessorHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterSubprocessorHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterSubprocessorHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterSubprocessorHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterSubprocessorHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterSubprocessorHistory mutation op: %q", m.Op())
	}
}

// TrustCenterWatermarkConfigClient is a client for the TrustCenterWatermarkConfig schema.
type TrustCenterWatermarkConfigClient struct {
	config
}

// NewTrustCenterWatermarkConfigClient returns a client for the TrustCenterWatermarkConfig from the given config.
func NewTrustCenterWatermarkConfigClient(c config) *TrustCenterWatermarkConfigClient {
	return &TrustCenterWatermarkConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcenterwatermarkconfig.Hooks(f(g(h())))`.
func (c *TrustCenterWatermarkConfigClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterWatermarkConfig = append(c.hooks.TrustCenterWatermarkConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcenterwatermarkconfig.Intercept(f(g(h())))`.
func (c *TrustCenterWatermarkConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterWatermarkConfig = append(c.inters.TrustCenterWatermarkConfig, interceptors...)
}

// Create returns a builder for creating a TrustCenterWatermarkConfig entity.
func (c *TrustCenterWatermarkConfigClient) Create() *TrustCenterWatermarkConfigCreate {
	mutation := newTrustCenterWatermarkConfigMutation(c.config, OpCreate)
	return &TrustCenterWatermarkConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterWatermarkConfig entities.
func (c *TrustCenterWatermarkConfigClient) CreateBulk(builders ...*TrustCenterWatermarkConfigCreate) *TrustCenterWatermarkConfigCreateBulk {
	return &TrustCenterWatermarkConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterWatermarkConfigClient) MapCreateBulk(slice any, setFunc func(*TrustCenterWatermarkConfigCreate, int)) *TrustCenterWatermarkConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterWatermarkConfigCreateBulk{err: fmt.Errorf("calling to TrustCenterWatermarkConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterWatermarkConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterWatermarkConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterWatermarkConfig.
func (c *TrustCenterWatermarkConfigClient) Update() *TrustCenterWatermarkConfigUpdate {
	mutation := newTrustCenterWatermarkConfigMutation(c.config, OpUpdate)
	return &TrustCenterWatermarkConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterWatermarkConfigClient) UpdateOne(_m *TrustCenterWatermarkConfig) *TrustCenterWatermarkConfigUpdateOne {
	mutation := newTrustCenterWatermarkConfigMutation(c.config, OpUpdateOne, withTrustCenterWatermarkConfig(_m))
	return &TrustCenterWatermarkConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterWatermarkConfigClient) UpdateOneID(id string) *TrustCenterWatermarkConfigUpdateOne {
	mutation := newTrustCenterWatermarkConfigMutation(c.config, OpUpdateOne, withTrustCenterWatermarkConfigID(id))
	return &TrustCenterWatermarkConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterWatermarkConfig.
func (c *TrustCenterWatermarkConfigClient) Delete() *TrustCenterWatermarkConfigDelete {
	mutation := newTrustCenterWatermarkConfigMutation(c.config, OpDelete)
	return &TrustCenterWatermarkConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterWatermarkConfigClient) DeleteOne(_m *TrustCenterWatermarkConfig) *TrustCenterWatermarkConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterWatermarkConfigClient) DeleteOneID(id string) *TrustCenterWatermarkConfigDeleteOne {
	builder := c.Delete().Where(trustcenterwatermarkconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterWatermarkConfigDeleteOne{builder}
}

// Query returns a query builder for TrustCenterWatermarkConfig.
func (c *TrustCenterWatermarkConfigClient) Query() *TrustCenterWatermarkConfigQuery {
	return &TrustCenterWatermarkConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterWatermarkConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterWatermarkConfig entity by its id.
func (c *TrustCenterWatermarkConfigClient) Get(ctx context.Context, id string) (*TrustCenterWatermarkConfig, error) {
	return c.Query().Where(trustcenterwatermarkconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterWatermarkConfigClient) GetX(ctx context.Context, id string) *TrustCenterWatermarkConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a TrustCenterWatermarkConfig.
func (c *TrustCenterWatermarkConfigClient) QueryOwner(_m *TrustCenterWatermarkConfig) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenterwatermarkconfig.Table, trustcenterwatermarkconfig.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trustcenterwatermarkconfig.OwnerTable, trustcenterwatermarkconfig.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.TrustCenterWatermarkConfig
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustCenter queries the trust_center edge of a TrustCenterWatermarkConfig.
func (c *TrustCenterWatermarkConfigClient) QueryTrustCenter(_m *TrustCenterWatermarkConfig) *TrustCenterQuery {
	query := (&TrustCenterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenterwatermarkconfig.Table, trustcenterwatermarkconfig.FieldID, id),
			sqlgraph.To(trustcenter.Table, trustcenter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, trustcenterwatermarkconfig.TrustCenterTable, trustcenterwatermarkconfig.TrustCenterColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TrustCenter
		step.Edge.Schema = schemaConfig.TrustCenter
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a TrustCenterWatermarkConfig.
func (c *TrustCenterWatermarkConfigClient) QueryFile(_m *TrustCenterWatermarkConfig) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trustcenterwatermarkconfig.Table, trustcenterwatermarkconfig.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, trustcenterwatermarkconfig.FileTable, trustcenterwatermarkconfig.FileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TrustCenterWatermarkConfig
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustCenterWatermarkConfigClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterWatermarkConfig
	return append(hooks[:len(hooks):len(hooks)], trustcenterwatermarkconfig.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterWatermarkConfigClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterWatermarkConfig
	return append(inters[:len(inters):len(inters)], trustcenterwatermarkconfig.Interceptors[:]...)
}

func (c *TrustCenterWatermarkConfigClient) mutate(ctx context.Context, m *TrustCenterWatermarkConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterWatermarkConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterWatermarkConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterWatermarkConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterWatermarkConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterWatermarkConfig mutation op: %q", m.Op())
	}
}

// TrustCenterWatermarkConfigHistoryClient is a client for the TrustCenterWatermarkConfigHistory schema.
type TrustCenterWatermarkConfigHistoryClient struct {
	config
}

// NewTrustCenterWatermarkConfigHistoryClient returns a client for the TrustCenterWatermarkConfigHistory from the given config.
func NewTrustCenterWatermarkConfigHistoryClient(c config) *TrustCenterWatermarkConfigHistoryClient {
	return &TrustCenterWatermarkConfigHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trustcenterwatermarkconfighistory.Hooks(f(g(h())))`.
func (c *TrustCenterWatermarkConfigHistoryClient) Use(hooks ...Hook) {
	c.hooks.TrustCenterWatermarkConfigHistory = append(c.hooks.TrustCenterWatermarkConfigHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trustcenterwatermarkconfighistory.Intercept(f(g(h())))`.
func (c *TrustCenterWatermarkConfigHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustCenterWatermarkConfigHistory = append(c.inters.TrustCenterWatermarkConfigHistory, interceptors...)
}

// Create returns a builder for creating a TrustCenterWatermarkConfigHistory entity.
func (c *TrustCenterWatermarkConfigHistoryClient) Create() *TrustCenterWatermarkConfigHistoryCreate {
	mutation := newTrustCenterWatermarkConfigHistoryMutation(c.config, OpCreate)
	return &TrustCenterWatermarkConfigHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustCenterWatermarkConfigHistory entities.
func (c *TrustCenterWatermarkConfigHistoryClient) CreateBulk(builders ...*TrustCenterWatermarkConfigHistoryCreate) *TrustCenterWatermarkConfigHistoryCreateBulk {
	return &TrustCenterWatermarkConfigHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustCenterWatermarkConfigHistoryClient) MapCreateBulk(slice any, setFunc func(*TrustCenterWatermarkConfigHistoryCreate, int)) *TrustCenterWatermarkConfigHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustCenterWatermarkConfigHistoryCreateBulk{err: fmt.Errorf("calling to TrustCenterWatermarkConfigHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustCenterWatermarkConfigHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustCenterWatermarkConfigHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustCenterWatermarkConfigHistory.
func (c *TrustCenterWatermarkConfigHistoryClient) Update() *TrustCenterWatermarkConfigHistoryUpdate {
	mutation := newTrustCenterWatermarkConfigHistoryMutation(c.config, OpUpdate)
	return &TrustCenterWatermarkConfigHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustCenterWatermarkConfigHistoryClient) UpdateOne(_m *TrustCenterWatermarkConfigHistory) *TrustCenterWatermarkConfigHistoryUpdateOne {
	mutation := newTrustCenterWatermarkConfigHistoryMutation(c.config, OpUpdateOne, withTrustCenterWatermarkConfigHistory(_m))
	return &TrustCenterWatermarkConfigHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustCenterWatermarkConfigHistoryClient) UpdateOneID(id string) *TrustCenterWatermarkConfigHistoryUpdateOne {
	mutation := newTrustCenterWatermarkConfigHistoryMutation(c.config, OpUpdateOne, withTrustCenterWatermarkConfigHistoryID(id))
	return &TrustCenterWatermarkConfigHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustCenterWatermarkConfigHistory.
func (c *TrustCenterWatermarkConfigHistoryClient) Delete() *TrustCenterWatermarkConfigHistoryDelete {
	mutation := newTrustCenterWatermarkConfigHistoryMutation(c.config, OpDelete)
	return &TrustCenterWatermarkConfigHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustCenterWatermarkConfigHistoryClient) DeleteOne(_m *TrustCenterWatermarkConfigHistory) *TrustCenterWatermarkConfigHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustCenterWatermarkConfigHistoryClient) DeleteOneID(id string) *TrustCenterWatermarkConfigHistoryDeleteOne {
	builder := c.Delete().Where(trustcenterwatermarkconfighistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustCenterWatermarkConfigHistoryDeleteOne{builder}
}

// Query returns a query builder for TrustCenterWatermarkConfigHistory.
func (c *TrustCenterWatermarkConfigHistoryClient) Query() *TrustCenterWatermarkConfigHistoryQuery {
	return &TrustCenterWatermarkConfigHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustCenterWatermarkConfigHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustCenterWatermarkConfigHistory entity by its id.
func (c *TrustCenterWatermarkConfigHistoryClient) Get(ctx context.Context, id string) (*TrustCenterWatermarkConfigHistory, error) {
	return c.Query().Where(trustcenterwatermarkconfighistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustCenterWatermarkConfigHistoryClient) GetX(ctx context.Context, id string) *TrustCenterWatermarkConfigHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TrustCenterWatermarkConfigHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TrustCenterWatermarkConfigHistory
	return append(hooks[:len(hooks):len(hooks)], trustcenterwatermarkconfighistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TrustCenterWatermarkConfigHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TrustCenterWatermarkConfigHistory
	return append(inters[:len(inters):len(inters)], trustcenterwatermarkconfighistory.Interceptors[:]...)
}

func (c *TrustCenterWatermarkConfigHistoryClient) mutate(ctx context.Context, m *TrustCenterWatermarkConfigHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustCenterWatermarkConfigHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustCenterWatermarkConfigHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustCenterWatermarkConfigHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustCenterWatermarkConfigHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TrustCenterWatermarkConfigHistory mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPersonalAccessTokens queries the personal_access_tokens edge of a User.
func (c *UserClient) QueryPersonalAccessTokens(_m *User) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PersonalAccessTokensTable, user.PersonalAccessTokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PersonalAccessToken
		step.Edge.Schema = schemaConfig.PersonalAccessToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTfaSettings queries the tfa_settings edge of a User.
func (c *UserClient) QueryTfaSettings(_m *User) *TFASettingQuery {
	query := (&TFASettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tfasetting.Table, tfasetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TfaSettingsTable, user.TfaSettingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.TFASetting
		step.Edge.Schema = schemaConfig.TFASetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a User.
func (c *UserClient) QuerySetting(_m *User) *UserSettingQuery {
	query := (&UserSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersetting.Table, usersetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.SettingTable, user.SettingColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.UserSetting
		step.Edge.Schema = schemaConfig.UserSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailVerificationTokens queries the email_verification_tokens edge of a User.
func (c *UserClient) QueryEmailVerificationTokens(_m *User) *EmailVerificationTokenQuery {
	query := (&EmailVerificationTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(emailverificationtoken.Table, emailverificationtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EmailVerificationTokensTable, user.EmailVerificationTokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.EmailVerificationToken
		step.Edge.Schema = schemaConfig.EmailVerificationToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDownloadTokens queries the file_download_tokens edge of a User.
func (c *UserClient) QueryFileDownloadTokens(_m *User) *FileDownloadTokenQuery {
	query := (&FileDownloadTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(filedownloadtoken.Table, filedownloadtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FileDownloadTokensTable, user.FileDownloadTokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.FileDownloadToken
		step.Edge.Schema = schemaConfig.FileDownloadToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPasswordResetTokens queries the password_reset_tokens edge of a User.
func (c *UserClient) QueryPasswordResetTokens(_m *User) *PasswordResetTokenQuery {
	query := (&PasswordResetTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(passwordresettoken.Table, passwordresettoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PasswordResetTokensTable, user.PasswordResetTokensColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.PasswordResetToken
		step.Edge.Schema = schemaConfig.PasswordResetToken
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(_m *User) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a User.
func (c *UserClient) QueryOrganizations(_m *User) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.OrganizationsTable, user.OrganizationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebauthns queries the webauthns edge of a User.
func (c *UserClient) QueryWebauthns(_m *User) *WebauthnQuery {
	query := (&WebauthnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(webauthn.Table, webauthn.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WebauthnsTable, user.WebauthnsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Webauthn
		step.Edge.Schema = schemaConfig.Webauthn
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a User.
func (c *UserClient) QueryFiles(_m *User) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.FilesTable, user.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.UserFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAvatarFile queries the avatar_file edge of a User.
func (c *UserClient) QueryAvatarFile(_m *User) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.AvatarFileTable, user.AvatarFileColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.User
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a User.
func (c *UserClient) QueryEvents(_m *User) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.EventsTable, user.EventsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.UserEvents
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a User.
func (c *UserClient) QueryActionPlans(_m *User) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ActionPlansTable, user.ActionPlansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ActionPlan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a User.
func (c *UserClient) QuerySubcontrols(_m *User) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubcontrolsTable, user.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignerTasks queries the assigner_tasks edge of a User.
func (c *UserClient) QueryAssignerTasks(_m *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignerTasksTable, user.AssignerTasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssigneeTasks queries the assignee_tasks edge of a User.
func (c *UserClient) QueryAssigneeTasks(_m *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssigneeTasksTable, user.AssigneeTasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a User.
func (c *UserClient) QueryPrograms(_m *User) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.ProgramsTable, user.ProgramsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramsOwned queries the programs_owned edge of a User.
func (c *UserClient) QueryProgramsOwned(_m *User) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProgramsOwnedTable, user.ProgramsOwnedColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImpersonationEvents queries the impersonation_events edge of a User.
func (c *UserClient) QueryImpersonationEvents(_m *User) *ImpersonationEventQuery {
	query := (&ImpersonationEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(impersonationevent.Table, impersonationevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ImpersonationEventsTable, user.ImpersonationEventsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ImpersonationEvent
		step.Edge.Schema = schemaConfig.ImpersonationEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetedImpersonations queries the targeted_impersonations edge of a User.
func (c *UserClient) QueryTargetedImpersonations(_m *User) *ImpersonationEventQuery {
	query := (&ImpersonationEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(impersonationevent.Table, impersonationevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TargetedImpersonationsTable, user.TargetedImpersonationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ImpersonationEvent
		step.Edge.Schema = schemaConfig.ImpersonationEvent
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a User.
func (c *UserClient) QueryNotifications(_m *User) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NotificationsTable, user.NotificationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Notification
		step.Edge.Schema = schemaConfig.Notification
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMemberships queries the group_memberships edge of a User.
func (c *UserClient) QueryGroupMemberships(_m *User) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.GroupMembershipsTable, user.GroupMembershipsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.GroupMembership
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgMemberships queries the org_memberships edge of a User.
func (c *UserClient) QueryOrgMemberships(_m *User) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OrgMembershipsTable, user.OrgMembershipsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramMemberships queries the program_memberships edge of a User.
func (c *UserClient) QueryProgramMemberships(_m *User) *ProgramMembershipQuery {
	query := (&ProgramMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(programmembership.Table, programmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ProgramMembershipsTable, user.ProgramMembershipsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ProgramMembership
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown User mutation op: %q", m.Op())
	}
}

// UserHistoryClient is a client for the UserHistory schema.
type UserHistoryClient struct {
	config
}

// NewUserHistoryClient returns a client for the UserHistory from the given config.
func NewUserHistoryClient(c config) *UserHistoryClient {
	return &UserHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userhistory.Hooks(f(g(h())))`.
func (c *UserHistoryClient) Use(hooks ...Hook) {
	c.hooks.UserHistory = append(c.hooks.UserHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userhistory.Intercept(f(g(h())))`.
func (c *UserHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserHistory = append(c.inters.UserHistory, interceptors...)
}

// Create returns a builder for creating a UserHistory entity.
func (c *UserHistoryClient) Create() *UserHistoryCreate {
	mutation := newUserHistoryMutation(c.config, OpCreate)
	return &UserHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserHistory entities.
func (c *UserHistoryClient) CreateBulk(builders ...*UserHistoryCreate) *UserHistoryCreateBulk {
	return &UserHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserHistoryClient) MapCreateBulk(slice any, setFunc func(*UserHistoryCreate, int)) *UserHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserHistoryCreateBulk{err: fmt.Errorf("calling to UserHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserHistory.
func (c *UserHistoryClient) Update() *UserHistoryUpdate {
	mutation := newUserHistoryMutation(c.config, OpUpdate)
	return &UserHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserHistoryClient) UpdateOne(_m *UserHistory) *UserHistoryUpdateOne {
	mutation := newUserHistoryMutation(c.config, OpUpdateOne, withUserHistory(_m))
	return &UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserHistoryClient) UpdateOneID(id string) *UserHistoryUpdateOne {
	mutation := newUserHistoryMutation(c.config, OpUpdateOne, withUserHistoryID(id))
	return &UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserHistory.
func (c *UserHistoryClient) Delete() *UserHistoryDelete {
	mutation := newUserHistoryMutation(c.config, OpDelete)
	return &UserHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserHistoryClient) DeleteOne(_m *UserHistory) *UserHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserHistoryClient) DeleteOneID(id string) *UserHistoryDeleteOne {
	builder := c.Delete().Where(userhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserHistoryDeleteOne{builder}
}

// Query returns a query builder for UserHistory.
func (c *UserHistoryClient) Query() *UserHistoryQuery {
	return &UserHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a UserHistory entity by its id.
func (c *UserHistoryClient) Get(ctx context.Context, id string) (*UserHistory, error) {
	return c.Query().Where(userhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserHistoryClient) GetX(ctx context.Context, id string) *UserHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserHistoryClient) Hooks() []Hook {
	hooks := c.hooks.UserHistory
	return append(hooks[:len(hooks):len(hooks)], userhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.UserHistory
	return append(inters[:len(inters):len(inters)], userhistory.Interceptors[:]...)
}

func (c *UserHistoryClient) mutate(ctx context.Context, m *UserHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserHistory mutation op: %q", m.Op())
	}
}

// UserSettingClient is a client for the UserSetting schema.
type UserSettingClient struct {
	config
}

// NewUserSettingClient returns a client for the UserSetting from the given config.
func NewUserSettingClient(c config) *UserSettingClient {
	return &UserSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersetting.Hooks(f(g(h())))`.
func (c *UserSettingClient) Use(hooks ...Hook) {
	c.hooks.UserSetting = append(c.hooks.UserSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersetting.Intercept(f(g(h())))`.
func (c *UserSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSetting = append(c.inters.UserSetting, interceptors...)
}

// Create returns a builder for creating a UserSetting entity.
func (c *UserSettingClient) Create() *UserSettingCreate {
	mutation := newUserSettingMutation(c.config, OpCreate)
	return &UserSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSetting entities.
func (c *UserSettingClient) CreateBulk(builders ...*UserSettingCreate) *UserSettingCreateBulk {
	return &UserSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSettingClient) MapCreateBulk(slice any, setFunc func(*UserSettingCreate, int)) *UserSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSettingCreateBulk{err: fmt.Errorf("calling to UserSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSetting.
func (c *UserSettingClient) Update() *UserSettingUpdate {
	mutation := newUserSettingMutation(c.config, OpUpdate)
	return &UserSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSettingClient) UpdateOne(_m *UserSetting) *UserSettingUpdateOne {
	mutation := newUserSettingMutation(c.config, OpUpdateOne, withUserSetting(_m))
	return &UserSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSettingClient) UpdateOneID(id string) *UserSettingUpdateOne {
	mutation := newUserSettingMutation(c.config, OpUpdateOne, withUserSettingID(id))
	return &UserSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSetting.
func (c *UserSettingClient) Delete() *UserSettingDelete {
	mutation := newUserSettingMutation(c.config, OpDelete)
	return &UserSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSettingClient) DeleteOne(_m *UserSetting) *UserSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSettingClient) DeleteOneID(id string) *UserSettingDeleteOne {
	builder := c.Delete().Where(usersetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSettingDeleteOne{builder}
}

// Query returns a query builder for UserSetting.
func (c *UserSettingClient) Query() *UserSettingQuery {
	return &UserSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSetting entity by its id.
func (c *UserSettingClient) Get(ctx context.Context, id string) (*UserSetting, error) {
	return c.Query().Where(usersetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSettingClient) GetX(ctx context.Context, id string) *UserSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSetting.
func (c *UserSettingClient) QueryUser(_m *UserSetting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersetting.Table, usersetting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, usersetting.UserTable, usersetting.UserColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDefaultOrg queries the default_org edge of a UserSetting.
func (c *UserSettingClient) QueryDefaultOrg(_m *UserSetting) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersetting.Table, usersetting.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usersetting.DefaultOrgTable, usersetting.DefaultOrgColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.UserSetting
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a UserSetting.
func (c *UserSettingClient) QueryFiles(_m *UserSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersetting.Table, usersetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, usersetting.FilesTable, usersetting.FilesPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.UserSettingFiles
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSettingClient) Hooks() []Hook {
	hooks := c.hooks.UserSetting
	return append(hooks[:len(hooks):len(hooks)], usersetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserSettingClient) Interceptors() []Interceptor {
	inters := c.inters.UserSetting
	return append(inters[:len(inters):len(inters)], usersetting.Interceptors[:]...)
}

func (c *UserSettingClient) mutate(ctx context.Context, m *UserSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserSetting mutation op: %q", m.Op())
	}
}

// UserSettingHistoryClient is a client for the UserSettingHistory schema.
type UserSettingHistoryClient struct {
	config
}

// NewUserSettingHistoryClient returns a client for the UserSettingHistory from the given config.
func NewUserSettingHistoryClient(c config) *UserSettingHistoryClient {
	return &UserSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersettinghistory.Hooks(f(g(h())))`.
func (c *UserSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.UserSettingHistory = append(c.hooks.UserSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersettinghistory.Intercept(f(g(h())))`.
func (c *UserSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSettingHistory = append(c.inters.UserSettingHistory, interceptors...)
}

// Create returns a builder for creating a UserSettingHistory entity.
func (c *UserSettingHistoryClient) Create() *UserSettingHistoryCreate {
	mutation := newUserSettingHistoryMutation(c.config, OpCreate)
	return &UserSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSettingHistory entities.
func (c *UserSettingHistoryClient) CreateBulk(builders ...*UserSettingHistoryCreate) *UserSettingHistoryCreateBulk {
	return &UserSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*UserSettingHistoryCreate, int)) *UserSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSettingHistoryCreateBulk{err: fmt.Errorf("calling to UserSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSettingHistory.
func (c *UserSettingHistoryClient) Update() *UserSettingHistoryUpdate {
	mutation := newUserSettingHistoryMutation(c.config, OpUpdate)
	return &UserSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSettingHistoryClient) UpdateOne(_m *UserSettingHistory) *UserSettingHistoryUpdateOne {
	mutation := newUserSettingHistoryMutation(c.config, OpUpdateOne, withUserSettingHistory(_m))
	return &UserSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSettingHistoryClient) UpdateOneID(id string) *UserSettingHistoryUpdateOne {
	mutation := newUserSettingHistoryMutation(c.config, OpUpdateOne, withUserSettingHistoryID(id))
	return &UserSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSettingHistory.
func (c *UserSettingHistoryClient) Delete() *UserSettingHistoryDelete {
	mutation := newUserSettingHistoryMutation(c.config, OpDelete)
	return &UserSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSettingHistoryClient) DeleteOne(_m *UserSettingHistory) *UserSettingHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSettingHistoryClient) DeleteOneID(id string) *UserSettingHistoryDeleteOne {
	builder := c.Delete().Where(usersettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for UserSettingHistory.
func (c *UserSettingHistoryClient) Query() *UserSettingHistoryQuery {
	return &UserSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSettingHistory entity by its id.
func (c *UserSettingHistoryClient) Get(ctx context.Context, id string) (*UserSettingHistory, error) {
	return c.Query().Where(usersettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSettingHistoryClient) GetX(ctx context.Context, id string) *UserSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserSettingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.UserSettingHistory
	return append(hooks[:len(hooks):len(hooks)], usersettinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.UserSettingHistory
	return append(inters[:len(inters):len(inters)], usersettinghistory.Interceptors[:]...)
}

func (c *UserSettingHistoryClient) mutate(ctx context.Context, m *UserSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserSettingHistory mutation op: %q", m.Op())
	}
}

// VulnerabilityClient is a client for the Vulnerability schema.
type VulnerabilityClient struct {
	config
}

// NewVulnerabilityClient returns a client for the Vulnerability from the given config.
func NewVulnerabilityClient(c config) *VulnerabilityClient {
	return &VulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerability.Hooks(f(g(h())))`.
func (c *VulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.Vulnerability = append(c.hooks.Vulnerability, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnerability.Intercept(f(g(h())))`.
func (c *VulnerabilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vulnerability = append(c.inters.Vulnerability, interceptors...)
}

// Create returns a builder for creating a Vulnerability entity.
func (c *VulnerabilityClient) Create() *VulnerabilityCreate {
	mutation := newVulnerabilityMutation(c.config, OpCreate)
	return &VulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vulnerability entities.
func (c *VulnerabilityClient) CreateBulk(builders ...*VulnerabilityCreate) *VulnerabilityCreateBulk {
	return &VulnerabilityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnerabilityClient) MapCreateBulk(slice any, setFunc func(*VulnerabilityCreate, int)) *VulnerabilityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnerabilityCreateBulk{err: fmt.Errorf("calling to VulnerabilityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnerabilityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vulnerability.
func (c *VulnerabilityClient) Update() *VulnerabilityUpdate {
	mutation := newVulnerabilityMutation(c.config, OpUpdate)
	return &VulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityClient) UpdateOne(_m *Vulnerability) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerability(_m))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityClient) UpdateOneID(id string) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerabilityID(id))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vulnerability.
func (c *VulnerabilityClient) Delete() *VulnerabilityDelete {
	mutation := newVulnerabilityMutation(c.config, OpDelete)
	return &VulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnerabilityClient) DeleteOne(_m *Vulnerability) *VulnerabilityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnerabilityClient) DeleteOneID(id string) *VulnerabilityDeleteOne {
	builder := c.Delete().Where(vulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityDeleteOne{builder}
}

// Query returns a query builder for Vulnerability.
func (c *VulnerabilityClient) Query() *VulnerabilityQuery {
	return &VulnerabilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnerability},
		inters: c.Interceptors(),
	}
}

// Get returns a Vulnerability entity by its id.
func (c *VulnerabilityClient) Get(ctx context.Context, id string) (*Vulnerability, error) {
	return c.Query().Where(vulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityClient) GetX(ctx context.Context, id string) *Vulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Vulnerability.
func (c *VulnerabilityClient) QueryOwner(_m *Vulnerability) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vulnerability.OwnerTable, vulnerability.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Vulnerability
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockedGroups queries the blocked_groups edge of a Vulnerability.
func (c *VulnerabilityClient) QueryBlockedGroups(_m *Vulnerability) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.BlockedGroupsTable, vulnerability.BlockedGroupsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEditors queries the editors edge of a Vulnerability.
func (c *VulnerabilityClient) QueryEditors(_m *Vulnerability) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.EditorsTable, vulnerability.EditorsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViewers queries the viewers edge of a Vulnerability.
func (c *VulnerabilityClient) QueryViewers(_m *Vulnerability) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.ViewersTable, vulnerability.ViewersColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Vulnerability.
func (c *VulnerabilityClient) QueryIntegrations(_m *Vulnerability) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, vulnerability.IntegrationsTable, vulnerability.IntegrationsPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationVulnerabilities
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the findings edge of a Vulnerability.
func (c *VulnerabilityClient) QueryFindings(_m *Vulnerability) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.FindingsTable, vulnerability.FindingsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Finding
		step.Edge.Schema = schemaConfig.Finding
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionPlans queries the action_plans edge of a Vulnerability.
func (c *VulnerabilityClient) QueryActionPlans(_m *Vulnerability) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, vulnerability.ActionPlansTable, vulnerability.ActionPlansPrimaryKey...),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.VulnerabilityActionPlans
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Vulnerability.
func (c *VulnerabilityClient) QueryControls(_m *Vulnerability) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.ControlsTable, vulnerability.ControlsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Vulnerability.
func (c *VulnerabilityClient) QuerySubcontrols(_m *Vulnerability) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.SubcontrolsTable, vulnerability.SubcontrolsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Vulnerability.
func (c *VulnerabilityClient) QueryRisks(_m *Vulnerability) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.RisksTable, vulnerability.RisksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Vulnerability.
func (c *VulnerabilityClient) QueryPrograms(_m *Vulnerability) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.ProgramsTable, vulnerability.ProgramsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Vulnerability.
func (c *VulnerabilityClient) QueryAssets(_m *Vulnerability) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.AssetsTable, vulnerability.AssetsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Asset
		step.Edge.Schema = schemaConfig.Asset
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Vulnerability.
func (c *VulnerabilityClient) QueryEntities(_m *Vulnerability) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.EntitiesTable, vulnerability.EntitiesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a Vulnerability.
func (c *VulnerabilityClient) QueryScans(_m *Vulnerability) *ScanQuery {
	query := (&ScanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(scan.Table, scan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.ScansTable, vulnerability.ScansColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Scan
		step.Edge.Schema = schemaConfig.Scan
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Vulnerability.
func (c *VulnerabilityClient) QueryTasks(_m *Vulnerability) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.TasksTable, vulnerability.TasksColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediations queries the remediations edge of a Vulnerability.
func (c *VulnerabilityClient) QueryRemediations(_m *Vulnerability) *RemediationQuery {
	query := (&RemediationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(remediation.Table, remediation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.RemediationsTable, vulnerability.RemediationsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Remediation
		step.Edge.Schema = schemaConfig.Remediation
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Vulnerability.
func (c *VulnerabilityClient) QueryReviews(_m *Vulnerability) *ReviewQuery {
	query := (&ReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(review.Table, review.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.ReviewsTable, vulnerability.ReviewsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Review
		step.Edge.Schema = schemaConfig.Review
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Vulnerability.
func (c *VulnerabilityClient) QueryComments(_m *Vulnerability) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.CommentsTable, vulnerability.CommentsColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Vulnerability.
func (c *VulnerabilityClient) QueryFiles(_m *Vulnerability) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerability.FilesTable, vulnerability.FilesColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.File
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityClient) Hooks() []Hook {
	hooks := c.hooks.Vulnerability
	return append(hooks[:len(hooks):len(hooks)], vulnerability.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VulnerabilityClient) Interceptors() []Interceptor {
	inters := c.inters.Vulnerability
	return append(inters[:len(inters):len(inters)], vulnerability.Interceptors[:]...)
}

func (c *VulnerabilityClient) mutate(ctx context.Context, m *VulnerabilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Vulnerability mutation op: %q", m.Op())
	}
}

// VulnerabilityHistoryClient is a client for the VulnerabilityHistory schema.
type VulnerabilityHistoryClient struct {
	config
}

// NewVulnerabilityHistoryClient returns a client for the VulnerabilityHistory from the given config.
func NewVulnerabilityHistoryClient(c config) *VulnerabilityHistoryClient {
	return &VulnerabilityHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilityhistory.Hooks(f(g(h())))`.
func (c *VulnerabilityHistoryClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityHistory = append(c.hooks.VulnerabilityHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnerabilityhistory.Intercept(f(g(h())))`.
func (c *VulnerabilityHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnerabilityHistory = append(c.inters.VulnerabilityHistory, interceptors...)
}

// Create returns a builder for creating a VulnerabilityHistory entity.
func (c *VulnerabilityHistoryClient) Create() *VulnerabilityHistoryCreate {
	mutation := newVulnerabilityHistoryMutation(c.config, OpCreate)
	return &VulnerabilityHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityHistory entities.
func (c *VulnerabilityHistoryClient) CreateBulk(builders ...*VulnerabilityHistoryCreate) *VulnerabilityHistoryCreateBulk {
	return &VulnerabilityHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnerabilityHistoryClient) MapCreateBulk(slice any, setFunc func(*VulnerabilityHistoryCreate, int)) *VulnerabilityHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnerabilityHistoryCreateBulk{err: fmt.Errorf("calling to VulnerabilityHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnerabilityHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnerabilityHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityHistory.
func (c *VulnerabilityHistoryClient) Update() *VulnerabilityHistoryUpdate {
	mutation := newVulnerabilityHistoryMutation(c.config, OpUpdate)
	return &VulnerabilityHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityHistoryClient) UpdateOne(_m *VulnerabilityHistory) *VulnerabilityHistoryUpdateOne {
	mutation := newVulnerabilityHistoryMutation(c.config, OpUpdateOne, withVulnerabilityHistory(_m))
	return &VulnerabilityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityHistoryClient) UpdateOneID(id string) *VulnerabilityHistoryUpdateOne {
	mutation := newVulnerabilityHistoryMutation(c.config, OpUpdateOne, withVulnerabilityHistoryID(id))
	return &VulnerabilityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityHistory.
func (c *VulnerabilityHistoryClient) Delete() *VulnerabilityHistoryDelete {
	mutation := newVulnerabilityHistoryMutation(c.config, OpDelete)
	return &VulnerabilityHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnerabilityHistoryClient) DeleteOne(_m *VulnerabilityHistory) *VulnerabilityHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnerabilityHistoryClient) DeleteOneID(id string) *VulnerabilityHistoryDeleteOne {
	builder := c.Delete().Where(vulnerabilityhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityHistoryDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityHistory.
func (c *VulnerabilityHistoryClient) Query() *VulnerabilityHistoryQuery {
	return &VulnerabilityHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnerabilityHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnerabilityHistory entity by its id.
func (c *VulnerabilityHistoryClient) Get(ctx context.Context, id string) (*VulnerabilityHistory, error) {
	return c.Query().Where(vulnerabilityhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityHistoryClient) GetX(ctx context.Context, id string) *VulnerabilityHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VulnerabilityHistoryClient) Hooks() []Hook {
	hooks := c.hooks.VulnerabilityHistory
	return append(hooks[:len(hooks):len(hooks)], vulnerabilityhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VulnerabilityHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.VulnerabilityHistory
	return append(inters[:len(inters):len(inters)], vulnerabilityhistory.Interceptors[:]...)
}

func (c *VulnerabilityHistoryClient) mutate(ctx context.Context, m *VulnerabilityHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnerabilityHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnerabilityHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnerabilityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnerabilityHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown VulnerabilityHistory mutation op: %q", m.Op())
	}
}

// WebauthnClient is a client for the Webauthn schema.
type WebauthnClient struct {
	config
}

// NewWebauthnClient returns a client for the Webauthn from the given config.
func NewWebauthnClient(c config) *WebauthnClient {
	return &WebauthnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webauthn.Hooks(f(g(h())))`.
func (c *WebauthnClient) Use(hooks ...Hook) {
	c.hooks.Webauthn = append(c.hooks.Webauthn, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webauthn.Intercept(f(g(h())))`.
func (c *WebauthnClient) Intercept(interceptors ...Interceptor) {
	c.inters.Webauthn = append(c.inters.Webauthn, interceptors...)
}

// Create returns a builder for creating a Webauthn entity.
func (c *WebauthnClient) Create() *WebauthnCreate {
	mutation := newWebauthnMutation(c.config, OpCreate)
	return &WebauthnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Webauthn entities.
func (c *WebauthnClient) CreateBulk(builders ...*WebauthnCreate) *WebauthnCreateBulk {
	return &WebauthnCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebauthnClient) MapCreateBulk(slice any, setFunc func(*WebauthnCreate, int)) *WebauthnCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebauthnCreateBulk{err: fmt.Errorf("calling to WebauthnClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebauthnCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebauthnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Webauthn.
func (c *WebauthnClient) Update() *WebauthnUpdate {
	mutation := newWebauthnMutation(c.config, OpUpdate)
	return &WebauthnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebauthnClient) UpdateOne(_m *Webauthn) *WebauthnUpdateOne {
	mutation := newWebauthnMutation(c.config, OpUpdateOne, withWebauthn(_m))
	return &WebauthnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebauthnClient) UpdateOneID(id string) *WebauthnUpdateOne {
	mutation := newWebauthnMutation(c.config, OpUpdateOne, withWebauthnID(id))
	return &WebauthnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Webauthn.
func (c *WebauthnClient) Delete() *WebauthnDelete {
	mutation := newWebauthnMutation(c.config, OpDelete)
	return &WebauthnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebauthnClient) DeleteOne(_m *Webauthn) *WebauthnDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebauthnClient) DeleteOneID(id string) *WebauthnDeleteOne {
	builder := c.Delete().Where(webauthn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebauthnDeleteOne{builder}
}

// Query returns a query builder for Webauthn.
func (c *WebauthnClient) Query() *WebauthnQuery {
	return &WebauthnQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebauthn},
		inters: c.Interceptors(),
	}
}

// Get returns a Webauthn entity by its id.
func (c *WebauthnClient) Get(ctx context.Context, id string) (*Webauthn, error) {
	return c.Query().Where(webauthn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebauthnClient) GetX(ctx context.Context, id string) *Webauthn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Webauthn.
func (c *WebauthnClient) QueryOwner(_m *Webauthn) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webauthn.Table, webauthn.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, webauthn.OwnerTable, webauthn.OwnerColumn),
		)
		schemaConfig := _m.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Webauthn
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WebauthnClient) Hooks() []Hook {
	hooks := c.hooks.Webauthn
	return append(hooks[:len(hooks):len(hooks)], webauthn.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WebauthnClient) Interceptors() []Interceptor {
	inters := c.inters.Webauthn
	return append(inters[:len(inters):len(inters)], webauthn.Interceptors[:]...)
}

func (c *WebauthnClient) mutate(ctx context.Context, m *WebauthnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebauthnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebauthnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebauthnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebauthnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Webauthn mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIToken, ActionPlan, ActionPlanHistory, Assessment, AssessmentHistory,
		AssessmentResponse, AssessmentResponseHistory, Asset, AssetHistory, Contact,
		ContactHistory, Control, ControlHistory, ControlImplementation,
		ControlImplementationHistory, ControlObjective, ControlObjectiveHistory,
		CustomDomain, CustomDomainHistory, CustomTypeEnum, DNSVerification,
		DNSVerificationHistory, DocumentData, DocumentDataHistory,
		EmailVerificationToken, Entity, EntityHistory, EntityType, EntityTypeHistory,
		Event, Evidence, EvidenceHistory, Export, File, FileDownloadToken, FileHistory,
		Finding, FindingControl, FindingControlHistory, FindingHistory, Group,
		GroupHistory, GroupMembership, GroupMembershipHistory, GroupSetting,
		GroupSettingHistory, Hush, HushHistory, ImpersonationEvent, Integration,
		IntegrationHistory, InternalPolicy, InternalPolicyHistory, Invite, JobResult,
		JobRunner, JobRunnerRegistrationToken, JobRunnerToken, JobTemplate,
		JobTemplateHistory, MappableDomain, MappableDomainHistory, MappedControl,
		MappedControlHistory, Narrative, NarrativeHistory, Note, NoteHistory,
		Notification, Onboarding, OrgMembership, OrgMembershipHistory, OrgModule,
		OrgPrice, OrgProduct, OrgSubscription, OrgSubscriptionHistory, Organization,
		OrganizationHistory, OrganizationSetting, OrganizationSettingHistory,
		PasswordResetToken, PersonalAccessToken, Procedure, ProcedureHistory, Program,
		ProgramHistory, ProgramMembership, ProgramMembershipHistory, Remediation,
		RemediationHistory, Review, ReviewHistory, Risk, RiskHistory, Scan,
		ScanHistory, ScheduledJob, ScheduledJobHistory, ScheduledJobRun, Standard,
		StandardHistory, Subcontrol, SubcontrolHistory, Subprocessor,
		SubprocessorHistory, Subscriber, TFASetting, TagDefinition, Task, TaskHistory,
		Template, TemplateHistory, TrustCenter, TrustCenterCompliance,
		TrustCenterComplianceHistory, TrustCenterDoc, TrustCenterDocHistory,
		TrustCenterHistory, TrustCenterSetting, TrustCenterSettingHistory,
		TrustCenterSubprocessor, TrustCenterSubprocessorHistory,
		TrustCenterWatermarkConfig, TrustCenterWatermarkConfigHistory, User,
		UserHistory, UserSetting, UserSettingHistory, Vulnerability,
		VulnerabilityHistory, Webauthn []ent.Hook
	}
	inters struct {
		APIToken, ActionPlan, ActionPlanHistory, Assessment, AssessmentHistory,
		AssessmentResponse, AssessmentResponseHistory, Asset, AssetHistory, Contact,
		ContactHistory, Control, ControlHistory, ControlImplementation,
		ControlImplementationHistory, ControlObjective, ControlObjectiveHistory,
		CustomDomain, CustomDomainHistory, CustomTypeEnum, DNSVerification,
		DNSVerificationHistory, DocumentData, DocumentDataHistory,
		EmailVerificationToken, Entity, EntityHistory, EntityType, EntityTypeHistory,
		Event, Evidence, EvidenceHistory, Export, File, FileDownloadToken, FileHistory,
		Finding, FindingControl, FindingControlHistory, FindingHistory, Group,
		GroupHistory, GroupMembership, GroupMembershipHistory, GroupSetting,
		GroupSettingHistory, Hush, HushHistory, ImpersonationEvent, Integration,
		IntegrationHistory, InternalPolicy, InternalPolicyHistory, Invite, JobResult,
		JobRunner, JobRunnerRegistrationToken, JobRunnerToken, JobTemplate,
		JobTemplateHistory, MappableDomain, MappableDomainHistory, MappedControl,
		MappedControlHistory, Narrative, NarrativeHistory, Note, NoteHistory,
		Notification, Onboarding, OrgMembership, OrgMembershipHistory, OrgModule,
		OrgPrice, OrgProduct, OrgSubscription, OrgSubscriptionHistory, Organization,
		OrganizationHistory, OrganizationSetting, OrganizationSettingHistory,
		PasswordResetToken, PersonalAccessToken, Procedure, ProcedureHistory, Program,
		ProgramHistory, ProgramMembership, ProgramMembershipHistory, Remediation,
		RemediationHistory, Review, ReviewHistory, Risk, RiskHistory, Scan,
		ScanHistory, ScheduledJob, ScheduledJobHistory, ScheduledJobRun, Standard,
		StandardHistory, Subcontrol, SubcontrolHistory, Subprocessor,
		SubprocessorHistory, Subscriber, TFASetting, TagDefinition, Task, TaskHistory,
		Template, TemplateHistory, TrustCenter, TrustCenterCompliance,
		TrustCenterComplianceHistory, TrustCenterDoc, TrustCenterDocHistory,
		TrustCenterHistory, TrustCenterSetting, TrustCenterSettingHistory,
		TrustCenterSubprocessor, TrustCenterSubprocessorHistory,
		TrustCenterWatermarkConfig, TrustCenterWatermarkConfigHistory, User,
		UserHistory, UserSetting, UserSettingHistory, Vulnerability,
		VulnerabilityHistory, Webauthn []ent.Interceptor
	}
)

// Job option added by the client template to add the job client.
func Job(ctx context.Context, opts ...riverqueue.Option) Option {
	return func(c *config) {
		var err error

		c.Job, err = riverqueue.New(ctx, opts...)
		if err != nil {
			panic(err)
		}
	}
}

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}
