// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"ariga.io/entcache"
	"github.com/theopenlane/core/internal/ent/generated/migrate"
	"github.com/theopenlane/entx"
	"github.com/theopenlane/riverboat/pkg/riverqueue"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/theopenlane/core/internal/ent/entconfig"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/emailverificationtoken"
	"github.com/theopenlane/core/internal/ent/generated/entitlement"
	"github.com/theopenlane/core/internal/ent/generated/entitlementhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplan"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeature"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeaturehistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/eventhistory"
	"github.com/theopenlane/core/internal/ent/generated/feature"
	"github.com/theopenlane/core/internal/ent/generated/featurehistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/oauthprovider"
	"github.com/theopenlane/core/internal/ent/generated/oauthproviderhistory"
	"github.com/theopenlane/core/internal/ent/generated/ohauthtootoken"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/passwordresettoken"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/programmembership"
	"github.com/theopenlane/core/internal/ent/generated/programmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/theopenlane/core/internal/ent/generated/webhook"
	"github.com/theopenlane/core/internal/ent/generated/webhookhistory"
	"github.com/theopenlane/emailtemplates"
	"github.com/theopenlane/iam/fgax"
	"github.com/theopenlane/iam/sessions"
	"github.com/theopenlane/iam/tokens"
	"github.com/theopenlane/iam/totp"
	"gocloud.dev/secrets"

	"github.com/theopenlane/iam/entfga"

	stdsql "database/sql"

	"github.com/theopenlane/core/internal/ent/generated/internal"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIToken is the client for interacting with the APIToken builders.
	APIToken *APITokenClient
	// ActionPlan is the client for interacting with the ActionPlan builders.
	ActionPlan *ActionPlanClient
	// ActionPlanHistory is the client for interacting with the ActionPlanHistory builders.
	ActionPlanHistory *ActionPlanHistoryClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// ContactHistory is the client for interacting with the ContactHistory builders.
	ContactHistory *ContactHistoryClient
	// Control is the client for interacting with the Control builders.
	Control *ControlClient
	// ControlHistory is the client for interacting with the ControlHistory builders.
	ControlHistory *ControlHistoryClient
	// ControlObjective is the client for interacting with the ControlObjective builders.
	ControlObjective *ControlObjectiveClient
	// ControlObjectiveHistory is the client for interacting with the ControlObjectiveHistory builders.
	ControlObjectiveHistory *ControlObjectiveHistoryClient
	// DocumentData is the client for interacting with the DocumentData builders.
	DocumentData *DocumentDataClient
	// DocumentDataHistory is the client for interacting with the DocumentDataHistory builders.
	DocumentDataHistory *DocumentDataHistoryClient
	// EmailVerificationToken is the client for interacting with the EmailVerificationToken builders.
	EmailVerificationToken *EmailVerificationTokenClient
	// Entitlement is the client for interacting with the Entitlement builders.
	Entitlement *EntitlementClient
	// EntitlementHistory is the client for interacting with the EntitlementHistory builders.
	EntitlementHistory *EntitlementHistoryClient
	// EntitlementPlan is the client for interacting with the EntitlementPlan builders.
	EntitlementPlan *EntitlementPlanClient
	// EntitlementPlanFeature is the client for interacting with the EntitlementPlanFeature builders.
	EntitlementPlanFeature *EntitlementPlanFeatureClient
	// EntitlementPlanFeatureHistory is the client for interacting with the EntitlementPlanFeatureHistory builders.
	EntitlementPlanFeatureHistory *EntitlementPlanFeatureHistoryClient
	// EntitlementPlanHistory is the client for interacting with the EntitlementPlanHistory builders.
	EntitlementPlanHistory *EntitlementPlanHistoryClient
	// Entity is the client for interacting with the Entity builders.
	Entity *EntityClient
	// EntityHistory is the client for interacting with the EntityHistory builders.
	EntityHistory *EntityHistoryClient
	// EntityType is the client for interacting with the EntityType builders.
	EntityType *EntityTypeClient
	// EntityTypeHistory is the client for interacting with the EntityTypeHistory builders.
	EntityTypeHistory *EntityTypeHistoryClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventHistory is the client for interacting with the EventHistory builders.
	EventHistory *EventHistoryClient
	// Feature is the client for interacting with the Feature builders.
	Feature *FeatureClient
	// FeatureHistory is the client for interacting with the FeatureHistory builders.
	FeatureHistory *FeatureHistoryClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// FileHistory is the client for interacting with the FileHistory builders.
	FileHistory *FileHistoryClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// GroupHistory is the client for interacting with the GroupHistory builders.
	GroupHistory *GroupHistoryClient
	// GroupMembership is the client for interacting with the GroupMembership builders.
	GroupMembership *GroupMembershipClient
	// GroupMembershipHistory is the client for interacting with the GroupMembershipHistory builders.
	GroupMembershipHistory *GroupMembershipHistoryClient
	// GroupSetting is the client for interacting with the GroupSetting builders.
	GroupSetting *GroupSettingClient
	// GroupSettingHistory is the client for interacting with the GroupSettingHistory builders.
	GroupSettingHistory *GroupSettingHistoryClient
	// Hush is the client for interacting with the Hush builders.
	Hush *HushClient
	// HushHistory is the client for interacting with the HushHistory builders.
	HushHistory *HushHistoryClient
	// Integration is the client for interacting with the Integration builders.
	Integration *IntegrationClient
	// IntegrationHistory is the client for interacting with the IntegrationHistory builders.
	IntegrationHistory *IntegrationHistoryClient
	// InternalPolicy is the client for interacting with the InternalPolicy builders.
	InternalPolicy *InternalPolicyClient
	// InternalPolicyHistory is the client for interacting with the InternalPolicyHistory builders.
	InternalPolicyHistory *InternalPolicyHistoryClient
	// Invite is the client for interacting with the Invite builders.
	Invite *InviteClient
	// Narrative is the client for interacting with the Narrative builders.
	Narrative *NarrativeClient
	// NarrativeHistory is the client for interacting with the NarrativeHistory builders.
	NarrativeHistory *NarrativeHistoryClient
	// Note is the client for interacting with the Note builders.
	Note *NoteClient
	// NoteHistory is the client for interacting with the NoteHistory builders.
	NoteHistory *NoteHistoryClient
	// OauthProvider is the client for interacting with the OauthProvider builders.
	OauthProvider *OauthProviderClient
	// OauthProviderHistory is the client for interacting with the OauthProviderHistory builders.
	OauthProviderHistory *OauthProviderHistoryClient
	// OhAuthTooToken is the client for interacting with the OhAuthTooToken builders.
	OhAuthTooToken *OhAuthTooTokenClient
	// OrgMembership is the client for interacting with the OrgMembership builders.
	OrgMembership *OrgMembershipClient
	// OrgMembershipHistory is the client for interacting with the OrgMembershipHistory builders.
	OrgMembershipHistory *OrgMembershipHistoryClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// OrganizationHistory is the client for interacting with the OrganizationHistory builders.
	OrganizationHistory *OrganizationHistoryClient
	// OrganizationSetting is the client for interacting with the OrganizationSetting builders.
	OrganizationSetting *OrganizationSettingClient
	// OrganizationSettingHistory is the client for interacting with the OrganizationSettingHistory builders.
	OrganizationSettingHistory *OrganizationSettingHistoryClient
	// PasswordResetToken is the client for interacting with the PasswordResetToken builders.
	PasswordResetToken *PasswordResetTokenClient
	// PersonalAccessToken is the client for interacting with the PersonalAccessToken builders.
	PersonalAccessToken *PersonalAccessTokenClient
	// Procedure is the client for interacting with the Procedure builders.
	Procedure *ProcedureClient
	// ProcedureHistory is the client for interacting with the ProcedureHistory builders.
	ProcedureHistory *ProcedureHistoryClient
	// Program is the client for interacting with the Program builders.
	Program *ProgramClient
	// ProgramHistory is the client for interacting with the ProgramHistory builders.
	ProgramHistory *ProgramHistoryClient
	// ProgramMembership is the client for interacting with the ProgramMembership builders.
	ProgramMembership *ProgramMembershipClient
	// ProgramMembershipHistory is the client for interacting with the ProgramMembershipHistory builders.
	ProgramMembershipHistory *ProgramMembershipHistoryClient
	// Risk is the client for interacting with the Risk builders.
	Risk *RiskClient
	// RiskHistory is the client for interacting with the RiskHistory builders.
	RiskHistory *RiskHistoryClient
	// Standard is the client for interacting with the Standard builders.
	Standard *StandardClient
	// StandardHistory is the client for interacting with the StandardHistory builders.
	StandardHistory *StandardHistoryClient
	// Subcontrol is the client for interacting with the Subcontrol builders.
	Subcontrol *SubcontrolClient
	// SubcontrolHistory is the client for interacting with the SubcontrolHistory builders.
	SubcontrolHistory *SubcontrolHistoryClient
	// Subscriber is the client for interacting with the Subscriber builders.
	Subscriber *SubscriberClient
	// TFASetting is the client for interacting with the TFASetting builders.
	TFASetting *TFASettingClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// TaskHistory is the client for interacting with the TaskHistory builders.
	TaskHistory *TaskHistoryClient
	// Template is the client for interacting with the Template builders.
	Template *TemplateClient
	// TemplateHistory is the client for interacting with the TemplateHistory builders.
	TemplateHistory *TemplateHistoryClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserHistory is the client for interacting with the UserHistory builders.
	UserHistory *UserHistoryClient
	// UserSetting is the client for interacting with the UserSetting builders.
	UserSetting *UserSettingClient
	// UserSettingHistory is the client for interacting with the UserSettingHistory builders.
	UserSettingHistory *UserSettingHistoryClient
	// Webauthn is the client for interacting with the Webauthn builders.
	Webauthn *WebauthnClient
	// Webhook is the client for interacting with the Webhook builders.
	Webhook *WebhookClient
	// WebhookHistory is the client for interacting with the WebhookHistory builders.
	WebhookHistory *WebhookHistoryClient

	// authzActivated determines if the authz hooks have already been activated
	authzActivated bool

	// Config is the db client configuration
	Config *entx.EntClientConfig

	// Job is the job client to insert jobs into the queue.
	Job riverqueue.JobClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIToken = NewAPITokenClient(c.config)
	c.ActionPlan = NewActionPlanClient(c.config)
	c.ActionPlanHistory = NewActionPlanHistoryClient(c.config)
	c.Contact = NewContactClient(c.config)
	c.ContactHistory = NewContactHistoryClient(c.config)
	c.Control = NewControlClient(c.config)
	c.ControlHistory = NewControlHistoryClient(c.config)
	c.ControlObjective = NewControlObjectiveClient(c.config)
	c.ControlObjectiveHistory = NewControlObjectiveHistoryClient(c.config)
	c.DocumentData = NewDocumentDataClient(c.config)
	c.DocumentDataHistory = NewDocumentDataHistoryClient(c.config)
	c.EmailVerificationToken = NewEmailVerificationTokenClient(c.config)
	c.Entitlement = NewEntitlementClient(c.config)
	c.EntitlementHistory = NewEntitlementHistoryClient(c.config)
	c.EntitlementPlan = NewEntitlementPlanClient(c.config)
	c.EntitlementPlanFeature = NewEntitlementPlanFeatureClient(c.config)
	c.EntitlementPlanFeatureHistory = NewEntitlementPlanFeatureHistoryClient(c.config)
	c.EntitlementPlanHistory = NewEntitlementPlanHistoryClient(c.config)
	c.Entity = NewEntityClient(c.config)
	c.EntityHistory = NewEntityHistoryClient(c.config)
	c.EntityType = NewEntityTypeClient(c.config)
	c.EntityTypeHistory = NewEntityTypeHistoryClient(c.config)
	c.Event = NewEventClient(c.config)
	c.EventHistory = NewEventHistoryClient(c.config)
	c.Feature = NewFeatureClient(c.config)
	c.FeatureHistory = NewFeatureHistoryClient(c.config)
	c.File = NewFileClient(c.config)
	c.FileHistory = NewFileHistoryClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.GroupHistory = NewGroupHistoryClient(c.config)
	c.GroupMembership = NewGroupMembershipClient(c.config)
	c.GroupMembershipHistory = NewGroupMembershipHistoryClient(c.config)
	c.GroupSetting = NewGroupSettingClient(c.config)
	c.GroupSettingHistory = NewGroupSettingHistoryClient(c.config)
	c.Hush = NewHushClient(c.config)
	c.HushHistory = NewHushHistoryClient(c.config)
	c.Integration = NewIntegrationClient(c.config)
	c.IntegrationHistory = NewIntegrationHistoryClient(c.config)
	c.InternalPolicy = NewInternalPolicyClient(c.config)
	c.InternalPolicyHistory = NewInternalPolicyHistoryClient(c.config)
	c.Invite = NewInviteClient(c.config)
	c.Narrative = NewNarrativeClient(c.config)
	c.NarrativeHistory = NewNarrativeHistoryClient(c.config)
	c.Note = NewNoteClient(c.config)
	c.NoteHistory = NewNoteHistoryClient(c.config)
	c.OauthProvider = NewOauthProviderClient(c.config)
	c.OauthProviderHistory = NewOauthProviderHistoryClient(c.config)
	c.OhAuthTooToken = NewOhAuthTooTokenClient(c.config)
	c.OrgMembership = NewOrgMembershipClient(c.config)
	c.OrgMembershipHistory = NewOrgMembershipHistoryClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.OrganizationHistory = NewOrganizationHistoryClient(c.config)
	c.OrganizationSetting = NewOrganizationSettingClient(c.config)
	c.OrganizationSettingHistory = NewOrganizationSettingHistoryClient(c.config)
	c.PasswordResetToken = NewPasswordResetTokenClient(c.config)
	c.PersonalAccessToken = NewPersonalAccessTokenClient(c.config)
	c.Procedure = NewProcedureClient(c.config)
	c.ProcedureHistory = NewProcedureHistoryClient(c.config)
	c.Program = NewProgramClient(c.config)
	c.ProgramHistory = NewProgramHistoryClient(c.config)
	c.ProgramMembership = NewProgramMembershipClient(c.config)
	c.ProgramMembershipHistory = NewProgramMembershipHistoryClient(c.config)
	c.Risk = NewRiskClient(c.config)
	c.RiskHistory = NewRiskHistoryClient(c.config)
	c.Standard = NewStandardClient(c.config)
	c.StandardHistory = NewStandardHistoryClient(c.config)
	c.Subcontrol = NewSubcontrolClient(c.config)
	c.SubcontrolHistory = NewSubcontrolHistoryClient(c.config)
	c.Subscriber = NewSubscriberClient(c.config)
	c.TFASetting = NewTFASettingClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.TaskHistory = NewTaskHistoryClient(c.config)
	c.Template = NewTemplateClient(c.config)
	c.TemplateHistory = NewTemplateHistoryClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserHistory = NewUserHistoryClient(c.config)
	c.UserSetting = NewUserSettingClient(c.config)
	c.UserSettingHistory = NewUserSettingHistoryClient(c.config)
	c.Webauthn = NewWebauthnClient(c.config)
	c.Webhook = NewWebhookClient(c.config)
	c.WebhookHistory = NewWebhookHistoryClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters        *inters
		EntConfig     *entconfig.Config
		Secrets       *secrets.Keeper
		Authz         fgax.Client
		TokenManager  *tokens.TokenManager
		SessionConfig *sessions.SessionConfig
		Emailer       *emailtemplates.Config
		TOTP          *totp.Manager
		// Job is the job client to insert jobs into the queue.
		Job riverqueue.JobClient

		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// EntConfig configures the EntConfig.
func EntConfig(v *entconfig.Config) Option {
	return func(c *config) {
		c.EntConfig = v
	}
}

// Secrets configures the Secrets.
func Secrets(v *secrets.Keeper) Option {
	return func(c *config) {
		c.Secrets = v
	}
}

// Authz configures the Authz.
func Authz(v fgax.Client) Option {
	return func(c *config) {
		c.Authz = v
	}
}

// TokenManager configures the TokenManager.
func TokenManager(v *tokens.TokenManager) Option {
	return func(c *config) {
		c.TokenManager = v
	}
}

// SessionConfig configures the SessionConfig.
func SessionConfig(v *sessions.SessionConfig) Option {
	return func(c *config) {
		c.SessionConfig = v
	}
}

// Emailer configures the Emailer.
func Emailer(v *emailtemplates.Config) Option {
	return func(c *config) {
		c.Emailer = v
	}
}

// TOTP configures the TOTP.
func TOTP(v *totp.Manager) Option {
	return func(c *config) {
		c.TOTP = v
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                           ctx,
		config:                        cfg,
		APIToken:                      NewAPITokenClient(cfg),
		ActionPlan:                    NewActionPlanClient(cfg),
		ActionPlanHistory:             NewActionPlanHistoryClient(cfg),
		Contact:                       NewContactClient(cfg),
		ContactHistory:                NewContactHistoryClient(cfg),
		Control:                       NewControlClient(cfg),
		ControlHistory:                NewControlHistoryClient(cfg),
		ControlObjective:              NewControlObjectiveClient(cfg),
		ControlObjectiveHistory:       NewControlObjectiveHistoryClient(cfg),
		DocumentData:                  NewDocumentDataClient(cfg),
		DocumentDataHistory:           NewDocumentDataHistoryClient(cfg),
		EmailVerificationToken:        NewEmailVerificationTokenClient(cfg),
		Entitlement:                   NewEntitlementClient(cfg),
		EntitlementHistory:            NewEntitlementHistoryClient(cfg),
		EntitlementPlan:               NewEntitlementPlanClient(cfg),
		EntitlementPlanFeature:        NewEntitlementPlanFeatureClient(cfg),
		EntitlementPlanFeatureHistory: NewEntitlementPlanFeatureHistoryClient(cfg),
		EntitlementPlanHistory:        NewEntitlementPlanHistoryClient(cfg),
		Entity:                        NewEntityClient(cfg),
		EntityHistory:                 NewEntityHistoryClient(cfg),
		EntityType:                    NewEntityTypeClient(cfg),
		EntityTypeHistory:             NewEntityTypeHistoryClient(cfg),
		Event:                         NewEventClient(cfg),
		EventHistory:                  NewEventHistoryClient(cfg),
		Feature:                       NewFeatureClient(cfg),
		FeatureHistory:                NewFeatureHistoryClient(cfg),
		File:                          NewFileClient(cfg),
		FileHistory:                   NewFileHistoryClient(cfg),
		Group:                         NewGroupClient(cfg),
		GroupHistory:                  NewGroupHistoryClient(cfg),
		GroupMembership:               NewGroupMembershipClient(cfg),
		GroupMembershipHistory:        NewGroupMembershipHistoryClient(cfg),
		GroupSetting:                  NewGroupSettingClient(cfg),
		GroupSettingHistory:           NewGroupSettingHistoryClient(cfg),
		Hush:                          NewHushClient(cfg),
		HushHistory:                   NewHushHistoryClient(cfg),
		Integration:                   NewIntegrationClient(cfg),
		IntegrationHistory:            NewIntegrationHistoryClient(cfg),
		InternalPolicy:                NewInternalPolicyClient(cfg),
		InternalPolicyHistory:         NewInternalPolicyHistoryClient(cfg),
		Invite:                        NewInviteClient(cfg),
		Narrative:                     NewNarrativeClient(cfg),
		NarrativeHistory:              NewNarrativeHistoryClient(cfg),
		Note:                          NewNoteClient(cfg),
		NoteHistory:                   NewNoteHistoryClient(cfg),
		OauthProvider:                 NewOauthProviderClient(cfg),
		OauthProviderHistory:          NewOauthProviderHistoryClient(cfg),
		OhAuthTooToken:                NewOhAuthTooTokenClient(cfg),
		OrgMembership:                 NewOrgMembershipClient(cfg),
		OrgMembershipHistory:          NewOrgMembershipHistoryClient(cfg),
		Organization:                  NewOrganizationClient(cfg),
		OrganizationHistory:           NewOrganizationHistoryClient(cfg),
		OrganizationSetting:           NewOrganizationSettingClient(cfg),
		OrganizationSettingHistory:    NewOrganizationSettingHistoryClient(cfg),
		PasswordResetToken:            NewPasswordResetTokenClient(cfg),
		PersonalAccessToken:           NewPersonalAccessTokenClient(cfg),
		Procedure:                     NewProcedureClient(cfg),
		ProcedureHistory:              NewProcedureHistoryClient(cfg),
		Program:                       NewProgramClient(cfg),
		ProgramHistory:                NewProgramHistoryClient(cfg),
		ProgramMembership:             NewProgramMembershipClient(cfg),
		ProgramMembershipHistory:      NewProgramMembershipHistoryClient(cfg),
		Risk:                          NewRiskClient(cfg),
		RiskHistory:                   NewRiskHistoryClient(cfg),
		Standard:                      NewStandardClient(cfg),
		StandardHistory:               NewStandardHistoryClient(cfg),
		Subcontrol:                    NewSubcontrolClient(cfg),
		SubcontrolHistory:             NewSubcontrolHistoryClient(cfg),
		Subscriber:                    NewSubscriberClient(cfg),
		TFASetting:                    NewTFASettingClient(cfg),
		Task:                          NewTaskClient(cfg),
		TaskHistory:                   NewTaskHistoryClient(cfg),
		Template:                      NewTemplateClient(cfg),
		TemplateHistory:               NewTemplateHistoryClient(cfg),
		User:                          NewUserClient(cfg),
		UserHistory:                   NewUserHistoryClient(cfg),
		UserSetting:                   NewUserSettingClient(cfg),
		UserSettingHistory:            NewUserSettingHistoryClient(cfg),
		Webauthn:                      NewWebauthnClient(cfg),
		Webhook:                       NewWebhookClient(cfg),
		WebhookHistory:                NewWebhookHistoryClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                           ctx,
		config:                        cfg,
		APIToken:                      NewAPITokenClient(cfg),
		ActionPlan:                    NewActionPlanClient(cfg),
		ActionPlanHistory:             NewActionPlanHistoryClient(cfg),
		Contact:                       NewContactClient(cfg),
		ContactHistory:                NewContactHistoryClient(cfg),
		Control:                       NewControlClient(cfg),
		ControlHistory:                NewControlHistoryClient(cfg),
		ControlObjective:              NewControlObjectiveClient(cfg),
		ControlObjectiveHistory:       NewControlObjectiveHistoryClient(cfg),
		DocumentData:                  NewDocumentDataClient(cfg),
		DocumentDataHistory:           NewDocumentDataHistoryClient(cfg),
		EmailVerificationToken:        NewEmailVerificationTokenClient(cfg),
		Entitlement:                   NewEntitlementClient(cfg),
		EntitlementHistory:            NewEntitlementHistoryClient(cfg),
		EntitlementPlan:               NewEntitlementPlanClient(cfg),
		EntitlementPlanFeature:        NewEntitlementPlanFeatureClient(cfg),
		EntitlementPlanFeatureHistory: NewEntitlementPlanFeatureHistoryClient(cfg),
		EntitlementPlanHistory:        NewEntitlementPlanHistoryClient(cfg),
		Entity:                        NewEntityClient(cfg),
		EntityHistory:                 NewEntityHistoryClient(cfg),
		EntityType:                    NewEntityTypeClient(cfg),
		EntityTypeHistory:             NewEntityTypeHistoryClient(cfg),
		Event:                         NewEventClient(cfg),
		EventHistory:                  NewEventHistoryClient(cfg),
		Feature:                       NewFeatureClient(cfg),
		FeatureHistory:                NewFeatureHistoryClient(cfg),
		File:                          NewFileClient(cfg),
		FileHistory:                   NewFileHistoryClient(cfg),
		Group:                         NewGroupClient(cfg),
		GroupHistory:                  NewGroupHistoryClient(cfg),
		GroupMembership:               NewGroupMembershipClient(cfg),
		GroupMembershipHistory:        NewGroupMembershipHistoryClient(cfg),
		GroupSetting:                  NewGroupSettingClient(cfg),
		GroupSettingHistory:           NewGroupSettingHistoryClient(cfg),
		Hush:                          NewHushClient(cfg),
		HushHistory:                   NewHushHistoryClient(cfg),
		Integration:                   NewIntegrationClient(cfg),
		IntegrationHistory:            NewIntegrationHistoryClient(cfg),
		InternalPolicy:                NewInternalPolicyClient(cfg),
		InternalPolicyHistory:         NewInternalPolicyHistoryClient(cfg),
		Invite:                        NewInviteClient(cfg),
		Narrative:                     NewNarrativeClient(cfg),
		NarrativeHistory:              NewNarrativeHistoryClient(cfg),
		Note:                          NewNoteClient(cfg),
		NoteHistory:                   NewNoteHistoryClient(cfg),
		OauthProvider:                 NewOauthProviderClient(cfg),
		OauthProviderHistory:          NewOauthProviderHistoryClient(cfg),
		OhAuthTooToken:                NewOhAuthTooTokenClient(cfg),
		OrgMembership:                 NewOrgMembershipClient(cfg),
		OrgMembershipHistory:          NewOrgMembershipHistoryClient(cfg),
		Organization:                  NewOrganizationClient(cfg),
		OrganizationHistory:           NewOrganizationHistoryClient(cfg),
		OrganizationSetting:           NewOrganizationSettingClient(cfg),
		OrganizationSettingHistory:    NewOrganizationSettingHistoryClient(cfg),
		PasswordResetToken:            NewPasswordResetTokenClient(cfg),
		PersonalAccessToken:           NewPersonalAccessTokenClient(cfg),
		Procedure:                     NewProcedureClient(cfg),
		ProcedureHistory:              NewProcedureHistoryClient(cfg),
		Program:                       NewProgramClient(cfg),
		ProgramHistory:                NewProgramHistoryClient(cfg),
		ProgramMembership:             NewProgramMembershipClient(cfg),
		ProgramMembershipHistory:      NewProgramMembershipHistoryClient(cfg),
		Risk:                          NewRiskClient(cfg),
		RiskHistory:                   NewRiskHistoryClient(cfg),
		Standard:                      NewStandardClient(cfg),
		StandardHistory:               NewStandardHistoryClient(cfg),
		Subcontrol:                    NewSubcontrolClient(cfg),
		SubcontrolHistory:             NewSubcontrolHistoryClient(cfg),
		Subscriber:                    NewSubscriberClient(cfg),
		TFASetting:                    NewTFASettingClient(cfg),
		Task:                          NewTaskClient(cfg),
		TaskHistory:                   NewTaskHistoryClient(cfg),
		Template:                      NewTemplateClient(cfg),
		TemplateHistory:               NewTemplateHistoryClient(cfg),
		User:                          NewUserClient(cfg),
		UserHistory:                   NewUserHistoryClient(cfg),
		UserSetting:                   NewUserSettingClient(cfg),
		UserSettingHistory:            NewUserSettingHistoryClient(cfg),
		Webauthn:                      NewWebauthnClient(cfg),
		Webhook:                       NewWebhookClient(cfg),
		WebhookHistory:                NewWebhookHistoryClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIToken, c.ActionPlan, c.ActionPlanHistory, c.Contact, c.ContactHistory,
		c.Control, c.ControlHistory, c.ControlObjective, c.ControlObjectiveHistory,
		c.DocumentData, c.DocumentDataHistory, c.EmailVerificationToken, c.Entitlement,
		c.EntitlementHistory, c.EntitlementPlan, c.EntitlementPlanFeature,
		c.EntitlementPlanFeatureHistory, c.EntitlementPlanHistory, c.Entity,
		c.EntityHistory, c.EntityType, c.EntityTypeHistory, c.Event, c.EventHistory,
		c.Feature, c.FeatureHistory, c.File, c.FileHistory, c.Group, c.GroupHistory,
		c.GroupMembership, c.GroupMembershipHistory, c.GroupSetting,
		c.GroupSettingHistory, c.Hush, c.HushHistory, c.Integration,
		c.IntegrationHistory, c.InternalPolicy, c.InternalPolicyHistory, c.Invite,
		c.Narrative, c.NarrativeHistory, c.Note, c.NoteHistory, c.OauthProvider,
		c.OauthProviderHistory, c.OhAuthTooToken, c.OrgMembership,
		c.OrgMembershipHistory, c.Organization, c.OrganizationHistory,
		c.OrganizationSetting, c.OrganizationSettingHistory, c.PasswordResetToken,
		c.PersonalAccessToken, c.Procedure, c.ProcedureHistory, c.Program,
		c.ProgramHistory, c.ProgramMembership, c.ProgramMembershipHistory, c.Risk,
		c.RiskHistory, c.Standard, c.StandardHistory, c.Subcontrol,
		c.SubcontrolHistory, c.Subscriber, c.TFASetting, c.Task, c.TaskHistory,
		c.Template, c.TemplateHistory, c.User, c.UserHistory, c.UserSetting,
		c.UserSettingHistory, c.Webauthn, c.Webhook, c.WebhookHistory,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIToken, c.ActionPlan, c.ActionPlanHistory, c.Contact, c.ContactHistory,
		c.Control, c.ControlHistory, c.ControlObjective, c.ControlObjectiveHistory,
		c.DocumentData, c.DocumentDataHistory, c.EmailVerificationToken, c.Entitlement,
		c.EntitlementHistory, c.EntitlementPlan, c.EntitlementPlanFeature,
		c.EntitlementPlanFeatureHistory, c.EntitlementPlanHistory, c.Entity,
		c.EntityHistory, c.EntityType, c.EntityTypeHistory, c.Event, c.EventHistory,
		c.Feature, c.FeatureHistory, c.File, c.FileHistory, c.Group, c.GroupHistory,
		c.GroupMembership, c.GroupMembershipHistory, c.GroupSetting,
		c.GroupSettingHistory, c.Hush, c.HushHistory, c.Integration,
		c.IntegrationHistory, c.InternalPolicy, c.InternalPolicyHistory, c.Invite,
		c.Narrative, c.NarrativeHistory, c.Note, c.NoteHistory, c.OauthProvider,
		c.OauthProviderHistory, c.OhAuthTooToken, c.OrgMembership,
		c.OrgMembershipHistory, c.Organization, c.OrganizationHistory,
		c.OrganizationSetting, c.OrganizationSettingHistory, c.PasswordResetToken,
		c.PersonalAccessToken, c.Procedure, c.ProcedureHistory, c.Program,
		c.ProgramHistory, c.ProgramMembership, c.ProgramMembershipHistory, c.Risk,
		c.RiskHistory, c.Standard, c.StandardHistory, c.Subcontrol,
		c.SubcontrolHistory, c.Subscriber, c.TFASetting, c.Task, c.TaskHistory,
		c.Template, c.TemplateHistory, c.User, c.UserHistory, c.UserSetting,
		c.UserSettingHistory, c.Webauthn, c.Webhook, c.WebhookHistory,
	} {
		n.Intercept(interceptors...)
	}
}

// WithAuthz adds the authz hooks to the appropriate schemas - generated by entfga
func (c *Client) WithAuthz() {
	if !c.authzActivated {

		for _, hook := range entfga.AuthzHooks[*GroupMembershipMutation]() {
			c.GroupMembership.Use(hook)
		}

		for _, hook := range entfga.AuthzHooks[*OrgMembershipMutation]() {
			c.OrgMembership.Use(hook)
		}

		for _, hook := range entfga.AuthzHooks[*ProgramMembershipMutation]() {
			c.ProgramMembership.Use(hook)
		}

		c.authzActivated = true
	}
}

// CloseAll closes the all database client connections
func (c *Client) CloseAll() error {
	if err := c.Job.Close(); err != nil {
		return err
	}

	return c.Close()
}

// Dialect returns the driver dialect.
func (c *Client) Dialect() string {
	return c.driver.Dialect()
}

// Driver returns the underlying driver.
func (c *Client) Driver() dialect.Driver {
	return c.driver
}

// DB returns the underlying *sql.DB.
func (c *Client) DB() *stdsql.DB {
	switch c.driver.(type) {
	case *sql.Driver: // default
		return c.driver.(*sql.Driver).DB()
	case *entcache.Driver: // when using entcache we need to unwrap the driver
		return c.driver.(*entcache.Driver).Driver.(*sql.Driver).DB()
	case *dialect.DebugDriver: // when the ent debug driver is used
		driver := c.driver.(*dialect.DebugDriver)

		switch driver.Driver.(type) {
		case *sql.Driver: // default
			return driver.Driver.(*sql.Driver).DB()
		case *entcache.Driver: // when using entcache we need to unwrap the driver
			return driver.Driver.(*entcache.Driver).Driver.(*sql.Driver).DB()
		default:
			panic(fmt.Sprintf("ent: unknown driver type: %T", driver))
		}
	default:
		panic(fmt.Sprintf("ent: unknown driver type: %T", c.driver))
	}
}

// WithJobClient adds the job client to the database client based on the configuration.
func (c *Client) WithJobClient() {
	c.Job = NewJobClient(c.config)
}

// NewJobClient returns a new job client based on the configuration.
func NewJobClient(c config) riverqueue.JobClient {
	return c.Job
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APITokenMutation:
		return c.APIToken.mutate(ctx, m)
	case *ActionPlanMutation:
		return c.ActionPlan.mutate(ctx, m)
	case *ActionPlanHistoryMutation:
		return c.ActionPlanHistory.mutate(ctx, m)
	case *ContactMutation:
		return c.Contact.mutate(ctx, m)
	case *ContactHistoryMutation:
		return c.ContactHistory.mutate(ctx, m)
	case *ControlMutation:
		return c.Control.mutate(ctx, m)
	case *ControlHistoryMutation:
		return c.ControlHistory.mutate(ctx, m)
	case *ControlObjectiveMutation:
		return c.ControlObjective.mutate(ctx, m)
	case *ControlObjectiveHistoryMutation:
		return c.ControlObjectiveHistory.mutate(ctx, m)
	case *DocumentDataMutation:
		return c.DocumentData.mutate(ctx, m)
	case *DocumentDataHistoryMutation:
		return c.DocumentDataHistory.mutate(ctx, m)
	case *EmailVerificationTokenMutation:
		return c.EmailVerificationToken.mutate(ctx, m)
	case *EntitlementMutation:
		return c.Entitlement.mutate(ctx, m)
	case *EntitlementHistoryMutation:
		return c.EntitlementHistory.mutate(ctx, m)
	case *EntitlementPlanMutation:
		return c.EntitlementPlan.mutate(ctx, m)
	case *EntitlementPlanFeatureMutation:
		return c.EntitlementPlanFeature.mutate(ctx, m)
	case *EntitlementPlanFeatureHistoryMutation:
		return c.EntitlementPlanFeatureHistory.mutate(ctx, m)
	case *EntitlementPlanHistoryMutation:
		return c.EntitlementPlanHistory.mutate(ctx, m)
	case *EntityMutation:
		return c.Entity.mutate(ctx, m)
	case *EntityHistoryMutation:
		return c.EntityHistory.mutate(ctx, m)
	case *EntityTypeMutation:
		return c.EntityType.mutate(ctx, m)
	case *EntityTypeHistoryMutation:
		return c.EntityTypeHistory.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventHistoryMutation:
		return c.EventHistory.mutate(ctx, m)
	case *FeatureMutation:
		return c.Feature.mutate(ctx, m)
	case *FeatureHistoryMutation:
		return c.FeatureHistory.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *FileHistoryMutation:
		return c.FileHistory.mutate(ctx, m)
	case *GroupMutation:
		return c.Group.mutate(ctx, m)
	case *GroupHistoryMutation:
		return c.GroupHistory.mutate(ctx, m)
	case *GroupMembershipMutation:
		return c.GroupMembership.mutate(ctx, m)
	case *GroupMembershipHistoryMutation:
		return c.GroupMembershipHistory.mutate(ctx, m)
	case *GroupSettingMutation:
		return c.GroupSetting.mutate(ctx, m)
	case *GroupSettingHistoryMutation:
		return c.GroupSettingHistory.mutate(ctx, m)
	case *HushMutation:
		return c.Hush.mutate(ctx, m)
	case *HushHistoryMutation:
		return c.HushHistory.mutate(ctx, m)
	case *IntegrationMutation:
		return c.Integration.mutate(ctx, m)
	case *IntegrationHistoryMutation:
		return c.IntegrationHistory.mutate(ctx, m)
	case *InternalPolicyMutation:
		return c.InternalPolicy.mutate(ctx, m)
	case *InternalPolicyHistoryMutation:
		return c.InternalPolicyHistory.mutate(ctx, m)
	case *InviteMutation:
		return c.Invite.mutate(ctx, m)
	case *NarrativeMutation:
		return c.Narrative.mutate(ctx, m)
	case *NarrativeHistoryMutation:
		return c.NarrativeHistory.mutate(ctx, m)
	case *NoteMutation:
		return c.Note.mutate(ctx, m)
	case *NoteHistoryMutation:
		return c.NoteHistory.mutate(ctx, m)
	case *OauthProviderMutation:
		return c.OauthProvider.mutate(ctx, m)
	case *OauthProviderHistoryMutation:
		return c.OauthProviderHistory.mutate(ctx, m)
	case *OhAuthTooTokenMutation:
		return c.OhAuthTooToken.mutate(ctx, m)
	case *OrgMembershipMutation:
		return c.OrgMembership.mutate(ctx, m)
	case *OrgMembershipHistoryMutation:
		return c.OrgMembershipHistory.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *OrganizationHistoryMutation:
		return c.OrganizationHistory.mutate(ctx, m)
	case *OrganizationSettingMutation:
		return c.OrganizationSetting.mutate(ctx, m)
	case *OrganizationSettingHistoryMutation:
		return c.OrganizationSettingHistory.mutate(ctx, m)
	case *PasswordResetTokenMutation:
		return c.PasswordResetToken.mutate(ctx, m)
	case *PersonalAccessTokenMutation:
		return c.PersonalAccessToken.mutate(ctx, m)
	case *ProcedureMutation:
		return c.Procedure.mutate(ctx, m)
	case *ProcedureHistoryMutation:
		return c.ProcedureHistory.mutate(ctx, m)
	case *ProgramMutation:
		return c.Program.mutate(ctx, m)
	case *ProgramHistoryMutation:
		return c.ProgramHistory.mutate(ctx, m)
	case *ProgramMembershipMutation:
		return c.ProgramMembership.mutate(ctx, m)
	case *ProgramMembershipHistoryMutation:
		return c.ProgramMembershipHistory.mutate(ctx, m)
	case *RiskMutation:
		return c.Risk.mutate(ctx, m)
	case *RiskHistoryMutation:
		return c.RiskHistory.mutate(ctx, m)
	case *StandardMutation:
		return c.Standard.mutate(ctx, m)
	case *StandardHistoryMutation:
		return c.StandardHistory.mutate(ctx, m)
	case *SubcontrolMutation:
		return c.Subcontrol.mutate(ctx, m)
	case *SubcontrolHistoryMutation:
		return c.SubcontrolHistory.mutate(ctx, m)
	case *SubscriberMutation:
		return c.Subscriber.mutate(ctx, m)
	case *TFASettingMutation:
		return c.TFASetting.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TaskHistoryMutation:
		return c.TaskHistory.mutate(ctx, m)
	case *TemplateMutation:
		return c.Template.mutate(ctx, m)
	case *TemplateHistoryMutation:
		return c.TemplateHistory.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserHistoryMutation:
		return c.UserHistory.mutate(ctx, m)
	case *UserSettingMutation:
		return c.UserSetting.mutate(ctx, m)
	case *UserSettingHistoryMutation:
		return c.UserSettingHistory.mutate(ctx, m)
	case *WebauthnMutation:
		return c.Webauthn.mutate(ctx, m)
	case *WebhookMutation:
		return c.Webhook.mutate(ctx, m)
	case *WebhookHistoryMutation:
		return c.WebhookHistory.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// APITokenClient is a client for the APIToken schema.
type APITokenClient struct {
	config
}

// NewAPITokenClient returns a client for the APIToken from the given config.
func NewAPITokenClient(c config) *APITokenClient {
	return &APITokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apitoken.Hooks(f(g(h())))`.
func (c *APITokenClient) Use(hooks ...Hook) {
	c.hooks.APIToken = append(c.hooks.APIToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apitoken.Intercept(f(g(h())))`.
func (c *APITokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIToken = append(c.inters.APIToken, interceptors...)
}

// Create returns a builder for creating a APIToken entity.
func (c *APITokenClient) Create() *APITokenCreate {
	mutation := newAPITokenMutation(c.config, OpCreate)
	return &APITokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIToken entities.
func (c *APITokenClient) CreateBulk(builders ...*APITokenCreate) *APITokenCreateBulk {
	return &APITokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APITokenClient) MapCreateBulk(slice any, setFunc func(*APITokenCreate, int)) *APITokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APITokenCreateBulk{err: fmt.Errorf("calling to APITokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APITokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APITokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIToken.
func (c *APITokenClient) Update() *APITokenUpdate {
	mutation := newAPITokenMutation(c.config, OpUpdate)
	return &APITokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APITokenClient) UpdateOne(at *APIToken) *APITokenUpdateOne {
	mutation := newAPITokenMutation(c.config, OpUpdateOne, withAPIToken(at))
	return &APITokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APITokenClient) UpdateOneID(id string) *APITokenUpdateOne {
	mutation := newAPITokenMutation(c.config, OpUpdateOne, withAPITokenID(id))
	return &APITokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIToken.
func (c *APITokenClient) Delete() *APITokenDelete {
	mutation := newAPITokenMutation(c.config, OpDelete)
	return &APITokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APITokenClient) DeleteOne(at *APIToken) *APITokenDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APITokenClient) DeleteOneID(id string) *APITokenDeleteOne {
	builder := c.Delete().Where(apitoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APITokenDeleteOne{builder}
}

// Query returns a query builder for APIToken.
func (c *APITokenClient) Query() *APITokenQuery {
	return &APITokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIToken},
		inters: c.Interceptors(),
	}
}

// Get returns a APIToken entity by its id.
func (c *APITokenClient) Get(ctx context.Context, id string) (*APIToken, error) {
	return c.Query().Where(apitoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APITokenClient) GetX(ctx context.Context, id string) *APIToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a APIToken.
func (c *APITokenClient) QueryOwner(at *APIToken) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apitoken.Table, apitoken.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apitoken.OwnerTable, apitoken.OwnerColumn),
		)
		schemaConfig := at.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.APIToken
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APITokenClient) Hooks() []Hook {
	hooks := c.hooks.APIToken
	return append(hooks[:len(hooks):len(hooks)], apitoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *APITokenClient) Interceptors() []Interceptor {
	inters := c.inters.APIToken
	return append(inters[:len(inters):len(inters)], apitoken.Interceptors[:]...)
}

func (c *APITokenClient) mutate(ctx context.Context, m *APITokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APITokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APITokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APITokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APITokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown APIToken mutation op: %q", m.Op())
	}
}

// ActionPlanClient is a client for the ActionPlan schema.
type ActionPlanClient struct {
	config
}

// NewActionPlanClient returns a client for the ActionPlan from the given config.
func NewActionPlanClient(c config) *ActionPlanClient {
	return &ActionPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actionplan.Hooks(f(g(h())))`.
func (c *ActionPlanClient) Use(hooks ...Hook) {
	c.hooks.ActionPlan = append(c.hooks.ActionPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actionplan.Intercept(f(g(h())))`.
func (c *ActionPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionPlan = append(c.inters.ActionPlan, interceptors...)
}

// Create returns a builder for creating a ActionPlan entity.
func (c *ActionPlanClient) Create() *ActionPlanCreate {
	mutation := newActionPlanMutation(c.config, OpCreate)
	return &ActionPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionPlan entities.
func (c *ActionPlanClient) CreateBulk(builders ...*ActionPlanCreate) *ActionPlanCreateBulk {
	return &ActionPlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionPlanClient) MapCreateBulk(slice any, setFunc func(*ActionPlanCreate, int)) *ActionPlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionPlanCreateBulk{err: fmt.Errorf("calling to ActionPlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionPlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionPlan.
func (c *ActionPlanClient) Update() *ActionPlanUpdate {
	mutation := newActionPlanMutation(c.config, OpUpdate)
	return &ActionPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionPlanClient) UpdateOne(ap *ActionPlan) *ActionPlanUpdateOne {
	mutation := newActionPlanMutation(c.config, OpUpdateOne, withActionPlan(ap))
	return &ActionPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionPlanClient) UpdateOneID(id string) *ActionPlanUpdateOne {
	mutation := newActionPlanMutation(c.config, OpUpdateOne, withActionPlanID(id))
	return &ActionPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionPlan.
func (c *ActionPlanClient) Delete() *ActionPlanDelete {
	mutation := newActionPlanMutation(c.config, OpDelete)
	return &ActionPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionPlanClient) DeleteOne(ap *ActionPlan) *ActionPlanDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionPlanClient) DeleteOneID(id string) *ActionPlanDeleteOne {
	builder := c.Delete().Where(actionplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionPlanDeleteOne{builder}
}

// Query returns a query builder for ActionPlan.
func (c *ActionPlanClient) Query() *ActionPlanQuery {
	return &ActionPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionPlan entity by its id.
func (c *ActionPlanClient) Get(ctx context.Context, id string) (*ActionPlan, error) {
	return c.Query().Where(actionplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionPlanClient) GetX(ctx context.Context, id string) *ActionPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStandard queries the standard edge of a ActionPlan.
func (c *ActionPlanClient) QueryStandard(ap *ActionPlan) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.StandardTable, actionplan.StandardPrimaryKey...),
		)
		schemaConfig := ap.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.StandardActionplans
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisk queries the risk edge of a ActionPlan.
func (c *ActionPlanClient) QueryRisk(ap *ActionPlan) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.RiskTable, actionplan.RiskPrimaryKey...),
		)
		schemaConfig := ap.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.RiskActionplans
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a ActionPlan.
func (c *ActionPlanClient) QueryControl(ap *ActionPlan) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.ControlTable, actionplan.ControlPrimaryKey...),
		)
		schemaConfig := ap.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlActionplans
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ActionPlan.
func (c *ActionPlanClient) QueryUser(ap *ActionPlan) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.UserTable, actionplan.UserPrimaryKey...),
		)
		schemaConfig := ap.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserActionplans
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a ActionPlan.
func (c *ActionPlanClient) QueryProgram(ap *ActionPlan) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionplan.Table, actionplan.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, actionplan.ProgramTable, actionplan.ProgramPrimaryKey...),
		)
		schemaConfig := ap.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramActionplans
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionPlanClient) Hooks() []Hook {
	hooks := c.hooks.ActionPlan
	return append(hooks[:len(hooks):len(hooks)], actionplan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ActionPlanClient) Interceptors() []Interceptor {
	inters := c.inters.ActionPlan
	return append(inters[:len(inters):len(inters)], actionplan.Interceptors[:]...)
}

func (c *ActionPlanClient) mutate(ctx context.Context, m *ActionPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ActionPlan mutation op: %q", m.Op())
	}
}

// ActionPlanHistoryClient is a client for the ActionPlanHistory schema.
type ActionPlanHistoryClient struct {
	config
}

// NewActionPlanHistoryClient returns a client for the ActionPlanHistory from the given config.
func NewActionPlanHistoryClient(c config) *ActionPlanHistoryClient {
	return &ActionPlanHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actionplanhistory.Hooks(f(g(h())))`.
func (c *ActionPlanHistoryClient) Use(hooks ...Hook) {
	c.hooks.ActionPlanHistory = append(c.hooks.ActionPlanHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actionplanhistory.Intercept(f(g(h())))`.
func (c *ActionPlanHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionPlanHistory = append(c.inters.ActionPlanHistory, interceptors...)
}

// Create returns a builder for creating a ActionPlanHistory entity.
func (c *ActionPlanHistoryClient) Create() *ActionPlanHistoryCreate {
	mutation := newActionPlanHistoryMutation(c.config, OpCreate)
	return &ActionPlanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionPlanHistory entities.
func (c *ActionPlanHistoryClient) CreateBulk(builders ...*ActionPlanHistoryCreate) *ActionPlanHistoryCreateBulk {
	return &ActionPlanHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionPlanHistoryClient) MapCreateBulk(slice any, setFunc func(*ActionPlanHistoryCreate, int)) *ActionPlanHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionPlanHistoryCreateBulk{err: fmt.Errorf("calling to ActionPlanHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionPlanHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionPlanHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionPlanHistory.
func (c *ActionPlanHistoryClient) Update() *ActionPlanHistoryUpdate {
	mutation := newActionPlanHistoryMutation(c.config, OpUpdate)
	return &ActionPlanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionPlanHistoryClient) UpdateOne(aph *ActionPlanHistory) *ActionPlanHistoryUpdateOne {
	mutation := newActionPlanHistoryMutation(c.config, OpUpdateOne, withActionPlanHistory(aph))
	return &ActionPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionPlanHistoryClient) UpdateOneID(id string) *ActionPlanHistoryUpdateOne {
	mutation := newActionPlanHistoryMutation(c.config, OpUpdateOne, withActionPlanHistoryID(id))
	return &ActionPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionPlanHistory.
func (c *ActionPlanHistoryClient) Delete() *ActionPlanHistoryDelete {
	mutation := newActionPlanHistoryMutation(c.config, OpDelete)
	return &ActionPlanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionPlanHistoryClient) DeleteOne(aph *ActionPlanHistory) *ActionPlanHistoryDeleteOne {
	return c.DeleteOneID(aph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionPlanHistoryClient) DeleteOneID(id string) *ActionPlanHistoryDeleteOne {
	builder := c.Delete().Where(actionplanhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionPlanHistoryDeleteOne{builder}
}

// Query returns a query builder for ActionPlanHistory.
func (c *ActionPlanHistoryClient) Query() *ActionPlanHistoryQuery {
	return &ActionPlanHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionPlanHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionPlanHistory entity by its id.
func (c *ActionPlanHistoryClient) Get(ctx context.Context, id string) (*ActionPlanHistory, error) {
	return c.Query().Where(actionplanhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionPlanHistoryClient) GetX(ctx context.Context, id string) *ActionPlanHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ActionPlanHistoryClient) Hooks() []Hook {
	return c.hooks.ActionPlanHistory
}

// Interceptors returns the client interceptors.
func (c *ActionPlanHistoryClient) Interceptors() []Interceptor {
	return c.inters.ActionPlanHistory
}

func (c *ActionPlanHistoryClient) mutate(ctx context.Context, m *ActionPlanHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionPlanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionPlanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionPlanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ActionPlanHistory mutation op: %q", m.Op())
	}
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contact.Hooks(f(g(h())))`.
func (c *ContactClient) Use(hooks ...Hook) {
	c.hooks.Contact = append(c.hooks.Contact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contact.Intercept(f(g(h())))`.
func (c *ContactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contact = append(c.inters.Contact, interceptors...)
}

// Create returns a builder for creating a Contact entity.
func (c *ContactClient) Create() *ContactCreate {
	mutation := newContactMutation(c.config, OpCreate)
	return &ContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contact entities.
func (c *ContactClient) CreateBulk(builders ...*ContactCreate) *ContactCreateBulk {
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContactClient) MapCreateBulk(slice any, setFunc func(*ContactCreate, int)) *ContactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContactCreateBulk{err: fmt.Errorf("calling to ContactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	mutation := newContactMutation(c.config, OpUpdate)
	return &ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(co *Contact) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContact(co))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id string) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContactID(id))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	mutation := newContactMutation(c.config, OpDelete)
	return &ContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactClient) DeleteOne(co *Contact) *ContactDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactClient) DeleteOneID(id string) *ContactDeleteOne {
	builder := c.Delete().Where(contact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactDeleteOne{builder}
}

// Query returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContact},
		inters: c.Interceptors(),
	}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id string) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id string) *Contact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Contact.
func (c *ContactClient) QueryOwner(co *Contact) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.OwnerTable, contact.OwnerColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Contact
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Contact.
func (c *ContactClient) QueryEntities(co *Contact) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, contact.EntitiesTable, contact.EntitiesPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityContacts
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Contact.
func (c *ContactClient) QueryFiles(co *Contact) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, contact.FilesTable, contact.FilesPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.ContactFiles
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContactClient) Hooks() []Hook {
	hooks := c.hooks.Contact
	return append(hooks[:len(hooks):len(hooks)], contact.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ContactClient) Interceptors() []Interceptor {
	inters := c.inters.Contact
	return append(inters[:len(inters):len(inters)], contact.Interceptors[:]...)
}

func (c *ContactClient) mutate(ctx context.Context, m *ContactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Contact mutation op: %q", m.Op())
	}
}

// ContactHistoryClient is a client for the ContactHistory schema.
type ContactHistoryClient struct {
	config
}

// NewContactHistoryClient returns a client for the ContactHistory from the given config.
func NewContactHistoryClient(c config) *ContactHistoryClient {
	return &ContactHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contacthistory.Hooks(f(g(h())))`.
func (c *ContactHistoryClient) Use(hooks ...Hook) {
	c.hooks.ContactHistory = append(c.hooks.ContactHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contacthistory.Intercept(f(g(h())))`.
func (c *ContactHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContactHistory = append(c.inters.ContactHistory, interceptors...)
}

// Create returns a builder for creating a ContactHistory entity.
func (c *ContactHistoryClient) Create() *ContactHistoryCreate {
	mutation := newContactHistoryMutation(c.config, OpCreate)
	return &ContactHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContactHistory entities.
func (c *ContactHistoryClient) CreateBulk(builders ...*ContactHistoryCreate) *ContactHistoryCreateBulk {
	return &ContactHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContactHistoryClient) MapCreateBulk(slice any, setFunc func(*ContactHistoryCreate, int)) *ContactHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContactHistoryCreateBulk{err: fmt.Errorf("calling to ContactHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContactHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContactHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContactHistory.
func (c *ContactHistoryClient) Update() *ContactHistoryUpdate {
	mutation := newContactHistoryMutation(c.config, OpUpdate)
	return &ContactHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactHistoryClient) UpdateOne(ch *ContactHistory) *ContactHistoryUpdateOne {
	mutation := newContactHistoryMutation(c.config, OpUpdateOne, withContactHistory(ch))
	return &ContactHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactHistoryClient) UpdateOneID(id string) *ContactHistoryUpdateOne {
	mutation := newContactHistoryMutation(c.config, OpUpdateOne, withContactHistoryID(id))
	return &ContactHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContactHistory.
func (c *ContactHistoryClient) Delete() *ContactHistoryDelete {
	mutation := newContactHistoryMutation(c.config, OpDelete)
	return &ContactHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactHistoryClient) DeleteOne(ch *ContactHistory) *ContactHistoryDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactHistoryClient) DeleteOneID(id string) *ContactHistoryDeleteOne {
	builder := c.Delete().Where(contacthistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactHistoryDeleteOne{builder}
}

// Query returns a query builder for ContactHistory.
func (c *ContactHistoryClient) Query() *ContactHistoryQuery {
	return &ContactHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContactHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ContactHistory entity by its id.
func (c *ContactHistoryClient) Get(ctx context.Context, id string) (*ContactHistory, error) {
	return c.Query().Where(contacthistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactHistoryClient) GetX(ctx context.Context, id string) *ContactHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContactHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ContactHistory
	return append(hooks[:len(hooks):len(hooks)], contacthistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ContactHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ContactHistory
	return append(inters[:len(inters):len(inters)], contacthistory.Interceptors[:]...)
}

func (c *ContactHistoryClient) mutate(ctx context.Context, m *ContactHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContactHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContactHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContactHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContactHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ContactHistory mutation op: %q", m.Op())
	}
}

// ControlClient is a client for the Control schema.
type ControlClient struct {
	config
}

// NewControlClient returns a client for the Control from the given config.
func NewControlClient(c config) *ControlClient {
	return &ControlClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `control.Hooks(f(g(h())))`.
func (c *ControlClient) Use(hooks ...Hook) {
	c.hooks.Control = append(c.hooks.Control, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `control.Intercept(f(g(h())))`.
func (c *ControlClient) Intercept(interceptors ...Interceptor) {
	c.inters.Control = append(c.inters.Control, interceptors...)
}

// Create returns a builder for creating a Control entity.
func (c *ControlClient) Create() *ControlCreate {
	mutation := newControlMutation(c.config, OpCreate)
	return &ControlCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Control entities.
func (c *ControlClient) CreateBulk(builders ...*ControlCreate) *ControlCreateBulk {
	return &ControlCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlClient) MapCreateBulk(slice any, setFunc func(*ControlCreate, int)) *ControlCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlCreateBulk{err: fmt.Errorf("calling to ControlClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Control.
func (c *ControlClient) Update() *ControlUpdate {
	mutation := newControlMutation(c.config, OpUpdate)
	return &ControlUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlClient) UpdateOne(co *Control) *ControlUpdateOne {
	mutation := newControlMutation(c.config, OpUpdateOne, withControl(co))
	return &ControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlClient) UpdateOneID(id string) *ControlUpdateOne {
	mutation := newControlMutation(c.config, OpUpdateOne, withControlID(id))
	return &ControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Control.
func (c *ControlClient) Delete() *ControlDelete {
	mutation := newControlMutation(c.config, OpDelete)
	return &ControlDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlClient) DeleteOne(co *Control) *ControlDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlClient) DeleteOneID(id string) *ControlDeleteOne {
	builder := c.Delete().Where(control.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlDeleteOne{builder}
}

// Query returns a query builder for Control.
func (c *ControlClient) Query() *ControlQuery {
	return &ControlQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControl},
		inters: c.Interceptors(),
	}
}

// Get returns a Control entity by its id.
func (c *ControlClient) Get(ctx context.Context, id string) (*Control, error) {
	return c.Query().Where(control.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlClient) GetX(ctx context.Context, id string) *Control {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProcedures queries the procedures edge of a Control.
func (c *ControlClient) QueryProcedures(co *Control) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.ProceduresTable, control.ProceduresPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ControlProcedures
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Control.
func (c *ControlClient) QuerySubcontrols(co *Control) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.SubcontrolsTable, control.SubcontrolsPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.ControlSubcontrols
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlobjectives queries the controlobjectives edge of a Control.
func (c *ControlClient) QueryControlobjectives(co *Control) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, control.ControlobjectivesTable, control.ControlobjectivesColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjective
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandard queries the standard edge of a Control.
func (c *ControlClient) QueryStandard(co *Control) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.StandardTable, control.StandardPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.StandardControls
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Control.
func (c *ControlClient) QueryNarratives(co *Control) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.NarrativesTable, control.NarrativesPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ControlNarratives
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Control.
func (c *ControlClient) QueryRisks(co *Control) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.RisksTable, control.RisksPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.ControlRisks
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionplans queries the actionplans edge of a Control.
func (c *ControlClient) QueryActionplans(co *Control) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.ActionplansTable, control.ActionplansPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ControlActionplans
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Control.
func (c *ControlClient) QueryTasks(co *Control) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, control.TasksTable, control.TasksPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ControlTasks
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Control.
func (c *ControlClient) QueryPrograms(co *Control) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(control.Table, control.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, control.ProgramsTable, control.ProgramsPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramControls
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ControlClient) Hooks() []Hook {
	hooks := c.hooks.Control
	return append(hooks[:len(hooks):len(hooks)], control.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlClient) Interceptors() []Interceptor {
	inters := c.inters.Control
	return append(inters[:len(inters):len(inters)], control.Interceptors[:]...)
}

func (c *ControlClient) mutate(ctx context.Context, m *ControlMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Control mutation op: %q", m.Op())
	}
}

// ControlHistoryClient is a client for the ControlHistory schema.
type ControlHistoryClient struct {
	config
}

// NewControlHistoryClient returns a client for the ControlHistory from the given config.
func NewControlHistoryClient(c config) *ControlHistoryClient {
	return &ControlHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlhistory.Hooks(f(g(h())))`.
func (c *ControlHistoryClient) Use(hooks ...Hook) {
	c.hooks.ControlHistory = append(c.hooks.ControlHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlhistory.Intercept(f(g(h())))`.
func (c *ControlHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlHistory = append(c.inters.ControlHistory, interceptors...)
}

// Create returns a builder for creating a ControlHistory entity.
func (c *ControlHistoryClient) Create() *ControlHistoryCreate {
	mutation := newControlHistoryMutation(c.config, OpCreate)
	return &ControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlHistory entities.
func (c *ControlHistoryClient) CreateBulk(builders ...*ControlHistoryCreate) *ControlHistoryCreateBulk {
	return &ControlHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlHistoryClient) MapCreateBulk(slice any, setFunc func(*ControlHistoryCreate, int)) *ControlHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlHistoryCreateBulk{err: fmt.Errorf("calling to ControlHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlHistory.
func (c *ControlHistoryClient) Update() *ControlHistoryUpdate {
	mutation := newControlHistoryMutation(c.config, OpUpdate)
	return &ControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlHistoryClient) UpdateOne(ch *ControlHistory) *ControlHistoryUpdateOne {
	mutation := newControlHistoryMutation(c.config, OpUpdateOne, withControlHistory(ch))
	return &ControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlHistoryClient) UpdateOneID(id string) *ControlHistoryUpdateOne {
	mutation := newControlHistoryMutation(c.config, OpUpdateOne, withControlHistoryID(id))
	return &ControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlHistory.
func (c *ControlHistoryClient) Delete() *ControlHistoryDelete {
	mutation := newControlHistoryMutation(c.config, OpDelete)
	return &ControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlHistoryClient) DeleteOne(ch *ControlHistory) *ControlHistoryDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlHistoryClient) DeleteOneID(id string) *ControlHistoryDeleteOne {
	builder := c.Delete().Where(controlhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlHistoryDeleteOne{builder}
}

// Query returns a query builder for ControlHistory.
func (c *ControlHistoryClient) Query() *ControlHistoryQuery {
	return &ControlHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlHistory entity by its id.
func (c *ControlHistoryClient) Get(ctx context.Context, id string) (*ControlHistory, error) {
	return c.Query().Where(controlhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlHistoryClient) GetX(ctx context.Context, id string) *ControlHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ControlHistoryClient) Hooks() []Hook {
	return c.hooks.ControlHistory
}

// Interceptors returns the client interceptors.
func (c *ControlHistoryClient) Interceptors() []Interceptor {
	return c.inters.ControlHistory
}

func (c *ControlHistoryClient) mutate(ctx context.Context, m *ControlHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlHistory mutation op: %q", m.Op())
	}
}

// ControlObjectiveClient is a client for the ControlObjective schema.
type ControlObjectiveClient struct {
	config
}

// NewControlObjectiveClient returns a client for the ControlObjective from the given config.
func NewControlObjectiveClient(c config) *ControlObjectiveClient {
	return &ControlObjectiveClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlobjective.Hooks(f(g(h())))`.
func (c *ControlObjectiveClient) Use(hooks ...Hook) {
	c.hooks.ControlObjective = append(c.hooks.ControlObjective, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlobjective.Intercept(f(g(h())))`.
func (c *ControlObjectiveClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlObjective = append(c.inters.ControlObjective, interceptors...)
}

// Create returns a builder for creating a ControlObjective entity.
func (c *ControlObjectiveClient) Create() *ControlObjectiveCreate {
	mutation := newControlObjectiveMutation(c.config, OpCreate)
	return &ControlObjectiveCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlObjective entities.
func (c *ControlObjectiveClient) CreateBulk(builders ...*ControlObjectiveCreate) *ControlObjectiveCreateBulk {
	return &ControlObjectiveCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlObjectiveClient) MapCreateBulk(slice any, setFunc func(*ControlObjectiveCreate, int)) *ControlObjectiveCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlObjectiveCreateBulk{err: fmt.Errorf("calling to ControlObjectiveClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlObjectiveCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlObjectiveCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlObjective.
func (c *ControlObjectiveClient) Update() *ControlObjectiveUpdate {
	mutation := newControlObjectiveMutation(c.config, OpUpdate)
	return &ControlObjectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlObjectiveClient) UpdateOne(co *ControlObjective) *ControlObjectiveUpdateOne {
	mutation := newControlObjectiveMutation(c.config, OpUpdateOne, withControlObjective(co))
	return &ControlObjectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlObjectiveClient) UpdateOneID(id string) *ControlObjectiveUpdateOne {
	mutation := newControlObjectiveMutation(c.config, OpUpdateOne, withControlObjectiveID(id))
	return &ControlObjectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlObjective.
func (c *ControlObjectiveClient) Delete() *ControlObjectiveDelete {
	mutation := newControlObjectiveMutation(c.config, OpDelete)
	return &ControlObjectiveDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlObjectiveClient) DeleteOne(co *ControlObjective) *ControlObjectiveDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlObjectiveClient) DeleteOneID(id string) *ControlObjectiveDeleteOne {
	builder := c.Delete().Where(controlobjective.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlObjectiveDeleteOne{builder}
}

// Query returns a query builder for ControlObjective.
func (c *ControlObjectiveClient) Query() *ControlObjectiveQuery {
	return &ControlObjectiveQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlObjective},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlObjective entity by its id.
func (c *ControlObjectiveClient) Get(ctx context.Context, id string) (*ControlObjective, error) {
	return c.Query().Where(controlobjective.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlObjectiveClient) GetX(ctx context.Context, id string) *ControlObjective {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPolicy queries the policy edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryPolicy(co *ControlObjective) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.PolicyTable, controlobjective.PolicyPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyControlobjectives
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryControls(co *ControlObjective) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.ControlsTable, controlobjective.ControlsColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryProcedures(co *ControlObjective) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.ProceduresTable, controlobjective.ProceduresColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryRisks(co *ControlObjective) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.RisksTable, controlobjective.RisksColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.Risk
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a ControlObjective.
func (c *ControlObjectiveClient) QuerySubcontrols(co *ControlObjective) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, controlobjective.SubcontrolsTable, controlobjective.SubcontrolsColumn),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandard queries the standard edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryStandard(co *ControlObjective) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.StandardTable, controlobjective.StandardPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.StandardControlobjectives
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryNarratives(co *ControlObjective) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlobjective.NarrativesTable, controlobjective.NarrativesPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ControlObjectiveNarratives
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryTasks(co *ControlObjective) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, controlobjective.TasksTable, controlobjective.TasksPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ControlObjectiveTasks
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a ControlObjective.
func (c *ControlObjectiveClient) QueryPrograms(co *ControlObjective) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(controlobjective.Table, controlobjective.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, controlobjective.ProgramsTable, controlobjective.ProgramsPrimaryKey...),
		)
		schemaConfig := co.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramControlobjectives
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ControlObjectiveClient) Hooks() []Hook {
	hooks := c.hooks.ControlObjective
	return append(hooks[:len(hooks):len(hooks)], controlobjective.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ControlObjectiveClient) Interceptors() []Interceptor {
	inters := c.inters.ControlObjective
	return append(inters[:len(inters):len(inters)], controlobjective.Interceptors[:]...)
}

func (c *ControlObjectiveClient) mutate(ctx context.Context, m *ControlObjectiveMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlObjectiveCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlObjectiveUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlObjectiveUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlObjectiveDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlObjective mutation op: %q", m.Op())
	}
}

// ControlObjectiveHistoryClient is a client for the ControlObjectiveHistory schema.
type ControlObjectiveHistoryClient struct {
	config
}

// NewControlObjectiveHistoryClient returns a client for the ControlObjectiveHistory from the given config.
func NewControlObjectiveHistoryClient(c config) *ControlObjectiveHistoryClient {
	return &ControlObjectiveHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `controlobjectivehistory.Hooks(f(g(h())))`.
func (c *ControlObjectiveHistoryClient) Use(hooks ...Hook) {
	c.hooks.ControlObjectiveHistory = append(c.hooks.ControlObjectiveHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `controlobjectivehistory.Intercept(f(g(h())))`.
func (c *ControlObjectiveHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ControlObjectiveHistory = append(c.inters.ControlObjectiveHistory, interceptors...)
}

// Create returns a builder for creating a ControlObjectiveHistory entity.
func (c *ControlObjectiveHistoryClient) Create() *ControlObjectiveHistoryCreate {
	mutation := newControlObjectiveHistoryMutation(c.config, OpCreate)
	return &ControlObjectiveHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ControlObjectiveHistory entities.
func (c *ControlObjectiveHistoryClient) CreateBulk(builders ...*ControlObjectiveHistoryCreate) *ControlObjectiveHistoryCreateBulk {
	return &ControlObjectiveHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ControlObjectiveHistoryClient) MapCreateBulk(slice any, setFunc func(*ControlObjectiveHistoryCreate, int)) *ControlObjectiveHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ControlObjectiveHistoryCreateBulk{err: fmt.Errorf("calling to ControlObjectiveHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ControlObjectiveHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ControlObjectiveHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ControlObjectiveHistory.
func (c *ControlObjectiveHistoryClient) Update() *ControlObjectiveHistoryUpdate {
	mutation := newControlObjectiveHistoryMutation(c.config, OpUpdate)
	return &ControlObjectiveHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ControlObjectiveHistoryClient) UpdateOne(coh *ControlObjectiveHistory) *ControlObjectiveHistoryUpdateOne {
	mutation := newControlObjectiveHistoryMutation(c.config, OpUpdateOne, withControlObjectiveHistory(coh))
	return &ControlObjectiveHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ControlObjectiveHistoryClient) UpdateOneID(id string) *ControlObjectiveHistoryUpdateOne {
	mutation := newControlObjectiveHistoryMutation(c.config, OpUpdateOne, withControlObjectiveHistoryID(id))
	return &ControlObjectiveHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ControlObjectiveHistory.
func (c *ControlObjectiveHistoryClient) Delete() *ControlObjectiveHistoryDelete {
	mutation := newControlObjectiveHistoryMutation(c.config, OpDelete)
	return &ControlObjectiveHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ControlObjectiveHistoryClient) DeleteOne(coh *ControlObjectiveHistory) *ControlObjectiveHistoryDeleteOne {
	return c.DeleteOneID(coh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ControlObjectiveHistoryClient) DeleteOneID(id string) *ControlObjectiveHistoryDeleteOne {
	builder := c.Delete().Where(controlobjectivehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ControlObjectiveHistoryDeleteOne{builder}
}

// Query returns a query builder for ControlObjectiveHistory.
func (c *ControlObjectiveHistoryClient) Query() *ControlObjectiveHistoryQuery {
	return &ControlObjectiveHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeControlObjectiveHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ControlObjectiveHistory entity by its id.
func (c *ControlObjectiveHistoryClient) Get(ctx context.Context, id string) (*ControlObjectiveHistory, error) {
	return c.Query().Where(controlobjectivehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ControlObjectiveHistoryClient) GetX(ctx context.Context, id string) *ControlObjectiveHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ControlObjectiveHistoryClient) Hooks() []Hook {
	return c.hooks.ControlObjectiveHistory
}

// Interceptors returns the client interceptors.
func (c *ControlObjectiveHistoryClient) Interceptors() []Interceptor {
	return c.inters.ControlObjectiveHistory
}

func (c *ControlObjectiveHistoryClient) mutate(ctx context.Context, m *ControlObjectiveHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ControlObjectiveHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ControlObjectiveHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ControlObjectiveHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ControlObjectiveHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ControlObjectiveHistory mutation op: %q", m.Op())
	}
}

// DocumentDataClient is a client for the DocumentData schema.
type DocumentDataClient struct {
	config
}

// NewDocumentDataClient returns a client for the DocumentData from the given config.
func NewDocumentDataClient(c config) *DocumentDataClient {
	return &DocumentDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documentdata.Hooks(f(g(h())))`.
func (c *DocumentDataClient) Use(hooks ...Hook) {
	c.hooks.DocumentData = append(c.hooks.DocumentData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documentdata.Intercept(f(g(h())))`.
func (c *DocumentDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentData = append(c.inters.DocumentData, interceptors...)
}

// Create returns a builder for creating a DocumentData entity.
func (c *DocumentDataClient) Create() *DocumentDataCreate {
	mutation := newDocumentDataMutation(c.config, OpCreate)
	return &DocumentDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentData entities.
func (c *DocumentDataClient) CreateBulk(builders ...*DocumentDataCreate) *DocumentDataCreateBulk {
	return &DocumentDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentDataClient) MapCreateBulk(slice any, setFunc func(*DocumentDataCreate, int)) *DocumentDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentDataCreateBulk{err: fmt.Errorf("calling to DocumentDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentData.
func (c *DocumentDataClient) Update() *DocumentDataUpdate {
	mutation := newDocumentDataMutation(c.config, OpUpdate)
	return &DocumentDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentDataClient) UpdateOne(dd *DocumentData) *DocumentDataUpdateOne {
	mutation := newDocumentDataMutation(c.config, OpUpdateOne, withDocumentData(dd))
	return &DocumentDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentDataClient) UpdateOneID(id string) *DocumentDataUpdateOne {
	mutation := newDocumentDataMutation(c.config, OpUpdateOne, withDocumentDataID(id))
	return &DocumentDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentData.
func (c *DocumentDataClient) Delete() *DocumentDataDelete {
	mutation := newDocumentDataMutation(c.config, OpDelete)
	return &DocumentDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentDataClient) DeleteOne(dd *DocumentData) *DocumentDataDeleteOne {
	return c.DeleteOneID(dd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentDataClient) DeleteOneID(id string) *DocumentDataDeleteOne {
	builder := c.Delete().Where(documentdata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDataDeleteOne{builder}
}

// Query returns a query builder for DocumentData.
func (c *DocumentDataClient) Query() *DocumentDataQuery {
	return &DocumentDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentData},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentData entity by its id.
func (c *DocumentDataClient) Get(ctx context.Context, id string) (*DocumentData, error) {
	return c.Query().Where(documentdata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentDataClient) GetX(ctx context.Context, id string) *DocumentData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a DocumentData.
func (c *DocumentDataClient) QueryOwner(dd *DocumentData) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, documentdata.OwnerTable, documentdata.OwnerColumn),
		)
		schemaConfig := dd.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a DocumentData.
func (c *DocumentDataClient) QueryTemplate(dd *DocumentData) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, documentdata.TemplateTable, documentdata.TemplateColumn),
		)
		schemaConfig := dd.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntity queries the entity edge of a DocumentData.
func (c *DocumentDataClient) QueryEntity(dd *DocumentData) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, documentdata.EntityTable, documentdata.EntityPrimaryKey...),
		)
		schemaConfig := dd.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityDocuments
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a DocumentData.
func (c *DocumentDataClient) QueryFiles(dd *DocumentData) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentdata.Table, documentdata.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, documentdata.FilesTable, documentdata.FilesPrimaryKey...),
		)
		schemaConfig := dd.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.DocumentDataFiles
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentDataClient) Hooks() []Hook {
	hooks := c.hooks.DocumentData
	return append(hooks[:len(hooks):len(hooks)], documentdata.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DocumentDataClient) Interceptors() []Interceptor {
	inters := c.inters.DocumentData
	return append(inters[:len(inters):len(inters)], documentdata.Interceptors[:]...)
}

func (c *DocumentDataClient) mutate(ctx context.Context, m *DocumentDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DocumentData mutation op: %q", m.Op())
	}
}

// DocumentDataHistoryClient is a client for the DocumentDataHistory schema.
type DocumentDataHistoryClient struct {
	config
}

// NewDocumentDataHistoryClient returns a client for the DocumentDataHistory from the given config.
func NewDocumentDataHistoryClient(c config) *DocumentDataHistoryClient {
	return &DocumentDataHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documentdatahistory.Hooks(f(g(h())))`.
func (c *DocumentDataHistoryClient) Use(hooks ...Hook) {
	c.hooks.DocumentDataHistory = append(c.hooks.DocumentDataHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documentdatahistory.Intercept(f(g(h())))`.
func (c *DocumentDataHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentDataHistory = append(c.inters.DocumentDataHistory, interceptors...)
}

// Create returns a builder for creating a DocumentDataHistory entity.
func (c *DocumentDataHistoryClient) Create() *DocumentDataHistoryCreate {
	mutation := newDocumentDataHistoryMutation(c.config, OpCreate)
	return &DocumentDataHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentDataHistory entities.
func (c *DocumentDataHistoryClient) CreateBulk(builders ...*DocumentDataHistoryCreate) *DocumentDataHistoryCreateBulk {
	return &DocumentDataHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentDataHistoryClient) MapCreateBulk(slice any, setFunc func(*DocumentDataHistoryCreate, int)) *DocumentDataHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentDataHistoryCreateBulk{err: fmt.Errorf("calling to DocumentDataHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentDataHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentDataHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentDataHistory.
func (c *DocumentDataHistoryClient) Update() *DocumentDataHistoryUpdate {
	mutation := newDocumentDataHistoryMutation(c.config, OpUpdate)
	return &DocumentDataHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentDataHistoryClient) UpdateOne(ddh *DocumentDataHistory) *DocumentDataHistoryUpdateOne {
	mutation := newDocumentDataHistoryMutation(c.config, OpUpdateOne, withDocumentDataHistory(ddh))
	return &DocumentDataHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentDataHistoryClient) UpdateOneID(id string) *DocumentDataHistoryUpdateOne {
	mutation := newDocumentDataHistoryMutation(c.config, OpUpdateOne, withDocumentDataHistoryID(id))
	return &DocumentDataHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentDataHistory.
func (c *DocumentDataHistoryClient) Delete() *DocumentDataHistoryDelete {
	mutation := newDocumentDataHistoryMutation(c.config, OpDelete)
	return &DocumentDataHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentDataHistoryClient) DeleteOne(ddh *DocumentDataHistory) *DocumentDataHistoryDeleteOne {
	return c.DeleteOneID(ddh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentDataHistoryClient) DeleteOneID(id string) *DocumentDataHistoryDeleteOne {
	builder := c.Delete().Where(documentdatahistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDataHistoryDeleteOne{builder}
}

// Query returns a query builder for DocumentDataHistory.
func (c *DocumentDataHistoryClient) Query() *DocumentDataHistoryQuery {
	return &DocumentDataHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentDataHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentDataHistory entity by its id.
func (c *DocumentDataHistoryClient) Get(ctx context.Context, id string) (*DocumentDataHistory, error) {
	return c.Query().Where(documentdatahistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentDataHistoryClient) GetX(ctx context.Context, id string) *DocumentDataHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DocumentDataHistoryClient) Hooks() []Hook {
	hooks := c.hooks.DocumentDataHistory
	return append(hooks[:len(hooks):len(hooks)], documentdatahistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DocumentDataHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.DocumentDataHistory
	return append(inters[:len(inters):len(inters)], documentdatahistory.Interceptors[:]...)
}

func (c *DocumentDataHistoryClient) mutate(ctx context.Context, m *DocumentDataHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentDataHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentDataHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentDataHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDataHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DocumentDataHistory mutation op: %q", m.Op())
	}
}

// EmailVerificationTokenClient is a client for the EmailVerificationToken schema.
type EmailVerificationTokenClient struct {
	config
}

// NewEmailVerificationTokenClient returns a client for the EmailVerificationToken from the given config.
func NewEmailVerificationTokenClient(c config) *EmailVerificationTokenClient {
	return &EmailVerificationTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailverificationtoken.Hooks(f(g(h())))`.
func (c *EmailVerificationTokenClient) Use(hooks ...Hook) {
	c.hooks.EmailVerificationToken = append(c.hooks.EmailVerificationToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailverificationtoken.Intercept(f(g(h())))`.
func (c *EmailVerificationTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailVerificationToken = append(c.inters.EmailVerificationToken, interceptors...)
}

// Create returns a builder for creating a EmailVerificationToken entity.
func (c *EmailVerificationTokenClient) Create() *EmailVerificationTokenCreate {
	mutation := newEmailVerificationTokenMutation(c.config, OpCreate)
	return &EmailVerificationTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailVerificationToken entities.
func (c *EmailVerificationTokenClient) CreateBulk(builders ...*EmailVerificationTokenCreate) *EmailVerificationTokenCreateBulk {
	return &EmailVerificationTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailVerificationTokenClient) MapCreateBulk(slice any, setFunc func(*EmailVerificationTokenCreate, int)) *EmailVerificationTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailVerificationTokenCreateBulk{err: fmt.Errorf("calling to EmailVerificationTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailVerificationTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailVerificationTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailVerificationToken.
func (c *EmailVerificationTokenClient) Update() *EmailVerificationTokenUpdate {
	mutation := newEmailVerificationTokenMutation(c.config, OpUpdate)
	return &EmailVerificationTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailVerificationTokenClient) UpdateOne(evt *EmailVerificationToken) *EmailVerificationTokenUpdateOne {
	mutation := newEmailVerificationTokenMutation(c.config, OpUpdateOne, withEmailVerificationToken(evt))
	return &EmailVerificationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailVerificationTokenClient) UpdateOneID(id string) *EmailVerificationTokenUpdateOne {
	mutation := newEmailVerificationTokenMutation(c.config, OpUpdateOne, withEmailVerificationTokenID(id))
	return &EmailVerificationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailVerificationToken.
func (c *EmailVerificationTokenClient) Delete() *EmailVerificationTokenDelete {
	mutation := newEmailVerificationTokenMutation(c.config, OpDelete)
	return &EmailVerificationTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailVerificationTokenClient) DeleteOne(evt *EmailVerificationToken) *EmailVerificationTokenDeleteOne {
	return c.DeleteOneID(evt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailVerificationTokenClient) DeleteOneID(id string) *EmailVerificationTokenDeleteOne {
	builder := c.Delete().Where(emailverificationtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailVerificationTokenDeleteOne{builder}
}

// Query returns a query builder for EmailVerificationToken.
func (c *EmailVerificationTokenClient) Query() *EmailVerificationTokenQuery {
	return &EmailVerificationTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailVerificationToken},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailVerificationToken entity by its id.
func (c *EmailVerificationTokenClient) Get(ctx context.Context, id string) (*EmailVerificationToken, error) {
	return c.Query().Where(emailverificationtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailVerificationTokenClient) GetX(ctx context.Context, id string) *EmailVerificationToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a EmailVerificationToken.
func (c *EmailVerificationTokenClient) QueryOwner(evt *EmailVerificationToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := evt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailverificationtoken.Table, emailverificationtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailverificationtoken.OwnerTable, emailverificationtoken.OwnerColumn),
		)
		schemaConfig := evt.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.EmailVerificationToken
		fromV = sqlgraph.Neighbors(evt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailVerificationTokenClient) Hooks() []Hook {
	hooks := c.hooks.EmailVerificationToken
	return append(hooks[:len(hooks):len(hooks)], emailverificationtoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EmailVerificationTokenClient) Interceptors() []Interceptor {
	inters := c.inters.EmailVerificationToken
	return append(inters[:len(inters):len(inters)], emailverificationtoken.Interceptors[:]...)
}

func (c *EmailVerificationTokenClient) mutate(ctx context.Context, m *EmailVerificationTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailVerificationTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailVerificationTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailVerificationTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailVerificationTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EmailVerificationToken mutation op: %q", m.Op())
	}
}

// EntitlementClient is a client for the Entitlement schema.
type EntitlementClient struct {
	config
}

// NewEntitlementClient returns a client for the Entitlement from the given config.
func NewEntitlementClient(c config) *EntitlementClient {
	return &EntitlementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitlement.Hooks(f(g(h())))`.
func (c *EntitlementClient) Use(hooks ...Hook) {
	c.hooks.Entitlement = append(c.hooks.Entitlement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitlement.Intercept(f(g(h())))`.
func (c *EntitlementClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entitlement = append(c.inters.Entitlement, interceptors...)
}

// Create returns a builder for creating a Entitlement entity.
func (c *EntitlementClient) Create() *EntitlementCreate {
	mutation := newEntitlementMutation(c.config, OpCreate)
	return &EntitlementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entitlement entities.
func (c *EntitlementClient) CreateBulk(builders ...*EntitlementCreate) *EntitlementCreateBulk {
	return &EntitlementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntitlementClient) MapCreateBulk(slice any, setFunc func(*EntitlementCreate, int)) *EntitlementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntitlementCreateBulk{err: fmt.Errorf("calling to EntitlementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntitlementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntitlementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entitlement.
func (c *EntitlementClient) Update() *EntitlementUpdate {
	mutation := newEntitlementMutation(c.config, OpUpdate)
	return &EntitlementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntitlementClient) UpdateOne(e *Entitlement) *EntitlementUpdateOne {
	mutation := newEntitlementMutation(c.config, OpUpdateOne, withEntitlement(e))
	return &EntitlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntitlementClient) UpdateOneID(id string) *EntitlementUpdateOne {
	mutation := newEntitlementMutation(c.config, OpUpdateOne, withEntitlementID(id))
	return &EntitlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entitlement.
func (c *EntitlementClient) Delete() *EntitlementDelete {
	mutation := newEntitlementMutation(c.config, OpDelete)
	return &EntitlementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntitlementClient) DeleteOne(e *Entitlement) *EntitlementDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntitlementClient) DeleteOneID(id string) *EntitlementDeleteOne {
	builder := c.Delete().Where(entitlement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntitlementDeleteOne{builder}
}

// Query returns a query builder for Entitlement.
func (c *EntitlementClient) Query() *EntitlementQuery {
	return &EntitlementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntitlement},
		inters: c.Interceptors(),
	}
}

// Get returns a Entitlement entity by its id.
func (c *EntitlementClient) Get(ctx context.Context, id string) (*Entitlement, error) {
	return c.Query().Where(entitlement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntitlementClient) GetX(ctx context.Context, id string) *Entitlement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Entitlement.
func (c *EntitlementClient) QueryOwner(e *Entitlement) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlement.Table, entitlement.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitlement.OwnerTable, entitlement.OwnerColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Entitlement
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the plan edge of a Entitlement.
func (c *EntitlementClient) QueryPlan(e *Entitlement) *EntitlementPlanQuery {
	query := (&EntitlementPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlement.Table, entitlement.FieldID, id),
			sqlgraph.To(entitlementplan.Table, entitlementplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitlement.PlanTable, entitlement.PlanColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlan
		step.Edge.Schema = schemaConfig.Entitlement
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Entitlement.
func (c *EntitlementClient) QueryOrganization(e *Entitlement) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlement.Table, entitlement.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitlement.OrganizationTable, entitlement.OrganizationColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Entitlement
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Entitlement.
func (c *EntitlementClient) QueryEvents(e *Entitlement) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlement.Table, entitlement.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entitlement.EventsTable, entitlement.EventsPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.EntitlementEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntitlementClient) Hooks() []Hook {
	hooks := c.hooks.Entitlement
	return append(hooks[:len(hooks):len(hooks)], entitlement.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntitlementClient) Interceptors() []Interceptor {
	inters := c.inters.Entitlement
	return append(inters[:len(inters):len(inters)], entitlement.Interceptors[:]...)
}

func (c *EntitlementClient) mutate(ctx context.Context, m *EntitlementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntitlementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntitlementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntitlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntitlementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Entitlement mutation op: %q", m.Op())
	}
}

// EntitlementHistoryClient is a client for the EntitlementHistory schema.
type EntitlementHistoryClient struct {
	config
}

// NewEntitlementHistoryClient returns a client for the EntitlementHistory from the given config.
func NewEntitlementHistoryClient(c config) *EntitlementHistoryClient {
	return &EntitlementHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitlementhistory.Hooks(f(g(h())))`.
func (c *EntitlementHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntitlementHistory = append(c.hooks.EntitlementHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitlementhistory.Intercept(f(g(h())))`.
func (c *EntitlementHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntitlementHistory = append(c.inters.EntitlementHistory, interceptors...)
}

// Create returns a builder for creating a EntitlementHistory entity.
func (c *EntitlementHistoryClient) Create() *EntitlementHistoryCreate {
	mutation := newEntitlementHistoryMutation(c.config, OpCreate)
	return &EntitlementHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntitlementHistory entities.
func (c *EntitlementHistoryClient) CreateBulk(builders ...*EntitlementHistoryCreate) *EntitlementHistoryCreateBulk {
	return &EntitlementHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntitlementHistoryClient) MapCreateBulk(slice any, setFunc func(*EntitlementHistoryCreate, int)) *EntitlementHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntitlementHistoryCreateBulk{err: fmt.Errorf("calling to EntitlementHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntitlementHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntitlementHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntitlementHistory.
func (c *EntitlementHistoryClient) Update() *EntitlementHistoryUpdate {
	mutation := newEntitlementHistoryMutation(c.config, OpUpdate)
	return &EntitlementHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntitlementHistoryClient) UpdateOne(eh *EntitlementHistory) *EntitlementHistoryUpdateOne {
	mutation := newEntitlementHistoryMutation(c.config, OpUpdateOne, withEntitlementHistory(eh))
	return &EntitlementHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntitlementHistoryClient) UpdateOneID(id string) *EntitlementHistoryUpdateOne {
	mutation := newEntitlementHistoryMutation(c.config, OpUpdateOne, withEntitlementHistoryID(id))
	return &EntitlementHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntitlementHistory.
func (c *EntitlementHistoryClient) Delete() *EntitlementHistoryDelete {
	mutation := newEntitlementHistoryMutation(c.config, OpDelete)
	return &EntitlementHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntitlementHistoryClient) DeleteOne(eh *EntitlementHistory) *EntitlementHistoryDeleteOne {
	return c.DeleteOneID(eh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntitlementHistoryClient) DeleteOneID(id string) *EntitlementHistoryDeleteOne {
	builder := c.Delete().Where(entitlementhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntitlementHistoryDeleteOne{builder}
}

// Query returns a query builder for EntitlementHistory.
func (c *EntitlementHistoryClient) Query() *EntitlementHistoryQuery {
	return &EntitlementHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntitlementHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntitlementHistory entity by its id.
func (c *EntitlementHistoryClient) Get(ctx context.Context, id string) (*EntitlementHistory, error) {
	return c.Query().Where(entitlementhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntitlementHistoryClient) GetX(ctx context.Context, id string) *EntitlementHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntitlementHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntitlementHistory
	return append(hooks[:len(hooks):len(hooks)], entitlementhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntitlementHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntitlementHistory
	return append(inters[:len(inters):len(inters)], entitlementhistory.Interceptors[:]...)
}

func (c *EntitlementHistoryClient) mutate(ctx context.Context, m *EntitlementHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntitlementHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntitlementHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntitlementHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntitlementHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntitlementHistory mutation op: %q", m.Op())
	}
}

// EntitlementPlanClient is a client for the EntitlementPlan schema.
type EntitlementPlanClient struct {
	config
}

// NewEntitlementPlanClient returns a client for the EntitlementPlan from the given config.
func NewEntitlementPlanClient(c config) *EntitlementPlanClient {
	return &EntitlementPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitlementplan.Hooks(f(g(h())))`.
func (c *EntitlementPlanClient) Use(hooks ...Hook) {
	c.hooks.EntitlementPlan = append(c.hooks.EntitlementPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitlementplan.Intercept(f(g(h())))`.
func (c *EntitlementPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntitlementPlan = append(c.inters.EntitlementPlan, interceptors...)
}

// Create returns a builder for creating a EntitlementPlan entity.
func (c *EntitlementPlanClient) Create() *EntitlementPlanCreate {
	mutation := newEntitlementPlanMutation(c.config, OpCreate)
	return &EntitlementPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntitlementPlan entities.
func (c *EntitlementPlanClient) CreateBulk(builders ...*EntitlementPlanCreate) *EntitlementPlanCreateBulk {
	return &EntitlementPlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntitlementPlanClient) MapCreateBulk(slice any, setFunc func(*EntitlementPlanCreate, int)) *EntitlementPlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntitlementPlanCreateBulk{err: fmt.Errorf("calling to EntitlementPlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntitlementPlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntitlementPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntitlementPlan.
func (c *EntitlementPlanClient) Update() *EntitlementPlanUpdate {
	mutation := newEntitlementPlanMutation(c.config, OpUpdate)
	return &EntitlementPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntitlementPlanClient) UpdateOne(ep *EntitlementPlan) *EntitlementPlanUpdateOne {
	mutation := newEntitlementPlanMutation(c.config, OpUpdateOne, withEntitlementPlan(ep))
	return &EntitlementPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntitlementPlanClient) UpdateOneID(id string) *EntitlementPlanUpdateOne {
	mutation := newEntitlementPlanMutation(c.config, OpUpdateOne, withEntitlementPlanID(id))
	return &EntitlementPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntitlementPlan.
func (c *EntitlementPlanClient) Delete() *EntitlementPlanDelete {
	mutation := newEntitlementPlanMutation(c.config, OpDelete)
	return &EntitlementPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntitlementPlanClient) DeleteOne(ep *EntitlementPlan) *EntitlementPlanDeleteOne {
	return c.DeleteOneID(ep.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntitlementPlanClient) DeleteOneID(id string) *EntitlementPlanDeleteOne {
	builder := c.Delete().Where(entitlementplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntitlementPlanDeleteOne{builder}
}

// Query returns a query builder for EntitlementPlan.
func (c *EntitlementPlanClient) Query() *EntitlementPlanQuery {
	return &EntitlementPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntitlementPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a EntitlementPlan entity by its id.
func (c *EntitlementPlanClient) Get(ctx context.Context, id string) (*EntitlementPlan, error) {
	return c.Query().Where(entitlementplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntitlementPlanClient) GetX(ctx context.Context, id string) *EntitlementPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a EntitlementPlan.
func (c *EntitlementPlanClient) QueryOwner(ep *EntitlementPlan) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplan.Table, entitlementplan.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitlementplan.OwnerTable, entitlementplan.OwnerColumn),
		)
		schemaConfig := ep.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.EntitlementPlan
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlements queries the entitlements edge of a EntitlementPlan.
func (c *EntitlementPlanClient) QueryEntitlements(ep *EntitlementPlan) *EntitlementQuery {
	query := (&EntitlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplan.Table, entitlementplan.FieldID, id),
			sqlgraph.To(entitlement.Table, entitlement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entitlementplan.EntitlementsTable, entitlementplan.EntitlementsColumn),
		)
		schemaConfig := ep.schemaConfig
		step.To.Schema = schemaConfig.Entitlement
		step.Edge.Schema = schemaConfig.Entitlement
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBaseFeatures queries the base_features edge of a EntitlementPlan.
func (c *EntitlementPlanClient) QueryBaseFeatures(ep *EntitlementPlan) *FeatureQuery {
	query := (&FeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplan.Table, entitlementplan.FieldID, id),
			sqlgraph.To(feature.Table, feature.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, entitlementplan.BaseFeaturesTable, entitlementplan.BaseFeaturesPrimaryKey...),
		)
		schemaConfig := ep.schemaConfig
		step.To.Schema = schemaConfig.Feature
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a EntitlementPlan.
func (c *EntitlementPlanClient) QueryEvents(ep *EntitlementPlan) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplan.Table, entitlementplan.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entitlementplan.EventsTable, entitlementplan.EventsPrimaryKey...),
		)
		schemaConfig := ep.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.EntitlementPlanEvents
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeatures queries the features edge of a EntitlementPlan.
func (c *EntitlementPlanClient) QueryFeatures(ep *EntitlementPlan) *EntitlementPlanFeatureQuery {
	query := (&EntitlementPlanFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ep.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplan.Table, entitlementplan.FieldID, id),
			sqlgraph.To(entitlementplanfeature.Table, entitlementplanfeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, entitlementplan.FeaturesTable, entitlementplan.FeaturesColumn),
		)
		schemaConfig := ep.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlanFeature
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(ep.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntitlementPlanClient) Hooks() []Hook {
	hooks := c.hooks.EntitlementPlan
	return append(hooks[:len(hooks):len(hooks)], entitlementplan.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntitlementPlanClient) Interceptors() []Interceptor {
	inters := c.inters.EntitlementPlan
	return append(inters[:len(inters):len(inters)], entitlementplan.Interceptors[:]...)
}

func (c *EntitlementPlanClient) mutate(ctx context.Context, m *EntitlementPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntitlementPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntitlementPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntitlementPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntitlementPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntitlementPlan mutation op: %q", m.Op())
	}
}

// EntitlementPlanFeatureClient is a client for the EntitlementPlanFeature schema.
type EntitlementPlanFeatureClient struct {
	config
}

// NewEntitlementPlanFeatureClient returns a client for the EntitlementPlanFeature from the given config.
func NewEntitlementPlanFeatureClient(c config) *EntitlementPlanFeatureClient {
	return &EntitlementPlanFeatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitlementplanfeature.Hooks(f(g(h())))`.
func (c *EntitlementPlanFeatureClient) Use(hooks ...Hook) {
	c.hooks.EntitlementPlanFeature = append(c.hooks.EntitlementPlanFeature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitlementplanfeature.Intercept(f(g(h())))`.
func (c *EntitlementPlanFeatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntitlementPlanFeature = append(c.inters.EntitlementPlanFeature, interceptors...)
}

// Create returns a builder for creating a EntitlementPlanFeature entity.
func (c *EntitlementPlanFeatureClient) Create() *EntitlementPlanFeatureCreate {
	mutation := newEntitlementPlanFeatureMutation(c.config, OpCreate)
	return &EntitlementPlanFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntitlementPlanFeature entities.
func (c *EntitlementPlanFeatureClient) CreateBulk(builders ...*EntitlementPlanFeatureCreate) *EntitlementPlanFeatureCreateBulk {
	return &EntitlementPlanFeatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntitlementPlanFeatureClient) MapCreateBulk(slice any, setFunc func(*EntitlementPlanFeatureCreate, int)) *EntitlementPlanFeatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntitlementPlanFeatureCreateBulk{err: fmt.Errorf("calling to EntitlementPlanFeatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntitlementPlanFeatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntitlementPlanFeatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) Update() *EntitlementPlanFeatureUpdate {
	mutation := newEntitlementPlanFeatureMutation(c.config, OpUpdate)
	return &EntitlementPlanFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntitlementPlanFeatureClient) UpdateOne(epf *EntitlementPlanFeature) *EntitlementPlanFeatureUpdateOne {
	mutation := newEntitlementPlanFeatureMutation(c.config, OpUpdateOne, withEntitlementPlanFeature(epf))
	return &EntitlementPlanFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntitlementPlanFeatureClient) UpdateOneID(id string) *EntitlementPlanFeatureUpdateOne {
	mutation := newEntitlementPlanFeatureMutation(c.config, OpUpdateOne, withEntitlementPlanFeatureID(id))
	return &EntitlementPlanFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) Delete() *EntitlementPlanFeatureDelete {
	mutation := newEntitlementPlanFeatureMutation(c.config, OpDelete)
	return &EntitlementPlanFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntitlementPlanFeatureClient) DeleteOne(epf *EntitlementPlanFeature) *EntitlementPlanFeatureDeleteOne {
	return c.DeleteOneID(epf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntitlementPlanFeatureClient) DeleteOneID(id string) *EntitlementPlanFeatureDeleteOne {
	builder := c.Delete().Where(entitlementplanfeature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntitlementPlanFeatureDeleteOne{builder}
}

// Query returns a query builder for EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) Query() *EntitlementPlanFeatureQuery {
	return &EntitlementPlanFeatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntitlementPlanFeature},
		inters: c.Interceptors(),
	}
}

// Get returns a EntitlementPlanFeature entity by its id.
func (c *EntitlementPlanFeatureClient) Get(ctx context.Context, id string) (*EntitlementPlanFeature, error) {
	return c.Query().Where(entitlementplanfeature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntitlementPlanFeatureClient) GetX(ctx context.Context, id string) *EntitlementPlanFeature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) QueryOwner(epf *EntitlementPlanFeature) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := epf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplanfeature.Table, entitlementplanfeature.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitlementplanfeature.OwnerTable, entitlementplanfeature.OwnerColumn),
		)
		schemaConfig := epf.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(epf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the plan edge of a EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) QueryPlan(epf *EntitlementPlanFeature) *EntitlementPlanQuery {
	query := (&EntitlementPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := epf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplanfeature.Table, entitlementplanfeature.FieldID, id),
			sqlgraph.To(entitlementplan.Table, entitlementplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, entitlementplanfeature.PlanTable, entitlementplanfeature.PlanColumn),
		)
		schemaConfig := epf.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlan
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(epf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeature queries the feature edge of a EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) QueryFeature(epf *EntitlementPlanFeature) *FeatureQuery {
	query := (&FeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := epf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplanfeature.Table, entitlementplanfeature.FieldID, id),
			sqlgraph.To(feature.Table, feature.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, entitlementplanfeature.FeatureTable, entitlementplanfeature.FeatureColumn),
		)
		schemaConfig := epf.schemaConfig
		step.To.Schema = schemaConfig.Feature
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(epf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a EntitlementPlanFeature.
func (c *EntitlementPlanFeatureClient) QueryEvents(epf *EntitlementPlanFeature) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := epf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitlementplanfeature.Table, entitlementplanfeature.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entitlementplanfeature.EventsTable, entitlementplanfeature.EventsPrimaryKey...),
		)
		schemaConfig := epf.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.EntitlementPlanFeatureEvents
		fromV = sqlgraph.Neighbors(epf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntitlementPlanFeatureClient) Hooks() []Hook {
	hooks := c.hooks.EntitlementPlanFeature
	return append(hooks[:len(hooks):len(hooks)], entitlementplanfeature.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntitlementPlanFeatureClient) Interceptors() []Interceptor {
	inters := c.inters.EntitlementPlanFeature
	return append(inters[:len(inters):len(inters)], entitlementplanfeature.Interceptors[:]...)
}

func (c *EntitlementPlanFeatureClient) mutate(ctx context.Context, m *EntitlementPlanFeatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntitlementPlanFeatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntitlementPlanFeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntitlementPlanFeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntitlementPlanFeatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntitlementPlanFeature mutation op: %q", m.Op())
	}
}

// EntitlementPlanFeatureHistoryClient is a client for the EntitlementPlanFeatureHistory schema.
type EntitlementPlanFeatureHistoryClient struct {
	config
}

// NewEntitlementPlanFeatureHistoryClient returns a client for the EntitlementPlanFeatureHistory from the given config.
func NewEntitlementPlanFeatureHistoryClient(c config) *EntitlementPlanFeatureHistoryClient {
	return &EntitlementPlanFeatureHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitlementplanfeaturehistory.Hooks(f(g(h())))`.
func (c *EntitlementPlanFeatureHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntitlementPlanFeatureHistory = append(c.hooks.EntitlementPlanFeatureHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitlementplanfeaturehistory.Intercept(f(g(h())))`.
func (c *EntitlementPlanFeatureHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntitlementPlanFeatureHistory = append(c.inters.EntitlementPlanFeatureHistory, interceptors...)
}

// Create returns a builder for creating a EntitlementPlanFeatureHistory entity.
func (c *EntitlementPlanFeatureHistoryClient) Create() *EntitlementPlanFeatureHistoryCreate {
	mutation := newEntitlementPlanFeatureHistoryMutation(c.config, OpCreate)
	return &EntitlementPlanFeatureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntitlementPlanFeatureHistory entities.
func (c *EntitlementPlanFeatureHistoryClient) CreateBulk(builders ...*EntitlementPlanFeatureHistoryCreate) *EntitlementPlanFeatureHistoryCreateBulk {
	return &EntitlementPlanFeatureHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntitlementPlanFeatureHistoryClient) MapCreateBulk(slice any, setFunc func(*EntitlementPlanFeatureHistoryCreate, int)) *EntitlementPlanFeatureHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntitlementPlanFeatureHistoryCreateBulk{err: fmt.Errorf("calling to EntitlementPlanFeatureHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntitlementPlanFeatureHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntitlementPlanFeatureHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntitlementPlanFeatureHistory.
func (c *EntitlementPlanFeatureHistoryClient) Update() *EntitlementPlanFeatureHistoryUpdate {
	mutation := newEntitlementPlanFeatureHistoryMutation(c.config, OpUpdate)
	return &EntitlementPlanFeatureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntitlementPlanFeatureHistoryClient) UpdateOne(epfh *EntitlementPlanFeatureHistory) *EntitlementPlanFeatureHistoryUpdateOne {
	mutation := newEntitlementPlanFeatureHistoryMutation(c.config, OpUpdateOne, withEntitlementPlanFeatureHistory(epfh))
	return &EntitlementPlanFeatureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntitlementPlanFeatureHistoryClient) UpdateOneID(id string) *EntitlementPlanFeatureHistoryUpdateOne {
	mutation := newEntitlementPlanFeatureHistoryMutation(c.config, OpUpdateOne, withEntitlementPlanFeatureHistoryID(id))
	return &EntitlementPlanFeatureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntitlementPlanFeatureHistory.
func (c *EntitlementPlanFeatureHistoryClient) Delete() *EntitlementPlanFeatureHistoryDelete {
	mutation := newEntitlementPlanFeatureHistoryMutation(c.config, OpDelete)
	return &EntitlementPlanFeatureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntitlementPlanFeatureHistoryClient) DeleteOne(epfh *EntitlementPlanFeatureHistory) *EntitlementPlanFeatureHistoryDeleteOne {
	return c.DeleteOneID(epfh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntitlementPlanFeatureHistoryClient) DeleteOneID(id string) *EntitlementPlanFeatureHistoryDeleteOne {
	builder := c.Delete().Where(entitlementplanfeaturehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntitlementPlanFeatureHistoryDeleteOne{builder}
}

// Query returns a query builder for EntitlementPlanFeatureHistory.
func (c *EntitlementPlanFeatureHistoryClient) Query() *EntitlementPlanFeatureHistoryQuery {
	return &EntitlementPlanFeatureHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntitlementPlanFeatureHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntitlementPlanFeatureHistory entity by its id.
func (c *EntitlementPlanFeatureHistoryClient) Get(ctx context.Context, id string) (*EntitlementPlanFeatureHistory, error) {
	return c.Query().Where(entitlementplanfeaturehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntitlementPlanFeatureHistoryClient) GetX(ctx context.Context, id string) *EntitlementPlanFeatureHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntitlementPlanFeatureHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntitlementPlanFeatureHistory
	return append(hooks[:len(hooks):len(hooks)], entitlementplanfeaturehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntitlementPlanFeatureHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntitlementPlanFeatureHistory
	return append(inters[:len(inters):len(inters)], entitlementplanfeaturehistory.Interceptors[:]...)
}

func (c *EntitlementPlanFeatureHistoryClient) mutate(ctx context.Context, m *EntitlementPlanFeatureHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntitlementPlanFeatureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntitlementPlanFeatureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntitlementPlanFeatureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntitlementPlanFeatureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntitlementPlanFeatureHistory mutation op: %q", m.Op())
	}
}

// EntitlementPlanHistoryClient is a client for the EntitlementPlanHistory schema.
type EntitlementPlanHistoryClient struct {
	config
}

// NewEntitlementPlanHistoryClient returns a client for the EntitlementPlanHistory from the given config.
func NewEntitlementPlanHistoryClient(c config) *EntitlementPlanHistoryClient {
	return &EntitlementPlanHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitlementplanhistory.Hooks(f(g(h())))`.
func (c *EntitlementPlanHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntitlementPlanHistory = append(c.hooks.EntitlementPlanHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitlementplanhistory.Intercept(f(g(h())))`.
func (c *EntitlementPlanHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntitlementPlanHistory = append(c.inters.EntitlementPlanHistory, interceptors...)
}

// Create returns a builder for creating a EntitlementPlanHistory entity.
func (c *EntitlementPlanHistoryClient) Create() *EntitlementPlanHistoryCreate {
	mutation := newEntitlementPlanHistoryMutation(c.config, OpCreate)
	return &EntitlementPlanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntitlementPlanHistory entities.
func (c *EntitlementPlanHistoryClient) CreateBulk(builders ...*EntitlementPlanHistoryCreate) *EntitlementPlanHistoryCreateBulk {
	return &EntitlementPlanHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntitlementPlanHistoryClient) MapCreateBulk(slice any, setFunc func(*EntitlementPlanHistoryCreate, int)) *EntitlementPlanHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntitlementPlanHistoryCreateBulk{err: fmt.Errorf("calling to EntitlementPlanHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntitlementPlanHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntitlementPlanHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntitlementPlanHistory.
func (c *EntitlementPlanHistoryClient) Update() *EntitlementPlanHistoryUpdate {
	mutation := newEntitlementPlanHistoryMutation(c.config, OpUpdate)
	return &EntitlementPlanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntitlementPlanHistoryClient) UpdateOne(eph *EntitlementPlanHistory) *EntitlementPlanHistoryUpdateOne {
	mutation := newEntitlementPlanHistoryMutation(c.config, OpUpdateOne, withEntitlementPlanHistory(eph))
	return &EntitlementPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntitlementPlanHistoryClient) UpdateOneID(id string) *EntitlementPlanHistoryUpdateOne {
	mutation := newEntitlementPlanHistoryMutation(c.config, OpUpdateOne, withEntitlementPlanHistoryID(id))
	return &EntitlementPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntitlementPlanHistory.
func (c *EntitlementPlanHistoryClient) Delete() *EntitlementPlanHistoryDelete {
	mutation := newEntitlementPlanHistoryMutation(c.config, OpDelete)
	return &EntitlementPlanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntitlementPlanHistoryClient) DeleteOne(eph *EntitlementPlanHistory) *EntitlementPlanHistoryDeleteOne {
	return c.DeleteOneID(eph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntitlementPlanHistoryClient) DeleteOneID(id string) *EntitlementPlanHistoryDeleteOne {
	builder := c.Delete().Where(entitlementplanhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntitlementPlanHistoryDeleteOne{builder}
}

// Query returns a query builder for EntitlementPlanHistory.
func (c *EntitlementPlanHistoryClient) Query() *EntitlementPlanHistoryQuery {
	return &EntitlementPlanHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntitlementPlanHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntitlementPlanHistory entity by its id.
func (c *EntitlementPlanHistoryClient) Get(ctx context.Context, id string) (*EntitlementPlanHistory, error) {
	return c.Query().Where(entitlementplanhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntitlementPlanHistoryClient) GetX(ctx context.Context, id string) *EntitlementPlanHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntitlementPlanHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntitlementPlanHistory
	return append(hooks[:len(hooks):len(hooks)], entitlementplanhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntitlementPlanHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntitlementPlanHistory
	return append(inters[:len(inters):len(inters)], entitlementplanhistory.Interceptors[:]...)
}

func (c *EntitlementPlanHistoryClient) mutate(ctx context.Context, m *EntitlementPlanHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntitlementPlanHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntitlementPlanHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntitlementPlanHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntitlementPlanHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntitlementPlanHistory mutation op: %q", m.Op())
	}
}

// EntityClient is a client for the Entity schema.
type EntityClient struct {
	config
}

// NewEntityClient returns a client for the Entity from the given config.
func NewEntityClient(c config) *EntityClient {
	return &EntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entity.Hooks(f(g(h())))`.
func (c *EntityClient) Use(hooks ...Hook) {
	c.hooks.Entity = append(c.hooks.Entity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entity.Intercept(f(g(h())))`.
func (c *EntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entity = append(c.inters.Entity, interceptors...)
}

// Create returns a builder for creating a Entity entity.
func (c *EntityClient) Create() *EntityCreate {
	mutation := newEntityMutation(c.config, OpCreate)
	return &EntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entity entities.
func (c *EntityClient) CreateBulk(builders ...*EntityCreate) *EntityCreateBulk {
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityClient) MapCreateBulk(slice any, setFunc func(*EntityCreate, int)) *EntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityCreateBulk{err: fmt.Errorf("calling to EntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entity.
func (c *EntityClient) Update() *EntityUpdate {
	mutation := newEntityMutation(c.config, OpUpdate)
	return &EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityClient) UpdateOne(e *Entity) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntity(e))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityClient) UpdateOneID(id string) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntityID(id))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entity.
func (c *EntityClient) Delete() *EntityDelete {
	mutation := newEntityMutation(c.config, OpDelete)
	return &EntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityClient) DeleteOne(e *Entity) *EntityDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityClient) DeleteOneID(id string) *EntityDeleteOne {
	builder := c.Delete().Where(entity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityDeleteOne{builder}
}

// Query returns a query builder for Entity.
func (c *EntityClient) Query() *EntityQuery {
	return &EntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a Entity entity by its id.
func (c *EntityClient) Get(ctx context.Context, id string) (*Entity, error) {
	return c.Query().Where(entity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityClient) GetX(ctx context.Context, id string) *Entity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Entity.
func (c *EntityClient) QueryOwner(e *Entity) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entity.OwnerTable, entity.OwnerColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Entity.
func (c *EntityClient) QueryContacts(e *Entity) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.ContactsTable, entity.ContactsPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Contact
		step.Edge.Schema = schemaConfig.EntityContacts
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Entity.
func (c *EntityClient) QueryDocuments(e *Entity) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.DocumentsTable, entity.DocumentsPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.EntityDocuments
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Entity.
func (c *EntityClient) QueryNotes(e *Entity) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.NotesTable, entity.NotesColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Entity.
func (c *EntityClient) QueryFiles(e *Entity) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.FilesTable, entity.FilesPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.EntityFiles
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntityType queries the entity_type edge of a Entity.
func (c *EntityClient) QueryEntityType(e *Entity) *EntityTypeQuery {
	query := (&EntityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(entitytype.Table, entitytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, entity.EntityTypeTable, entity.EntityTypeColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EntityType
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityClient) Hooks() []Hook {
	hooks := c.hooks.Entity
	return append(hooks[:len(hooks):len(hooks)], entity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityClient) Interceptors() []Interceptor {
	inters := c.inters.Entity
	return append(inters[:len(inters):len(inters)], entity.Interceptors[:]...)
}

func (c *EntityClient) mutate(ctx context.Context, m *EntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Entity mutation op: %q", m.Op())
	}
}

// EntityHistoryClient is a client for the EntityHistory schema.
type EntityHistoryClient struct {
	config
}

// NewEntityHistoryClient returns a client for the EntityHistory from the given config.
func NewEntityHistoryClient(c config) *EntityHistoryClient {
	return &EntityHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entityhistory.Hooks(f(g(h())))`.
func (c *EntityHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntityHistory = append(c.hooks.EntityHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entityhistory.Intercept(f(g(h())))`.
func (c *EntityHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntityHistory = append(c.inters.EntityHistory, interceptors...)
}

// Create returns a builder for creating a EntityHistory entity.
func (c *EntityHistoryClient) Create() *EntityHistoryCreate {
	mutation := newEntityHistoryMutation(c.config, OpCreate)
	return &EntityHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntityHistory entities.
func (c *EntityHistoryClient) CreateBulk(builders ...*EntityHistoryCreate) *EntityHistoryCreateBulk {
	return &EntityHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityHistoryClient) MapCreateBulk(slice any, setFunc func(*EntityHistoryCreate, int)) *EntityHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityHistoryCreateBulk{err: fmt.Errorf("calling to EntityHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntityHistory.
func (c *EntityHistoryClient) Update() *EntityHistoryUpdate {
	mutation := newEntityHistoryMutation(c.config, OpUpdate)
	return &EntityHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityHistoryClient) UpdateOne(eh *EntityHistory) *EntityHistoryUpdateOne {
	mutation := newEntityHistoryMutation(c.config, OpUpdateOne, withEntityHistory(eh))
	return &EntityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityHistoryClient) UpdateOneID(id string) *EntityHistoryUpdateOne {
	mutation := newEntityHistoryMutation(c.config, OpUpdateOne, withEntityHistoryID(id))
	return &EntityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntityHistory.
func (c *EntityHistoryClient) Delete() *EntityHistoryDelete {
	mutation := newEntityHistoryMutation(c.config, OpDelete)
	return &EntityHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityHistoryClient) DeleteOne(eh *EntityHistory) *EntityHistoryDeleteOne {
	return c.DeleteOneID(eh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityHistoryClient) DeleteOneID(id string) *EntityHistoryDeleteOne {
	builder := c.Delete().Where(entityhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityHistoryDeleteOne{builder}
}

// Query returns a query builder for EntityHistory.
func (c *EntityHistoryClient) Query() *EntityHistoryQuery {
	return &EntityHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntityHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntityHistory entity by its id.
func (c *EntityHistoryClient) Get(ctx context.Context, id string) (*EntityHistory, error) {
	return c.Query().Where(entityhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityHistoryClient) GetX(ctx context.Context, id string) *EntityHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntityHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntityHistory
	return append(hooks[:len(hooks):len(hooks)], entityhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntityHistory
	return append(inters[:len(inters):len(inters)], entityhistory.Interceptors[:]...)
}

func (c *EntityHistoryClient) mutate(ctx context.Context, m *EntityHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntityHistory mutation op: %q", m.Op())
	}
}

// EntityTypeClient is a client for the EntityType schema.
type EntityTypeClient struct {
	config
}

// NewEntityTypeClient returns a client for the EntityType from the given config.
func NewEntityTypeClient(c config) *EntityTypeClient {
	return &EntityTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitytype.Hooks(f(g(h())))`.
func (c *EntityTypeClient) Use(hooks ...Hook) {
	c.hooks.EntityType = append(c.hooks.EntityType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitytype.Intercept(f(g(h())))`.
func (c *EntityTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntityType = append(c.inters.EntityType, interceptors...)
}

// Create returns a builder for creating a EntityType entity.
func (c *EntityTypeClient) Create() *EntityTypeCreate {
	mutation := newEntityTypeMutation(c.config, OpCreate)
	return &EntityTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntityType entities.
func (c *EntityTypeClient) CreateBulk(builders ...*EntityTypeCreate) *EntityTypeCreateBulk {
	return &EntityTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityTypeClient) MapCreateBulk(slice any, setFunc func(*EntityTypeCreate, int)) *EntityTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityTypeCreateBulk{err: fmt.Errorf("calling to EntityTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntityType.
func (c *EntityTypeClient) Update() *EntityTypeUpdate {
	mutation := newEntityTypeMutation(c.config, OpUpdate)
	return &EntityTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityTypeClient) UpdateOne(et *EntityType) *EntityTypeUpdateOne {
	mutation := newEntityTypeMutation(c.config, OpUpdateOne, withEntityType(et))
	return &EntityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityTypeClient) UpdateOneID(id string) *EntityTypeUpdateOne {
	mutation := newEntityTypeMutation(c.config, OpUpdateOne, withEntityTypeID(id))
	return &EntityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntityType.
func (c *EntityTypeClient) Delete() *EntityTypeDelete {
	mutation := newEntityTypeMutation(c.config, OpDelete)
	return &EntityTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityTypeClient) DeleteOne(et *EntityType) *EntityTypeDeleteOne {
	return c.DeleteOneID(et.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityTypeClient) DeleteOneID(id string) *EntityTypeDeleteOne {
	builder := c.Delete().Where(entitytype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityTypeDeleteOne{builder}
}

// Query returns a query builder for EntityType.
func (c *EntityTypeClient) Query() *EntityTypeQuery {
	return &EntityTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntityType},
		inters: c.Interceptors(),
	}
}

// Get returns a EntityType entity by its id.
func (c *EntityTypeClient) Get(ctx context.Context, id string) (*EntityType, error) {
	return c.Query().Where(entitytype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityTypeClient) GetX(ctx context.Context, id string) *EntityType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a EntityType.
func (c *EntityTypeClient) QueryOwner(et *EntityType) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitytype.Table, entitytype.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entitytype.OwnerTable, entitytype.OwnerColumn),
		)
		schemaConfig := et.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.EntityType
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a EntityType.
func (c *EntityTypeClient) QueryEntities(et *EntityType) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := et.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entitytype.Table, entitytype.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entitytype.EntitiesTable, entitytype.EntitiesColumn),
		)
		schemaConfig := et.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(et.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityTypeClient) Hooks() []Hook {
	hooks := c.hooks.EntityType
	return append(hooks[:len(hooks):len(hooks)], entitytype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityTypeClient) Interceptors() []Interceptor {
	inters := c.inters.EntityType
	return append(inters[:len(inters):len(inters)], entitytype.Interceptors[:]...)
}

func (c *EntityTypeClient) mutate(ctx context.Context, m *EntityTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntityType mutation op: %q", m.Op())
	}
}

// EntityTypeHistoryClient is a client for the EntityTypeHistory schema.
type EntityTypeHistoryClient struct {
	config
}

// NewEntityTypeHistoryClient returns a client for the EntityTypeHistory from the given config.
func NewEntityTypeHistoryClient(c config) *EntityTypeHistoryClient {
	return &EntityTypeHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entitytypehistory.Hooks(f(g(h())))`.
func (c *EntityTypeHistoryClient) Use(hooks ...Hook) {
	c.hooks.EntityTypeHistory = append(c.hooks.EntityTypeHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entitytypehistory.Intercept(f(g(h())))`.
func (c *EntityTypeHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntityTypeHistory = append(c.inters.EntityTypeHistory, interceptors...)
}

// Create returns a builder for creating a EntityTypeHistory entity.
func (c *EntityTypeHistoryClient) Create() *EntityTypeHistoryCreate {
	mutation := newEntityTypeHistoryMutation(c.config, OpCreate)
	return &EntityTypeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntityTypeHistory entities.
func (c *EntityTypeHistoryClient) CreateBulk(builders ...*EntityTypeHistoryCreate) *EntityTypeHistoryCreateBulk {
	return &EntityTypeHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntityTypeHistoryClient) MapCreateBulk(slice any, setFunc func(*EntityTypeHistoryCreate, int)) *EntityTypeHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntityTypeHistoryCreateBulk{err: fmt.Errorf("calling to EntityTypeHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntityTypeHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntityTypeHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntityTypeHistory.
func (c *EntityTypeHistoryClient) Update() *EntityTypeHistoryUpdate {
	mutation := newEntityTypeHistoryMutation(c.config, OpUpdate)
	return &EntityTypeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityTypeHistoryClient) UpdateOne(eth *EntityTypeHistory) *EntityTypeHistoryUpdateOne {
	mutation := newEntityTypeHistoryMutation(c.config, OpUpdateOne, withEntityTypeHistory(eth))
	return &EntityTypeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityTypeHistoryClient) UpdateOneID(id string) *EntityTypeHistoryUpdateOne {
	mutation := newEntityTypeHistoryMutation(c.config, OpUpdateOne, withEntityTypeHistoryID(id))
	return &EntityTypeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntityTypeHistory.
func (c *EntityTypeHistoryClient) Delete() *EntityTypeHistoryDelete {
	mutation := newEntityTypeHistoryMutation(c.config, OpDelete)
	return &EntityTypeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityTypeHistoryClient) DeleteOne(eth *EntityTypeHistory) *EntityTypeHistoryDeleteOne {
	return c.DeleteOneID(eth.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityTypeHistoryClient) DeleteOneID(id string) *EntityTypeHistoryDeleteOne {
	builder := c.Delete().Where(entitytypehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityTypeHistoryDeleteOne{builder}
}

// Query returns a query builder for EntityTypeHistory.
func (c *EntityTypeHistoryClient) Query() *EntityTypeHistoryQuery {
	return &EntityTypeHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntityTypeHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EntityTypeHistory entity by its id.
func (c *EntityTypeHistoryClient) Get(ctx context.Context, id string) (*EntityTypeHistory, error) {
	return c.Query().Where(entitytypehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityTypeHistoryClient) GetX(ctx context.Context, id string) *EntityTypeHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EntityTypeHistoryClient) Hooks() []Hook {
	hooks := c.hooks.EntityTypeHistory
	return append(hooks[:len(hooks):len(hooks)], entitytypehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EntityTypeHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.EntityTypeHistory
	return append(inters[:len(inters):len(inters)], entitytypehistory.Interceptors[:]...)
}

func (c *EntityTypeHistoryClient) mutate(ctx context.Context, m *EntityTypeHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityTypeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityTypeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityTypeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityTypeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EntityTypeHistory mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id string) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id string) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id string) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id string) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Event.
func (c *EventClient) QueryUser(e *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.UserTable, event.UserPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a Event.
func (c *EventClient) QueryGroup(e *Event) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.GroupTable, event.GroupPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegration queries the integration edge of a Event.
func (c *EventClient) QueryIntegration(e *Event) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.IntegrationTable, event.IntegrationPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Event.
func (c *EventClient) QueryOrganization(e *Event) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.OrganizationTable, event.OrganizationPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvite queries the invite edge of a Event.
func (c *EventClient) QueryInvite(e *Event) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.InviteTable, event.InvitePrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Invite
		step.Edge.Schema = schemaConfig.InviteEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeature queries the feature edge of a Event.
func (c *EventClient) QueryFeature(e *Event) *FeatureQuery {
	query := (&FeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(feature.Table, feature.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.FeatureTable, event.FeaturePrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Feature
		step.Edge.Schema = schemaConfig.FeatureEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlementplan queries the entitlementplan edge of a Event.
func (c *EventClient) QueryEntitlementplan(e *Event) *EntitlementPlanQuery {
	query := (&EntitlementPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(entitlementplan.Table, entitlementplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.EntitlementplanTable, event.EntitlementplanPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlan
		step.Edge.Schema = schemaConfig.EntitlementPlanEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlementplanfeature queries the entitlementplanfeature edge of a Event.
func (c *EventClient) QueryEntitlementplanfeature(e *Event) *EntitlementPlanFeatureQuery {
	query := (&EntitlementPlanFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(entitlementplanfeature.Table, entitlementplanfeature.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.EntitlementplanfeatureTable, event.EntitlementplanfeaturePrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlanFeature
		step.Edge.Schema = schemaConfig.EntitlementPlanFeatureEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonalAccessToken queries the personal_access_token edge of a Event.
func (c *EventClient) QueryPersonalAccessToken(e *Event) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.PersonalAccessTokenTable, event.PersonalAccessTokenPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.PersonalAccessToken
		step.Edge.Schema = schemaConfig.PersonalAccessTokenEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauth2token queries the oauth2token edge of a Event.
func (c *EventClient) QueryOauth2token(e *Event) *OhAuthTooTokenQuery {
	query := (&OhAuthTooTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(ohauthtootoken.Table, ohauthtootoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.Oauth2tokenTable, event.Oauth2tokenPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.OhAuthTooToken
		step.Edge.Schema = schemaConfig.OhAuthTooTokenEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHush queries the hush edge of a Event.
func (c *EventClient) QueryHush(e *Event) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.HushTable, event.HushPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.HushEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgmembership queries the orgmembership edge of a Event.
func (c *EventClient) QueryOrgmembership(e *Event) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.OrgmembershipTable, event.OrgmembershipPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.OrgMembershipEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupmembership queries the groupmembership edge of a Event.
func (c *EventClient) QueryGroupmembership(e *Event) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.GroupmembershipTable, event.GroupmembershipPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.GroupMembership
		step.Edge.Schema = schemaConfig.GroupMembershipEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlement queries the entitlement edge of a Event.
func (c *EventClient) QueryEntitlement(e *Event) *EntitlementQuery {
	query := (&EntitlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(entitlement.Table, entitlement.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.EntitlementTable, event.EntitlementPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Entitlement
		step.Edge.Schema = schemaConfig.EntitlementEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebhook queries the webhook edge of a Event.
func (c *EventClient) QueryWebhook(e *Event) *WebhookQuery {
	query := (&WebhookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(webhook.Table, webhook.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.WebhookTable, event.WebhookPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Webhook
		step.Edge.Schema = schemaConfig.WebhookEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriber queries the subscriber edge of a Event.
func (c *EventClient) QuerySubscriber(e *Event) *SubscriberQuery {
	query := (&SubscriberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(subscriber.Table, subscriber.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.SubscriberTable, event.SubscriberPrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Subscriber
		step.Edge.Schema = schemaConfig.SubscriberEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a Event.
func (c *EventClient) QueryFile(e *Event) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, event.FileTable, event.FilePrimaryKey...),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.FileEvents
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	hooks := c.hooks.Event
	return append(hooks[:len(hooks):len(hooks)], event.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Event mutation op: %q", m.Op())
	}
}

// EventHistoryClient is a client for the EventHistory schema.
type EventHistoryClient struct {
	config
}

// NewEventHistoryClient returns a client for the EventHistory from the given config.
func NewEventHistoryClient(c config) *EventHistoryClient {
	return &EventHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventhistory.Hooks(f(g(h())))`.
func (c *EventHistoryClient) Use(hooks ...Hook) {
	c.hooks.EventHistory = append(c.hooks.EventHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventhistory.Intercept(f(g(h())))`.
func (c *EventHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventHistory = append(c.inters.EventHistory, interceptors...)
}

// Create returns a builder for creating a EventHistory entity.
func (c *EventHistoryClient) Create() *EventHistoryCreate {
	mutation := newEventHistoryMutation(c.config, OpCreate)
	return &EventHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventHistory entities.
func (c *EventHistoryClient) CreateBulk(builders ...*EventHistoryCreate) *EventHistoryCreateBulk {
	return &EventHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventHistoryClient) MapCreateBulk(slice any, setFunc func(*EventHistoryCreate, int)) *EventHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventHistoryCreateBulk{err: fmt.Errorf("calling to EventHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventHistory.
func (c *EventHistoryClient) Update() *EventHistoryUpdate {
	mutation := newEventHistoryMutation(c.config, OpUpdate)
	return &EventHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventHistoryClient) UpdateOne(eh *EventHistory) *EventHistoryUpdateOne {
	mutation := newEventHistoryMutation(c.config, OpUpdateOne, withEventHistory(eh))
	return &EventHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventHistoryClient) UpdateOneID(id string) *EventHistoryUpdateOne {
	mutation := newEventHistoryMutation(c.config, OpUpdateOne, withEventHistoryID(id))
	return &EventHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventHistory.
func (c *EventHistoryClient) Delete() *EventHistoryDelete {
	mutation := newEventHistoryMutation(c.config, OpDelete)
	return &EventHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventHistoryClient) DeleteOne(eh *EventHistory) *EventHistoryDeleteOne {
	return c.DeleteOneID(eh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventHistoryClient) DeleteOneID(id string) *EventHistoryDeleteOne {
	builder := c.Delete().Where(eventhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventHistoryDeleteOne{builder}
}

// Query returns a query builder for EventHistory.
func (c *EventHistoryClient) Query() *EventHistoryQuery {
	return &EventHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a EventHistory entity by its id.
func (c *EventHistoryClient) Get(ctx context.Context, id string) (*EventHistory, error) {
	return c.Query().Where(eventhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventHistoryClient) GetX(ctx context.Context, id string) *EventHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventHistoryClient) Hooks() []Hook {
	return c.hooks.EventHistory
}

// Interceptors returns the client interceptors.
func (c *EventHistoryClient) Interceptors() []Interceptor {
	return c.inters.EventHistory
}

func (c *EventHistoryClient) mutate(ctx context.Context, m *EventHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown EventHistory mutation op: %q", m.Op())
	}
}

// FeatureClient is a client for the Feature schema.
type FeatureClient struct {
	config
}

// NewFeatureClient returns a client for the Feature from the given config.
func NewFeatureClient(c config) *FeatureClient {
	return &FeatureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `feature.Hooks(f(g(h())))`.
func (c *FeatureClient) Use(hooks ...Hook) {
	c.hooks.Feature = append(c.hooks.Feature, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `feature.Intercept(f(g(h())))`.
func (c *FeatureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Feature = append(c.inters.Feature, interceptors...)
}

// Create returns a builder for creating a Feature entity.
func (c *FeatureClient) Create() *FeatureCreate {
	mutation := newFeatureMutation(c.config, OpCreate)
	return &FeatureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Feature entities.
func (c *FeatureClient) CreateBulk(builders ...*FeatureCreate) *FeatureCreateBulk {
	return &FeatureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeatureClient) MapCreateBulk(slice any, setFunc func(*FeatureCreate, int)) *FeatureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeatureCreateBulk{err: fmt.Errorf("calling to FeatureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeatureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeatureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Feature.
func (c *FeatureClient) Update() *FeatureUpdate {
	mutation := newFeatureMutation(c.config, OpUpdate)
	return &FeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeatureClient) UpdateOne(f *Feature) *FeatureUpdateOne {
	mutation := newFeatureMutation(c.config, OpUpdateOne, withFeature(f))
	return &FeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeatureClient) UpdateOneID(id string) *FeatureUpdateOne {
	mutation := newFeatureMutation(c.config, OpUpdateOne, withFeatureID(id))
	return &FeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Feature.
func (c *FeatureClient) Delete() *FeatureDelete {
	mutation := newFeatureMutation(c.config, OpDelete)
	return &FeatureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeatureClient) DeleteOne(f *Feature) *FeatureDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeatureClient) DeleteOneID(id string) *FeatureDeleteOne {
	builder := c.Delete().Where(feature.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeatureDeleteOne{builder}
}

// Query returns a query builder for Feature.
func (c *FeatureClient) Query() *FeatureQuery {
	return &FeatureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeature},
		inters: c.Interceptors(),
	}
}

// Get returns a Feature entity by its id.
func (c *FeatureClient) Get(ctx context.Context, id string) (*Feature, error) {
	return c.Query().Where(feature.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeatureClient) GetX(ctx context.Context, id string) *Feature {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Feature.
func (c *FeatureClient) QueryOwner(f *Feature) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feature.Table, feature.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, feature.OwnerTable, feature.OwnerColumn),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Feature
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlans queries the plans edge of a Feature.
func (c *FeatureClient) QueryPlans(f *Feature) *EntitlementPlanQuery {
	query := (&EntitlementPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feature.Table, feature.FieldID, id),
			sqlgraph.To(entitlementplan.Table, entitlementplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, feature.PlansTable, feature.PlansPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlan
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Feature.
func (c *FeatureClient) QueryEvents(f *Feature) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feature.Table, feature.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, feature.EventsTable, feature.EventsPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.FeatureEvents
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeatures queries the features edge of a Feature.
func (c *FeatureClient) QueryFeatures(f *Feature) *EntitlementPlanFeatureQuery {
	query := (&EntitlementPlanFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feature.Table, feature.FieldID, id),
			sqlgraph.To(entitlementplanfeature.Table, entitlementplanfeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, feature.FeaturesTable, feature.FeaturesColumn),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlanFeature
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeatureClient) Hooks() []Hook {
	hooks := c.hooks.Feature
	return append(hooks[:len(hooks):len(hooks)], feature.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FeatureClient) Interceptors() []Interceptor {
	inters := c.inters.Feature
	return append(inters[:len(inters):len(inters)], feature.Interceptors[:]...)
}

func (c *FeatureClient) mutate(ctx context.Context, m *FeatureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeatureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeatureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeatureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeatureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Feature mutation op: %q", m.Op())
	}
}

// FeatureHistoryClient is a client for the FeatureHistory schema.
type FeatureHistoryClient struct {
	config
}

// NewFeatureHistoryClient returns a client for the FeatureHistory from the given config.
func NewFeatureHistoryClient(c config) *FeatureHistoryClient {
	return &FeatureHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featurehistory.Hooks(f(g(h())))`.
func (c *FeatureHistoryClient) Use(hooks ...Hook) {
	c.hooks.FeatureHistory = append(c.hooks.FeatureHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featurehistory.Intercept(f(g(h())))`.
func (c *FeatureHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeatureHistory = append(c.inters.FeatureHistory, interceptors...)
}

// Create returns a builder for creating a FeatureHistory entity.
func (c *FeatureHistoryClient) Create() *FeatureHistoryCreate {
	mutation := newFeatureHistoryMutation(c.config, OpCreate)
	return &FeatureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeatureHistory entities.
func (c *FeatureHistoryClient) CreateBulk(builders ...*FeatureHistoryCreate) *FeatureHistoryCreateBulk {
	return &FeatureHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeatureHistoryClient) MapCreateBulk(slice any, setFunc func(*FeatureHistoryCreate, int)) *FeatureHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeatureHistoryCreateBulk{err: fmt.Errorf("calling to FeatureHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeatureHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeatureHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeatureHistory.
func (c *FeatureHistoryClient) Update() *FeatureHistoryUpdate {
	mutation := newFeatureHistoryMutation(c.config, OpUpdate)
	return &FeatureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeatureHistoryClient) UpdateOne(fh *FeatureHistory) *FeatureHistoryUpdateOne {
	mutation := newFeatureHistoryMutation(c.config, OpUpdateOne, withFeatureHistory(fh))
	return &FeatureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeatureHistoryClient) UpdateOneID(id string) *FeatureHistoryUpdateOne {
	mutation := newFeatureHistoryMutation(c.config, OpUpdateOne, withFeatureHistoryID(id))
	return &FeatureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeatureHistory.
func (c *FeatureHistoryClient) Delete() *FeatureHistoryDelete {
	mutation := newFeatureHistoryMutation(c.config, OpDelete)
	return &FeatureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeatureHistoryClient) DeleteOne(fh *FeatureHistory) *FeatureHistoryDeleteOne {
	return c.DeleteOneID(fh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeatureHistoryClient) DeleteOneID(id string) *FeatureHistoryDeleteOne {
	builder := c.Delete().Where(featurehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeatureHistoryDeleteOne{builder}
}

// Query returns a query builder for FeatureHistory.
func (c *FeatureHistoryClient) Query() *FeatureHistoryQuery {
	return &FeatureHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeatureHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a FeatureHistory entity by its id.
func (c *FeatureHistoryClient) Get(ctx context.Context, id string) (*FeatureHistory, error) {
	return c.Query().Where(featurehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeatureHistoryClient) GetX(ctx context.Context, id string) *FeatureHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FeatureHistoryClient) Hooks() []Hook {
	hooks := c.hooks.FeatureHistory
	return append(hooks[:len(hooks):len(hooks)], featurehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FeatureHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.FeatureHistory
	return append(inters[:len(inters):len(inters)], featurehistory.Interceptors[:]...)
}

func (c *FeatureHistoryClient) mutate(ctx context.Context, m *FeatureHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeatureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeatureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeatureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeatureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FeatureHistory mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id string) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id string) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id string) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id string) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a File.
func (c *FileClient) QueryUser(f *File) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.UserTable, file.UserPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a File.
func (c *FileClient) QueryOrganization(f *File) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.OrganizationTable, file.OrganizationPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a File.
func (c *FileClient) QueryGroup(f *File) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.GroupTable, file.GroupPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContact queries the contact edge of a File.
func (c *FileClient) QueryContact(f *File) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.ContactTable, file.ContactPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Contact
		step.Edge.Schema = schemaConfig.ContactFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntity queries the entity edge of a File.
func (c *FileClient) QueryEntity(f *File) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.EntityTable, file.EntityPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.EntityFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsersetting queries the usersetting edge of a File.
func (c *FileClient) QueryUsersetting(f *File) *UserSettingQuery {
	query := (&UserSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(usersetting.Table, usersetting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.UsersettingTable, file.UsersettingPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.UserSetting
		step.Edge.Schema = schemaConfig.UserSettingFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationsetting queries the organizationsetting edge of a File.
func (c *FileClient) QueryOrganizationsetting(f *File) *OrganizationSettingQuery {
	query := (&OrganizationSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(organizationsetting.Table, organizationsetting.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.OrganizationsettingTable, file.OrganizationsettingPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.OrganizationSetting
		step.Edge.Schema = schemaConfig.OrganizationSettingFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a File.
func (c *FileClient) QueryTemplate(f *File) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.TemplateTable, file.TemplatePrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.TemplateFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocumentdata queries the documentdata edge of a File.
func (c *FileClient) QueryDocumentdata(f *File) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.DocumentdataTable, file.DocumentdataPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.DocumentDataFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a File.
func (c *FileClient) QueryEvents(f *File) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, file.EventsTable, file.EventsPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.FileEvents
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a File.
func (c *FileClient) QueryProgram(f *File) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.ProgramTable, file.ProgramPrimaryKey...),
		)
		schemaConfig := f.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramFiles
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	hooks := c.hooks.File
	return append(hooks[:len(hooks):len(hooks)], file.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	inters := c.inters.File
	return append(inters[:len(inters):len(inters)], file.Interceptors[:]...)
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown File mutation op: %q", m.Op())
	}
}

// FileHistoryClient is a client for the FileHistory schema.
type FileHistoryClient struct {
	config
}

// NewFileHistoryClient returns a client for the FileHistory from the given config.
func NewFileHistoryClient(c config) *FileHistoryClient {
	return &FileHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filehistory.Hooks(f(g(h())))`.
func (c *FileHistoryClient) Use(hooks ...Hook) {
	c.hooks.FileHistory = append(c.hooks.FileHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filehistory.Intercept(f(g(h())))`.
func (c *FileHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileHistory = append(c.inters.FileHistory, interceptors...)
}

// Create returns a builder for creating a FileHistory entity.
func (c *FileHistoryClient) Create() *FileHistoryCreate {
	mutation := newFileHistoryMutation(c.config, OpCreate)
	return &FileHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileHistory entities.
func (c *FileHistoryClient) CreateBulk(builders ...*FileHistoryCreate) *FileHistoryCreateBulk {
	return &FileHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileHistoryClient) MapCreateBulk(slice any, setFunc func(*FileHistoryCreate, int)) *FileHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileHistoryCreateBulk{err: fmt.Errorf("calling to FileHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileHistory.
func (c *FileHistoryClient) Update() *FileHistoryUpdate {
	mutation := newFileHistoryMutation(c.config, OpUpdate)
	return &FileHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileHistoryClient) UpdateOne(fh *FileHistory) *FileHistoryUpdateOne {
	mutation := newFileHistoryMutation(c.config, OpUpdateOne, withFileHistory(fh))
	return &FileHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileHistoryClient) UpdateOneID(id string) *FileHistoryUpdateOne {
	mutation := newFileHistoryMutation(c.config, OpUpdateOne, withFileHistoryID(id))
	return &FileHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileHistory.
func (c *FileHistoryClient) Delete() *FileHistoryDelete {
	mutation := newFileHistoryMutation(c.config, OpDelete)
	return &FileHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileHistoryClient) DeleteOne(fh *FileHistory) *FileHistoryDeleteOne {
	return c.DeleteOneID(fh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileHistoryClient) DeleteOneID(id string) *FileHistoryDeleteOne {
	builder := c.Delete().Where(filehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileHistoryDeleteOne{builder}
}

// Query returns a query builder for FileHistory.
func (c *FileHistoryClient) Query() *FileHistoryQuery {
	return &FileHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a FileHistory entity by its id.
func (c *FileHistoryClient) Get(ctx context.Context, id string) (*FileHistory, error) {
	return c.Query().Where(filehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileHistoryClient) GetX(ctx context.Context, id string) *FileHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FileHistoryClient) Hooks() []Hook {
	hooks := c.hooks.FileHistory
	return append(hooks[:len(hooks):len(hooks)], filehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.FileHistory
	return append(inters[:len(inters):len(inters)], filehistory.Interceptors[:]...)
}

func (c *FileHistoryClient) mutate(ctx context.Context, m *FileHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown FileHistory mutation op: %q", m.Op())
	}
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `group.Intercept(f(g(h())))`.
func (c *GroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.Group = append(c.inters.Group, interceptors...)
}

// Create returns a builder for creating a Group entity.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupClient) MapCreateBulk(slice any, setFunc func(*GroupCreate, int)) *GroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupCreateBulk{err: fmt.Errorf("calling to GroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id string) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupClient) DeleteOneID(id string) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id string) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id string) *Group {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Group.
func (c *GroupClient) QueryOwner(gr *Group) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, group.OwnerTable, group.OwnerColumn),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a Group.
func (c *GroupClient) QuerySetting(gr *Group) *GroupSettingQuery {
	query := (&GroupSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(groupsetting.Table, groupsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, group.SettingTable, group.SettingColumn),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.GroupSetting
		step.Edge.Schema = schemaConfig.GroupSetting
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(gr *Group) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.UsersTable, group.UsersPrimaryKey...),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Group.
func (c *GroupClient) QueryEvents(gr *Group) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.EventsTable, group.EventsPrimaryKey...),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.GroupEvents
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Group.
func (c *GroupClient) QueryIntegrations(gr *Group) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, group.IntegrationsTable, group.IntegrationsColumn),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Group.
func (c *GroupClient) QueryFiles(gr *Group) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.FilesTable, group.FilesPrimaryKey...),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.GroupFiles
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Group.
func (c *GroupClient) QueryTasks(gr *Group) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.TasksTable, group.TasksPrimaryKey...),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.GroupTasks
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Group.
func (c *GroupClient) QueryMembers(gr *Group) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, group.MembersTable, group.MembersColumn),
		)
		schemaConfig := gr.schemaConfig
		step.To.Schema = schemaConfig.GroupMembership
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	hooks := c.hooks.Group
	return append(hooks[:len(hooks):len(hooks)], group.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupClient) Interceptors() []Interceptor {
	inters := c.inters.Group
	return append(inters[:len(inters):len(inters)], group.Interceptors[:]...)
}

func (c *GroupClient) mutate(ctx context.Context, m *GroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Group mutation op: %q", m.Op())
	}
}

// GroupHistoryClient is a client for the GroupHistory schema.
type GroupHistoryClient struct {
	config
}

// NewGroupHistoryClient returns a client for the GroupHistory from the given config.
func NewGroupHistoryClient(c config) *GroupHistoryClient {
	return &GroupHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grouphistory.Hooks(f(g(h())))`.
func (c *GroupHistoryClient) Use(hooks ...Hook) {
	c.hooks.GroupHistory = append(c.hooks.GroupHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grouphistory.Intercept(f(g(h())))`.
func (c *GroupHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupHistory = append(c.inters.GroupHistory, interceptors...)
}

// Create returns a builder for creating a GroupHistory entity.
func (c *GroupHistoryClient) Create() *GroupHistoryCreate {
	mutation := newGroupHistoryMutation(c.config, OpCreate)
	return &GroupHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupHistory entities.
func (c *GroupHistoryClient) CreateBulk(builders ...*GroupHistoryCreate) *GroupHistoryCreateBulk {
	return &GroupHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupHistoryClient) MapCreateBulk(slice any, setFunc func(*GroupHistoryCreate, int)) *GroupHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupHistoryCreateBulk{err: fmt.Errorf("calling to GroupHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupHistory.
func (c *GroupHistoryClient) Update() *GroupHistoryUpdate {
	mutation := newGroupHistoryMutation(c.config, OpUpdate)
	return &GroupHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupHistoryClient) UpdateOne(gh *GroupHistory) *GroupHistoryUpdateOne {
	mutation := newGroupHistoryMutation(c.config, OpUpdateOne, withGroupHistory(gh))
	return &GroupHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupHistoryClient) UpdateOneID(id string) *GroupHistoryUpdateOne {
	mutation := newGroupHistoryMutation(c.config, OpUpdateOne, withGroupHistoryID(id))
	return &GroupHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupHistory.
func (c *GroupHistoryClient) Delete() *GroupHistoryDelete {
	mutation := newGroupHistoryMutation(c.config, OpDelete)
	return &GroupHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupHistoryClient) DeleteOne(gh *GroupHistory) *GroupHistoryDeleteOne {
	return c.DeleteOneID(gh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupHistoryClient) DeleteOneID(id string) *GroupHistoryDeleteOne {
	builder := c.Delete().Where(grouphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupHistoryDeleteOne{builder}
}

// Query returns a query builder for GroupHistory.
func (c *GroupHistoryClient) Query() *GroupHistoryQuery {
	return &GroupHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupHistory entity by its id.
func (c *GroupHistoryClient) Get(ctx context.Context, id string) (*GroupHistory, error) {
	return c.Query().Where(grouphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupHistoryClient) GetX(ctx context.Context, id string) *GroupHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupHistoryClient) Hooks() []Hook {
	hooks := c.hooks.GroupHistory
	return append(hooks[:len(hooks):len(hooks)], grouphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.GroupHistory
	return append(inters[:len(inters):len(inters)], grouphistory.Interceptors[:]...)
}

func (c *GroupHistoryClient) mutate(ctx context.Context, m *GroupHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupHistory mutation op: %q", m.Op())
	}
}

// GroupMembershipClient is a client for the GroupMembership schema.
type GroupMembershipClient struct {
	config
}

// NewGroupMembershipClient returns a client for the GroupMembership from the given config.
func NewGroupMembershipClient(c config) *GroupMembershipClient {
	return &GroupMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupmembership.Hooks(f(g(h())))`.
func (c *GroupMembershipClient) Use(hooks ...Hook) {
	c.hooks.GroupMembership = append(c.hooks.GroupMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupmembership.Intercept(f(g(h())))`.
func (c *GroupMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupMembership = append(c.inters.GroupMembership, interceptors...)
}

// Create returns a builder for creating a GroupMembership entity.
func (c *GroupMembershipClient) Create() *GroupMembershipCreate {
	mutation := newGroupMembershipMutation(c.config, OpCreate)
	return &GroupMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupMembership entities.
func (c *GroupMembershipClient) CreateBulk(builders ...*GroupMembershipCreate) *GroupMembershipCreateBulk {
	return &GroupMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupMembershipClient) MapCreateBulk(slice any, setFunc func(*GroupMembershipCreate, int)) *GroupMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupMembershipCreateBulk{err: fmt.Errorf("calling to GroupMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupMembership.
func (c *GroupMembershipClient) Update() *GroupMembershipUpdate {
	mutation := newGroupMembershipMutation(c.config, OpUpdate)
	return &GroupMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupMembershipClient) UpdateOne(gm *GroupMembership) *GroupMembershipUpdateOne {
	mutation := newGroupMembershipMutation(c.config, OpUpdateOne, withGroupMembership(gm))
	return &GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupMembershipClient) UpdateOneID(id string) *GroupMembershipUpdateOne {
	mutation := newGroupMembershipMutation(c.config, OpUpdateOne, withGroupMembershipID(id))
	return &GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupMembership.
func (c *GroupMembershipClient) Delete() *GroupMembershipDelete {
	mutation := newGroupMembershipMutation(c.config, OpDelete)
	return &GroupMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupMembershipClient) DeleteOne(gm *GroupMembership) *GroupMembershipDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupMembershipClient) DeleteOneID(id string) *GroupMembershipDeleteOne {
	builder := c.Delete().Where(groupmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupMembershipDeleteOne{builder}
}

// Query returns a query builder for GroupMembership.
func (c *GroupMembershipClient) Query() *GroupMembershipQuery {
	return &GroupMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupMembership entity by its id.
func (c *GroupMembershipClient) Get(ctx context.Context, id string) (*GroupMembership, error) {
	return c.Query().Where(groupmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupMembershipClient) GetX(ctx context.Context, id string) *GroupMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a GroupMembership.
func (c *GroupMembershipClient) QueryGroup(gm *GroupMembership) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.GroupTable, groupmembership.GroupColumn),
		)
		schemaConfig := gm.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(gm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a GroupMembership.
func (c *GroupMembershipClient) QueryUser(gm *GroupMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, groupmembership.UserTable, groupmembership.UserColumn),
		)
		schemaConfig := gm.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(gm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a GroupMembership.
func (c *GroupMembershipClient) QueryEvents(gm *GroupMembership) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupmembership.Table, groupmembership.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, groupmembership.EventsTable, groupmembership.EventsPrimaryKey...),
		)
		schemaConfig := gm.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.GroupMembershipEvents
		fromV = sqlgraph.Neighbors(gm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupMembershipClient) Hooks() []Hook {
	hooks := c.hooks.GroupMembership
	return append(hooks[:len(hooks):len(hooks)], groupmembership.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupMembershipClient) Interceptors() []Interceptor {
	inters := c.inters.GroupMembership
	return append(inters[:len(inters):len(inters)], groupmembership.Interceptors[:]...)
}

func (c *GroupMembershipClient) mutate(ctx context.Context, m *GroupMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupMembership mutation op: %q", m.Op())
	}
}

// GroupMembershipHistoryClient is a client for the GroupMembershipHistory schema.
type GroupMembershipHistoryClient struct {
	config
}

// NewGroupMembershipHistoryClient returns a client for the GroupMembershipHistory from the given config.
func NewGroupMembershipHistoryClient(c config) *GroupMembershipHistoryClient {
	return &GroupMembershipHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupmembershiphistory.Hooks(f(g(h())))`.
func (c *GroupMembershipHistoryClient) Use(hooks ...Hook) {
	c.hooks.GroupMembershipHistory = append(c.hooks.GroupMembershipHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupmembershiphistory.Intercept(f(g(h())))`.
func (c *GroupMembershipHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupMembershipHistory = append(c.inters.GroupMembershipHistory, interceptors...)
}

// Create returns a builder for creating a GroupMembershipHistory entity.
func (c *GroupMembershipHistoryClient) Create() *GroupMembershipHistoryCreate {
	mutation := newGroupMembershipHistoryMutation(c.config, OpCreate)
	return &GroupMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupMembershipHistory entities.
func (c *GroupMembershipHistoryClient) CreateBulk(builders ...*GroupMembershipHistoryCreate) *GroupMembershipHistoryCreateBulk {
	return &GroupMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupMembershipHistoryClient) MapCreateBulk(slice any, setFunc func(*GroupMembershipHistoryCreate, int)) *GroupMembershipHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupMembershipHistoryCreateBulk{err: fmt.Errorf("calling to GroupMembershipHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupMembershipHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupMembershipHistory.
func (c *GroupMembershipHistoryClient) Update() *GroupMembershipHistoryUpdate {
	mutation := newGroupMembershipHistoryMutation(c.config, OpUpdate)
	return &GroupMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupMembershipHistoryClient) UpdateOne(gmh *GroupMembershipHistory) *GroupMembershipHistoryUpdateOne {
	mutation := newGroupMembershipHistoryMutation(c.config, OpUpdateOne, withGroupMembershipHistory(gmh))
	return &GroupMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupMembershipHistoryClient) UpdateOneID(id string) *GroupMembershipHistoryUpdateOne {
	mutation := newGroupMembershipHistoryMutation(c.config, OpUpdateOne, withGroupMembershipHistoryID(id))
	return &GroupMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupMembershipHistory.
func (c *GroupMembershipHistoryClient) Delete() *GroupMembershipHistoryDelete {
	mutation := newGroupMembershipHistoryMutation(c.config, OpDelete)
	return &GroupMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupMembershipHistoryClient) DeleteOne(gmh *GroupMembershipHistory) *GroupMembershipHistoryDeleteOne {
	return c.DeleteOneID(gmh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupMembershipHistoryClient) DeleteOneID(id string) *GroupMembershipHistoryDeleteOne {
	builder := c.Delete().Where(groupmembershiphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupMembershipHistoryDeleteOne{builder}
}

// Query returns a query builder for GroupMembershipHistory.
func (c *GroupMembershipHistoryClient) Query() *GroupMembershipHistoryQuery {
	return &GroupMembershipHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupMembershipHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupMembershipHistory entity by its id.
func (c *GroupMembershipHistoryClient) Get(ctx context.Context, id string) (*GroupMembershipHistory, error) {
	return c.Query().Where(groupmembershiphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupMembershipHistoryClient) GetX(ctx context.Context, id string) *GroupMembershipHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupMembershipHistoryClient) Hooks() []Hook {
	hooks := c.hooks.GroupMembershipHistory
	return append(hooks[:len(hooks):len(hooks)], groupmembershiphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupMembershipHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.GroupMembershipHistory
	return append(inters[:len(inters):len(inters)], groupmembershiphistory.Interceptors[:]...)
}

func (c *GroupMembershipHistoryClient) mutate(ctx context.Context, m *GroupMembershipHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupMembershipHistory mutation op: %q", m.Op())
	}
}

// GroupSettingClient is a client for the GroupSetting schema.
type GroupSettingClient struct {
	config
}

// NewGroupSettingClient returns a client for the GroupSetting from the given config.
func NewGroupSettingClient(c config) *GroupSettingClient {
	return &GroupSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupsetting.Hooks(f(g(h())))`.
func (c *GroupSettingClient) Use(hooks ...Hook) {
	c.hooks.GroupSetting = append(c.hooks.GroupSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupsetting.Intercept(f(g(h())))`.
func (c *GroupSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupSetting = append(c.inters.GroupSetting, interceptors...)
}

// Create returns a builder for creating a GroupSetting entity.
func (c *GroupSettingClient) Create() *GroupSettingCreate {
	mutation := newGroupSettingMutation(c.config, OpCreate)
	return &GroupSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupSetting entities.
func (c *GroupSettingClient) CreateBulk(builders ...*GroupSettingCreate) *GroupSettingCreateBulk {
	return &GroupSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupSettingClient) MapCreateBulk(slice any, setFunc func(*GroupSettingCreate, int)) *GroupSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupSettingCreateBulk{err: fmt.Errorf("calling to GroupSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupSetting.
func (c *GroupSettingClient) Update() *GroupSettingUpdate {
	mutation := newGroupSettingMutation(c.config, OpUpdate)
	return &GroupSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupSettingClient) UpdateOne(gs *GroupSetting) *GroupSettingUpdateOne {
	mutation := newGroupSettingMutation(c.config, OpUpdateOne, withGroupSetting(gs))
	return &GroupSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupSettingClient) UpdateOneID(id string) *GroupSettingUpdateOne {
	mutation := newGroupSettingMutation(c.config, OpUpdateOne, withGroupSettingID(id))
	return &GroupSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupSetting.
func (c *GroupSettingClient) Delete() *GroupSettingDelete {
	mutation := newGroupSettingMutation(c.config, OpDelete)
	return &GroupSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupSettingClient) DeleteOne(gs *GroupSetting) *GroupSettingDeleteOne {
	return c.DeleteOneID(gs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupSettingClient) DeleteOneID(id string) *GroupSettingDeleteOne {
	builder := c.Delete().Where(groupsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupSettingDeleteOne{builder}
}

// Query returns a query builder for GroupSetting.
func (c *GroupSettingClient) Query() *GroupSettingQuery {
	return &GroupSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupSetting entity by its id.
func (c *GroupSettingClient) Get(ctx context.Context, id string) (*GroupSetting, error) {
	return c.Query().Where(groupsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupSettingClient) GetX(ctx context.Context, id string) *GroupSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a GroupSetting.
func (c *GroupSettingClient) QueryGroup(gs *GroupSetting) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(groupsetting.Table, groupsetting.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, groupsetting.GroupTable, groupsetting.GroupColumn),
		)
		schemaConfig := gs.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupSetting
		fromV = sqlgraph.Neighbors(gs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupSettingClient) Hooks() []Hook {
	hooks := c.hooks.GroupSetting
	return append(hooks[:len(hooks):len(hooks)], groupsetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupSettingClient) Interceptors() []Interceptor {
	inters := c.inters.GroupSetting
	return append(inters[:len(inters):len(inters)], groupsetting.Interceptors[:]...)
}

func (c *GroupSettingClient) mutate(ctx context.Context, m *GroupSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupSetting mutation op: %q", m.Op())
	}
}

// GroupSettingHistoryClient is a client for the GroupSettingHistory schema.
type GroupSettingHistoryClient struct {
	config
}

// NewGroupSettingHistoryClient returns a client for the GroupSettingHistory from the given config.
func NewGroupSettingHistoryClient(c config) *GroupSettingHistoryClient {
	return &GroupSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupsettinghistory.Hooks(f(g(h())))`.
func (c *GroupSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.GroupSettingHistory = append(c.hooks.GroupSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupsettinghistory.Intercept(f(g(h())))`.
func (c *GroupSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupSettingHistory = append(c.inters.GroupSettingHistory, interceptors...)
}

// Create returns a builder for creating a GroupSettingHistory entity.
func (c *GroupSettingHistoryClient) Create() *GroupSettingHistoryCreate {
	mutation := newGroupSettingHistoryMutation(c.config, OpCreate)
	return &GroupSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupSettingHistory entities.
func (c *GroupSettingHistoryClient) CreateBulk(builders ...*GroupSettingHistoryCreate) *GroupSettingHistoryCreateBulk {
	return &GroupSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroupSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*GroupSettingHistoryCreate, int)) *GroupSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroupSettingHistoryCreateBulk{err: fmt.Errorf("calling to GroupSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroupSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroupSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupSettingHistory.
func (c *GroupSettingHistoryClient) Update() *GroupSettingHistoryUpdate {
	mutation := newGroupSettingHistoryMutation(c.config, OpUpdate)
	return &GroupSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupSettingHistoryClient) UpdateOne(gsh *GroupSettingHistory) *GroupSettingHistoryUpdateOne {
	mutation := newGroupSettingHistoryMutation(c.config, OpUpdateOne, withGroupSettingHistory(gsh))
	return &GroupSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupSettingHistoryClient) UpdateOneID(id string) *GroupSettingHistoryUpdateOne {
	mutation := newGroupSettingHistoryMutation(c.config, OpUpdateOne, withGroupSettingHistoryID(id))
	return &GroupSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupSettingHistory.
func (c *GroupSettingHistoryClient) Delete() *GroupSettingHistoryDelete {
	mutation := newGroupSettingHistoryMutation(c.config, OpDelete)
	return &GroupSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupSettingHistoryClient) DeleteOne(gsh *GroupSettingHistory) *GroupSettingHistoryDeleteOne {
	return c.DeleteOneID(gsh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupSettingHistoryClient) DeleteOneID(id string) *GroupSettingHistoryDeleteOne {
	builder := c.Delete().Where(groupsettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for GroupSettingHistory.
func (c *GroupSettingHistoryClient) Query() *GroupSettingHistoryQuery {
	return &GroupSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupSettingHistory entity by its id.
func (c *GroupSettingHistoryClient) Get(ctx context.Context, id string) (*GroupSettingHistory, error) {
	return c.Query().Where(groupsettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupSettingHistoryClient) GetX(ctx context.Context, id string) *GroupSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupSettingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.GroupSettingHistory
	return append(hooks[:len(hooks):len(hooks)], groupsettinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *GroupSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.GroupSettingHistory
	return append(inters[:len(inters):len(inters)], groupsettinghistory.Interceptors[:]...)
}

func (c *GroupSettingHistoryClient) mutate(ctx context.Context, m *GroupSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown GroupSettingHistory mutation op: %q", m.Op())
	}
}

// HushClient is a client for the Hush schema.
type HushClient struct {
	config
}

// NewHushClient returns a client for the Hush from the given config.
func NewHushClient(c config) *HushClient {
	return &HushClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hush.Hooks(f(g(h())))`.
func (c *HushClient) Use(hooks ...Hook) {
	c.hooks.Hush = append(c.hooks.Hush, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hush.Intercept(f(g(h())))`.
func (c *HushClient) Intercept(interceptors ...Interceptor) {
	c.inters.Hush = append(c.inters.Hush, interceptors...)
}

// Create returns a builder for creating a Hush entity.
func (c *HushClient) Create() *HushCreate {
	mutation := newHushMutation(c.config, OpCreate)
	return &HushCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hush entities.
func (c *HushClient) CreateBulk(builders ...*HushCreate) *HushCreateBulk {
	return &HushCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HushClient) MapCreateBulk(slice any, setFunc func(*HushCreate, int)) *HushCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HushCreateBulk{err: fmt.Errorf("calling to HushClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HushCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HushCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hush.
func (c *HushClient) Update() *HushUpdate {
	mutation := newHushMutation(c.config, OpUpdate)
	return &HushUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HushClient) UpdateOne(h *Hush) *HushUpdateOne {
	mutation := newHushMutation(c.config, OpUpdateOne, withHush(h))
	return &HushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HushClient) UpdateOneID(id string) *HushUpdateOne {
	mutation := newHushMutation(c.config, OpUpdateOne, withHushID(id))
	return &HushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hush.
func (c *HushClient) Delete() *HushDelete {
	mutation := newHushMutation(c.config, OpDelete)
	return &HushDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HushClient) DeleteOne(h *Hush) *HushDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HushClient) DeleteOneID(id string) *HushDeleteOne {
	builder := c.Delete().Where(hush.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HushDeleteOne{builder}
}

// Query returns a query builder for Hush.
func (c *HushClient) Query() *HushQuery {
	return &HushQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHush},
		inters: c.Interceptors(),
	}
}

// Get returns a Hush entity by its id.
func (c *HushClient) Get(ctx context.Context, id string) (*Hush, error) {
	return c.Query().Where(hush.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HushClient) GetX(ctx context.Context, id string) *Hush {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIntegrations queries the integrations edge of a Hush.
func (c *HushClient) QueryIntegrations(h *Hush) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, hush.IntegrationsTable, hush.IntegrationsPrimaryKey...),
		)
		schemaConfig := h.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationSecrets
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Hush.
func (c *HushClient) QueryOrganization(h *Hush) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, hush.OrganizationTable, hush.OrganizationPrimaryKey...),
		)
		schemaConfig := h.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationSecrets
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Hush.
func (c *HushClient) QueryEvents(h *Hush) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hush.Table, hush.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, hush.EventsTable, hush.EventsPrimaryKey...),
		)
		schemaConfig := h.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.HushEvents
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HushClient) Hooks() []Hook {
	hooks := c.hooks.Hush
	return append(hooks[:len(hooks):len(hooks)], hush.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *HushClient) Interceptors() []Interceptor {
	inters := c.inters.Hush
	return append(inters[:len(inters):len(inters)], hush.Interceptors[:]...)
}

func (c *HushClient) mutate(ctx context.Context, m *HushMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HushCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HushUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HushDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Hush mutation op: %q", m.Op())
	}
}

// HushHistoryClient is a client for the HushHistory schema.
type HushHistoryClient struct {
	config
}

// NewHushHistoryClient returns a client for the HushHistory from the given config.
func NewHushHistoryClient(c config) *HushHistoryClient {
	return &HushHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hushhistory.Hooks(f(g(h())))`.
func (c *HushHistoryClient) Use(hooks ...Hook) {
	c.hooks.HushHistory = append(c.hooks.HushHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hushhistory.Intercept(f(g(h())))`.
func (c *HushHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.HushHistory = append(c.inters.HushHistory, interceptors...)
}

// Create returns a builder for creating a HushHistory entity.
func (c *HushHistoryClient) Create() *HushHistoryCreate {
	mutation := newHushHistoryMutation(c.config, OpCreate)
	return &HushHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HushHistory entities.
func (c *HushHistoryClient) CreateBulk(builders ...*HushHistoryCreate) *HushHistoryCreateBulk {
	return &HushHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HushHistoryClient) MapCreateBulk(slice any, setFunc func(*HushHistoryCreate, int)) *HushHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HushHistoryCreateBulk{err: fmt.Errorf("calling to HushHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HushHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HushHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HushHistory.
func (c *HushHistoryClient) Update() *HushHistoryUpdate {
	mutation := newHushHistoryMutation(c.config, OpUpdate)
	return &HushHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HushHistoryClient) UpdateOne(hh *HushHistory) *HushHistoryUpdateOne {
	mutation := newHushHistoryMutation(c.config, OpUpdateOne, withHushHistory(hh))
	return &HushHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HushHistoryClient) UpdateOneID(id string) *HushHistoryUpdateOne {
	mutation := newHushHistoryMutation(c.config, OpUpdateOne, withHushHistoryID(id))
	return &HushHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HushHistory.
func (c *HushHistoryClient) Delete() *HushHistoryDelete {
	mutation := newHushHistoryMutation(c.config, OpDelete)
	return &HushHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HushHistoryClient) DeleteOne(hh *HushHistory) *HushHistoryDeleteOne {
	return c.DeleteOneID(hh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HushHistoryClient) DeleteOneID(id string) *HushHistoryDeleteOne {
	builder := c.Delete().Where(hushhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HushHistoryDeleteOne{builder}
}

// Query returns a query builder for HushHistory.
func (c *HushHistoryClient) Query() *HushHistoryQuery {
	return &HushHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHushHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a HushHistory entity by its id.
func (c *HushHistoryClient) Get(ctx context.Context, id string) (*HushHistory, error) {
	return c.Query().Where(hushhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HushHistoryClient) GetX(ctx context.Context, id string) *HushHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HushHistoryClient) Hooks() []Hook {
	return c.hooks.HushHistory
}

// Interceptors returns the client interceptors.
func (c *HushHistoryClient) Interceptors() []Interceptor {
	return c.inters.HushHistory
}

func (c *HushHistoryClient) mutate(ctx context.Context, m *HushHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HushHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HushHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HushHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HushHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown HushHistory mutation op: %q", m.Op())
	}
}

// IntegrationClient is a client for the Integration schema.
type IntegrationClient struct {
	config
}

// NewIntegrationClient returns a client for the Integration from the given config.
func NewIntegrationClient(c config) *IntegrationClient {
	return &IntegrationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integration.Hooks(f(g(h())))`.
func (c *IntegrationClient) Use(hooks ...Hook) {
	c.hooks.Integration = append(c.hooks.Integration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integration.Intercept(f(g(h())))`.
func (c *IntegrationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Integration = append(c.inters.Integration, interceptors...)
}

// Create returns a builder for creating a Integration entity.
func (c *IntegrationClient) Create() *IntegrationCreate {
	mutation := newIntegrationMutation(c.config, OpCreate)
	return &IntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Integration entities.
func (c *IntegrationClient) CreateBulk(builders ...*IntegrationCreate) *IntegrationCreateBulk {
	return &IntegrationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationClient) MapCreateBulk(slice any, setFunc func(*IntegrationCreate, int)) *IntegrationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationCreateBulk{err: fmt.Errorf("calling to IntegrationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Integration.
func (c *IntegrationClient) Update() *IntegrationUpdate {
	mutation := newIntegrationMutation(c.config, OpUpdate)
	return &IntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationClient) UpdateOne(i *Integration) *IntegrationUpdateOne {
	mutation := newIntegrationMutation(c.config, OpUpdateOne, withIntegration(i))
	return &IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationClient) UpdateOneID(id string) *IntegrationUpdateOne {
	mutation := newIntegrationMutation(c.config, OpUpdateOne, withIntegrationID(id))
	return &IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Integration.
func (c *IntegrationClient) Delete() *IntegrationDelete {
	mutation := newIntegrationMutation(c.config, OpDelete)
	return &IntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationClient) DeleteOne(i *Integration) *IntegrationDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationClient) DeleteOneID(id string) *IntegrationDeleteOne {
	builder := c.Delete().Where(integration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationDeleteOne{builder}
}

// Query returns a query builder for Integration.
func (c *IntegrationClient) Query() *IntegrationQuery {
	return &IntegrationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegration},
		inters: c.Interceptors(),
	}
}

// Get returns a Integration entity by its id.
func (c *IntegrationClient) Get(ctx context.Context, id string) (*Integration, error) {
	return c.Query().Where(integration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationClient) GetX(ctx context.Context, id string) *Integration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Integration.
func (c *IntegrationClient) QueryOwner(i *Integration) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, integration.OwnerTable, integration.OwnerColumn),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySecrets queries the secrets edge of a Integration.
func (c *IntegrationClient) QuerySecrets(i *Integration) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.SecretsTable, integration.SecretsPrimaryKey...),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.IntegrationSecrets
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauth2tokens queries the oauth2tokens edge of a Integration.
func (c *IntegrationClient) QueryOauth2tokens(i *Integration) *OhAuthTooTokenQuery {
	query := (&OhAuthTooTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(ohauthtootoken.Table, ohauthtootoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.Oauth2tokensTable, integration.Oauth2tokensPrimaryKey...),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.OhAuthTooToken
		step.Edge.Schema = schemaConfig.IntegrationOauth2tokens
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Integration.
func (c *IntegrationClient) QueryEvents(i *Integration) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.EventsTable, integration.EventsPrimaryKey...),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.IntegrationEvents
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebhooks queries the webhooks edge of a Integration.
func (c *IntegrationClient) QueryWebhooks(i *Integration) *WebhookQuery {
	query := (&WebhookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(integration.Table, integration.FieldID, id),
			sqlgraph.To(webhook.Table, webhook.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, integration.WebhooksTable, integration.WebhooksPrimaryKey...),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.Webhook
		step.Edge.Schema = schemaConfig.IntegrationWebhooks
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntegrationClient) Hooks() []Hook {
	hooks := c.hooks.Integration
	return append(hooks[:len(hooks):len(hooks)], integration.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IntegrationClient) Interceptors() []Interceptor {
	inters := c.inters.Integration
	return append(inters[:len(inters):len(inters)], integration.Interceptors[:]...)
}

func (c *IntegrationClient) mutate(ctx context.Context, m *IntegrationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Integration mutation op: %q", m.Op())
	}
}

// IntegrationHistoryClient is a client for the IntegrationHistory schema.
type IntegrationHistoryClient struct {
	config
}

// NewIntegrationHistoryClient returns a client for the IntegrationHistory from the given config.
func NewIntegrationHistoryClient(c config) *IntegrationHistoryClient {
	return &IntegrationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integrationhistory.Hooks(f(g(h())))`.
func (c *IntegrationHistoryClient) Use(hooks ...Hook) {
	c.hooks.IntegrationHistory = append(c.hooks.IntegrationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integrationhistory.Intercept(f(g(h())))`.
func (c *IntegrationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.IntegrationHistory = append(c.inters.IntegrationHistory, interceptors...)
}

// Create returns a builder for creating a IntegrationHistory entity.
func (c *IntegrationHistoryClient) Create() *IntegrationHistoryCreate {
	mutation := newIntegrationHistoryMutation(c.config, OpCreate)
	return &IntegrationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IntegrationHistory entities.
func (c *IntegrationHistoryClient) CreateBulk(builders ...*IntegrationHistoryCreate) *IntegrationHistoryCreateBulk {
	return &IntegrationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationHistoryClient) MapCreateBulk(slice any, setFunc func(*IntegrationHistoryCreate, int)) *IntegrationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationHistoryCreateBulk{err: fmt.Errorf("calling to IntegrationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IntegrationHistory.
func (c *IntegrationHistoryClient) Update() *IntegrationHistoryUpdate {
	mutation := newIntegrationHistoryMutation(c.config, OpUpdate)
	return &IntegrationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationHistoryClient) UpdateOne(ih *IntegrationHistory) *IntegrationHistoryUpdateOne {
	mutation := newIntegrationHistoryMutation(c.config, OpUpdateOne, withIntegrationHistory(ih))
	return &IntegrationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationHistoryClient) UpdateOneID(id string) *IntegrationHistoryUpdateOne {
	mutation := newIntegrationHistoryMutation(c.config, OpUpdateOne, withIntegrationHistoryID(id))
	return &IntegrationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IntegrationHistory.
func (c *IntegrationHistoryClient) Delete() *IntegrationHistoryDelete {
	mutation := newIntegrationHistoryMutation(c.config, OpDelete)
	return &IntegrationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationHistoryClient) DeleteOne(ih *IntegrationHistory) *IntegrationHistoryDeleteOne {
	return c.DeleteOneID(ih.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationHistoryClient) DeleteOneID(id string) *IntegrationHistoryDeleteOne {
	builder := c.Delete().Where(integrationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationHistoryDeleteOne{builder}
}

// Query returns a query builder for IntegrationHistory.
func (c *IntegrationHistoryClient) Query() *IntegrationHistoryQuery {
	return &IntegrationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegrationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a IntegrationHistory entity by its id.
func (c *IntegrationHistoryClient) Get(ctx context.Context, id string) (*IntegrationHistory, error) {
	return c.Query().Where(integrationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationHistoryClient) GetX(ctx context.Context, id string) *IntegrationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IntegrationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.IntegrationHistory
	return append(hooks[:len(hooks):len(hooks)], integrationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *IntegrationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.IntegrationHistory
	return append(inters[:len(inters):len(inters)], integrationhistory.Interceptors[:]...)
}

func (c *IntegrationHistoryClient) mutate(ctx context.Context, m *IntegrationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown IntegrationHistory mutation op: %q", m.Op())
	}
}

// InternalPolicyClient is a client for the InternalPolicy schema.
type InternalPolicyClient struct {
	config
}

// NewInternalPolicyClient returns a client for the InternalPolicy from the given config.
func NewInternalPolicyClient(c config) *InternalPolicyClient {
	return &InternalPolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `internalpolicy.Hooks(f(g(h())))`.
func (c *InternalPolicyClient) Use(hooks ...Hook) {
	c.hooks.InternalPolicy = append(c.hooks.InternalPolicy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `internalpolicy.Intercept(f(g(h())))`.
func (c *InternalPolicyClient) Intercept(interceptors ...Interceptor) {
	c.inters.InternalPolicy = append(c.inters.InternalPolicy, interceptors...)
}

// Create returns a builder for creating a InternalPolicy entity.
func (c *InternalPolicyClient) Create() *InternalPolicyCreate {
	mutation := newInternalPolicyMutation(c.config, OpCreate)
	return &InternalPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InternalPolicy entities.
func (c *InternalPolicyClient) CreateBulk(builders ...*InternalPolicyCreate) *InternalPolicyCreateBulk {
	return &InternalPolicyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InternalPolicyClient) MapCreateBulk(slice any, setFunc func(*InternalPolicyCreate, int)) *InternalPolicyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InternalPolicyCreateBulk{err: fmt.Errorf("calling to InternalPolicyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InternalPolicyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InternalPolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InternalPolicy.
func (c *InternalPolicyClient) Update() *InternalPolicyUpdate {
	mutation := newInternalPolicyMutation(c.config, OpUpdate)
	return &InternalPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InternalPolicyClient) UpdateOne(ip *InternalPolicy) *InternalPolicyUpdateOne {
	mutation := newInternalPolicyMutation(c.config, OpUpdateOne, withInternalPolicy(ip))
	return &InternalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InternalPolicyClient) UpdateOneID(id string) *InternalPolicyUpdateOne {
	mutation := newInternalPolicyMutation(c.config, OpUpdateOne, withInternalPolicyID(id))
	return &InternalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InternalPolicy.
func (c *InternalPolicyClient) Delete() *InternalPolicyDelete {
	mutation := newInternalPolicyMutation(c.config, OpDelete)
	return &InternalPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InternalPolicyClient) DeleteOne(ip *InternalPolicy) *InternalPolicyDeleteOne {
	return c.DeleteOneID(ip.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InternalPolicyClient) DeleteOneID(id string) *InternalPolicyDeleteOne {
	builder := c.Delete().Where(internalpolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InternalPolicyDeleteOne{builder}
}

// Query returns a query builder for InternalPolicy.
func (c *InternalPolicyClient) Query() *InternalPolicyQuery {
	return &InternalPolicyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInternalPolicy},
		inters: c.Interceptors(),
	}
}

// Get returns a InternalPolicy entity by its id.
func (c *InternalPolicyClient) Get(ctx context.Context, id string) (*InternalPolicy, error) {
	return c.Query().Where(internalpolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InternalPolicyClient) GetX(ctx context.Context, id string) *InternalPolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryControlobjectives queries the controlobjectives edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryControlobjectives(ip *InternalPolicy) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.ControlobjectivesTable, internalpolicy.ControlobjectivesPrimaryKey...),
		)
		schemaConfig := ip.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.InternalPolicyControlobjectives
		fromV = sqlgraph.Neighbors(ip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryControls(ip *InternalPolicy) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, internalpolicy.ControlsTable, internalpolicy.ControlsColumn),
		)
		schemaConfig := ip.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.Control
		fromV = sqlgraph.Neighbors(ip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryProcedures(ip *InternalPolicy) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.ProceduresTable, internalpolicy.ProceduresPrimaryKey...),
		)
		schemaConfig := ip.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.InternalPolicyProcedures
		fromV = sqlgraph.Neighbors(ip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryNarratives(ip *InternalPolicy) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.NarrativesTable, internalpolicy.NarrativesPrimaryKey...),
		)
		schemaConfig := ip.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.InternalPolicyNarratives
		fromV = sqlgraph.Neighbors(ip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryTasks(ip *InternalPolicy) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, internalpolicy.TasksTable, internalpolicy.TasksPrimaryKey...),
		)
		schemaConfig := ip.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.InternalPolicyTasks
		fromV = sqlgraph.Neighbors(ip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a InternalPolicy.
func (c *InternalPolicyClient) QueryPrograms(ip *InternalPolicy) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ip.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(internalpolicy.Table, internalpolicy.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, internalpolicy.ProgramsTable, internalpolicy.ProgramsPrimaryKey...),
		)
		schemaConfig := ip.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramPolicies
		fromV = sqlgraph.Neighbors(ip.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InternalPolicyClient) Hooks() []Hook {
	hooks := c.hooks.InternalPolicy
	return append(hooks[:len(hooks):len(hooks)], internalpolicy.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InternalPolicyClient) Interceptors() []Interceptor {
	inters := c.inters.InternalPolicy
	return append(inters[:len(inters):len(inters)], internalpolicy.Interceptors[:]...)
}

func (c *InternalPolicyClient) mutate(ctx context.Context, m *InternalPolicyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InternalPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InternalPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InternalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InternalPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown InternalPolicy mutation op: %q", m.Op())
	}
}

// InternalPolicyHistoryClient is a client for the InternalPolicyHistory schema.
type InternalPolicyHistoryClient struct {
	config
}

// NewInternalPolicyHistoryClient returns a client for the InternalPolicyHistory from the given config.
func NewInternalPolicyHistoryClient(c config) *InternalPolicyHistoryClient {
	return &InternalPolicyHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `internalpolicyhistory.Hooks(f(g(h())))`.
func (c *InternalPolicyHistoryClient) Use(hooks ...Hook) {
	c.hooks.InternalPolicyHistory = append(c.hooks.InternalPolicyHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `internalpolicyhistory.Intercept(f(g(h())))`.
func (c *InternalPolicyHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.InternalPolicyHistory = append(c.inters.InternalPolicyHistory, interceptors...)
}

// Create returns a builder for creating a InternalPolicyHistory entity.
func (c *InternalPolicyHistoryClient) Create() *InternalPolicyHistoryCreate {
	mutation := newInternalPolicyHistoryMutation(c.config, OpCreate)
	return &InternalPolicyHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InternalPolicyHistory entities.
func (c *InternalPolicyHistoryClient) CreateBulk(builders ...*InternalPolicyHistoryCreate) *InternalPolicyHistoryCreateBulk {
	return &InternalPolicyHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InternalPolicyHistoryClient) MapCreateBulk(slice any, setFunc func(*InternalPolicyHistoryCreate, int)) *InternalPolicyHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InternalPolicyHistoryCreateBulk{err: fmt.Errorf("calling to InternalPolicyHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InternalPolicyHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InternalPolicyHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InternalPolicyHistory.
func (c *InternalPolicyHistoryClient) Update() *InternalPolicyHistoryUpdate {
	mutation := newInternalPolicyHistoryMutation(c.config, OpUpdate)
	return &InternalPolicyHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InternalPolicyHistoryClient) UpdateOne(iph *InternalPolicyHistory) *InternalPolicyHistoryUpdateOne {
	mutation := newInternalPolicyHistoryMutation(c.config, OpUpdateOne, withInternalPolicyHistory(iph))
	return &InternalPolicyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InternalPolicyHistoryClient) UpdateOneID(id string) *InternalPolicyHistoryUpdateOne {
	mutation := newInternalPolicyHistoryMutation(c.config, OpUpdateOne, withInternalPolicyHistoryID(id))
	return &InternalPolicyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InternalPolicyHistory.
func (c *InternalPolicyHistoryClient) Delete() *InternalPolicyHistoryDelete {
	mutation := newInternalPolicyHistoryMutation(c.config, OpDelete)
	return &InternalPolicyHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InternalPolicyHistoryClient) DeleteOne(iph *InternalPolicyHistory) *InternalPolicyHistoryDeleteOne {
	return c.DeleteOneID(iph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InternalPolicyHistoryClient) DeleteOneID(id string) *InternalPolicyHistoryDeleteOne {
	builder := c.Delete().Where(internalpolicyhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InternalPolicyHistoryDeleteOne{builder}
}

// Query returns a query builder for InternalPolicyHistory.
func (c *InternalPolicyHistoryClient) Query() *InternalPolicyHistoryQuery {
	return &InternalPolicyHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInternalPolicyHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a InternalPolicyHistory entity by its id.
func (c *InternalPolicyHistoryClient) Get(ctx context.Context, id string) (*InternalPolicyHistory, error) {
	return c.Query().Where(internalpolicyhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InternalPolicyHistoryClient) GetX(ctx context.Context, id string) *InternalPolicyHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InternalPolicyHistoryClient) Hooks() []Hook {
	return c.hooks.InternalPolicyHistory
}

// Interceptors returns the client interceptors.
func (c *InternalPolicyHistoryClient) Interceptors() []Interceptor {
	return c.inters.InternalPolicyHistory
}

func (c *InternalPolicyHistoryClient) mutate(ctx context.Context, m *InternalPolicyHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InternalPolicyHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InternalPolicyHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InternalPolicyHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InternalPolicyHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown InternalPolicyHistory mutation op: %q", m.Op())
	}
}

// InviteClient is a client for the Invite schema.
type InviteClient struct {
	config
}

// NewInviteClient returns a client for the Invite from the given config.
func NewInviteClient(c config) *InviteClient {
	return &InviteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invite.Hooks(f(g(h())))`.
func (c *InviteClient) Use(hooks ...Hook) {
	c.hooks.Invite = append(c.hooks.Invite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invite.Intercept(f(g(h())))`.
func (c *InviteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invite = append(c.inters.Invite, interceptors...)
}

// Create returns a builder for creating a Invite entity.
func (c *InviteClient) Create() *InviteCreate {
	mutation := newInviteMutation(c.config, OpCreate)
	return &InviteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invite entities.
func (c *InviteClient) CreateBulk(builders ...*InviteCreate) *InviteCreateBulk {
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InviteClient) MapCreateBulk(slice any, setFunc func(*InviteCreate, int)) *InviteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InviteCreateBulk{err: fmt.Errorf("calling to InviteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InviteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InviteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invite.
func (c *InviteClient) Update() *InviteUpdate {
	mutation := newInviteMutation(c.config, OpUpdate)
	return &InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InviteClient) UpdateOne(i *Invite) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInvite(i))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InviteClient) UpdateOneID(id string) *InviteUpdateOne {
	mutation := newInviteMutation(c.config, OpUpdateOne, withInviteID(id))
	return &InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invite.
func (c *InviteClient) Delete() *InviteDelete {
	mutation := newInviteMutation(c.config, OpDelete)
	return &InviteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InviteClient) DeleteOne(i *Invite) *InviteDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InviteClient) DeleteOneID(id string) *InviteDeleteOne {
	builder := c.Delete().Where(invite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InviteDeleteOne{builder}
}

// Query returns a query builder for Invite.
func (c *InviteClient) Query() *InviteQuery {
	return &InviteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvite},
		inters: c.Interceptors(),
	}
}

// Get returns a Invite entity by its id.
func (c *InviteClient) Get(ctx context.Context, id string) (*Invite, error) {
	return c.Query().Where(invite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InviteClient) GetX(ctx context.Context, id string) *Invite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Invite.
func (c *InviteClient) QueryOwner(i *Invite) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite.OwnerTable, invite.OwnerColumn),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Invite
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Invite.
func (c *InviteClient) QueryEvents(i *Invite) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite.Table, invite.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, invite.EventsTable, invite.EventsPrimaryKey...),
		)
		schemaConfig := i.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.InviteEvents
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InviteClient) Hooks() []Hook {
	hooks := c.hooks.Invite
	return append(hooks[:len(hooks):len(hooks)], invite.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *InviteClient) Interceptors() []Interceptor {
	inters := c.inters.Invite
	return append(inters[:len(inters):len(inters)], invite.Interceptors[:]...)
}

func (c *InviteClient) mutate(ctx context.Context, m *InviteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InviteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InviteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InviteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Invite mutation op: %q", m.Op())
	}
}

// NarrativeClient is a client for the Narrative schema.
type NarrativeClient struct {
	config
}

// NewNarrativeClient returns a client for the Narrative from the given config.
func NewNarrativeClient(c config) *NarrativeClient {
	return &NarrativeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `narrative.Hooks(f(g(h())))`.
func (c *NarrativeClient) Use(hooks ...Hook) {
	c.hooks.Narrative = append(c.hooks.Narrative, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `narrative.Intercept(f(g(h())))`.
func (c *NarrativeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Narrative = append(c.inters.Narrative, interceptors...)
}

// Create returns a builder for creating a Narrative entity.
func (c *NarrativeClient) Create() *NarrativeCreate {
	mutation := newNarrativeMutation(c.config, OpCreate)
	return &NarrativeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Narrative entities.
func (c *NarrativeClient) CreateBulk(builders ...*NarrativeCreate) *NarrativeCreateBulk {
	return &NarrativeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NarrativeClient) MapCreateBulk(slice any, setFunc func(*NarrativeCreate, int)) *NarrativeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NarrativeCreateBulk{err: fmt.Errorf("calling to NarrativeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NarrativeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NarrativeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Narrative.
func (c *NarrativeClient) Update() *NarrativeUpdate {
	mutation := newNarrativeMutation(c.config, OpUpdate)
	return &NarrativeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NarrativeClient) UpdateOne(n *Narrative) *NarrativeUpdateOne {
	mutation := newNarrativeMutation(c.config, OpUpdateOne, withNarrative(n))
	return &NarrativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NarrativeClient) UpdateOneID(id string) *NarrativeUpdateOne {
	mutation := newNarrativeMutation(c.config, OpUpdateOne, withNarrativeID(id))
	return &NarrativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Narrative.
func (c *NarrativeClient) Delete() *NarrativeDelete {
	mutation := newNarrativeMutation(c.config, OpDelete)
	return &NarrativeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NarrativeClient) DeleteOne(n *Narrative) *NarrativeDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NarrativeClient) DeleteOneID(id string) *NarrativeDeleteOne {
	builder := c.Delete().Where(narrative.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NarrativeDeleteOne{builder}
}

// Query returns a query builder for Narrative.
func (c *NarrativeClient) Query() *NarrativeQuery {
	return &NarrativeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNarrative},
		inters: c.Interceptors(),
	}
}

// Get returns a Narrative entity by its id.
func (c *NarrativeClient) Get(ctx context.Context, id string) (*Narrative, error) {
	return c.Query().Where(narrative.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NarrativeClient) GetX(ctx context.Context, id string) *Narrative {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPolicy queries the policy edge of a Narrative.
func (c *NarrativeClient) QueryPolicy(n *Narrative) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.PolicyTable, narrative.PolicyPrimaryKey...),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyNarratives
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a Narrative.
func (c *NarrativeClient) QueryControl(n *Narrative) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.ControlTable, narrative.ControlPrimaryKey...),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlNarratives
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedure queries the procedure edge of a Narrative.
func (c *NarrativeClient) QueryProcedure(n *Narrative) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.ProcedureTable, narrative.ProcedurePrimaryKey...),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureNarratives
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlobjective queries the controlobjective edge of a Narrative.
func (c *NarrativeClient) QueryControlobjective(n *Narrative) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.ControlobjectiveTable, narrative.ControlobjectivePrimaryKey...),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjectiveNarratives
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a Narrative.
func (c *NarrativeClient) QueryProgram(n *Narrative) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(narrative.Table, narrative.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, narrative.ProgramTable, narrative.ProgramPrimaryKey...),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramNarratives
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NarrativeClient) Hooks() []Hook {
	hooks := c.hooks.Narrative
	return append(hooks[:len(hooks):len(hooks)], narrative.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NarrativeClient) Interceptors() []Interceptor {
	inters := c.inters.Narrative
	return append(inters[:len(inters):len(inters)], narrative.Interceptors[:]...)
}

func (c *NarrativeClient) mutate(ctx context.Context, m *NarrativeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NarrativeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NarrativeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NarrativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NarrativeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Narrative mutation op: %q", m.Op())
	}
}

// NarrativeHistoryClient is a client for the NarrativeHistory schema.
type NarrativeHistoryClient struct {
	config
}

// NewNarrativeHistoryClient returns a client for the NarrativeHistory from the given config.
func NewNarrativeHistoryClient(c config) *NarrativeHistoryClient {
	return &NarrativeHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `narrativehistory.Hooks(f(g(h())))`.
func (c *NarrativeHistoryClient) Use(hooks ...Hook) {
	c.hooks.NarrativeHistory = append(c.hooks.NarrativeHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `narrativehistory.Intercept(f(g(h())))`.
func (c *NarrativeHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.NarrativeHistory = append(c.inters.NarrativeHistory, interceptors...)
}

// Create returns a builder for creating a NarrativeHistory entity.
func (c *NarrativeHistoryClient) Create() *NarrativeHistoryCreate {
	mutation := newNarrativeHistoryMutation(c.config, OpCreate)
	return &NarrativeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NarrativeHistory entities.
func (c *NarrativeHistoryClient) CreateBulk(builders ...*NarrativeHistoryCreate) *NarrativeHistoryCreateBulk {
	return &NarrativeHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NarrativeHistoryClient) MapCreateBulk(slice any, setFunc func(*NarrativeHistoryCreate, int)) *NarrativeHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NarrativeHistoryCreateBulk{err: fmt.Errorf("calling to NarrativeHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NarrativeHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NarrativeHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NarrativeHistory.
func (c *NarrativeHistoryClient) Update() *NarrativeHistoryUpdate {
	mutation := newNarrativeHistoryMutation(c.config, OpUpdate)
	return &NarrativeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NarrativeHistoryClient) UpdateOne(nh *NarrativeHistory) *NarrativeHistoryUpdateOne {
	mutation := newNarrativeHistoryMutation(c.config, OpUpdateOne, withNarrativeHistory(nh))
	return &NarrativeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NarrativeHistoryClient) UpdateOneID(id string) *NarrativeHistoryUpdateOne {
	mutation := newNarrativeHistoryMutation(c.config, OpUpdateOne, withNarrativeHistoryID(id))
	return &NarrativeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NarrativeHistory.
func (c *NarrativeHistoryClient) Delete() *NarrativeHistoryDelete {
	mutation := newNarrativeHistoryMutation(c.config, OpDelete)
	return &NarrativeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NarrativeHistoryClient) DeleteOne(nh *NarrativeHistory) *NarrativeHistoryDeleteOne {
	return c.DeleteOneID(nh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NarrativeHistoryClient) DeleteOneID(id string) *NarrativeHistoryDeleteOne {
	builder := c.Delete().Where(narrativehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NarrativeHistoryDeleteOne{builder}
}

// Query returns a query builder for NarrativeHistory.
func (c *NarrativeHistoryClient) Query() *NarrativeHistoryQuery {
	return &NarrativeHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNarrativeHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a NarrativeHistory entity by its id.
func (c *NarrativeHistoryClient) Get(ctx context.Context, id string) (*NarrativeHistory, error) {
	return c.Query().Where(narrativehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NarrativeHistoryClient) GetX(ctx context.Context, id string) *NarrativeHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NarrativeHistoryClient) Hooks() []Hook {
	return c.hooks.NarrativeHistory
}

// Interceptors returns the client interceptors.
func (c *NarrativeHistoryClient) Interceptors() []Interceptor {
	return c.inters.NarrativeHistory
}

func (c *NarrativeHistoryClient) mutate(ctx context.Context, m *NarrativeHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NarrativeHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NarrativeHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NarrativeHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NarrativeHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown NarrativeHistory mutation op: %q", m.Op())
	}
}

// NoteClient is a client for the Note schema.
type NoteClient struct {
	config
}

// NewNoteClient returns a client for the Note from the given config.
func NewNoteClient(c config) *NoteClient {
	return &NoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `note.Hooks(f(g(h())))`.
func (c *NoteClient) Use(hooks ...Hook) {
	c.hooks.Note = append(c.hooks.Note, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `note.Intercept(f(g(h())))`.
func (c *NoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Note = append(c.inters.Note, interceptors...)
}

// Create returns a builder for creating a Note entity.
func (c *NoteClient) Create() *NoteCreate {
	mutation := newNoteMutation(c.config, OpCreate)
	return &NoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Note entities.
func (c *NoteClient) CreateBulk(builders ...*NoteCreate) *NoteCreateBulk {
	return &NoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NoteClient) MapCreateBulk(slice any, setFunc func(*NoteCreate, int)) *NoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NoteCreateBulk{err: fmt.Errorf("calling to NoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Note.
func (c *NoteClient) Update() *NoteUpdate {
	mutation := newNoteMutation(c.config, OpUpdate)
	return &NoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NoteClient) UpdateOne(n *Note) *NoteUpdateOne {
	mutation := newNoteMutation(c.config, OpUpdateOne, withNote(n))
	return &NoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NoteClient) UpdateOneID(id string) *NoteUpdateOne {
	mutation := newNoteMutation(c.config, OpUpdateOne, withNoteID(id))
	return &NoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Note.
func (c *NoteClient) Delete() *NoteDelete {
	mutation := newNoteMutation(c.config, OpDelete)
	return &NoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NoteClient) DeleteOne(n *Note) *NoteDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NoteClient) DeleteOneID(id string) *NoteDeleteOne {
	builder := c.Delete().Where(note.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NoteDeleteOne{builder}
}

// Query returns a query builder for Note.
func (c *NoteClient) Query() *NoteQuery {
	return &NoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNote},
		inters: c.Interceptors(),
	}
}

// Get returns a Note entity by its id.
func (c *NoteClient) Get(ctx context.Context, id string) (*Note, error) {
	return c.Query().Where(note.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NoteClient) GetX(ctx context.Context, id string) *Note {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Note.
func (c *NoteClient) QueryOwner(n *Note) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.OwnerTable, note.OwnerColumn),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntity queries the entity edge of a Note.
func (c *NoteClient) QueryEntity(n *Note) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, note.EntityTable, note.EntityColumn),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Note.
func (c *NoteClient) QuerySubcontrols(n *Note) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, note.SubcontrolsTable, note.SubcontrolsColumn),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a Note.
func (c *NoteClient) QueryProgram(n *Note) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(note.Table, note.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, note.ProgramTable, note.ProgramPrimaryKey...),
		)
		schemaConfig := n.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramNotes
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NoteClient) Hooks() []Hook {
	hooks := c.hooks.Note
	return append(hooks[:len(hooks):len(hooks)], note.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NoteClient) Interceptors() []Interceptor {
	inters := c.inters.Note
	return append(inters[:len(inters):len(inters)], note.Interceptors[:]...)
}

func (c *NoteClient) mutate(ctx context.Context, m *NoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Note mutation op: %q", m.Op())
	}
}

// NoteHistoryClient is a client for the NoteHistory schema.
type NoteHistoryClient struct {
	config
}

// NewNoteHistoryClient returns a client for the NoteHistory from the given config.
func NewNoteHistoryClient(c config) *NoteHistoryClient {
	return &NoteHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notehistory.Hooks(f(g(h())))`.
func (c *NoteHistoryClient) Use(hooks ...Hook) {
	c.hooks.NoteHistory = append(c.hooks.NoteHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notehistory.Intercept(f(g(h())))`.
func (c *NoteHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.NoteHistory = append(c.inters.NoteHistory, interceptors...)
}

// Create returns a builder for creating a NoteHistory entity.
func (c *NoteHistoryClient) Create() *NoteHistoryCreate {
	mutation := newNoteHistoryMutation(c.config, OpCreate)
	return &NoteHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NoteHistory entities.
func (c *NoteHistoryClient) CreateBulk(builders ...*NoteHistoryCreate) *NoteHistoryCreateBulk {
	return &NoteHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NoteHistoryClient) MapCreateBulk(slice any, setFunc func(*NoteHistoryCreate, int)) *NoteHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NoteHistoryCreateBulk{err: fmt.Errorf("calling to NoteHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NoteHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NoteHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NoteHistory.
func (c *NoteHistoryClient) Update() *NoteHistoryUpdate {
	mutation := newNoteHistoryMutation(c.config, OpUpdate)
	return &NoteHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NoteHistoryClient) UpdateOne(nh *NoteHistory) *NoteHistoryUpdateOne {
	mutation := newNoteHistoryMutation(c.config, OpUpdateOne, withNoteHistory(nh))
	return &NoteHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NoteHistoryClient) UpdateOneID(id string) *NoteHistoryUpdateOne {
	mutation := newNoteHistoryMutation(c.config, OpUpdateOne, withNoteHistoryID(id))
	return &NoteHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NoteHistory.
func (c *NoteHistoryClient) Delete() *NoteHistoryDelete {
	mutation := newNoteHistoryMutation(c.config, OpDelete)
	return &NoteHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NoteHistoryClient) DeleteOne(nh *NoteHistory) *NoteHistoryDeleteOne {
	return c.DeleteOneID(nh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NoteHistoryClient) DeleteOneID(id string) *NoteHistoryDeleteOne {
	builder := c.Delete().Where(notehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NoteHistoryDeleteOne{builder}
}

// Query returns a query builder for NoteHistory.
func (c *NoteHistoryClient) Query() *NoteHistoryQuery {
	return &NoteHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNoteHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a NoteHistory entity by its id.
func (c *NoteHistoryClient) Get(ctx context.Context, id string) (*NoteHistory, error) {
	return c.Query().Where(notehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NoteHistoryClient) GetX(ctx context.Context, id string) *NoteHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NoteHistoryClient) Hooks() []Hook {
	hooks := c.hooks.NoteHistory
	return append(hooks[:len(hooks):len(hooks)], notehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *NoteHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.NoteHistory
	return append(inters[:len(inters):len(inters)], notehistory.Interceptors[:]...)
}

func (c *NoteHistoryClient) mutate(ctx context.Context, m *NoteHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NoteHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NoteHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NoteHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NoteHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown NoteHistory mutation op: %q", m.Op())
	}
}

// OauthProviderClient is a client for the OauthProvider schema.
type OauthProviderClient struct {
	config
}

// NewOauthProviderClient returns a client for the OauthProvider from the given config.
func NewOauthProviderClient(c config) *OauthProviderClient {
	return &OauthProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthprovider.Hooks(f(g(h())))`.
func (c *OauthProviderClient) Use(hooks ...Hook) {
	c.hooks.OauthProvider = append(c.hooks.OauthProvider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthprovider.Intercept(f(g(h())))`.
func (c *OauthProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthProvider = append(c.inters.OauthProvider, interceptors...)
}

// Create returns a builder for creating a OauthProvider entity.
func (c *OauthProviderClient) Create() *OauthProviderCreate {
	mutation := newOauthProviderMutation(c.config, OpCreate)
	return &OauthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthProvider entities.
func (c *OauthProviderClient) CreateBulk(builders ...*OauthProviderCreate) *OauthProviderCreateBulk {
	return &OauthProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthProviderClient) MapCreateBulk(slice any, setFunc func(*OauthProviderCreate, int)) *OauthProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthProviderCreateBulk{err: fmt.Errorf("calling to OauthProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthProvider.
func (c *OauthProviderClient) Update() *OauthProviderUpdate {
	mutation := newOauthProviderMutation(c.config, OpUpdate)
	return &OauthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthProviderClient) UpdateOne(op *OauthProvider) *OauthProviderUpdateOne {
	mutation := newOauthProviderMutation(c.config, OpUpdateOne, withOauthProvider(op))
	return &OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthProviderClient) UpdateOneID(id string) *OauthProviderUpdateOne {
	mutation := newOauthProviderMutation(c.config, OpUpdateOne, withOauthProviderID(id))
	return &OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthProvider.
func (c *OauthProviderClient) Delete() *OauthProviderDelete {
	mutation := newOauthProviderMutation(c.config, OpDelete)
	return &OauthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthProviderClient) DeleteOne(op *OauthProvider) *OauthProviderDeleteOne {
	return c.DeleteOneID(op.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthProviderClient) DeleteOneID(id string) *OauthProviderDeleteOne {
	builder := c.Delete().Where(oauthprovider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthProviderDeleteOne{builder}
}

// Query returns a query builder for OauthProvider.
func (c *OauthProviderClient) Query() *OauthProviderQuery {
	return &OauthProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthProvider entity by its id.
func (c *OauthProviderClient) Get(ctx context.Context, id string) (*OauthProvider, error) {
	return c.Query().Where(oauthprovider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthProviderClient) GetX(ctx context.Context, id string) *OauthProvider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OauthProvider.
func (c *OauthProviderClient) QueryOwner(op *OauthProvider) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := op.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(oauthprovider.Table, oauthprovider.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, oauthprovider.OwnerTable, oauthprovider.OwnerColumn),
		)
		schemaConfig := op.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OauthProvider
		fromV = sqlgraph.Neighbors(op.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OauthProviderClient) Hooks() []Hook {
	hooks := c.hooks.OauthProvider
	return append(hooks[:len(hooks):len(hooks)], oauthprovider.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthProviderClient) Interceptors() []Interceptor {
	inters := c.inters.OauthProvider
	return append(inters[:len(inters):len(inters)], oauthprovider.Interceptors[:]...)
}

func (c *OauthProviderClient) mutate(ctx context.Context, m *OauthProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OauthProvider mutation op: %q", m.Op())
	}
}

// OauthProviderHistoryClient is a client for the OauthProviderHistory schema.
type OauthProviderHistoryClient struct {
	config
}

// NewOauthProviderHistoryClient returns a client for the OauthProviderHistory from the given config.
func NewOauthProviderHistoryClient(c config) *OauthProviderHistoryClient {
	return &OauthProviderHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthproviderhistory.Hooks(f(g(h())))`.
func (c *OauthProviderHistoryClient) Use(hooks ...Hook) {
	c.hooks.OauthProviderHistory = append(c.hooks.OauthProviderHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthproviderhistory.Intercept(f(g(h())))`.
func (c *OauthProviderHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthProviderHistory = append(c.inters.OauthProviderHistory, interceptors...)
}

// Create returns a builder for creating a OauthProviderHistory entity.
func (c *OauthProviderHistoryClient) Create() *OauthProviderHistoryCreate {
	mutation := newOauthProviderHistoryMutation(c.config, OpCreate)
	return &OauthProviderHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthProviderHistory entities.
func (c *OauthProviderHistoryClient) CreateBulk(builders ...*OauthProviderHistoryCreate) *OauthProviderHistoryCreateBulk {
	return &OauthProviderHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthProviderHistoryClient) MapCreateBulk(slice any, setFunc func(*OauthProviderHistoryCreate, int)) *OauthProviderHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthProviderHistoryCreateBulk{err: fmt.Errorf("calling to OauthProviderHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthProviderHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthProviderHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthProviderHistory.
func (c *OauthProviderHistoryClient) Update() *OauthProviderHistoryUpdate {
	mutation := newOauthProviderHistoryMutation(c.config, OpUpdate)
	return &OauthProviderHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthProviderHistoryClient) UpdateOne(oph *OauthProviderHistory) *OauthProviderHistoryUpdateOne {
	mutation := newOauthProviderHistoryMutation(c.config, OpUpdateOne, withOauthProviderHistory(oph))
	return &OauthProviderHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthProviderHistoryClient) UpdateOneID(id string) *OauthProviderHistoryUpdateOne {
	mutation := newOauthProviderHistoryMutation(c.config, OpUpdateOne, withOauthProviderHistoryID(id))
	return &OauthProviderHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthProviderHistory.
func (c *OauthProviderHistoryClient) Delete() *OauthProviderHistoryDelete {
	mutation := newOauthProviderHistoryMutation(c.config, OpDelete)
	return &OauthProviderHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthProviderHistoryClient) DeleteOne(oph *OauthProviderHistory) *OauthProviderHistoryDeleteOne {
	return c.DeleteOneID(oph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthProviderHistoryClient) DeleteOneID(id string) *OauthProviderHistoryDeleteOne {
	builder := c.Delete().Where(oauthproviderhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthProviderHistoryDeleteOne{builder}
}

// Query returns a query builder for OauthProviderHistory.
func (c *OauthProviderHistoryClient) Query() *OauthProviderHistoryQuery {
	return &OauthProviderHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthProviderHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthProviderHistory entity by its id.
func (c *OauthProviderHistoryClient) Get(ctx context.Context, id string) (*OauthProviderHistory, error) {
	return c.Query().Where(oauthproviderhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthProviderHistoryClient) GetX(ctx context.Context, id string) *OauthProviderHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OauthProviderHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OauthProviderHistory
	return append(hooks[:len(hooks):len(hooks)], oauthproviderhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OauthProviderHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OauthProviderHistory
	return append(inters[:len(inters):len(inters)], oauthproviderhistory.Interceptors[:]...)
}

func (c *OauthProviderHistoryClient) mutate(ctx context.Context, m *OauthProviderHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthProviderHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthProviderHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthProviderHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthProviderHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OauthProviderHistory mutation op: %q", m.Op())
	}
}

// OhAuthTooTokenClient is a client for the OhAuthTooToken schema.
type OhAuthTooTokenClient struct {
	config
}

// NewOhAuthTooTokenClient returns a client for the OhAuthTooToken from the given config.
func NewOhAuthTooTokenClient(c config) *OhAuthTooTokenClient {
	return &OhAuthTooTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ohauthtootoken.Hooks(f(g(h())))`.
func (c *OhAuthTooTokenClient) Use(hooks ...Hook) {
	c.hooks.OhAuthTooToken = append(c.hooks.OhAuthTooToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ohauthtootoken.Intercept(f(g(h())))`.
func (c *OhAuthTooTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.OhAuthTooToken = append(c.inters.OhAuthTooToken, interceptors...)
}

// Create returns a builder for creating a OhAuthTooToken entity.
func (c *OhAuthTooTokenClient) Create() *OhAuthTooTokenCreate {
	mutation := newOhAuthTooTokenMutation(c.config, OpCreate)
	return &OhAuthTooTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OhAuthTooToken entities.
func (c *OhAuthTooTokenClient) CreateBulk(builders ...*OhAuthTooTokenCreate) *OhAuthTooTokenCreateBulk {
	return &OhAuthTooTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OhAuthTooTokenClient) MapCreateBulk(slice any, setFunc func(*OhAuthTooTokenCreate, int)) *OhAuthTooTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OhAuthTooTokenCreateBulk{err: fmt.Errorf("calling to OhAuthTooTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OhAuthTooTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OhAuthTooTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OhAuthTooToken.
func (c *OhAuthTooTokenClient) Update() *OhAuthTooTokenUpdate {
	mutation := newOhAuthTooTokenMutation(c.config, OpUpdate)
	return &OhAuthTooTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OhAuthTooTokenClient) UpdateOne(oatt *OhAuthTooToken) *OhAuthTooTokenUpdateOne {
	mutation := newOhAuthTooTokenMutation(c.config, OpUpdateOne, withOhAuthTooToken(oatt))
	return &OhAuthTooTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OhAuthTooTokenClient) UpdateOneID(id string) *OhAuthTooTokenUpdateOne {
	mutation := newOhAuthTooTokenMutation(c.config, OpUpdateOne, withOhAuthTooTokenID(id))
	return &OhAuthTooTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OhAuthTooToken.
func (c *OhAuthTooTokenClient) Delete() *OhAuthTooTokenDelete {
	mutation := newOhAuthTooTokenMutation(c.config, OpDelete)
	return &OhAuthTooTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OhAuthTooTokenClient) DeleteOne(oatt *OhAuthTooToken) *OhAuthTooTokenDeleteOne {
	return c.DeleteOneID(oatt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OhAuthTooTokenClient) DeleteOneID(id string) *OhAuthTooTokenDeleteOne {
	builder := c.Delete().Where(ohauthtootoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OhAuthTooTokenDeleteOne{builder}
}

// Query returns a query builder for OhAuthTooToken.
func (c *OhAuthTooTokenClient) Query() *OhAuthTooTokenQuery {
	return &OhAuthTooTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOhAuthTooToken},
		inters: c.Interceptors(),
	}
}

// Get returns a OhAuthTooToken entity by its id.
func (c *OhAuthTooTokenClient) Get(ctx context.Context, id string) (*OhAuthTooToken, error) {
	return c.Query().Where(ohauthtootoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OhAuthTooTokenClient) GetX(ctx context.Context, id string) *OhAuthTooToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIntegration queries the integration edge of a OhAuthTooToken.
func (c *OhAuthTooTokenClient) QueryIntegration(oatt *OhAuthTooToken) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oatt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ohauthtootoken.Table, ohauthtootoken.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ohauthtootoken.IntegrationTable, ohauthtootoken.IntegrationPrimaryKey...),
		)
		schemaConfig := oatt.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationOauth2tokens
		fromV = sqlgraph.Neighbors(oatt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a OhAuthTooToken.
func (c *OhAuthTooTokenClient) QueryEvents(oatt *OhAuthTooToken) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oatt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ohauthtootoken.Table, ohauthtootoken.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, ohauthtootoken.EventsTable, ohauthtootoken.EventsPrimaryKey...),
		)
		schemaConfig := oatt.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.OhAuthTooTokenEvents
		fromV = sqlgraph.Neighbors(oatt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OhAuthTooTokenClient) Hooks() []Hook {
	return c.hooks.OhAuthTooToken
}

// Interceptors returns the client interceptors.
func (c *OhAuthTooTokenClient) Interceptors() []Interceptor {
	return c.inters.OhAuthTooToken
}

func (c *OhAuthTooTokenClient) mutate(ctx context.Context, m *OhAuthTooTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OhAuthTooTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OhAuthTooTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OhAuthTooTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OhAuthTooTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OhAuthTooToken mutation op: %q", m.Op())
	}
}

// OrgMembershipClient is a client for the OrgMembership schema.
type OrgMembershipClient struct {
	config
}

// NewOrgMembershipClient returns a client for the OrgMembership from the given config.
func NewOrgMembershipClient(c config) *OrgMembershipClient {
	return &OrgMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmembership.Hooks(f(g(h())))`.
func (c *OrgMembershipClient) Use(hooks ...Hook) {
	c.hooks.OrgMembership = append(c.hooks.OrgMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmembership.Intercept(f(g(h())))`.
func (c *OrgMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgMembership = append(c.inters.OrgMembership, interceptors...)
}

// Create returns a builder for creating a OrgMembership entity.
func (c *OrgMembershipClient) Create() *OrgMembershipCreate {
	mutation := newOrgMembershipMutation(c.config, OpCreate)
	return &OrgMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgMembership entities.
func (c *OrgMembershipClient) CreateBulk(builders ...*OrgMembershipCreate) *OrgMembershipCreateBulk {
	return &OrgMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgMembershipClient) MapCreateBulk(slice any, setFunc func(*OrgMembershipCreate, int)) *OrgMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgMembershipCreateBulk{err: fmt.Errorf("calling to OrgMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgMembership.
func (c *OrgMembershipClient) Update() *OrgMembershipUpdate {
	mutation := newOrgMembershipMutation(c.config, OpUpdate)
	return &OrgMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgMembershipClient) UpdateOne(om *OrgMembership) *OrgMembershipUpdateOne {
	mutation := newOrgMembershipMutation(c.config, OpUpdateOne, withOrgMembership(om))
	return &OrgMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgMembershipClient) UpdateOneID(id string) *OrgMembershipUpdateOne {
	mutation := newOrgMembershipMutation(c.config, OpUpdateOne, withOrgMembershipID(id))
	return &OrgMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgMembership.
func (c *OrgMembershipClient) Delete() *OrgMembershipDelete {
	mutation := newOrgMembershipMutation(c.config, OpDelete)
	return &OrgMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgMembershipClient) DeleteOne(om *OrgMembership) *OrgMembershipDeleteOne {
	return c.DeleteOneID(om.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgMembershipClient) DeleteOneID(id string) *OrgMembershipDeleteOne {
	builder := c.Delete().Where(orgmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgMembershipDeleteOne{builder}
}

// Query returns a query builder for OrgMembership.
func (c *OrgMembershipClient) Query() *OrgMembershipQuery {
	return &OrgMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgMembership entity by its id.
func (c *OrgMembershipClient) Get(ctx context.Context, id string) (*OrgMembership, error) {
	return c.Query().Where(orgmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgMembershipClient) GetX(ctx context.Context, id string) *OrgMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrgMembership.
func (c *OrgMembershipClient) QueryOrganization(om *OrgMembership) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := om.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmembership.Table, orgmembership.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orgmembership.OrganizationTable, orgmembership.OrganizationColumn),
		)
		schemaConfig := om.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(om.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OrgMembership.
func (c *OrgMembershipClient) QueryUser(om *OrgMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := om.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmembership.Table, orgmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orgmembership.UserTable, orgmembership.UserColumn),
		)
		schemaConfig := om.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(om.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a OrgMembership.
func (c *OrgMembershipClient) QueryEvents(om *OrgMembership) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := om.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmembership.Table, orgmembership.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, orgmembership.EventsTable, orgmembership.EventsPrimaryKey...),
		)
		schemaConfig := om.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.OrgMembershipEvents
		fromV = sqlgraph.Neighbors(om.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgMembershipClient) Hooks() []Hook {
	hooks := c.hooks.OrgMembership
	return append(hooks[:len(hooks):len(hooks)], orgmembership.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgMembershipClient) Interceptors() []Interceptor {
	inters := c.inters.OrgMembership
	return append(inters[:len(inters):len(inters)], orgmembership.Interceptors[:]...)
}

func (c *OrgMembershipClient) mutate(ctx context.Context, m *OrgMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgMembership mutation op: %q", m.Op())
	}
}

// OrgMembershipHistoryClient is a client for the OrgMembershipHistory schema.
type OrgMembershipHistoryClient struct {
	config
}

// NewOrgMembershipHistoryClient returns a client for the OrgMembershipHistory from the given config.
func NewOrgMembershipHistoryClient(c config) *OrgMembershipHistoryClient {
	return &OrgMembershipHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmembershiphistory.Hooks(f(g(h())))`.
func (c *OrgMembershipHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrgMembershipHistory = append(c.hooks.OrgMembershipHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmembershiphistory.Intercept(f(g(h())))`.
func (c *OrgMembershipHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgMembershipHistory = append(c.inters.OrgMembershipHistory, interceptors...)
}

// Create returns a builder for creating a OrgMembershipHistory entity.
func (c *OrgMembershipHistoryClient) Create() *OrgMembershipHistoryCreate {
	mutation := newOrgMembershipHistoryMutation(c.config, OpCreate)
	return &OrgMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgMembershipHistory entities.
func (c *OrgMembershipHistoryClient) CreateBulk(builders ...*OrgMembershipHistoryCreate) *OrgMembershipHistoryCreateBulk {
	return &OrgMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgMembershipHistoryClient) MapCreateBulk(slice any, setFunc func(*OrgMembershipHistoryCreate, int)) *OrgMembershipHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgMembershipHistoryCreateBulk{err: fmt.Errorf("calling to OrgMembershipHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgMembershipHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgMembershipHistory.
func (c *OrgMembershipHistoryClient) Update() *OrgMembershipHistoryUpdate {
	mutation := newOrgMembershipHistoryMutation(c.config, OpUpdate)
	return &OrgMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgMembershipHistoryClient) UpdateOne(omh *OrgMembershipHistory) *OrgMembershipHistoryUpdateOne {
	mutation := newOrgMembershipHistoryMutation(c.config, OpUpdateOne, withOrgMembershipHistory(omh))
	return &OrgMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgMembershipHistoryClient) UpdateOneID(id string) *OrgMembershipHistoryUpdateOne {
	mutation := newOrgMembershipHistoryMutation(c.config, OpUpdateOne, withOrgMembershipHistoryID(id))
	return &OrgMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgMembershipHistory.
func (c *OrgMembershipHistoryClient) Delete() *OrgMembershipHistoryDelete {
	mutation := newOrgMembershipHistoryMutation(c.config, OpDelete)
	return &OrgMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgMembershipHistoryClient) DeleteOne(omh *OrgMembershipHistory) *OrgMembershipHistoryDeleteOne {
	return c.DeleteOneID(omh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgMembershipHistoryClient) DeleteOneID(id string) *OrgMembershipHistoryDeleteOne {
	builder := c.Delete().Where(orgmembershiphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgMembershipHistoryDeleteOne{builder}
}

// Query returns a query builder for OrgMembershipHistory.
func (c *OrgMembershipHistoryClient) Query() *OrgMembershipHistoryQuery {
	return &OrgMembershipHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgMembershipHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgMembershipHistory entity by its id.
func (c *OrgMembershipHistoryClient) Get(ctx context.Context, id string) (*OrgMembershipHistory, error) {
	return c.Query().Where(orgmembershiphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgMembershipHistoryClient) GetX(ctx context.Context, id string) *OrgMembershipHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrgMembershipHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OrgMembershipHistory
	return append(hooks[:len(hooks):len(hooks)], orgmembershiphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrgMembershipHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OrgMembershipHistory
	return append(inters[:len(inters):len(inters)], orgmembershiphistory.Interceptors[:]...)
}

func (c *OrgMembershipHistoryClient) mutate(ctx context.Context, m *OrgMembershipHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrgMembershipHistory mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id string) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id string) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id string) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id string) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Organization.
func (c *OrganizationClient) QueryParent(o *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.ParentTable, organization.ParentColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Organization
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Organization.
func (c *OrganizationClient) QueryChildren(o *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ChildrenTable, organization.ChildrenColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Organization
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Organization.
func (c *OrganizationClient) QueryGroups(o *Organization) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.GroupsTable, organization.GroupsColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.Group
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplates queries the templates edge of a Organization.
func (c *OrganizationClient) QueryTemplates(o *Organization) *TemplateQuery {
	query := (&TemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(template.Table, template.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.TemplatesTable, organization.TemplatesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Template
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Organization.
func (c *OrganizationClient) QueryIntegrations(o *Organization) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.IntegrationsTable, organization.IntegrationsColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.Integration
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a Organization.
func (c *OrganizationClient) QuerySetting(o *Organization) *OrganizationSettingQuery {
	query := (&OrganizationSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organizationsetting.Table, organizationsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, organization.SettingTable, organization.SettingColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.OrganizationSetting
		step.Edge.Schema = schemaConfig.OrganizationSetting
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocumentdata queries the documentdata edge of a Organization.
func (c *OrganizationClient) QueryDocumentdata(o *Organization) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.DocumentdataTable, organization.DocumentdataColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlements queries the entitlements edge of a Organization.
func (c *OrganizationClient) QueryEntitlements(o *Organization) *EntitlementQuery {
	query := (&EntitlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entitlement.Table, entitlement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntitlementsTable, organization.EntitlementsColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Entitlement
		step.Edge.Schema = schemaConfig.Entitlement
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationEntitlement queries the organization_entitlement edge of a Organization.
func (c *OrganizationClient) QueryOrganizationEntitlement(o *Organization) *EntitlementQuery {
	query := (&EntitlementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entitlement.Table, entitlement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.OrganizationEntitlementTable, organization.OrganizationEntitlementColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Entitlement
		step.Edge.Schema = schemaConfig.Entitlement
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonalAccessTokens queries the personal_access_tokens edge of a Organization.
func (c *OrganizationClient) QueryPersonalAccessTokens(o *Organization) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.PersonalAccessTokensTable, organization.PersonalAccessTokensPrimaryKey...),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.PersonalAccessToken
		step.Edge.Schema = schemaConfig.OrganizationPersonalAccessTokens
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPITokens queries the api_tokens edge of a Organization.
func (c *OrganizationClient) QueryAPITokens(o *Organization) *APITokenQuery {
	query := (&APITokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(apitoken.Table, apitoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.APITokensTable, organization.APITokensColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.APIToken
		step.Edge.Schema = schemaConfig.APIToken
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOauthprovider queries the oauthprovider edge of a Organization.
func (c *OrganizationClient) QueryOauthprovider(o *Organization) *OauthProviderQuery {
	query := (&OauthProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(oauthprovider.Table, oauthprovider.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.OauthproviderTable, organization.OauthproviderColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.OauthProvider
		step.Edge.Schema = schemaConfig.OauthProvider
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Organization.
func (c *OrganizationClient) QueryUsers(o *Organization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, organization.UsersTable, organization.UsersPrimaryKey...),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvites queries the invites edge of a Organization.
func (c *OrganizationClient) QueryInvites(o *Organization) *InviteQuery {
	query := (&InviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(invite.Table, invite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.InvitesTable, organization.InvitesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Invite
		step.Edge.Schema = schemaConfig.Invite
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribers queries the subscribers edge of a Organization.
func (c *OrganizationClient) QuerySubscribers(o *Organization) *SubscriberQuery {
	query := (&SubscriberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(subscriber.Table, subscriber.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.SubscribersTable, organization.SubscribersColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Subscriber
		step.Edge.Schema = schemaConfig.Subscriber
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebhooks queries the webhooks edge of a Organization.
func (c *OrganizationClient) QueryWebhooks(o *Organization) *WebhookQuery {
	query := (&WebhookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(webhook.Table, webhook.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.WebhooksTable, organization.WebhooksColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Webhook
		step.Edge.Schema = schemaConfig.Webhook
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Organization.
func (c *OrganizationClient) QueryEvents(o *Organization) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.EventsTable, organization.EventsPrimaryKey...),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.OrganizationEvents
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySecrets queries the secrets edge of a Organization.
func (c *OrganizationClient) QuerySecrets(o *Organization) *HushQuery {
	query := (&HushClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(hush.Table, hush.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.SecretsTable, organization.SecretsPrimaryKey...),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Hush
		step.Edge.Schema = schemaConfig.OrganizationSecrets
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeatures queries the features edge of a Organization.
func (c *OrganizationClient) QueryFeatures(o *Organization) *FeatureQuery {
	query := (&FeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(feature.Table, feature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.FeaturesTable, organization.FeaturesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Feature
		step.Edge.Schema = schemaConfig.Feature
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Organization.
func (c *OrganizationClient) QueryFiles(o *Organization) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.FilesTable, organization.FilesPrimaryKey...),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.OrganizationFiles
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlementplans queries the entitlementplans edge of a Organization.
func (c *OrganizationClient) QueryEntitlementplans(o *Organization) *EntitlementPlanQuery {
	query := (&EntitlementPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entitlementplan.Table, entitlementplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntitlementplansTable, organization.EntitlementplansColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlan
		step.Edge.Schema = schemaConfig.EntitlementPlan
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitlementplanfeatures queries the entitlementplanfeatures edge of a Organization.
func (c *OrganizationClient) QueryEntitlementplanfeatures(o *Organization) *EntitlementPlanFeatureQuery {
	query := (&EntitlementPlanFeatureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entitlementplanfeature.Table, entitlementplanfeature.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntitlementplanfeaturesTable, organization.EntitlementplanfeaturesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.EntitlementPlanFeature
		step.Edge.Schema = schemaConfig.EntitlementPlanFeature
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntities queries the entities edge of a Organization.
func (c *OrganizationClient) QueryEntities(o *Organization) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntitiesTable, organization.EntitiesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Entity
		step.Edge.Schema = schemaConfig.Entity
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntitytypes queries the entitytypes edge of a Organization.
func (c *OrganizationClient) QueryEntitytypes(o *Organization) *EntityTypeQuery {
	query := (&EntityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(entitytype.Table, entitytype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.EntitytypesTable, organization.EntitytypesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.EntityType
		step.Edge.Schema = schemaConfig.EntityType
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContacts queries the contacts edge of a Organization.
func (c *OrganizationClient) QueryContacts(o *Organization) *ContactQuery {
	query := (&ContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ContactsTable, organization.ContactsColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Contact
		step.Edge.Schema = schemaConfig.Contact
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Organization.
func (c *OrganizationClient) QueryNotes(o *Organization) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.NotesTable, organization.NotesColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Note
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Organization.
func (c *OrganizationClient) QueryTasks(o *Organization) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.TasksTable, organization.TasksPrimaryKey...),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.OrganizationTasks
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Organization.
func (c *OrganizationClient) QueryPrograms(o *Organization) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ProgramsTable, organization.ProgramsColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Organization.
func (c *OrganizationClient) QueryMembers(o *Organization) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, organization.MembersTable, organization.MembersColumn),
		)
		schemaConfig := o.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Organization
	return append(hooks[:len(hooks):len(hooks)], organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	inters := c.inters.Organization
	return append(inters[:len(inters):len(inters)], organization.Interceptors[:]...)
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Organization mutation op: %q", m.Op())
	}
}

// OrganizationHistoryClient is a client for the OrganizationHistory schema.
type OrganizationHistoryClient struct {
	config
}

// NewOrganizationHistoryClient returns a client for the OrganizationHistory from the given config.
func NewOrganizationHistoryClient(c config) *OrganizationHistoryClient {
	return &OrganizationHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationhistory.Hooks(f(g(h())))`.
func (c *OrganizationHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrganizationHistory = append(c.hooks.OrganizationHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationhistory.Intercept(f(g(h())))`.
func (c *OrganizationHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationHistory = append(c.inters.OrganizationHistory, interceptors...)
}

// Create returns a builder for creating a OrganizationHistory entity.
func (c *OrganizationHistoryClient) Create() *OrganizationHistoryCreate {
	mutation := newOrganizationHistoryMutation(c.config, OpCreate)
	return &OrganizationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationHistory entities.
func (c *OrganizationHistoryClient) CreateBulk(builders ...*OrganizationHistoryCreate) *OrganizationHistoryCreateBulk {
	return &OrganizationHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationHistoryClient) MapCreateBulk(slice any, setFunc func(*OrganizationHistoryCreate, int)) *OrganizationHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationHistoryCreateBulk{err: fmt.Errorf("calling to OrganizationHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationHistory.
func (c *OrganizationHistoryClient) Update() *OrganizationHistoryUpdate {
	mutation := newOrganizationHistoryMutation(c.config, OpUpdate)
	return &OrganizationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationHistoryClient) UpdateOne(oh *OrganizationHistory) *OrganizationHistoryUpdateOne {
	mutation := newOrganizationHistoryMutation(c.config, OpUpdateOne, withOrganizationHistory(oh))
	return &OrganizationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationHistoryClient) UpdateOneID(id string) *OrganizationHistoryUpdateOne {
	mutation := newOrganizationHistoryMutation(c.config, OpUpdateOne, withOrganizationHistoryID(id))
	return &OrganizationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationHistory.
func (c *OrganizationHistoryClient) Delete() *OrganizationHistoryDelete {
	mutation := newOrganizationHistoryMutation(c.config, OpDelete)
	return &OrganizationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationHistoryClient) DeleteOne(oh *OrganizationHistory) *OrganizationHistoryDeleteOne {
	return c.DeleteOneID(oh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationHistoryClient) DeleteOneID(id string) *OrganizationHistoryDeleteOne {
	builder := c.Delete().Where(organizationhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationHistoryDeleteOne{builder}
}

// Query returns a query builder for OrganizationHistory.
func (c *OrganizationHistoryClient) Query() *OrganizationHistoryQuery {
	return &OrganizationHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationHistory entity by its id.
func (c *OrganizationHistoryClient) Get(ctx context.Context, id string) (*OrganizationHistory, error) {
	return c.Query().Where(organizationhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationHistoryClient) GetX(ctx context.Context, id string) *OrganizationHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganizationHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationHistory
	return append(hooks[:len(hooks):len(hooks)], organizationhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OrganizationHistory
	return append(inters[:len(inters):len(inters)], organizationhistory.Interceptors[:]...)
}

func (c *OrganizationHistoryClient) mutate(ctx context.Context, m *OrganizationHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrganizationHistory mutation op: %q", m.Op())
	}
}

// OrganizationSettingClient is a client for the OrganizationSetting schema.
type OrganizationSettingClient struct {
	config
}

// NewOrganizationSettingClient returns a client for the OrganizationSetting from the given config.
func NewOrganizationSettingClient(c config) *OrganizationSettingClient {
	return &OrganizationSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationsetting.Hooks(f(g(h())))`.
func (c *OrganizationSettingClient) Use(hooks ...Hook) {
	c.hooks.OrganizationSetting = append(c.hooks.OrganizationSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationsetting.Intercept(f(g(h())))`.
func (c *OrganizationSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationSetting = append(c.inters.OrganizationSetting, interceptors...)
}

// Create returns a builder for creating a OrganizationSetting entity.
func (c *OrganizationSettingClient) Create() *OrganizationSettingCreate {
	mutation := newOrganizationSettingMutation(c.config, OpCreate)
	return &OrganizationSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationSetting entities.
func (c *OrganizationSettingClient) CreateBulk(builders ...*OrganizationSettingCreate) *OrganizationSettingCreateBulk {
	return &OrganizationSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationSettingClient) MapCreateBulk(slice any, setFunc func(*OrganizationSettingCreate, int)) *OrganizationSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationSettingCreateBulk{err: fmt.Errorf("calling to OrganizationSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationSetting.
func (c *OrganizationSettingClient) Update() *OrganizationSettingUpdate {
	mutation := newOrganizationSettingMutation(c.config, OpUpdate)
	return &OrganizationSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationSettingClient) UpdateOne(os *OrganizationSetting) *OrganizationSettingUpdateOne {
	mutation := newOrganizationSettingMutation(c.config, OpUpdateOne, withOrganizationSetting(os))
	return &OrganizationSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationSettingClient) UpdateOneID(id string) *OrganizationSettingUpdateOne {
	mutation := newOrganizationSettingMutation(c.config, OpUpdateOne, withOrganizationSettingID(id))
	return &OrganizationSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationSetting.
func (c *OrganizationSettingClient) Delete() *OrganizationSettingDelete {
	mutation := newOrganizationSettingMutation(c.config, OpDelete)
	return &OrganizationSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationSettingClient) DeleteOne(os *OrganizationSetting) *OrganizationSettingDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationSettingClient) DeleteOneID(id string) *OrganizationSettingDeleteOne {
	builder := c.Delete().Where(organizationsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationSettingDeleteOne{builder}
}

// Query returns a query builder for OrganizationSetting.
func (c *OrganizationSettingClient) Query() *OrganizationSettingQuery {
	return &OrganizationSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationSetting entity by its id.
func (c *OrganizationSettingClient) Get(ctx context.Context, id string) (*OrganizationSetting, error) {
	return c.Query().Where(organizationsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationSettingClient) GetX(ctx context.Context, id string) *OrganizationSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrganizationSetting.
func (c *OrganizationSettingClient) QueryOrganization(os *OrganizationSetting) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationsetting.Table, organizationsetting.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, organizationsetting.OrganizationTable, organizationsetting.OrganizationColumn),
		)
		schemaConfig := os.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationSetting
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a OrganizationSetting.
func (c *OrganizationSettingClient) QueryFiles(os *OrganizationSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationsetting.Table, organizationsetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organizationsetting.FilesTable, organizationsetting.FilesPrimaryKey...),
		)
		schemaConfig := os.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.OrganizationSettingFiles
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationSettingClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationSetting
	return append(hooks[:len(hooks):len(hooks)], organizationsetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationSettingClient) Interceptors() []Interceptor {
	inters := c.inters.OrganizationSetting
	return append(inters[:len(inters):len(inters)], organizationsetting.Interceptors[:]...)
}

func (c *OrganizationSettingClient) mutate(ctx context.Context, m *OrganizationSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrganizationSetting mutation op: %q", m.Op())
	}
}

// OrganizationSettingHistoryClient is a client for the OrganizationSettingHistory schema.
type OrganizationSettingHistoryClient struct {
	config
}

// NewOrganizationSettingHistoryClient returns a client for the OrganizationSettingHistory from the given config.
func NewOrganizationSettingHistoryClient(c config) *OrganizationSettingHistoryClient {
	return &OrganizationSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationsettinghistory.Hooks(f(g(h())))`.
func (c *OrganizationSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.OrganizationSettingHistory = append(c.hooks.OrganizationSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationsettinghistory.Intercept(f(g(h())))`.
func (c *OrganizationSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationSettingHistory = append(c.inters.OrganizationSettingHistory, interceptors...)
}

// Create returns a builder for creating a OrganizationSettingHistory entity.
func (c *OrganizationSettingHistoryClient) Create() *OrganizationSettingHistoryCreate {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpCreate)
	return &OrganizationSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationSettingHistory entities.
func (c *OrganizationSettingHistoryClient) CreateBulk(builders ...*OrganizationSettingHistoryCreate) *OrganizationSettingHistoryCreateBulk {
	return &OrganizationSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*OrganizationSettingHistoryCreate, int)) *OrganizationSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationSettingHistoryCreateBulk{err: fmt.Errorf("calling to OrganizationSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationSettingHistory.
func (c *OrganizationSettingHistoryClient) Update() *OrganizationSettingHistoryUpdate {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpUpdate)
	return &OrganizationSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationSettingHistoryClient) UpdateOne(osh *OrganizationSettingHistory) *OrganizationSettingHistoryUpdateOne {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpUpdateOne, withOrganizationSettingHistory(osh))
	return &OrganizationSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationSettingHistoryClient) UpdateOneID(id string) *OrganizationSettingHistoryUpdateOne {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpUpdateOne, withOrganizationSettingHistoryID(id))
	return &OrganizationSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationSettingHistory.
func (c *OrganizationSettingHistoryClient) Delete() *OrganizationSettingHistoryDelete {
	mutation := newOrganizationSettingHistoryMutation(c.config, OpDelete)
	return &OrganizationSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationSettingHistoryClient) DeleteOne(osh *OrganizationSettingHistory) *OrganizationSettingHistoryDeleteOne {
	return c.DeleteOneID(osh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationSettingHistoryClient) DeleteOneID(id string) *OrganizationSettingHistoryDeleteOne {
	builder := c.Delete().Where(organizationsettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for OrganizationSettingHistory.
func (c *OrganizationSettingHistoryClient) Query() *OrganizationSettingHistoryQuery {
	return &OrganizationSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationSettingHistory entity by its id.
func (c *OrganizationSettingHistoryClient) Get(ctx context.Context, id string) (*OrganizationSettingHistory, error) {
	return c.Query().Where(organizationsettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationSettingHistoryClient) GetX(ctx context.Context, id string) *OrganizationSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganizationSettingHistoryClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationSettingHistory
	return append(hooks[:len(hooks):len(hooks)], organizationsettinghistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.OrganizationSettingHistory
	return append(inters[:len(inters):len(inters)], organizationsettinghistory.Interceptors[:]...)
}

func (c *OrganizationSettingHistoryClient) mutate(ctx context.Context, m *OrganizationSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown OrganizationSettingHistory mutation op: %q", m.Op())
	}
}

// PasswordResetTokenClient is a client for the PasswordResetToken schema.
type PasswordResetTokenClient struct {
	config
}

// NewPasswordResetTokenClient returns a client for the PasswordResetToken from the given config.
func NewPasswordResetTokenClient(c config) *PasswordResetTokenClient {
	return &PasswordResetTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passwordresettoken.Hooks(f(g(h())))`.
func (c *PasswordResetTokenClient) Use(hooks ...Hook) {
	c.hooks.PasswordResetToken = append(c.hooks.PasswordResetToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passwordresettoken.Intercept(f(g(h())))`.
func (c *PasswordResetTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PasswordResetToken = append(c.inters.PasswordResetToken, interceptors...)
}

// Create returns a builder for creating a PasswordResetToken entity.
func (c *PasswordResetTokenClient) Create() *PasswordResetTokenCreate {
	mutation := newPasswordResetTokenMutation(c.config, OpCreate)
	return &PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PasswordResetToken entities.
func (c *PasswordResetTokenClient) CreateBulk(builders ...*PasswordResetTokenCreate) *PasswordResetTokenCreateBulk {
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PasswordResetTokenClient) MapCreateBulk(slice any, setFunc func(*PasswordResetTokenCreate, int)) *PasswordResetTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PasswordResetTokenCreateBulk{err: fmt.Errorf("calling to PasswordResetTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PasswordResetTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Update() *PasswordResetTokenUpdate {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdate)
	return &PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PasswordResetTokenClient) UpdateOne(prt *PasswordResetToken) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetToken(prt))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PasswordResetTokenClient) UpdateOneID(id string) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetTokenID(id))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Delete() *PasswordResetTokenDelete {
	mutation := newPasswordResetTokenMutation(c.config, OpDelete)
	return &PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PasswordResetTokenClient) DeleteOne(prt *PasswordResetToken) *PasswordResetTokenDeleteOne {
	return c.DeleteOneID(prt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PasswordResetTokenClient) DeleteOneID(id string) *PasswordResetTokenDeleteOne {
	builder := c.Delete().Where(passwordresettoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PasswordResetTokenDeleteOne{builder}
}

// Query returns a query builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Query() *PasswordResetTokenQuery {
	return &PasswordResetTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePasswordResetToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PasswordResetToken entity by its id.
func (c *PasswordResetTokenClient) Get(ctx context.Context, id string) (*PasswordResetToken, error) {
	return c.Query().Where(passwordresettoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PasswordResetTokenClient) GetX(ctx context.Context, id string) *PasswordResetToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a PasswordResetToken.
func (c *PasswordResetTokenClient) QueryOwner(prt *PasswordResetToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := prt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passwordresettoken.Table, passwordresettoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, passwordresettoken.OwnerTable, passwordresettoken.OwnerColumn),
		)
		schemaConfig := prt.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.PasswordResetToken
		fromV = sqlgraph.Neighbors(prt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PasswordResetTokenClient) Hooks() []Hook {
	hooks := c.hooks.PasswordResetToken
	return append(hooks[:len(hooks):len(hooks)], passwordresettoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PasswordResetTokenClient) Interceptors() []Interceptor {
	inters := c.inters.PasswordResetToken
	return append(inters[:len(inters):len(inters)], passwordresettoken.Interceptors[:]...)
}

func (c *PasswordResetTokenClient) mutate(ctx context.Context, m *PasswordResetTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown PasswordResetToken mutation op: %q", m.Op())
	}
}

// PersonalAccessTokenClient is a client for the PersonalAccessToken schema.
type PersonalAccessTokenClient struct {
	config
}

// NewPersonalAccessTokenClient returns a client for the PersonalAccessToken from the given config.
func NewPersonalAccessTokenClient(c config) *PersonalAccessTokenClient {
	return &PersonalAccessTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personalaccesstoken.Hooks(f(g(h())))`.
func (c *PersonalAccessTokenClient) Use(hooks ...Hook) {
	c.hooks.PersonalAccessToken = append(c.hooks.PersonalAccessToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `personalaccesstoken.Intercept(f(g(h())))`.
func (c *PersonalAccessTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PersonalAccessToken = append(c.inters.PersonalAccessToken, interceptors...)
}

// Create returns a builder for creating a PersonalAccessToken entity.
func (c *PersonalAccessTokenClient) Create() *PersonalAccessTokenCreate {
	mutation := newPersonalAccessTokenMutation(c.config, OpCreate)
	return &PersonalAccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PersonalAccessToken entities.
func (c *PersonalAccessTokenClient) CreateBulk(builders ...*PersonalAccessTokenCreate) *PersonalAccessTokenCreateBulk {
	return &PersonalAccessTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonalAccessTokenClient) MapCreateBulk(slice any, setFunc func(*PersonalAccessTokenCreate, int)) *PersonalAccessTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonalAccessTokenCreateBulk{err: fmt.Errorf("calling to PersonalAccessTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonalAccessTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonalAccessTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Update() *PersonalAccessTokenUpdate {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdate)
	return &PersonalAccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonalAccessTokenClient) UpdateOne(pat *PersonalAccessToken) *PersonalAccessTokenUpdateOne {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdateOne, withPersonalAccessToken(pat))
	return &PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonalAccessTokenClient) UpdateOneID(id string) *PersonalAccessTokenUpdateOne {
	mutation := newPersonalAccessTokenMutation(c.config, OpUpdateOne, withPersonalAccessTokenID(id))
	return &PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Delete() *PersonalAccessTokenDelete {
	mutation := newPersonalAccessTokenMutation(c.config, OpDelete)
	return &PersonalAccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonalAccessTokenClient) DeleteOne(pat *PersonalAccessToken) *PersonalAccessTokenDeleteOne {
	return c.DeleteOneID(pat.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonalAccessTokenClient) DeleteOneID(id string) *PersonalAccessTokenDeleteOne {
	builder := c.Delete().Where(personalaccesstoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonalAccessTokenDeleteOne{builder}
}

// Query returns a query builder for PersonalAccessToken.
func (c *PersonalAccessTokenClient) Query() *PersonalAccessTokenQuery {
	return &PersonalAccessTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePersonalAccessToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PersonalAccessToken entity by its id.
func (c *PersonalAccessTokenClient) Get(ctx context.Context, id string) (*PersonalAccessToken, error) {
	return c.Query().Where(personalaccesstoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonalAccessTokenClient) GetX(ctx context.Context, id string) *PersonalAccessToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryOwner(pat *PersonalAccessToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, personalaccesstoken.OwnerTable, personalaccesstoken.OwnerColumn),
		)
		schemaConfig := pat.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.PersonalAccessToken
		fromV = sqlgraph.Neighbors(pat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryOrganizations(pat *PersonalAccessToken) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, personalaccesstoken.OrganizationsTable, personalaccesstoken.OrganizationsPrimaryKey...),
		)
		schemaConfig := pat.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationPersonalAccessTokens
		fromV = sqlgraph.Neighbors(pat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a PersonalAccessToken.
func (c *PersonalAccessTokenClient) QueryEvents(pat *PersonalAccessToken) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personalaccesstoken.Table, personalaccesstoken.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, personalaccesstoken.EventsTable, personalaccesstoken.EventsPrimaryKey...),
		)
		schemaConfig := pat.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.PersonalAccessTokenEvents
		fromV = sqlgraph.Neighbors(pat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonalAccessTokenClient) Hooks() []Hook {
	hooks := c.hooks.PersonalAccessToken
	return append(hooks[:len(hooks):len(hooks)], personalaccesstoken.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PersonalAccessTokenClient) Interceptors() []Interceptor {
	inters := c.inters.PersonalAccessToken
	return append(inters[:len(inters):len(inters)], personalaccesstoken.Interceptors[:]...)
}

func (c *PersonalAccessTokenClient) mutate(ctx context.Context, m *PersonalAccessTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonalAccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonalAccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonalAccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonalAccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown PersonalAccessToken mutation op: %q", m.Op())
	}
}

// ProcedureClient is a client for the Procedure schema.
type ProcedureClient struct {
	config
}

// NewProcedureClient returns a client for the Procedure from the given config.
func NewProcedureClient(c config) *ProcedureClient {
	return &ProcedureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `procedure.Hooks(f(g(h())))`.
func (c *ProcedureClient) Use(hooks ...Hook) {
	c.hooks.Procedure = append(c.hooks.Procedure, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `procedure.Intercept(f(g(h())))`.
func (c *ProcedureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Procedure = append(c.inters.Procedure, interceptors...)
}

// Create returns a builder for creating a Procedure entity.
func (c *ProcedureClient) Create() *ProcedureCreate {
	mutation := newProcedureMutation(c.config, OpCreate)
	return &ProcedureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Procedure entities.
func (c *ProcedureClient) CreateBulk(builders ...*ProcedureCreate) *ProcedureCreateBulk {
	return &ProcedureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProcedureClient) MapCreateBulk(slice any, setFunc func(*ProcedureCreate, int)) *ProcedureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProcedureCreateBulk{err: fmt.Errorf("calling to ProcedureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProcedureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProcedureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Procedure.
func (c *ProcedureClient) Update() *ProcedureUpdate {
	mutation := newProcedureMutation(c.config, OpUpdate)
	return &ProcedureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcedureClient) UpdateOne(pr *Procedure) *ProcedureUpdateOne {
	mutation := newProcedureMutation(c.config, OpUpdateOne, withProcedure(pr))
	return &ProcedureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcedureClient) UpdateOneID(id string) *ProcedureUpdateOne {
	mutation := newProcedureMutation(c.config, OpUpdateOne, withProcedureID(id))
	return &ProcedureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Procedure.
func (c *ProcedureClient) Delete() *ProcedureDelete {
	mutation := newProcedureMutation(c.config, OpDelete)
	return &ProcedureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcedureClient) DeleteOne(pr *Procedure) *ProcedureDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProcedureClient) DeleteOneID(id string) *ProcedureDeleteOne {
	builder := c.Delete().Where(procedure.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcedureDeleteOne{builder}
}

// Query returns a query builder for Procedure.
func (c *ProcedureClient) Query() *ProcedureQuery {
	return &ProcedureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProcedure},
		inters: c.Interceptors(),
	}
}

// Get returns a Procedure entity by its id.
func (c *ProcedureClient) Get(ctx context.Context, id string) (*Procedure, error) {
	return c.Query().Where(procedure.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcedureClient) GetX(ctx context.Context, id string) *Procedure {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryControl queries the control edge of a Procedure.
func (c *ProcedureClient) QueryControl(pr *Procedure) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.ControlTable, procedure.ControlPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlProcedures
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInternalpolicy queries the internalpolicy edge of a Procedure.
func (c *ProcedureClient) QueryInternalpolicy(pr *Procedure) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.InternalpolicyTable, procedure.InternalpolicyPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyProcedures
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Procedure.
func (c *ProcedureClient) QueryNarratives(pr *Procedure) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.NarrativesTable, procedure.NarrativesPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ProcedureNarratives
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Procedure.
func (c *ProcedureClient) QueryRisks(pr *Procedure) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.RisksTable, procedure.RisksPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.ProcedureRisks
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Procedure.
func (c *ProcedureClient) QueryTasks(pr *Procedure) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, procedure.TasksTable, procedure.TasksPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ProcedureTasks
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Procedure.
func (c *ProcedureClient) QueryPrograms(pr *Procedure) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procedure.Table, procedure.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, procedure.ProgramsTable, procedure.ProgramsPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramProcedures
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProcedureClient) Hooks() []Hook {
	hooks := c.hooks.Procedure
	return append(hooks[:len(hooks):len(hooks)], procedure.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProcedureClient) Interceptors() []Interceptor {
	inters := c.inters.Procedure
	return append(inters[:len(inters):len(inters)], procedure.Interceptors[:]...)
}

func (c *ProcedureClient) mutate(ctx context.Context, m *ProcedureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProcedureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProcedureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProcedureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProcedureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Procedure mutation op: %q", m.Op())
	}
}

// ProcedureHistoryClient is a client for the ProcedureHistory schema.
type ProcedureHistoryClient struct {
	config
}

// NewProcedureHistoryClient returns a client for the ProcedureHistory from the given config.
func NewProcedureHistoryClient(c config) *ProcedureHistoryClient {
	return &ProcedureHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `procedurehistory.Hooks(f(g(h())))`.
func (c *ProcedureHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProcedureHistory = append(c.hooks.ProcedureHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `procedurehistory.Intercept(f(g(h())))`.
func (c *ProcedureHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProcedureHistory = append(c.inters.ProcedureHistory, interceptors...)
}

// Create returns a builder for creating a ProcedureHistory entity.
func (c *ProcedureHistoryClient) Create() *ProcedureHistoryCreate {
	mutation := newProcedureHistoryMutation(c.config, OpCreate)
	return &ProcedureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcedureHistory entities.
func (c *ProcedureHistoryClient) CreateBulk(builders ...*ProcedureHistoryCreate) *ProcedureHistoryCreateBulk {
	return &ProcedureHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProcedureHistoryClient) MapCreateBulk(slice any, setFunc func(*ProcedureHistoryCreate, int)) *ProcedureHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProcedureHistoryCreateBulk{err: fmt.Errorf("calling to ProcedureHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProcedureHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProcedureHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcedureHistory.
func (c *ProcedureHistoryClient) Update() *ProcedureHistoryUpdate {
	mutation := newProcedureHistoryMutation(c.config, OpUpdate)
	return &ProcedureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcedureHistoryClient) UpdateOne(ph *ProcedureHistory) *ProcedureHistoryUpdateOne {
	mutation := newProcedureHistoryMutation(c.config, OpUpdateOne, withProcedureHistory(ph))
	return &ProcedureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcedureHistoryClient) UpdateOneID(id string) *ProcedureHistoryUpdateOne {
	mutation := newProcedureHistoryMutation(c.config, OpUpdateOne, withProcedureHistoryID(id))
	return &ProcedureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcedureHistory.
func (c *ProcedureHistoryClient) Delete() *ProcedureHistoryDelete {
	mutation := newProcedureHistoryMutation(c.config, OpDelete)
	return &ProcedureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcedureHistoryClient) DeleteOne(ph *ProcedureHistory) *ProcedureHistoryDeleteOne {
	return c.DeleteOneID(ph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProcedureHistoryClient) DeleteOneID(id string) *ProcedureHistoryDeleteOne {
	builder := c.Delete().Where(procedurehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcedureHistoryDeleteOne{builder}
}

// Query returns a query builder for ProcedureHistory.
func (c *ProcedureHistoryClient) Query() *ProcedureHistoryQuery {
	return &ProcedureHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProcedureHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProcedureHistory entity by its id.
func (c *ProcedureHistoryClient) Get(ctx context.Context, id string) (*ProcedureHistory, error) {
	return c.Query().Where(procedurehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcedureHistoryClient) GetX(ctx context.Context, id string) *ProcedureHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProcedureHistoryClient) Hooks() []Hook {
	return c.hooks.ProcedureHistory
}

// Interceptors returns the client interceptors.
func (c *ProcedureHistoryClient) Interceptors() []Interceptor {
	return c.inters.ProcedureHistory
}

func (c *ProcedureHistoryClient) mutate(ctx context.Context, m *ProcedureHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProcedureHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProcedureHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProcedureHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProcedureHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProcedureHistory mutation op: %q", m.Op())
	}
}

// ProgramClient is a client for the Program schema.
type ProgramClient struct {
	config
}

// NewProgramClient returns a client for the Program from the given config.
func NewProgramClient(c config) *ProgramClient {
	return &ProgramClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `program.Hooks(f(g(h())))`.
func (c *ProgramClient) Use(hooks ...Hook) {
	c.hooks.Program = append(c.hooks.Program, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `program.Intercept(f(g(h())))`.
func (c *ProgramClient) Intercept(interceptors ...Interceptor) {
	c.inters.Program = append(c.inters.Program, interceptors...)
}

// Create returns a builder for creating a Program entity.
func (c *ProgramClient) Create() *ProgramCreate {
	mutation := newProgramMutation(c.config, OpCreate)
	return &ProgramCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Program entities.
func (c *ProgramClient) CreateBulk(builders ...*ProgramCreate) *ProgramCreateBulk {
	return &ProgramCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramClient) MapCreateBulk(slice any, setFunc func(*ProgramCreate, int)) *ProgramCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramCreateBulk{err: fmt.Errorf("calling to ProgramClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Program.
func (c *ProgramClient) Update() *ProgramUpdate {
	mutation := newProgramMutation(c.config, OpUpdate)
	return &ProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramClient) UpdateOne(pr *Program) *ProgramUpdateOne {
	mutation := newProgramMutation(c.config, OpUpdateOne, withProgram(pr))
	return &ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramClient) UpdateOneID(id string) *ProgramUpdateOne {
	mutation := newProgramMutation(c.config, OpUpdateOne, withProgramID(id))
	return &ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Program.
func (c *ProgramClient) Delete() *ProgramDelete {
	mutation := newProgramMutation(c.config, OpDelete)
	return &ProgramDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramClient) DeleteOne(pr *Program) *ProgramDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramClient) DeleteOneID(id string) *ProgramDeleteOne {
	builder := c.Delete().Where(program.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramDeleteOne{builder}
}

// Query returns a query builder for Program.
func (c *ProgramClient) Query() *ProgramQuery {
	return &ProgramQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgram},
		inters: c.Interceptors(),
	}
}

// Get returns a Program entity by its id.
func (c *ProgramClient) Get(ctx context.Context, id string) (*Program, error) {
	return c.Query().Where(program.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramClient) GetX(ctx context.Context, id string) *Program {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Program.
func (c *ProgramClient) QueryOwner(pr *Program) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, program.OwnerTable, program.OwnerColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Program
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Program.
func (c *ProgramClient) QueryControls(pr *Program) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ControlsTable, program.ControlsPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ProgramControls
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a Program.
func (c *ProgramClient) QuerySubcontrols(pr *Program) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.SubcontrolsTable, program.SubcontrolsPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.ProgramSubcontrols
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlobjectives queries the controlobjectives edge of a Program.
func (c *ProgramClient) QueryControlobjectives(pr *Program) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ControlobjectivesTable, program.ControlobjectivesPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ProgramControlobjectives
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPolicies queries the policies edge of a Program.
func (c *ProgramClient) QueryPolicies(pr *Program) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.PoliciesTable, program.PoliciesPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.ProgramPolicies
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Program.
func (c *ProgramClient) QueryProcedures(pr *Program) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ProceduresTable, program.ProceduresPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProgramProcedures
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRisks queries the risks edge of a Program.
func (c *ProgramClient) QueryRisks(pr *Program) *RiskQuery {
	query := (&RiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(risk.Table, risk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.RisksTable, program.RisksPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Risk
		step.Edge.Schema = schemaConfig.ProgramRisks
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Program.
func (c *ProgramClient) QueryTasks(pr *Program) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.TasksTable, program.TasksPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.ProgramTasks
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Program.
func (c *ProgramClient) QueryNotes(pr *Program) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.NotesTable, program.NotesPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.ProgramNotes
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Program.
func (c *ProgramClient) QueryFiles(pr *Program) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.FilesTable, program.FilesPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.ProgramFiles
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNarratives queries the narratives edge of a Program.
func (c *ProgramClient) QueryNarratives(pr *Program) *NarrativeQuery {
	query := (&NarrativeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(narrative.Table, narrative.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.NarrativesTable, program.NarrativesPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Narrative
		step.Edge.Schema = schemaConfig.ProgramNarratives
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionplans queries the actionplans edge of a Program.
func (c *ProgramClient) QueryActionplans(pr *Program) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, program.ActionplansTable, program.ActionplansPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.ProgramActionplans
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandards queries the standards edge of a Program.
func (c *ProgramClient) QueryStandards(pr *Program) *StandardQuery {
	query := (&StandardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(standard.Table, standard.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, program.StandardsTable, program.StandardsPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.Standard
		step.Edge.Schema = schemaConfig.StandardPrograms
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Program.
func (c *ProgramClient) QueryUsers(pr *Program) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, program.UsersTable, program.UsersPrimaryKey...),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Program.
func (c *ProgramClient) QueryMembers(pr *Program) *ProgramMembershipQuery {
	query := (&ProgramMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(programmembership.Table, programmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, program.MembersTable, program.MembersColumn),
		)
		schemaConfig := pr.schemaConfig
		step.To.Schema = schemaConfig.ProgramMembership
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramClient) Hooks() []Hook {
	hooks := c.hooks.Program
	return append(hooks[:len(hooks):len(hooks)], program.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramClient) Interceptors() []Interceptor {
	inters := c.inters.Program
	return append(inters[:len(inters):len(inters)], program.Interceptors[:]...)
}

func (c *ProgramClient) mutate(ctx context.Context, m *ProgramMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Program mutation op: %q", m.Op())
	}
}

// ProgramHistoryClient is a client for the ProgramHistory schema.
type ProgramHistoryClient struct {
	config
}

// NewProgramHistoryClient returns a client for the ProgramHistory from the given config.
func NewProgramHistoryClient(c config) *ProgramHistoryClient {
	return &ProgramHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programhistory.Hooks(f(g(h())))`.
func (c *ProgramHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProgramHistory = append(c.hooks.ProgramHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programhistory.Intercept(f(g(h())))`.
func (c *ProgramHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramHistory = append(c.inters.ProgramHistory, interceptors...)
}

// Create returns a builder for creating a ProgramHistory entity.
func (c *ProgramHistoryClient) Create() *ProgramHistoryCreate {
	mutation := newProgramHistoryMutation(c.config, OpCreate)
	return &ProgramHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramHistory entities.
func (c *ProgramHistoryClient) CreateBulk(builders ...*ProgramHistoryCreate) *ProgramHistoryCreateBulk {
	return &ProgramHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramHistoryClient) MapCreateBulk(slice any, setFunc func(*ProgramHistoryCreate, int)) *ProgramHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramHistoryCreateBulk{err: fmt.Errorf("calling to ProgramHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramHistory.
func (c *ProgramHistoryClient) Update() *ProgramHistoryUpdate {
	mutation := newProgramHistoryMutation(c.config, OpUpdate)
	return &ProgramHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramHistoryClient) UpdateOne(ph *ProgramHistory) *ProgramHistoryUpdateOne {
	mutation := newProgramHistoryMutation(c.config, OpUpdateOne, withProgramHistory(ph))
	return &ProgramHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramHistoryClient) UpdateOneID(id string) *ProgramHistoryUpdateOne {
	mutation := newProgramHistoryMutation(c.config, OpUpdateOne, withProgramHistoryID(id))
	return &ProgramHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramHistory.
func (c *ProgramHistoryClient) Delete() *ProgramHistoryDelete {
	mutation := newProgramHistoryMutation(c.config, OpDelete)
	return &ProgramHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramHistoryClient) DeleteOne(ph *ProgramHistory) *ProgramHistoryDeleteOne {
	return c.DeleteOneID(ph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramHistoryClient) DeleteOneID(id string) *ProgramHistoryDeleteOne {
	builder := c.Delete().Where(programhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramHistoryDeleteOne{builder}
}

// Query returns a query builder for ProgramHistory.
func (c *ProgramHistoryClient) Query() *ProgramHistoryQuery {
	return &ProgramHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramHistory entity by its id.
func (c *ProgramHistoryClient) Get(ctx context.Context, id string) (*ProgramHistory, error) {
	return c.Query().Where(programhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramHistoryClient) GetX(ctx context.Context, id string) *ProgramHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProgramHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ProgramHistory
	return append(hooks[:len(hooks):len(hooks)], programhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ProgramHistory
	return append(inters[:len(inters):len(inters)], programhistory.Interceptors[:]...)
}

func (c *ProgramHistoryClient) mutate(ctx context.Context, m *ProgramHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProgramHistory mutation op: %q", m.Op())
	}
}

// ProgramMembershipClient is a client for the ProgramMembership schema.
type ProgramMembershipClient struct {
	config
}

// NewProgramMembershipClient returns a client for the ProgramMembership from the given config.
func NewProgramMembershipClient(c config) *ProgramMembershipClient {
	return &ProgramMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programmembership.Hooks(f(g(h())))`.
func (c *ProgramMembershipClient) Use(hooks ...Hook) {
	c.hooks.ProgramMembership = append(c.hooks.ProgramMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programmembership.Intercept(f(g(h())))`.
func (c *ProgramMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramMembership = append(c.inters.ProgramMembership, interceptors...)
}

// Create returns a builder for creating a ProgramMembership entity.
func (c *ProgramMembershipClient) Create() *ProgramMembershipCreate {
	mutation := newProgramMembershipMutation(c.config, OpCreate)
	return &ProgramMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramMembership entities.
func (c *ProgramMembershipClient) CreateBulk(builders ...*ProgramMembershipCreate) *ProgramMembershipCreateBulk {
	return &ProgramMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramMembershipClient) MapCreateBulk(slice any, setFunc func(*ProgramMembershipCreate, int)) *ProgramMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramMembershipCreateBulk{err: fmt.Errorf("calling to ProgramMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramMembership.
func (c *ProgramMembershipClient) Update() *ProgramMembershipUpdate {
	mutation := newProgramMembershipMutation(c.config, OpUpdate)
	return &ProgramMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramMembershipClient) UpdateOne(pm *ProgramMembership) *ProgramMembershipUpdateOne {
	mutation := newProgramMembershipMutation(c.config, OpUpdateOne, withProgramMembership(pm))
	return &ProgramMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramMembershipClient) UpdateOneID(id string) *ProgramMembershipUpdateOne {
	mutation := newProgramMembershipMutation(c.config, OpUpdateOne, withProgramMembershipID(id))
	return &ProgramMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramMembership.
func (c *ProgramMembershipClient) Delete() *ProgramMembershipDelete {
	mutation := newProgramMembershipMutation(c.config, OpDelete)
	return &ProgramMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramMembershipClient) DeleteOne(pm *ProgramMembership) *ProgramMembershipDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramMembershipClient) DeleteOneID(id string) *ProgramMembershipDeleteOne {
	builder := c.Delete().Where(programmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramMembershipDeleteOne{builder}
}

// Query returns a query builder for ProgramMembership.
func (c *ProgramMembershipClient) Query() *ProgramMembershipQuery {
	return &ProgramMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramMembership entity by its id.
func (c *ProgramMembershipClient) Get(ctx context.Context, id string) (*ProgramMembership, error) {
	return c.Query().Where(programmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramMembershipClient) GetX(ctx context.Context, id string) *ProgramMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a ProgramMembership.
func (c *ProgramMembershipClient) QueryProgram(pm *ProgramMembership) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programmembership.Table, programmembership.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, programmembership.ProgramTable, programmembership.ProgramColumn),
		)
		schemaConfig := pm.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ProgramMembership.
func (c *ProgramMembershipClient) QueryUser(pm *ProgramMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programmembership.Table, programmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, programmembership.UserTable, programmembership.UserColumn),
		)
		schemaConfig := pm.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramMembershipClient) Hooks() []Hook {
	hooks := c.hooks.ProgramMembership
	return append(hooks[:len(hooks):len(hooks)], programmembership.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramMembershipClient) Interceptors() []Interceptor {
	inters := c.inters.ProgramMembership
	return append(inters[:len(inters):len(inters)], programmembership.Interceptors[:]...)
}

func (c *ProgramMembershipClient) mutate(ctx context.Context, m *ProgramMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProgramMembership mutation op: %q", m.Op())
	}
}

// ProgramMembershipHistoryClient is a client for the ProgramMembershipHistory schema.
type ProgramMembershipHistoryClient struct {
	config
}

// NewProgramMembershipHistoryClient returns a client for the ProgramMembershipHistory from the given config.
func NewProgramMembershipHistoryClient(c config) *ProgramMembershipHistoryClient {
	return &ProgramMembershipHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programmembershiphistory.Hooks(f(g(h())))`.
func (c *ProgramMembershipHistoryClient) Use(hooks ...Hook) {
	c.hooks.ProgramMembershipHistory = append(c.hooks.ProgramMembershipHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programmembershiphistory.Intercept(f(g(h())))`.
func (c *ProgramMembershipHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramMembershipHistory = append(c.inters.ProgramMembershipHistory, interceptors...)
}

// Create returns a builder for creating a ProgramMembershipHistory entity.
func (c *ProgramMembershipHistoryClient) Create() *ProgramMembershipHistoryCreate {
	mutation := newProgramMembershipHistoryMutation(c.config, OpCreate)
	return &ProgramMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramMembershipHistory entities.
func (c *ProgramMembershipHistoryClient) CreateBulk(builders ...*ProgramMembershipHistoryCreate) *ProgramMembershipHistoryCreateBulk {
	return &ProgramMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramMembershipHistoryClient) MapCreateBulk(slice any, setFunc func(*ProgramMembershipHistoryCreate, int)) *ProgramMembershipHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramMembershipHistoryCreateBulk{err: fmt.Errorf("calling to ProgramMembershipHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramMembershipHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramMembershipHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramMembershipHistory.
func (c *ProgramMembershipHistoryClient) Update() *ProgramMembershipHistoryUpdate {
	mutation := newProgramMembershipHistoryMutation(c.config, OpUpdate)
	return &ProgramMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramMembershipHistoryClient) UpdateOne(pmh *ProgramMembershipHistory) *ProgramMembershipHistoryUpdateOne {
	mutation := newProgramMembershipHistoryMutation(c.config, OpUpdateOne, withProgramMembershipHistory(pmh))
	return &ProgramMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramMembershipHistoryClient) UpdateOneID(id string) *ProgramMembershipHistoryUpdateOne {
	mutation := newProgramMembershipHistoryMutation(c.config, OpUpdateOne, withProgramMembershipHistoryID(id))
	return &ProgramMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramMembershipHistory.
func (c *ProgramMembershipHistoryClient) Delete() *ProgramMembershipHistoryDelete {
	mutation := newProgramMembershipHistoryMutation(c.config, OpDelete)
	return &ProgramMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramMembershipHistoryClient) DeleteOne(pmh *ProgramMembershipHistory) *ProgramMembershipHistoryDeleteOne {
	return c.DeleteOneID(pmh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramMembershipHistoryClient) DeleteOneID(id string) *ProgramMembershipHistoryDeleteOne {
	builder := c.Delete().Where(programmembershiphistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramMembershipHistoryDeleteOne{builder}
}

// Query returns a query builder for ProgramMembershipHistory.
func (c *ProgramMembershipHistoryClient) Query() *ProgramMembershipHistoryQuery {
	return &ProgramMembershipHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramMembershipHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramMembershipHistory entity by its id.
func (c *ProgramMembershipHistoryClient) Get(ctx context.Context, id string) (*ProgramMembershipHistory, error) {
	return c.Query().Where(programmembershiphistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramMembershipHistoryClient) GetX(ctx context.Context, id string) *ProgramMembershipHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProgramMembershipHistoryClient) Hooks() []Hook {
	hooks := c.hooks.ProgramMembershipHistory
	return append(hooks[:len(hooks):len(hooks)], programmembershiphistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProgramMembershipHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.ProgramMembershipHistory
	return append(inters[:len(inters):len(inters)], programmembershiphistory.Interceptors[:]...)
}

func (c *ProgramMembershipHistoryClient) mutate(ctx context.Context, m *ProgramMembershipHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramMembershipHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramMembershipHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramMembershipHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramMembershipHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown ProgramMembershipHistory mutation op: %q", m.Op())
	}
}

// RiskClient is a client for the Risk schema.
type RiskClient struct {
	config
}

// NewRiskClient returns a client for the Risk from the given config.
func NewRiskClient(c config) *RiskClient {
	return &RiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `risk.Hooks(f(g(h())))`.
func (c *RiskClient) Use(hooks ...Hook) {
	c.hooks.Risk = append(c.hooks.Risk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `risk.Intercept(f(g(h())))`.
func (c *RiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Risk = append(c.inters.Risk, interceptors...)
}

// Create returns a builder for creating a Risk entity.
func (c *RiskClient) Create() *RiskCreate {
	mutation := newRiskMutation(c.config, OpCreate)
	return &RiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Risk entities.
func (c *RiskClient) CreateBulk(builders ...*RiskCreate) *RiskCreateBulk {
	return &RiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RiskClient) MapCreateBulk(slice any, setFunc func(*RiskCreate, int)) *RiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RiskCreateBulk{err: fmt.Errorf("calling to RiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Risk.
func (c *RiskClient) Update() *RiskUpdate {
	mutation := newRiskMutation(c.config, OpUpdate)
	return &RiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RiskClient) UpdateOne(r *Risk) *RiskUpdateOne {
	mutation := newRiskMutation(c.config, OpUpdateOne, withRisk(r))
	return &RiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RiskClient) UpdateOneID(id string) *RiskUpdateOne {
	mutation := newRiskMutation(c.config, OpUpdateOne, withRiskID(id))
	return &RiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Risk.
func (c *RiskClient) Delete() *RiskDelete {
	mutation := newRiskMutation(c.config, OpDelete)
	return &RiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RiskClient) DeleteOne(r *Risk) *RiskDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RiskClient) DeleteOneID(id string) *RiskDeleteOne {
	builder := c.Delete().Where(risk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RiskDeleteOne{builder}
}

// Query returns a query builder for Risk.
func (c *RiskClient) Query() *RiskQuery {
	return &RiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRisk},
		inters: c.Interceptors(),
	}
}

// Get returns a Risk entity by its id.
func (c *RiskClient) Get(ctx context.Context, id string) (*Risk, error) {
	return c.Query().Where(risk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RiskClient) GetX(ctx context.Context, id string) *Risk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryControl queries the control edge of a Risk.
func (c *RiskClient) QueryControl(r *Risk) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.ControlTable, risk.ControlPrimaryKey...),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlRisks
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedure queries the procedure edge of a Risk.
func (c *RiskClient) QueryProcedure(r *Risk) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.ProcedureTable, risk.ProcedurePrimaryKey...),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureRisks
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionplans queries the actionplans edge of a Risk.
func (c *RiskClient) QueryActionplans(r *Risk) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, risk.ActionplansTable, risk.ActionplansPrimaryKey...),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.RiskActionplans
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a Risk.
func (c *RiskClient) QueryProgram(r *Risk) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(risk.Table, risk.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, risk.ProgramTable, risk.ProgramPrimaryKey...),
		)
		schemaConfig := r.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramRisks
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RiskClient) Hooks() []Hook {
	hooks := c.hooks.Risk
	return append(hooks[:len(hooks):len(hooks)], risk.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RiskClient) Interceptors() []Interceptor {
	inters := c.inters.Risk
	return append(inters[:len(inters):len(inters)], risk.Interceptors[:]...)
}

func (c *RiskClient) mutate(ctx context.Context, m *RiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Risk mutation op: %q", m.Op())
	}
}

// RiskHistoryClient is a client for the RiskHistory schema.
type RiskHistoryClient struct {
	config
}

// NewRiskHistoryClient returns a client for the RiskHistory from the given config.
func NewRiskHistoryClient(c config) *RiskHistoryClient {
	return &RiskHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `riskhistory.Hooks(f(g(h())))`.
func (c *RiskHistoryClient) Use(hooks ...Hook) {
	c.hooks.RiskHistory = append(c.hooks.RiskHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `riskhistory.Intercept(f(g(h())))`.
func (c *RiskHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.RiskHistory = append(c.inters.RiskHistory, interceptors...)
}

// Create returns a builder for creating a RiskHistory entity.
func (c *RiskHistoryClient) Create() *RiskHistoryCreate {
	mutation := newRiskHistoryMutation(c.config, OpCreate)
	return &RiskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RiskHistory entities.
func (c *RiskHistoryClient) CreateBulk(builders ...*RiskHistoryCreate) *RiskHistoryCreateBulk {
	return &RiskHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RiskHistoryClient) MapCreateBulk(slice any, setFunc func(*RiskHistoryCreate, int)) *RiskHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RiskHistoryCreateBulk{err: fmt.Errorf("calling to RiskHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RiskHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RiskHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RiskHistory.
func (c *RiskHistoryClient) Update() *RiskHistoryUpdate {
	mutation := newRiskHistoryMutation(c.config, OpUpdate)
	return &RiskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RiskHistoryClient) UpdateOne(rh *RiskHistory) *RiskHistoryUpdateOne {
	mutation := newRiskHistoryMutation(c.config, OpUpdateOne, withRiskHistory(rh))
	return &RiskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RiskHistoryClient) UpdateOneID(id string) *RiskHistoryUpdateOne {
	mutation := newRiskHistoryMutation(c.config, OpUpdateOne, withRiskHistoryID(id))
	return &RiskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RiskHistory.
func (c *RiskHistoryClient) Delete() *RiskHistoryDelete {
	mutation := newRiskHistoryMutation(c.config, OpDelete)
	return &RiskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RiskHistoryClient) DeleteOne(rh *RiskHistory) *RiskHistoryDeleteOne {
	return c.DeleteOneID(rh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RiskHistoryClient) DeleteOneID(id string) *RiskHistoryDeleteOne {
	builder := c.Delete().Where(riskhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RiskHistoryDeleteOne{builder}
}

// Query returns a query builder for RiskHistory.
func (c *RiskHistoryClient) Query() *RiskHistoryQuery {
	return &RiskHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRiskHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a RiskHistory entity by its id.
func (c *RiskHistoryClient) Get(ctx context.Context, id string) (*RiskHistory, error) {
	return c.Query().Where(riskhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RiskHistoryClient) GetX(ctx context.Context, id string) *RiskHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RiskHistoryClient) Hooks() []Hook {
	return c.hooks.RiskHistory
}

// Interceptors returns the client interceptors.
func (c *RiskHistoryClient) Interceptors() []Interceptor {
	return c.inters.RiskHistory
}

func (c *RiskHistoryClient) mutate(ctx context.Context, m *RiskHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RiskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RiskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RiskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RiskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RiskHistory mutation op: %q", m.Op())
	}
}

// StandardClient is a client for the Standard schema.
type StandardClient struct {
	config
}

// NewStandardClient returns a client for the Standard from the given config.
func NewStandardClient(c config) *StandardClient {
	return &StandardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standard.Hooks(f(g(h())))`.
func (c *StandardClient) Use(hooks ...Hook) {
	c.hooks.Standard = append(c.hooks.Standard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standard.Intercept(f(g(h())))`.
func (c *StandardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Standard = append(c.inters.Standard, interceptors...)
}

// Create returns a builder for creating a Standard entity.
func (c *StandardClient) Create() *StandardCreate {
	mutation := newStandardMutation(c.config, OpCreate)
	return &StandardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Standard entities.
func (c *StandardClient) CreateBulk(builders ...*StandardCreate) *StandardCreateBulk {
	return &StandardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardClient) MapCreateBulk(slice any, setFunc func(*StandardCreate, int)) *StandardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardCreateBulk{err: fmt.Errorf("calling to StandardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Standard.
func (c *StandardClient) Update() *StandardUpdate {
	mutation := newStandardMutation(c.config, OpUpdate)
	return &StandardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardClient) UpdateOne(s *Standard) *StandardUpdateOne {
	mutation := newStandardMutation(c.config, OpUpdateOne, withStandard(s))
	return &StandardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardClient) UpdateOneID(id string) *StandardUpdateOne {
	mutation := newStandardMutation(c.config, OpUpdateOne, withStandardID(id))
	return &StandardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Standard.
func (c *StandardClient) Delete() *StandardDelete {
	mutation := newStandardMutation(c.config, OpDelete)
	return &StandardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardClient) DeleteOne(s *Standard) *StandardDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardClient) DeleteOneID(id string) *StandardDeleteOne {
	builder := c.Delete().Where(standard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardDeleteOne{builder}
}

// Query returns a query builder for Standard.
func (c *StandardClient) Query() *StandardQuery {
	return &StandardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandard},
		inters: c.Interceptors(),
	}
}

// Get returns a Standard entity by its id.
func (c *StandardClient) Get(ctx context.Context, id string) (*Standard, error) {
	return c.Query().Where(standard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardClient) GetX(ctx context.Context, id string) *Standard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryControlobjectives queries the controlobjectives edge of a Standard.
func (c *StandardClient) QueryControlobjectives(s *Standard) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, standard.ControlobjectivesTable, standard.ControlobjectivesPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.StandardControlobjectives
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControls queries the controls edge of a Standard.
func (c *StandardClient) QueryControls(s *Standard) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, standard.ControlsTable, standard.ControlsPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.StandardControls
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedures queries the procedures edge of a Standard.
func (c *StandardClient) QueryProcedures(s *Standard) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, standard.ProceduresTable, standard.ProceduresColumn),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.Procedure
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionplans queries the actionplans edge of a Standard.
func (c *StandardClient) QueryActionplans(s *Standard) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, standard.ActionplansTable, standard.ActionplansPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.StandardActionplans
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Standard.
func (c *StandardClient) QueryPrograms(s *Standard) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standard.Table, standard.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, standard.ProgramsTable, standard.ProgramsPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.StandardPrograms
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandardClient) Hooks() []Hook {
	hooks := c.hooks.Standard
	return append(hooks[:len(hooks):len(hooks)], standard.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StandardClient) Interceptors() []Interceptor {
	inters := c.inters.Standard
	return append(inters[:len(inters):len(inters)], standard.Interceptors[:]...)
}

func (c *StandardClient) mutate(ctx context.Context, m *StandardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Standard mutation op: %q", m.Op())
	}
}

// StandardHistoryClient is a client for the StandardHistory schema.
type StandardHistoryClient struct {
	config
}

// NewStandardHistoryClient returns a client for the StandardHistory from the given config.
func NewStandardHistoryClient(c config) *StandardHistoryClient {
	return &StandardHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standardhistory.Hooks(f(g(h())))`.
func (c *StandardHistoryClient) Use(hooks ...Hook) {
	c.hooks.StandardHistory = append(c.hooks.StandardHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standardhistory.Intercept(f(g(h())))`.
func (c *StandardHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.StandardHistory = append(c.inters.StandardHistory, interceptors...)
}

// Create returns a builder for creating a StandardHistory entity.
func (c *StandardHistoryClient) Create() *StandardHistoryCreate {
	mutation := newStandardHistoryMutation(c.config, OpCreate)
	return &StandardHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StandardHistory entities.
func (c *StandardHistoryClient) CreateBulk(builders ...*StandardHistoryCreate) *StandardHistoryCreateBulk {
	return &StandardHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandardHistoryClient) MapCreateBulk(slice any, setFunc func(*StandardHistoryCreate, int)) *StandardHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandardHistoryCreateBulk{err: fmt.Errorf("calling to StandardHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandardHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandardHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StandardHistory.
func (c *StandardHistoryClient) Update() *StandardHistoryUpdate {
	mutation := newStandardHistoryMutation(c.config, OpUpdate)
	return &StandardHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandardHistoryClient) UpdateOne(sh *StandardHistory) *StandardHistoryUpdateOne {
	mutation := newStandardHistoryMutation(c.config, OpUpdateOne, withStandardHistory(sh))
	return &StandardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandardHistoryClient) UpdateOneID(id string) *StandardHistoryUpdateOne {
	mutation := newStandardHistoryMutation(c.config, OpUpdateOne, withStandardHistoryID(id))
	return &StandardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StandardHistory.
func (c *StandardHistoryClient) Delete() *StandardHistoryDelete {
	mutation := newStandardHistoryMutation(c.config, OpDelete)
	return &StandardHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandardHistoryClient) DeleteOne(sh *StandardHistory) *StandardHistoryDeleteOne {
	return c.DeleteOneID(sh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandardHistoryClient) DeleteOneID(id string) *StandardHistoryDeleteOne {
	builder := c.Delete().Where(standardhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandardHistoryDeleteOne{builder}
}

// Query returns a query builder for StandardHistory.
func (c *StandardHistoryClient) Query() *StandardHistoryQuery {
	return &StandardHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandardHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a StandardHistory entity by its id.
func (c *StandardHistoryClient) Get(ctx context.Context, id string) (*StandardHistory, error) {
	return c.Query().Where(standardhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandardHistoryClient) GetX(ctx context.Context, id string) *StandardHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StandardHistoryClient) Hooks() []Hook {
	return c.hooks.StandardHistory
}

// Interceptors returns the client interceptors.
func (c *StandardHistoryClient) Interceptors() []Interceptor {
	return c.inters.StandardHistory
}

func (c *StandardHistoryClient) mutate(ctx context.Context, m *StandardHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandardHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandardHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandardHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandardHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown StandardHistory mutation op: %q", m.Op())
	}
}

// SubcontrolClient is a client for the Subcontrol schema.
type SubcontrolClient struct {
	config
}

// NewSubcontrolClient returns a client for the Subcontrol from the given config.
func NewSubcontrolClient(c config) *SubcontrolClient {
	return &SubcontrolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subcontrol.Hooks(f(g(h())))`.
func (c *SubcontrolClient) Use(hooks ...Hook) {
	c.hooks.Subcontrol = append(c.hooks.Subcontrol, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subcontrol.Intercept(f(g(h())))`.
func (c *SubcontrolClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subcontrol = append(c.inters.Subcontrol, interceptors...)
}

// Create returns a builder for creating a Subcontrol entity.
func (c *SubcontrolClient) Create() *SubcontrolCreate {
	mutation := newSubcontrolMutation(c.config, OpCreate)
	return &SubcontrolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subcontrol entities.
func (c *SubcontrolClient) CreateBulk(builders ...*SubcontrolCreate) *SubcontrolCreateBulk {
	return &SubcontrolCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubcontrolClient) MapCreateBulk(slice any, setFunc func(*SubcontrolCreate, int)) *SubcontrolCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubcontrolCreateBulk{err: fmt.Errorf("calling to SubcontrolClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubcontrolCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubcontrolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subcontrol.
func (c *SubcontrolClient) Update() *SubcontrolUpdate {
	mutation := newSubcontrolMutation(c.config, OpUpdate)
	return &SubcontrolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubcontrolClient) UpdateOne(s *Subcontrol) *SubcontrolUpdateOne {
	mutation := newSubcontrolMutation(c.config, OpUpdateOne, withSubcontrol(s))
	return &SubcontrolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubcontrolClient) UpdateOneID(id string) *SubcontrolUpdateOne {
	mutation := newSubcontrolMutation(c.config, OpUpdateOne, withSubcontrolID(id))
	return &SubcontrolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subcontrol.
func (c *SubcontrolClient) Delete() *SubcontrolDelete {
	mutation := newSubcontrolMutation(c.config, OpDelete)
	return &SubcontrolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubcontrolClient) DeleteOne(s *Subcontrol) *SubcontrolDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubcontrolClient) DeleteOneID(id string) *SubcontrolDeleteOne {
	builder := c.Delete().Where(subcontrol.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubcontrolDeleteOne{builder}
}

// Query returns a query builder for Subcontrol.
func (c *SubcontrolClient) Query() *SubcontrolQuery {
	return &SubcontrolQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubcontrol},
		inters: c.Interceptors(),
	}
}

// Get returns a Subcontrol entity by its id.
func (c *SubcontrolClient) Get(ctx context.Context, id string) (*Subcontrol, error) {
	return c.Query().Where(subcontrol.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubcontrolClient) GetX(ctx context.Context, id string) *Subcontrol {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryControl queries the control edge of a Subcontrol.
func (c *SubcontrolClient) QueryControl(s *Subcontrol) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.ControlTable, subcontrol.ControlPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlSubcontrols
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Subcontrol.
func (c *SubcontrolClient) QueryUser(s *Subcontrol) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.UserTable, subcontrol.UserPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserSubcontrols
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Subcontrol.
func (c *SubcontrolClient) QueryTasks(s *Subcontrol) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subcontrol.TasksTable, subcontrol.TasksPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.SubcontrolTasks
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a Subcontrol.
func (c *SubcontrolClient) QueryNotes(s *Subcontrol) *NoteQuery {
	query := (&NoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(note.Table, note.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subcontrol.NotesTable, subcontrol.NotesColumn),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Note
		step.Edge.Schema = schemaConfig.Subcontrol
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a Subcontrol.
func (c *SubcontrolClient) QueryPrograms(s *Subcontrol) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subcontrol.Table, subcontrol.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, subcontrol.ProgramsTable, subcontrol.ProgramsPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramSubcontrols
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubcontrolClient) Hooks() []Hook {
	hooks := c.hooks.Subcontrol
	return append(hooks[:len(hooks):len(hooks)], subcontrol.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubcontrolClient) Interceptors() []Interceptor {
	inters := c.inters.Subcontrol
	return append(inters[:len(inters):len(inters)], subcontrol.Interceptors[:]...)
}

func (c *SubcontrolClient) mutate(ctx context.Context, m *SubcontrolMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubcontrolCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubcontrolUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubcontrolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubcontrolDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subcontrol mutation op: %q", m.Op())
	}
}

// SubcontrolHistoryClient is a client for the SubcontrolHistory schema.
type SubcontrolHistoryClient struct {
	config
}

// NewSubcontrolHistoryClient returns a client for the SubcontrolHistory from the given config.
func NewSubcontrolHistoryClient(c config) *SubcontrolHistoryClient {
	return &SubcontrolHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subcontrolhistory.Hooks(f(g(h())))`.
func (c *SubcontrolHistoryClient) Use(hooks ...Hook) {
	c.hooks.SubcontrolHistory = append(c.hooks.SubcontrolHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subcontrolhistory.Intercept(f(g(h())))`.
func (c *SubcontrolHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubcontrolHistory = append(c.inters.SubcontrolHistory, interceptors...)
}

// Create returns a builder for creating a SubcontrolHistory entity.
func (c *SubcontrolHistoryClient) Create() *SubcontrolHistoryCreate {
	mutation := newSubcontrolHistoryMutation(c.config, OpCreate)
	return &SubcontrolHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubcontrolHistory entities.
func (c *SubcontrolHistoryClient) CreateBulk(builders ...*SubcontrolHistoryCreate) *SubcontrolHistoryCreateBulk {
	return &SubcontrolHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubcontrolHistoryClient) MapCreateBulk(slice any, setFunc func(*SubcontrolHistoryCreate, int)) *SubcontrolHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubcontrolHistoryCreateBulk{err: fmt.Errorf("calling to SubcontrolHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubcontrolHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubcontrolHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubcontrolHistory.
func (c *SubcontrolHistoryClient) Update() *SubcontrolHistoryUpdate {
	mutation := newSubcontrolHistoryMutation(c.config, OpUpdate)
	return &SubcontrolHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubcontrolHistoryClient) UpdateOne(sh *SubcontrolHistory) *SubcontrolHistoryUpdateOne {
	mutation := newSubcontrolHistoryMutation(c.config, OpUpdateOne, withSubcontrolHistory(sh))
	return &SubcontrolHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubcontrolHistoryClient) UpdateOneID(id string) *SubcontrolHistoryUpdateOne {
	mutation := newSubcontrolHistoryMutation(c.config, OpUpdateOne, withSubcontrolHistoryID(id))
	return &SubcontrolHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubcontrolHistory.
func (c *SubcontrolHistoryClient) Delete() *SubcontrolHistoryDelete {
	mutation := newSubcontrolHistoryMutation(c.config, OpDelete)
	return &SubcontrolHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubcontrolHistoryClient) DeleteOne(sh *SubcontrolHistory) *SubcontrolHistoryDeleteOne {
	return c.DeleteOneID(sh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubcontrolHistoryClient) DeleteOneID(id string) *SubcontrolHistoryDeleteOne {
	builder := c.Delete().Where(subcontrolhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubcontrolHistoryDeleteOne{builder}
}

// Query returns a query builder for SubcontrolHistory.
func (c *SubcontrolHistoryClient) Query() *SubcontrolHistoryQuery {
	return &SubcontrolHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubcontrolHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a SubcontrolHistory entity by its id.
func (c *SubcontrolHistoryClient) Get(ctx context.Context, id string) (*SubcontrolHistory, error) {
	return c.Query().Where(subcontrolhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubcontrolHistoryClient) GetX(ctx context.Context, id string) *SubcontrolHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubcontrolHistoryClient) Hooks() []Hook {
	return c.hooks.SubcontrolHistory
}

// Interceptors returns the client interceptors.
func (c *SubcontrolHistoryClient) Interceptors() []Interceptor {
	return c.inters.SubcontrolHistory
}

func (c *SubcontrolHistoryClient) mutate(ctx context.Context, m *SubcontrolHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubcontrolHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubcontrolHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubcontrolHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubcontrolHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown SubcontrolHistory mutation op: %q", m.Op())
	}
}

// SubscriberClient is a client for the Subscriber schema.
type SubscriberClient struct {
	config
}

// NewSubscriberClient returns a client for the Subscriber from the given config.
func NewSubscriberClient(c config) *SubscriberClient {
	return &SubscriberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscriber.Hooks(f(g(h())))`.
func (c *SubscriberClient) Use(hooks ...Hook) {
	c.hooks.Subscriber = append(c.hooks.Subscriber, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscriber.Intercept(f(g(h())))`.
func (c *SubscriberClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscriber = append(c.inters.Subscriber, interceptors...)
}

// Create returns a builder for creating a Subscriber entity.
func (c *SubscriberClient) Create() *SubscriberCreate {
	mutation := newSubscriberMutation(c.config, OpCreate)
	return &SubscriberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscriber entities.
func (c *SubscriberClient) CreateBulk(builders ...*SubscriberCreate) *SubscriberCreateBulk {
	return &SubscriberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriberClient) MapCreateBulk(slice any, setFunc func(*SubscriberCreate, int)) *SubscriberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriberCreateBulk{err: fmt.Errorf("calling to SubscriberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscriber.
func (c *SubscriberClient) Update() *SubscriberUpdate {
	mutation := newSubscriberMutation(c.config, OpUpdate)
	return &SubscriberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriberClient) UpdateOne(s *Subscriber) *SubscriberUpdateOne {
	mutation := newSubscriberMutation(c.config, OpUpdateOne, withSubscriber(s))
	return &SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriberClient) UpdateOneID(id string) *SubscriberUpdateOne {
	mutation := newSubscriberMutation(c.config, OpUpdateOne, withSubscriberID(id))
	return &SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscriber.
func (c *SubscriberClient) Delete() *SubscriberDelete {
	mutation := newSubscriberMutation(c.config, OpDelete)
	return &SubscriberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriberClient) DeleteOne(s *Subscriber) *SubscriberDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriberClient) DeleteOneID(id string) *SubscriberDeleteOne {
	builder := c.Delete().Where(subscriber.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriberDeleteOne{builder}
}

// Query returns a query builder for Subscriber.
func (c *SubscriberClient) Query() *SubscriberQuery {
	return &SubscriberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscriber},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscriber entity by its id.
func (c *SubscriberClient) Get(ctx context.Context, id string) (*Subscriber, error) {
	return c.Query().Where(subscriber.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriberClient) GetX(ctx context.Context, id string) *Subscriber {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Subscriber.
func (c *SubscriberClient) QueryOwner(s *Subscriber) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscriber.Table, subscriber.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscriber.OwnerTable, subscriber.OwnerColumn),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Subscriber
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Subscriber.
func (c *SubscriberClient) QueryEvents(s *Subscriber) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscriber.Table, subscriber.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, subscriber.EventsTable, subscriber.EventsPrimaryKey...),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.SubscriberEvents
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriberClient) Hooks() []Hook {
	hooks := c.hooks.Subscriber
	return append(hooks[:len(hooks):len(hooks)], subscriber.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SubscriberClient) Interceptors() []Interceptor {
	inters := c.inters.Subscriber
	return append(inters[:len(inters):len(inters)], subscriber.Interceptors[:]...)
}

func (c *SubscriberClient) mutate(ctx context.Context, m *SubscriberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Subscriber mutation op: %q", m.Op())
	}
}

// TFASettingClient is a client for the TFASetting schema.
type TFASettingClient struct {
	config
}

// NewTFASettingClient returns a client for the TFASetting from the given config.
func NewTFASettingClient(c config) *TFASettingClient {
	return &TFASettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tfasetting.Hooks(f(g(h())))`.
func (c *TFASettingClient) Use(hooks ...Hook) {
	c.hooks.TFASetting = append(c.hooks.TFASetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tfasetting.Intercept(f(g(h())))`.
func (c *TFASettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.TFASetting = append(c.inters.TFASetting, interceptors...)
}

// Create returns a builder for creating a TFASetting entity.
func (c *TFASettingClient) Create() *TFASettingCreate {
	mutation := newTFASettingMutation(c.config, OpCreate)
	return &TFASettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TFASetting entities.
func (c *TFASettingClient) CreateBulk(builders ...*TFASettingCreate) *TFASettingCreateBulk {
	return &TFASettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TFASettingClient) MapCreateBulk(slice any, setFunc func(*TFASettingCreate, int)) *TFASettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TFASettingCreateBulk{err: fmt.Errorf("calling to TFASettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TFASettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TFASettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TFASetting.
func (c *TFASettingClient) Update() *TFASettingUpdate {
	mutation := newTFASettingMutation(c.config, OpUpdate)
	return &TFASettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TFASettingClient) UpdateOne(ts *TFASetting) *TFASettingUpdateOne {
	mutation := newTFASettingMutation(c.config, OpUpdateOne, withTFASetting(ts))
	return &TFASettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TFASettingClient) UpdateOneID(id string) *TFASettingUpdateOne {
	mutation := newTFASettingMutation(c.config, OpUpdateOne, withTFASettingID(id))
	return &TFASettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TFASetting.
func (c *TFASettingClient) Delete() *TFASettingDelete {
	mutation := newTFASettingMutation(c.config, OpDelete)
	return &TFASettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TFASettingClient) DeleteOne(ts *TFASetting) *TFASettingDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TFASettingClient) DeleteOneID(id string) *TFASettingDeleteOne {
	builder := c.Delete().Where(tfasetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TFASettingDeleteOne{builder}
}

// Query returns a query builder for TFASetting.
func (c *TFASettingClient) Query() *TFASettingQuery {
	return &TFASettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTFASetting},
		inters: c.Interceptors(),
	}
}

// Get returns a TFASetting entity by its id.
func (c *TFASettingClient) Get(ctx context.Context, id string) (*TFASetting, error) {
	return c.Query().Where(tfasetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TFASettingClient) GetX(ctx context.Context, id string) *TFASetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a TFASetting.
func (c *TFASettingClient) QueryOwner(ts *TFASetting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tfasetting.Table, tfasetting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tfasetting.OwnerTable, tfasetting.OwnerColumn),
		)
		schemaConfig := ts.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.TFASetting
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TFASettingClient) Hooks() []Hook {
	hooks := c.hooks.TFASetting
	return append(hooks[:len(hooks):len(hooks)], tfasetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TFASettingClient) Interceptors() []Interceptor {
	inters := c.inters.TFASetting
	return append(inters[:len(inters):len(inters)], tfasetting.Interceptors[:]...)
}

func (c *TFASettingClient) mutate(ctx context.Context, m *TFASettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TFASettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TFASettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TFASettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TFASettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TFASetting mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id string) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id string) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id string) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id string) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssigner queries the assigner edge of a Task.
func (c *TaskClient) QueryAssigner(t *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AssignerTable, task.AssignerColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignee queries the assignee edge of a Task.
func (c *TaskClient) QueryAssignee(t *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.AssigneeTable, task.AssigneeColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Task.
func (c *TaskClient) QueryOrganization(t *Task) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.OrganizationTable, task.OrganizationPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrganizationTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a Task.
func (c *TaskClient) QueryGroup(t *Task) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.GroupTable, task.GroupPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPolicy queries the policy edge of a Task.
func (c *TaskClient) QueryPolicy(t *Task) *InternalPolicyQuery {
	query := (&InternalPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(internalpolicy.Table, internalpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.PolicyTable, task.PolicyPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.InternalPolicy
		step.Edge.Schema = schemaConfig.InternalPolicyTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcedure queries the procedure edge of a Task.
func (c *TaskClient) QueryProcedure(t *Task) *ProcedureQuery {
	query := (&ProcedureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(procedure.Table, procedure.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ProcedureTable, task.ProcedurePrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Procedure
		step.Edge.Schema = schemaConfig.ProcedureTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControl queries the control edge of a Task.
func (c *TaskClient) QueryControl(t *Task) *ControlQuery {
	query := (&ControlClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(control.Table, control.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ControlTable, task.ControlPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Control
		step.Edge.Schema = schemaConfig.ControlTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryControlObjective queries the control_objective edge of a Task.
func (c *TaskClient) QueryControlObjective(t *Task) *ControlObjectiveQuery {
	query := (&ControlObjectiveClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(controlobjective.Table, controlobjective.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ControlObjectiveTable, task.ControlObjectivePrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.ControlObjective
		step.Edge.Schema = schemaConfig.ControlObjectiveTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrol queries the subcontrol edge of a Task.
func (c *TaskClient) QuerySubcontrol(t *Task) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.SubcontrolTable, task.SubcontrolPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.SubcontrolTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a Task.
func (c *TaskClient) QueryProgram(t *Task) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.ProgramTable, task.ProgramPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramTasks
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	hooks := c.hooks.Task
	return append(hooks[:len(hooks):len(hooks)], task.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	inters := c.inters.Task
	return append(inters[:len(inters):len(inters)], task.Interceptors[:]...)
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Task mutation op: %q", m.Op())
	}
}

// TaskHistoryClient is a client for the TaskHistory schema.
type TaskHistoryClient struct {
	config
}

// NewTaskHistoryClient returns a client for the TaskHistory from the given config.
func NewTaskHistoryClient(c config) *TaskHistoryClient {
	return &TaskHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskhistory.Hooks(f(g(h())))`.
func (c *TaskHistoryClient) Use(hooks ...Hook) {
	c.hooks.TaskHistory = append(c.hooks.TaskHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskhistory.Intercept(f(g(h())))`.
func (c *TaskHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskHistory = append(c.inters.TaskHistory, interceptors...)
}

// Create returns a builder for creating a TaskHistory entity.
func (c *TaskHistoryClient) Create() *TaskHistoryCreate {
	mutation := newTaskHistoryMutation(c.config, OpCreate)
	return &TaskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskHistory entities.
func (c *TaskHistoryClient) CreateBulk(builders ...*TaskHistoryCreate) *TaskHistoryCreateBulk {
	return &TaskHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskHistoryClient) MapCreateBulk(slice any, setFunc func(*TaskHistoryCreate, int)) *TaskHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskHistoryCreateBulk{err: fmt.Errorf("calling to TaskHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskHistory.
func (c *TaskHistoryClient) Update() *TaskHistoryUpdate {
	mutation := newTaskHistoryMutation(c.config, OpUpdate)
	return &TaskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskHistoryClient) UpdateOne(th *TaskHistory) *TaskHistoryUpdateOne {
	mutation := newTaskHistoryMutation(c.config, OpUpdateOne, withTaskHistory(th))
	return &TaskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskHistoryClient) UpdateOneID(id string) *TaskHistoryUpdateOne {
	mutation := newTaskHistoryMutation(c.config, OpUpdateOne, withTaskHistoryID(id))
	return &TaskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskHistory.
func (c *TaskHistoryClient) Delete() *TaskHistoryDelete {
	mutation := newTaskHistoryMutation(c.config, OpDelete)
	return &TaskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskHistoryClient) DeleteOne(th *TaskHistory) *TaskHistoryDeleteOne {
	return c.DeleteOneID(th.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskHistoryClient) DeleteOneID(id string) *TaskHistoryDeleteOne {
	builder := c.Delete().Where(taskhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskHistoryDeleteOne{builder}
}

// Query returns a query builder for TaskHistory.
func (c *TaskHistoryClient) Query() *TaskHistoryQuery {
	return &TaskHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskHistory entity by its id.
func (c *TaskHistoryClient) Get(ctx context.Context, id string) (*TaskHistory, error) {
	return c.Query().Where(taskhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskHistoryClient) GetX(ctx context.Context, id string) *TaskHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TaskHistory
	return append(hooks[:len(hooks):len(hooks)], taskhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TaskHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TaskHistory
	return append(inters[:len(inters):len(inters)], taskhistory.Interceptors[:]...)
}

func (c *TaskHistoryClient) mutate(ctx context.Context, m *TaskHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TaskHistory mutation op: %q", m.Op())
	}
}

// TemplateClient is a client for the Template schema.
type TemplateClient struct {
	config
}

// NewTemplateClient returns a client for the Template from the given config.
func NewTemplateClient(c config) *TemplateClient {
	return &TemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `template.Hooks(f(g(h())))`.
func (c *TemplateClient) Use(hooks ...Hook) {
	c.hooks.Template = append(c.hooks.Template, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `template.Intercept(f(g(h())))`.
func (c *TemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Template = append(c.inters.Template, interceptors...)
}

// Create returns a builder for creating a Template entity.
func (c *TemplateClient) Create() *TemplateCreate {
	mutation := newTemplateMutation(c.config, OpCreate)
	return &TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Template entities.
func (c *TemplateClient) CreateBulk(builders ...*TemplateCreate) *TemplateCreateBulk {
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateClient) MapCreateBulk(slice any, setFunc func(*TemplateCreate, int)) *TemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateCreateBulk{err: fmt.Errorf("calling to TemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Template.
func (c *TemplateClient) Update() *TemplateUpdate {
	mutation := newTemplateMutation(c.config, OpUpdate)
	return &TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateClient) UpdateOne(t *Template) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplate(t))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateClient) UpdateOneID(id string) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplateID(id))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Template.
func (c *TemplateClient) Delete() *TemplateDelete {
	mutation := newTemplateMutation(c.config, OpDelete)
	return &TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateClient) DeleteOne(t *Template) *TemplateDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateClient) DeleteOneID(id string) *TemplateDeleteOne {
	builder := c.Delete().Where(template.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateDeleteOne{builder}
}

// Query returns a query builder for Template.
func (c *TemplateClient) Query() *TemplateQuery {
	return &TemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a Template entity by its id.
func (c *TemplateClient) Get(ctx context.Context, id string) (*Template, error) {
	return c.Query().Where(template.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateClient) GetX(ctx context.Context, id string) *Template {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Template.
func (c *TemplateClient) QueryOwner(t *Template) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, template.OwnerTable, template.OwnerColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Template
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Template.
func (c *TemplateClient) QueryDocuments(t *Template) *DocumentDataQuery {
	query := (&DocumentDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(documentdata.Table, documentdata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, template.DocumentsTable, template.DocumentsColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.DocumentData
		step.Edge.Schema = schemaConfig.DocumentData
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Template.
func (c *TemplateClient) QueryFiles(t *Template) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(template.Table, template.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, template.FilesTable, template.FilesPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.TemplateFiles
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TemplateClient) Hooks() []Hook {
	hooks := c.hooks.Template
	return append(hooks[:len(hooks):len(hooks)], template.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TemplateClient) Interceptors() []Interceptor {
	inters := c.inters.Template
	return append(inters[:len(inters):len(inters)], template.Interceptors[:]...)
}

func (c *TemplateClient) mutate(ctx context.Context, m *TemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Template mutation op: %q", m.Op())
	}
}

// TemplateHistoryClient is a client for the TemplateHistory schema.
type TemplateHistoryClient struct {
	config
}

// NewTemplateHistoryClient returns a client for the TemplateHistory from the given config.
func NewTemplateHistoryClient(c config) *TemplateHistoryClient {
	return &TemplateHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `templatehistory.Hooks(f(g(h())))`.
func (c *TemplateHistoryClient) Use(hooks ...Hook) {
	c.hooks.TemplateHistory = append(c.hooks.TemplateHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `templatehistory.Intercept(f(g(h())))`.
func (c *TemplateHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TemplateHistory = append(c.inters.TemplateHistory, interceptors...)
}

// Create returns a builder for creating a TemplateHistory entity.
func (c *TemplateHistoryClient) Create() *TemplateHistoryCreate {
	mutation := newTemplateHistoryMutation(c.config, OpCreate)
	return &TemplateHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TemplateHistory entities.
func (c *TemplateHistoryClient) CreateBulk(builders ...*TemplateHistoryCreate) *TemplateHistoryCreateBulk {
	return &TemplateHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateHistoryClient) MapCreateBulk(slice any, setFunc func(*TemplateHistoryCreate, int)) *TemplateHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateHistoryCreateBulk{err: fmt.Errorf("calling to TemplateHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TemplateHistory.
func (c *TemplateHistoryClient) Update() *TemplateHistoryUpdate {
	mutation := newTemplateHistoryMutation(c.config, OpUpdate)
	return &TemplateHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateHistoryClient) UpdateOne(th *TemplateHistory) *TemplateHistoryUpdateOne {
	mutation := newTemplateHistoryMutation(c.config, OpUpdateOne, withTemplateHistory(th))
	return &TemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateHistoryClient) UpdateOneID(id string) *TemplateHistoryUpdateOne {
	mutation := newTemplateHistoryMutation(c.config, OpUpdateOne, withTemplateHistoryID(id))
	return &TemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TemplateHistory.
func (c *TemplateHistoryClient) Delete() *TemplateHistoryDelete {
	mutation := newTemplateHistoryMutation(c.config, OpDelete)
	return &TemplateHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateHistoryClient) DeleteOne(th *TemplateHistory) *TemplateHistoryDeleteOne {
	return c.DeleteOneID(th.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateHistoryClient) DeleteOneID(id string) *TemplateHistoryDeleteOne {
	builder := c.Delete().Where(templatehistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateHistoryDeleteOne{builder}
}

// Query returns a query builder for TemplateHistory.
func (c *TemplateHistoryClient) Query() *TemplateHistoryQuery {
	return &TemplateHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplateHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TemplateHistory entity by its id.
func (c *TemplateHistoryClient) Get(ctx context.Context, id string) (*TemplateHistory, error) {
	return c.Query().Where(templatehistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateHistoryClient) GetX(ctx context.Context, id string) *TemplateHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TemplateHistoryClient) Hooks() []Hook {
	hooks := c.hooks.TemplateHistory
	return append(hooks[:len(hooks):len(hooks)], templatehistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TemplateHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.TemplateHistory
	return append(inters[:len(inters):len(inters)], templatehistory.Interceptors[:]...)
}

func (c *TemplateHistoryClient) mutate(ctx context.Context, m *TemplateHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown TemplateHistory mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPersonalAccessTokens queries the personal_access_tokens edge of a User.
func (c *UserClient) QueryPersonalAccessTokens(u *User) *PersonalAccessTokenQuery {
	query := (&PersonalAccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(personalaccesstoken.Table, personalaccesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PersonalAccessTokensTable, user.PersonalAccessTokensColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.PersonalAccessToken
		step.Edge.Schema = schemaConfig.PersonalAccessToken
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTfaSettings queries the tfa_settings edge of a User.
func (c *UserClient) QueryTfaSettings(u *User) *TFASettingQuery {
	query := (&TFASettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tfasetting.Table, tfasetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TfaSettingsTable, user.TfaSettingsColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.TFASetting
		step.Edge.Schema = schemaConfig.TFASetting
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a User.
func (c *UserClient) QuerySetting(u *User) *UserSettingQuery {
	query := (&UserSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersetting.Table, usersetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.SettingTable, user.SettingColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.UserSetting
		step.Edge.Schema = schemaConfig.UserSetting
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailVerificationTokens queries the email_verification_tokens edge of a User.
func (c *UserClient) QueryEmailVerificationTokens(u *User) *EmailVerificationTokenQuery {
	query := (&EmailVerificationTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(emailverificationtoken.Table, emailverificationtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EmailVerificationTokensTable, user.EmailVerificationTokensColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.EmailVerificationToken
		step.Edge.Schema = schemaConfig.EmailVerificationToken
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPasswordResetTokens queries the password_reset_tokens edge of a User.
func (c *UserClient) QueryPasswordResetTokens(u *User) *PasswordResetTokenQuery {
	query := (&PasswordResetTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(passwordresettoken.Table, passwordresettoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PasswordResetTokensTable, user.PasswordResetTokensColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.PasswordResetToken
		step.Edge.Schema = schemaConfig.PasswordResetToken
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(u *User) *GroupQuery {
	query := (&GroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Group
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a User.
func (c *UserClient) QueryOrganizations(u *User) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.OrganizationsTable, user.OrganizationsPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebauthn queries the webauthn edge of a User.
func (c *UserClient) QueryWebauthn(u *User) *WebauthnQuery {
	query := (&WebauthnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(webauthn.Table, webauthn.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WebauthnTable, user.WebauthnColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Webauthn
		step.Edge.Schema = schemaConfig.Webauthn
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a User.
func (c *UserClient) QueryFiles(u *User) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.FilesTable, user.FilesPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.UserFiles
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFile queries the file edge of a User.
func (c *UserClient) QueryFile(u *User) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.FileTable, user.FileColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.User
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a User.
func (c *UserClient) QueryEvents(u *User) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.EventsTable, user.EventsPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.UserEvents
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionplans queries the actionplans edge of a User.
func (c *UserClient) QueryActionplans(u *User) *ActionPlanQuery {
	query := (&ActionPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(actionplan.Table, actionplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.ActionplansTable, user.ActionplansPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.ActionPlan
		step.Edge.Schema = schemaConfig.UserActionplans
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubcontrols queries the subcontrols edge of a User.
func (c *UserClient) QuerySubcontrols(u *User) *SubcontrolQuery {
	query := (&SubcontrolClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subcontrol.Table, subcontrol.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.SubcontrolsTable, user.SubcontrolsPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Subcontrol
		step.Edge.Schema = schemaConfig.UserSubcontrols
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignerTasks queries the assigner_tasks edge of a User.
func (c *UserClient) QueryAssignerTasks(u *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignerTasksTable, user.AssignerTasksColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssigneeTasks queries the assignee_tasks edge of a User.
func (c *UserClient) QueryAssigneeTasks(u *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssigneeTasksTable, user.AssigneeTasksColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Task
		step.Edge.Schema = schemaConfig.Task
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrograms queries the programs edge of a User.
func (c *UserClient) QueryPrograms(u *User) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.ProgramsTable, user.ProgramsPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Program
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupMemberships queries the group_memberships edge of a User.
func (c *UserClient) QueryGroupMemberships(u *User) *GroupMembershipQuery {
	query := (&GroupMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(groupmembership.Table, groupmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.GroupMembershipsTable, user.GroupMembershipsColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.GroupMembership
		step.Edge.Schema = schemaConfig.GroupMembership
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrgMemberships queries the org_memberships edge of a User.
func (c *UserClient) QueryOrgMemberships(u *User) *OrgMembershipQuery {
	query := (&OrgMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(orgmembership.Table, orgmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OrgMembershipsTable, user.OrgMembershipsColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.OrgMembership
		step.Edge.Schema = schemaConfig.OrgMembership
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramMemberships queries the program_memberships edge of a User.
func (c *UserClient) QueryProgramMemberships(u *User) *ProgramMembershipQuery {
	query := (&ProgramMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(programmembership.Table, programmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ProgramMembershipsTable, user.ProgramMembershipsColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.ProgramMembership
		step.Edge.Schema = schemaConfig.ProgramMembership
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown User mutation op: %q", m.Op())
	}
}

// UserHistoryClient is a client for the UserHistory schema.
type UserHistoryClient struct {
	config
}

// NewUserHistoryClient returns a client for the UserHistory from the given config.
func NewUserHistoryClient(c config) *UserHistoryClient {
	return &UserHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userhistory.Hooks(f(g(h())))`.
func (c *UserHistoryClient) Use(hooks ...Hook) {
	c.hooks.UserHistory = append(c.hooks.UserHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userhistory.Intercept(f(g(h())))`.
func (c *UserHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserHistory = append(c.inters.UserHistory, interceptors...)
}

// Create returns a builder for creating a UserHistory entity.
func (c *UserHistoryClient) Create() *UserHistoryCreate {
	mutation := newUserHistoryMutation(c.config, OpCreate)
	return &UserHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserHistory entities.
func (c *UserHistoryClient) CreateBulk(builders ...*UserHistoryCreate) *UserHistoryCreateBulk {
	return &UserHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserHistoryClient) MapCreateBulk(slice any, setFunc func(*UserHistoryCreate, int)) *UserHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserHistoryCreateBulk{err: fmt.Errorf("calling to UserHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserHistory.
func (c *UserHistoryClient) Update() *UserHistoryUpdate {
	mutation := newUserHistoryMutation(c.config, OpUpdate)
	return &UserHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserHistoryClient) UpdateOne(uh *UserHistory) *UserHistoryUpdateOne {
	mutation := newUserHistoryMutation(c.config, OpUpdateOne, withUserHistory(uh))
	return &UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserHistoryClient) UpdateOneID(id string) *UserHistoryUpdateOne {
	mutation := newUserHistoryMutation(c.config, OpUpdateOne, withUserHistoryID(id))
	return &UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserHistory.
func (c *UserHistoryClient) Delete() *UserHistoryDelete {
	mutation := newUserHistoryMutation(c.config, OpDelete)
	return &UserHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserHistoryClient) DeleteOne(uh *UserHistory) *UserHistoryDeleteOne {
	return c.DeleteOneID(uh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserHistoryClient) DeleteOneID(id string) *UserHistoryDeleteOne {
	builder := c.Delete().Where(userhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserHistoryDeleteOne{builder}
}

// Query returns a query builder for UserHistory.
func (c *UserHistoryClient) Query() *UserHistoryQuery {
	return &UserHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a UserHistory entity by its id.
func (c *UserHistoryClient) Get(ctx context.Context, id string) (*UserHistory, error) {
	return c.Query().Where(userhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserHistoryClient) GetX(ctx context.Context, id string) *UserHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserHistoryClient) Hooks() []Hook {
	return c.hooks.UserHistory
}

// Interceptors returns the client interceptors.
func (c *UserHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.UserHistory
	return append(inters[:len(inters):len(inters)], userhistory.Interceptors[:]...)
}

func (c *UserHistoryClient) mutate(ctx context.Context, m *UserHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserHistory mutation op: %q", m.Op())
	}
}

// UserSettingClient is a client for the UserSetting schema.
type UserSettingClient struct {
	config
}

// NewUserSettingClient returns a client for the UserSetting from the given config.
func NewUserSettingClient(c config) *UserSettingClient {
	return &UserSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersetting.Hooks(f(g(h())))`.
func (c *UserSettingClient) Use(hooks ...Hook) {
	c.hooks.UserSetting = append(c.hooks.UserSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersetting.Intercept(f(g(h())))`.
func (c *UserSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSetting = append(c.inters.UserSetting, interceptors...)
}

// Create returns a builder for creating a UserSetting entity.
func (c *UserSettingClient) Create() *UserSettingCreate {
	mutation := newUserSettingMutation(c.config, OpCreate)
	return &UserSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSetting entities.
func (c *UserSettingClient) CreateBulk(builders ...*UserSettingCreate) *UserSettingCreateBulk {
	return &UserSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSettingClient) MapCreateBulk(slice any, setFunc func(*UserSettingCreate, int)) *UserSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSettingCreateBulk{err: fmt.Errorf("calling to UserSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSetting.
func (c *UserSettingClient) Update() *UserSettingUpdate {
	mutation := newUserSettingMutation(c.config, OpUpdate)
	return &UserSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSettingClient) UpdateOne(us *UserSetting) *UserSettingUpdateOne {
	mutation := newUserSettingMutation(c.config, OpUpdateOne, withUserSetting(us))
	return &UserSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSettingClient) UpdateOneID(id string) *UserSettingUpdateOne {
	mutation := newUserSettingMutation(c.config, OpUpdateOne, withUserSettingID(id))
	return &UserSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSetting.
func (c *UserSettingClient) Delete() *UserSettingDelete {
	mutation := newUserSettingMutation(c.config, OpDelete)
	return &UserSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSettingClient) DeleteOne(us *UserSetting) *UserSettingDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSettingClient) DeleteOneID(id string) *UserSettingDeleteOne {
	builder := c.Delete().Where(usersetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSettingDeleteOne{builder}
}

// Query returns a query builder for UserSetting.
func (c *UserSettingClient) Query() *UserSettingQuery {
	return &UserSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSetting entity by its id.
func (c *UserSettingClient) Get(ctx context.Context, id string) (*UserSetting, error) {
	return c.Query().Where(usersetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSettingClient) GetX(ctx context.Context, id string) *UserSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSetting.
func (c *UserSettingClient) QueryUser(us *UserSetting) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersetting.Table, usersetting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, usersetting.UserTable, usersetting.UserColumn),
		)
		schemaConfig := us.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UserSetting
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDefaultOrg queries the default_org edge of a UserSetting.
func (c *UserSettingClient) QueryDefaultOrg(us *UserSetting) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersetting.Table, usersetting.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usersetting.DefaultOrgTable, usersetting.DefaultOrgColumn),
		)
		schemaConfig := us.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.UserSetting
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a UserSetting.
func (c *UserSettingClient) QueryFiles(us *UserSetting) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersetting.Table, usersetting.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, usersetting.FilesTable, usersetting.FilesPrimaryKey...),
		)
		schemaConfig := us.schemaConfig
		step.To.Schema = schemaConfig.File
		step.Edge.Schema = schemaConfig.UserSettingFiles
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSettingClient) Hooks() []Hook {
	hooks := c.hooks.UserSetting
	return append(hooks[:len(hooks):len(hooks)], usersetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserSettingClient) Interceptors() []Interceptor {
	inters := c.inters.UserSetting
	return append(inters[:len(inters):len(inters)], usersetting.Interceptors[:]...)
}

func (c *UserSettingClient) mutate(ctx context.Context, m *UserSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserSetting mutation op: %q", m.Op())
	}
}

// UserSettingHistoryClient is a client for the UserSettingHistory schema.
type UserSettingHistoryClient struct {
	config
}

// NewUserSettingHistoryClient returns a client for the UserSettingHistory from the given config.
func NewUserSettingHistoryClient(c config) *UserSettingHistoryClient {
	return &UserSettingHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersettinghistory.Hooks(f(g(h())))`.
func (c *UserSettingHistoryClient) Use(hooks ...Hook) {
	c.hooks.UserSettingHistory = append(c.hooks.UserSettingHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersettinghistory.Intercept(f(g(h())))`.
func (c *UserSettingHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSettingHistory = append(c.inters.UserSettingHistory, interceptors...)
}

// Create returns a builder for creating a UserSettingHistory entity.
func (c *UserSettingHistoryClient) Create() *UserSettingHistoryCreate {
	mutation := newUserSettingHistoryMutation(c.config, OpCreate)
	return &UserSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSettingHistory entities.
func (c *UserSettingHistoryClient) CreateBulk(builders ...*UserSettingHistoryCreate) *UserSettingHistoryCreateBulk {
	return &UserSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSettingHistoryClient) MapCreateBulk(slice any, setFunc func(*UserSettingHistoryCreate, int)) *UserSettingHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSettingHistoryCreateBulk{err: fmt.Errorf("calling to UserSettingHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSettingHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSettingHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSettingHistory.
func (c *UserSettingHistoryClient) Update() *UserSettingHistoryUpdate {
	mutation := newUserSettingHistoryMutation(c.config, OpUpdate)
	return &UserSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSettingHistoryClient) UpdateOne(ush *UserSettingHistory) *UserSettingHistoryUpdateOne {
	mutation := newUserSettingHistoryMutation(c.config, OpUpdateOne, withUserSettingHistory(ush))
	return &UserSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSettingHistoryClient) UpdateOneID(id string) *UserSettingHistoryUpdateOne {
	mutation := newUserSettingHistoryMutation(c.config, OpUpdateOne, withUserSettingHistoryID(id))
	return &UserSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSettingHistory.
func (c *UserSettingHistoryClient) Delete() *UserSettingHistoryDelete {
	mutation := newUserSettingHistoryMutation(c.config, OpDelete)
	return &UserSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSettingHistoryClient) DeleteOne(ush *UserSettingHistory) *UserSettingHistoryDeleteOne {
	return c.DeleteOneID(ush.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSettingHistoryClient) DeleteOneID(id string) *UserSettingHistoryDeleteOne {
	builder := c.Delete().Where(usersettinghistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSettingHistoryDeleteOne{builder}
}

// Query returns a query builder for UserSettingHistory.
func (c *UserSettingHistoryClient) Query() *UserSettingHistoryQuery {
	return &UserSettingHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSettingHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSettingHistory entity by its id.
func (c *UserSettingHistoryClient) Get(ctx context.Context, id string) (*UserSettingHistory, error) {
	return c.Query().Where(usersettinghistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSettingHistoryClient) GetX(ctx context.Context, id string) *UserSettingHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserSettingHistoryClient) Hooks() []Hook {
	return c.hooks.UserSettingHistory
}

// Interceptors returns the client interceptors.
func (c *UserSettingHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.UserSettingHistory
	return append(inters[:len(inters):len(inters)], usersettinghistory.Interceptors[:]...)
}

func (c *UserSettingHistoryClient) mutate(ctx context.Context, m *UserSettingHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSettingHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSettingHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSettingHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSettingHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserSettingHistory mutation op: %q", m.Op())
	}
}

// WebauthnClient is a client for the Webauthn schema.
type WebauthnClient struct {
	config
}

// NewWebauthnClient returns a client for the Webauthn from the given config.
func NewWebauthnClient(c config) *WebauthnClient {
	return &WebauthnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webauthn.Hooks(f(g(h())))`.
func (c *WebauthnClient) Use(hooks ...Hook) {
	c.hooks.Webauthn = append(c.hooks.Webauthn, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webauthn.Intercept(f(g(h())))`.
func (c *WebauthnClient) Intercept(interceptors ...Interceptor) {
	c.inters.Webauthn = append(c.inters.Webauthn, interceptors...)
}

// Create returns a builder for creating a Webauthn entity.
func (c *WebauthnClient) Create() *WebauthnCreate {
	mutation := newWebauthnMutation(c.config, OpCreate)
	return &WebauthnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Webauthn entities.
func (c *WebauthnClient) CreateBulk(builders ...*WebauthnCreate) *WebauthnCreateBulk {
	return &WebauthnCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebauthnClient) MapCreateBulk(slice any, setFunc func(*WebauthnCreate, int)) *WebauthnCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebauthnCreateBulk{err: fmt.Errorf("calling to WebauthnClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebauthnCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebauthnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Webauthn.
func (c *WebauthnClient) Update() *WebauthnUpdate {
	mutation := newWebauthnMutation(c.config, OpUpdate)
	return &WebauthnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebauthnClient) UpdateOne(w *Webauthn) *WebauthnUpdateOne {
	mutation := newWebauthnMutation(c.config, OpUpdateOne, withWebauthn(w))
	return &WebauthnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebauthnClient) UpdateOneID(id string) *WebauthnUpdateOne {
	mutation := newWebauthnMutation(c.config, OpUpdateOne, withWebauthnID(id))
	return &WebauthnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Webauthn.
func (c *WebauthnClient) Delete() *WebauthnDelete {
	mutation := newWebauthnMutation(c.config, OpDelete)
	return &WebauthnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebauthnClient) DeleteOne(w *Webauthn) *WebauthnDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebauthnClient) DeleteOneID(id string) *WebauthnDeleteOne {
	builder := c.Delete().Where(webauthn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebauthnDeleteOne{builder}
}

// Query returns a query builder for Webauthn.
func (c *WebauthnClient) Query() *WebauthnQuery {
	return &WebauthnQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebauthn},
		inters: c.Interceptors(),
	}
}

// Get returns a Webauthn entity by its id.
func (c *WebauthnClient) Get(ctx context.Context, id string) (*Webauthn, error) {
	return c.Query().Where(webauthn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebauthnClient) GetX(ctx context.Context, id string) *Webauthn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Webauthn.
func (c *WebauthnClient) QueryOwner(w *Webauthn) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webauthn.Table, webauthn.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, webauthn.OwnerTable, webauthn.OwnerColumn),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Webauthn
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WebauthnClient) Hooks() []Hook {
	hooks := c.hooks.Webauthn
	return append(hooks[:len(hooks):len(hooks)], webauthn.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WebauthnClient) Interceptors() []Interceptor {
	inters := c.inters.Webauthn
	return append(inters[:len(inters):len(inters)], webauthn.Interceptors[:]...)
}

func (c *WebauthnClient) mutate(ctx context.Context, m *WebauthnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebauthnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebauthnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebauthnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebauthnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Webauthn mutation op: %q", m.Op())
	}
}

// WebhookClient is a client for the Webhook schema.
type WebhookClient struct {
	config
}

// NewWebhookClient returns a client for the Webhook from the given config.
func NewWebhookClient(c config) *WebhookClient {
	return &WebhookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webhook.Hooks(f(g(h())))`.
func (c *WebhookClient) Use(hooks ...Hook) {
	c.hooks.Webhook = append(c.hooks.Webhook, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webhook.Intercept(f(g(h())))`.
func (c *WebhookClient) Intercept(interceptors ...Interceptor) {
	c.inters.Webhook = append(c.inters.Webhook, interceptors...)
}

// Create returns a builder for creating a Webhook entity.
func (c *WebhookClient) Create() *WebhookCreate {
	mutation := newWebhookMutation(c.config, OpCreate)
	return &WebhookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Webhook entities.
func (c *WebhookClient) CreateBulk(builders ...*WebhookCreate) *WebhookCreateBulk {
	return &WebhookCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebhookClient) MapCreateBulk(slice any, setFunc func(*WebhookCreate, int)) *WebhookCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebhookCreateBulk{err: fmt.Errorf("calling to WebhookClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebhookCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebhookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Webhook.
func (c *WebhookClient) Update() *WebhookUpdate {
	mutation := newWebhookMutation(c.config, OpUpdate)
	return &WebhookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebhookClient) UpdateOne(w *Webhook) *WebhookUpdateOne {
	mutation := newWebhookMutation(c.config, OpUpdateOne, withWebhook(w))
	return &WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebhookClient) UpdateOneID(id string) *WebhookUpdateOne {
	mutation := newWebhookMutation(c.config, OpUpdateOne, withWebhookID(id))
	return &WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Webhook.
func (c *WebhookClient) Delete() *WebhookDelete {
	mutation := newWebhookMutation(c.config, OpDelete)
	return &WebhookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebhookClient) DeleteOne(w *Webhook) *WebhookDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebhookClient) DeleteOneID(id string) *WebhookDeleteOne {
	builder := c.Delete().Where(webhook.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebhookDeleteOne{builder}
}

// Query returns a query builder for Webhook.
func (c *WebhookClient) Query() *WebhookQuery {
	return &WebhookQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebhook},
		inters: c.Interceptors(),
	}
}

// Get returns a Webhook entity by its id.
func (c *WebhookClient) Get(ctx context.Context, id string) (*Webhook, error) {
	return c.Query().Where(webhook.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebhookClient) GetX(ctx context.Context, id string) *Webhook {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Webhook.
func (c *WebhookClient) QueryOwner(w *Webhook) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webhook.Table, webhook.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, webhook.OwnerTable, webhook.OwnerColumn),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.Organization
		step.Edge.Schema = schemaConfig.Webhook
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Webhook.
func (c *WebhookClient) QueryEvents(w *Webhook) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webhook.Table, webhook.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, webhook.EventsTable, webhook.EventsPrimaryKey...),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.Event
		step.Edge.Schema = schemaConfig.WebhookEvents
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntegrations queries the integrations edge of a Webhook.
func (c *WebhookClient) QueryIntegrations(w *Webhook) *IntegrationQuery {
	query := (&IntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webhook.Table, webhook.FieldID, id),
			sqlgraph.To(integration.Table, integration.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, webhook.IntegrationsTable, webhook.IntegrationsPrimaryKey...),
		)
		schemaConfig := w.schemaConfig
		step.To.Schema = schemaConfig.Integration
		step.Edge.Schema = schemaConfig.IntegrationWebhooks
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WebhookClient) Hooks() []Hook {
	hooks := c.hooks.Webhook
	return append(hooks[:len(hooks):len(hooks)], webhook.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WebhookClient) Interceptors() []Interceptor {
	inters := c.inters.Webhook
	return append(inters[:len(inters):len(inters)], webhook.Interceptors[:]...)
}

func (c *WebhookClient) mutate(ctx context.Context, m *WebhookMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebhookCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebhookUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebhookDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Webhook mutation op: %q", m.Op())
	}
}

// WebhookHistoryClient is a client for the WebhookHistory schema.
type WebhookHistoryClient struct {
	config
}

// NewWebhookHistoryClient returns a client for the WebhookHistory from the given config.
func NewWebhookHistoryClient(c config) *WebhookHistoryClient {
	return &WebhookHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webhookhistory.Hooks(f(g(h())))`.
func (c *WebhookHistoryClient) Use(hooks ...Hook) {
	c.hooks.WebhookHistory = append(c.hooks.WebhookHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webhookhistory.Intercept(f(g(h())))`.
func (c *WebhookHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.WebhookHistory = append(c.inters.WebhookHistory, interceptors...)
}

// Create returns a builder for creating a WebhookHistory entity.
func (c *WebhookHistoryClient) Create() *WebhookHistoryCreate {
	mutation := newWebhookHistoryMutation(c.config, OpCreate)
	return &WebhookHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WebhookHistory entities.
func (c *WebhookHistoryClient) CreateBulk(builders ...*WebhookHistoryCreate) *WebhookHistoryCreateBulk {
	return &WebhookHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebhookHistoryClient) MapCreateBulk(slice any, setFunc func(*WebhookHistoryCreate, int)) *WebhookHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebhookHistoryCreateBulk{err: fmt.Errorf("calling to WebhookHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebhookHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebhookHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WebhookHistory.
func (c *WebhookHistoryClient) Update() *WebhookHistoryUpdate {
	mutation := newWebhookHistoryMutation(c.config, OpUpdate)
	return &WebhookHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebhookHistoryClient) UpdateOne(wh *WebhookHistory) *WebhookHistoryUpdateOne {
	mutation := newWebhookHistoryMutation(c.config, OpUpdateOne, withWebhookHistory(wh))
	return &WebhookHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebhookHistoryClient) UpdateOneID(id string) *WebhookHistoryUpdateOne {
	mutation := newWebhookHistoryMutation(c.config, OpUpdateOne, withWebhookHistoryID(id))
	return &WebhookHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WebhookHistory.
func (c *WebhookHistoryClient) Delete() *WebhookHistoryDelete {
	mutation := newWebhookHistoryMutation(c.config, OpDelete)
	return &WebhookHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebhookHistoryClient) DeleteOne(wh *WebhookHistory) *WebhookHistoryDeleteOne {
	return c.DeleteOneID(wh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebhookHistoryClient) DeleteOneID(id string) *WebhookHistoryDeleteOne {
	builder := c.Delete().Where(webhookhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebhookHistoryDeleteOne{builder}
}

// Query returns a query builder for WebhookHistory.
func (c *WebhookHistoryClient) Query() *WebhookHistoryQuery {
	return &WebhookHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebhookHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a WebhookHistory entity by its id.
func (c *WebhookHistoryClient) Get(ctx context.Context, id string) (*WebhookHistory, error) {
	return c.Query().Where(webhookhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebhookHistoryClient) GetX(ctx context.Context, id string) *WebhookHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WebhookHistoryClient) Hooks() []Hook {
	hooks := c.hooks.WebhookHistory
	return append(hooks[:len(hooks):len(hooks)], webhookhistory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *WebhookHistoryClient) Interceptors() []Interceptor {
	inters := c.inters.WebhookHistory
	return append(inters[:len(inters):len(inters)], webhookhistory.Interceptors[:]...)
}

func (c *WebhookHistoryClient) mutate(ctx context.Context, m *WebhookHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebhookHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebhookHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebhookHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebhookHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown WebhookHistory mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIToken, ActionPlan, ActionPlanHistory, Contact, ContactHistory, Control,
		ControlHistory, ControlObjective, ControlObjectiveHistory, DocumentData,
		DocumentDataHistory, EmailVerificationToken, Entitlement, EntitlementHistory,
		EntitlementPlan, EntitlementPlanFeature, EntitlementPlanFeatureHistory,
		EntitlementPlanHistory, Entity, EntityHistory, EntityType, EntityTypeHistory,
		Event, EventHistory, Feature, FeatureHistory, File, FileHistory, Group,
		GroupHistory, GroupMembership, GroupMembershipHistory, GroupSetting,
		GroupSettingHistory, Hush, HushHistory, Integration, IntegrationHistory,
		InternalPolicy, InternalPolicyHistory, Invite, Narrative, NarrativeHistory,
		Note, NoteHistory, OauthProvider, OauthProviderHistory, OhAuthTooToken,
		OrgMembership, OrgMembershipHistory, Organization, OrganizationHistory,
		OrganizationSetting, OrganizationSettingHistory, PasswordResetToken,
		PersonalAccessToken, Procedure, ProcedureHistory, Program, ProgramHistory,
		ProgramMembership, ProgramMembershipHistory, Risk, RiskHistory, Standard,
		StandardHistory, Subcontrol, SubcontrolHistory, Subscriber, TFASetting, Task,
		TaskHistory, Template, TemplateHistory, User, UserHistory, UserSetting,
		UserSettingHistory, Webauthn, Webhook, WebhookHistory []ent.Hook
	}
	inters struct {
		APIToken, ActionPlan, ActionPlanHistory, Contact, ContactHistory, Control,
		ControlHistory, ControlObjective, ControlObjectiveHistory, DocumentData,
		DocumentDataHistory, EmailVerificationToken, Entitlement, EntitlementHistory,
		EntitlementPlan, EntitlementPlanFeature, EntitlementPlanFeatureHistory,
		EntitlementPlanHistory, Entity, EntityHistory, EntityType, EntityTypeHistory,
		Event, EventHistory, Feature, FeatureHistory, File, FileHistory, Group,
		GroupHistory, GroupMembership, GroupMembershipHistory, GroupSetting,
		GroupSettingHistory, Hush, HushHistory, Integration, IntegrationHistory,
		InternalPolicy, InternalPolicyHistory, Invite, Narrative, NarrativeHistory,
		Note, NoteHistory, OauthProvider, OauthProviderHistory, OhAuthTooToken,
		OrgMembership, OrgMembershipHistory, Organization, OrganizationHistory,
		OrganizationSetting, OrganizationSettingHistory, PasswordResetToken,
		PersonalAccessToken, Procedure, ProcedureHistory, Program, ProgramHistory,
		ProgramMembership, ProgramMembershipHistory, Risk, RiskHistory, Standard,
		StandardHistory, Subcontrol, SubcontrolHistory, Subscriber, TFASetting, Task,
		TaskHistory, Template, TemplateHistory, User, UserHistory, UserSetting,
		UserSettingHistory, Webauthn, Webhook, WebhookHistory []ent.Interceptor
	}
)

// Job option added by the client template to add the job client.
func Job(ctx context.Context, opts ...riverqueue.Option) Option {
	return func(c *config) {
		var err error

		c.Job, err = riverqueue.New(ctx, opts...)
		if err != nil {
			panic(err)
		}
	}
}

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}
